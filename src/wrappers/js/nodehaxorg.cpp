/* clang-format off */
#include "node_utils.hpp"
#include "node_org_include.hpp"
using namespace org::bind::js;
struct UsertimebreakdownJs : public Napi::ObjectWrap<UsertimebreakdownJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "UsertimebreakdownJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("UsertimebreakdownJs", func);
    return exports;
  }
  UsertimebreakdownJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<UsertimebreakdownJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<hstd::UserTimeBreakdown>();
  }
  UsertimebreakdownJs(Napi::CallbackInfo const& info, std::shared_ptr<hstd::UserTimeBreakdown> const& ptr) : Napi::ObjectWrap<UsertimebreakdownJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<hstd::UserTimeBreakdown> _stored;
  hstd::UserTimeBreakdown* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<UsertimebreakdownJs> {
  using type = hstd::UserTimeBreakdown;
};

template <>
struct org_to_js_type<hstd::UserTimeBreakdown> {
  using type = UsertimebreakdownJs;
};

struct UsertimeJs : public Napi::ObjectWrap<UsertimeJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getBreakdown(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::UserTimeBreakdown(hstd::UserTime::*)() const>(&hstd::UserTime::getBreakdown),
                                        std::make_tuple()));
  }
  Napi::Value format(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(hstd::UserTime::*)() const>(&hstd::UserTime::format),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "UsertimeJs", {InstanceMethod("getBreakdown", &UsertimeJs::getBreakdown),
                                                          InstanceMethod("format", &UsertimeJs::format)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("UsertimeJs", func);
    return exports;
  }
  UsertimeJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<UsertimeJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<hstd::UserTime>();
  }
  UsertimeJs(Napi::CallbackInfo const& info, std::shared_ptr<hstd::UserTime> const& ptr) : Napi::ObjectWrap<UsertimeJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<hstd::UserTime> _stored;
  hstd::UserTime* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<UsertimeJs> {
  using type = hstd::UserTime;
};

template <>
struct org_to_js_type<hstd::UserTime> {
  using type = UsertimeJs;
};

struct ParseLinecolJs : public Napi::ObjectWrap<ParseLinecolJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ParseLinecolJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ParseLinecolJs", func);
    return exports;
  }
  ParseLinecolJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ParseLinecolJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::parse::LineCol>();
  }
  ParseLinecolJs(Napi::CallbackInfo const& info, std::shared_ptr<org::parse::LineCol> const& ptr) : Napi::ObjectWrap<ParseLinecolJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::parse::LineCol> _stored;
  org::parse::LineCol* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ParseLinecolJs> {
  using type = org::parse::LineCol;
};

template <>
struct org_to_js_type<org::parse::LineCol> {
  using type = ParseLinecolJs;
};

struct OrgjsonJs : public Napi::ObjectWrap<OrgjsonJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgJsonKind(org::sem::OrgJson::*)() const>(&org::sem::OrgJson::getKind),
                                        std::make_tuple()));
  }
  Napi::Value getJsonString(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::sem::OrgJson::*)() const>(&org::sem::OrgJson::getJsonString),
                                        std::make_tuple()));
  }
  Napi::Value atField(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::OrgJson(org::sem::OrgJson::*)(std::string const&) const>(&org::sem::OrgJson::at),
                                        std::make_tuple(CxxArgSpec<std::string>{"name"})));
  }
  Napi::Value getString(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::sem::OrgJson::*)() const>(&org::sem::OrgJson::getString),
                                        std::make_tuple()));
  }
  Napi::Value getField(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::OrgJson(org::sem::OrgJson::*)(std::string const&) const>(&org::sem::OrgJson::getField),
                                        std::make_tuple(CxxArgSpec<std::string>{"name"})));
  }
  Napi::Value getItem(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::OrgJson(org::sem::OrgJson::*)(int) const>(&org::sem::OrgJson::getItem),
                                        std::make_tuple(CxxArgSpec<int>{"index"})));
  }
  Napi::Value getInt(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::OrgJson::*)() const>(&org::sem::OrgJson::getInt),
                                        std::make_tuple()));
  }
  Napi::Value getBool(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::OrgJson::*)() const>(&org::sem::OrgJson::getBool),
                                        std::make_tuple()));
  }
  Napi::Value getArray(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::OrgJson>(org::sem::OrgJson::*)() const>(&org::sem::OrgJson::getArray),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "OrgjsonJs", {InstanceMethod("getKind", &OrgjsonJs::getKind),
                                                         InstanceMethod("getJsonString", &OrgjsonJs::getJsonString),
                                                         InstanceMethod("atField", &OrgjsonJs::atField),
                                                         InstanceMethod("getString", &OrgjsonJs::getString),
                                                         InstanceMethod("getField", &OrgjsonJs::getField),
                                                         InstanceMethod("getItem", &OrgjsonJs::getItem),
                                                         InstanceMethod("getInt", &OrgjsonJs::getInt),
                                                         InstanceMethod("getBool", &OrgjsonJs::getBool),
                                                         InstanceMethod("getArray", &OrgjsonJs::getArray)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("OrgjsonJs", func);
    return exports;
  }
  OrgjsonJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<OrgjsonJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::OrgJson>();
  }
  OrgjsonJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::OrgJson> const& ptr) : Napi::ObjectWrap<OrgjsonJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::OrgJson> _stored;
  org::sem::OrgJson* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<OrgjsonJs> {
  using type = org::sem::OrgJson;
};

template <>
struct org_to_js_type<org::sem::OrgJson> {
  using type = OrgjsonJs;
};

struct OperationstracerJs : public Napi::ObjectWrap<OperationstracerJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value setTraceFileStr(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(hstd::OperationsTracer::*)(std::string const&, bool)>(&hstd::OperationsTracer::setTraceFileStr),
                                   std::make_tuple(CxxArgSpec<std::string>{"outfile"},
                                                   CxxArgSpec<bool>{"overwrite"})));
  }
  Napi::Value sendMessage(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(hstd::OperationsTracer::*)(std::string const&, std::string const&, int, std::string const&)>(&hstd::OperationsTracer::sendMessage),
                                   std::make_tuple(CxxArgSpec<std::string>{"value"},
                                                   CxxArgSpec<std::string>{"function"},
                                                   CxxArgSpec<int>{"line"},
                                                   CxxArgSpec<std::string>{"file"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "OperationstracerJs", {InstanceMethod("setTraceFileStr", &OperationstracerJs::setTraceFileStr),
                                                                  InstanceMethod("sendMessage", &OperationstracerJs::sendMessage)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("OperationstracerJs", func);
    return exports;
  }
  OperationstracerJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<OperationstracerJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<hstd::OperationsTracer>();
  }
  OperationstracerJs(Napi::CallbackInfo const& info, std::shared_ptr<hstd::OperationsTracer> const& ptr) : Napi::ObjectWrap<OperationstracerJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<hstd::OperationsTracer> _stored;
  hstd::OperationsTracer* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<OperationstracerJs> {
  using type = hstd::OperationsTracer;
};

template <>
struct org_to_js_type<hstd::OperationsTracer> {
  using type = OperationstracerJs;
};

struct ImmidJs : public Napi::ObjectWrap<ImmidJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmId::*)() const>(&org::imm::ImmId::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmId::*)(OrgSemKind) const>(&org::imm::ImmId::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmId::*)() const>(&org::imm::ImmId::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmId::*)() const>(&org::imm::ImmId::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmidJs", {InstanceMethod("getKind", &ImmidJs::getKind),
                                                       InstanceMethod("is", &ImmidJs::is),
                                                       InstanceMethod("getNodeIndex", &ImmidJs::getNodeIndex),
                                                       InstanceMethod("getReadableId", &ImmidJs::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmidJs", func);
    return exports;
  }
  ImmidJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmidJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmId>();
  }
  ImmidJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmId> const& ptr) : Napi::ObjectWrap<ImmidJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmId> _stored;
  org::imm::ImmId* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmidJs> {
  using type = org::imm::ImmId;
};

template <>
struct org_to_js_type<org::imm::ImmId> {
  using type = ImmidJs;
};

struct ImmpathstepJs : public Napi::ObjectWrap<ImmpathstepJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmpathstepJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmpathstepJs", func);
    return exports;
  }
  ImmpathstepJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmpathstepJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmPathStep>();
  }
  ImmpathstepJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmPathStep> const& ptr) : Napi::ObjectWrap<ImmpathstepJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmPathStep> _stored;
  org::imm::ImmPathStep* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmpathstepJs> {
  using type = org::imm::ImmPathStep;
};

template <>
struct org_to_js_type<org::imm::ImmPathStep> {
  using type = ImmpathstepJs;
};

struct ImmpathJs : public Napi::ObjectWrap<ImmpathJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value empty(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmPath::*)() const>(&org::imm::ImmPath::empty),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmpathJs", {InstanceMethod("empty", &ImmpathJs::empty)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmpathJs", func);
    return exports;
  }
  ImmpathJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmpathJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmPath>();
  }
  ImmpathJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmPath> const& ptr) : Napi::ObjectWrap<ImmpathJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmPath> _stored;
  org::imm::ImmPath* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmpathJs> {
  using type = org::imm::ImmPath;
};

template <>
struct org_to_js_type<org::imm::ImmPath> {
  using type = ImmpathJs;
};

struct ImmuniqidJs : public Napi::ObjectWrap<ImmuniqidJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmuniqidJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmuniqidJs", func);
    return exports;
  }
  ImmuniqidJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmuniqidJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmUniqId>();
  }
  ImmuniqidJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmUniqId> const& ptr) : Napi::ObjectWrap<ImmuniqidJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmUniqId> _stored;
  org::imm::ImmUniqId* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmuniqidJs> {
  using type = org::imm::ImmUniqId;
};

template <>
struct org_to_js_type<org::imm::ImmUniqId> {
  using type = ImmuniqidJs;
};

struct ImmnonevaluereadJs : public Napi::ObjectWrap<ImmnonevaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmnonevaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmnonevaluereadJs", func);
    return exports;
  }
  ImmnonevaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmnonevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmnonevaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmNoneValueRead> const& ptr) : Napi::ObjectWrap<ImmnonevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmNoneValueRead> _stored;
  org::imm::ImmNoneValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmnonevaluereadJs> {
  using type = org::imm::ImmNoneValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmNoneValueRead> {
  using type = ImmnonevaluereadJs;
};

struct ImmerroritemvaluereadJs : public Napi::ObjectWrap<ImmerroritemvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getMessage(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmErrorItemValueRead::*)() const>(&org::imm::ImmErrorItemValueRead::getMessage),
                                        std::make_tuple()));
  }
  Napi::Value getFunction(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmErrorItemValueRead::*)() const>(&org::imm::ImmErrorItemValueRead::getFunction),
                                        std::make_tuple()));
  }
  Napi::Value getLine(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<int>> const&(org::imm::ImmErrorItemValueRead::*)() const>(&org::imm::ImmErrorItemValueRead::getLine),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmerroritemvaluereadJs", {InstanceMethod("getMessage", &ImmerroritemvaluereadJs::getMessage),
                                                                       InstanceMethod("getFunction", &ImmerroritemvaluereadJs::getFunction),
                                                                       InstanceMethod("getLine", &ImmerroritemvaluereadJs::getLine)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmerroritemvaluereadJs", func);
    return exports;
  }
  ImmerroritemvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmerroritemvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmerroritemvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmErrorItemValueRead> const& ptr) : Napi::ObjectWrap<ImmerroritemvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmErrorItemValueRead> _stored;
  org::imm::ImmErrorItemValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmerroritemvaluereadJs> {
  using type = org::imm::ImmErrorItemValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmErrorItemValueRead> {
  using type = ImmerroritemvaluereadJs;
};

struct ImmerrorgroupvaluereadJs : public Napi::ObjectWrap<ImmerrorgroupvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getDiagnostics(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmErrorItem>> const&(org::imm::ImmErrorGroupValueRead::*)() const>(&org::imm::ImmErrorGroupValueRead::getDiagnostics),
                                        std::make_tuple()));
  }
  Napi::Value getFunction(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmErrorGroupValueRead::*)() const>(&org::imm::ImmErrorGroupValueRead::getFunction),
                                        std::make_tuple()));
  }
  Napi::Value getLine(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<int>> const&(org::imm::ImmErrorGroupValueRead::*)() const>(&org::imm::ImmErrorGroupValueRead::getLine),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmerrorgroupvaluereadJs", {InstanceMethod("getDiagnostics", &ImmerrorgroupvaluereadJs::getDiagnostics),
                                                                        InstanceMethod("getFunction", &ImmerrorgroupvaluereadJs::getFunction),
                                                                        InstanceMethod("getLine", &ImmerrorgroupvaluereadJs::getLine)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmerrorgroupvaluereadJs", func);
    return exports;
  }
  ImmerrorgroupvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmerrorgroupvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmerrorgroupvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmErrorGroupValueRead> const& ptr) : Napi::ObjectWrap<ImmerrorgroupvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmErrorGroupValueRead> _stored;
  org::imm::ImmErrorGroupValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmerrorgroupvaluereadJs> {
  using type = org::imm::ImmErrorGroupValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmErrorGroupValueRead> {
  using type = ImmerrorgroupvaluereadJs;
};

struct ImmstmtlistvaluereadJs : public Napi::ObjectWrap<ImmstmtlistvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmstmtlistvaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmstmtlistvaluereadJs", func);
    return exports;
  }
  ImmstmtlistvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmstmtlistvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmstmtlistvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmStmtListValueRead> const& ptr) : Napi::ObjectWrap<ImmstmtlistvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmStmtListValueRead> _stored;
  org::imm::ImmStmtListValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmstmtlistvaluereadJs> {
  using type = org::imm::ImmStmtListValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmStmtListValueRead> {
  using type = ImmstmtlistvaluereadJs;
};

struct ImmemptyvaluereadJs : public Napi::ObjectWrap<ImmemptyvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmemptyvaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmemptyvaluereadJs", func);
    return exports;
  }
  ImmemptyvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmemptyvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmemptyvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmEmptyValueRead> const& ptr) : Napi::ObjectWrap<ImmemptyvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmEmptyValueRead> _stored;
  org::imm::ImmEmptyValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmemptyvaluereadJs> {
  using type = org::imm::ImmEmptyValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmEmptyValueRead> {
  using type = ImmemptyvaluereadJs;
};

struct ImmcmdcaptionvaluereadJs : public Napi::ObjectWrap<ImmcmdcaptionvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmIdT<org::imm::ImmParagraph> const&(org::imm::ImmCmdCaptionValueRead::*)() const>(&org::imm::ImmCmdCaptionValueRead::getText),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmcmdcaptionvaluereadJs", {InstanceMethod("getText", &ImmcmdcaptionvaluereadJs::getText)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmcmdcaptionvaluereadJs", func);
    return exports;
  }
  ImmcmdcaptionvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmcmdcaptionvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmcmdcaptionvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmCmdCaptionValueRead> const& ptr) : Napi::ObjectWrap<ImmcmdcaptionvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmCmdCaptionValueRead> _stored;
  org::imm::ImmCmdCaptionValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmcmdcaptionvaluereadJs> {
  using type = org::imm::ImmCmdCaptionValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmCmdCaptionValueRead> {
  using type = ImmcmdcaptionvaluereadJs;
};

struct ImmcmdcolumnsvaluereadJs : public Napi::ObjectWrap<ImmcmdcolumnsvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getView(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::ColumnView const&(org::imm::ImmCmdColumnsValueRead::*)() const>(&org::imm::ImmCmdColumnsValueRead::getView),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmcmdcolumnsvaluereadJs", {InstanceMethod("getView", &ImmcmdcolumnsvaluereadJs::getView)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmcmdcolumnsvaluereadJs", func);
    return exports;
  }
  ImmcmdcolumnsvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmcmdcolumnsvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmcmdcolumnsvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmCmdColumnsValueRead> const& ptr) : Napi::ObjectWrap<ImmcmdcolumnsvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmCmdColumnsValueRead> _stored;
  org::imm::ImmCmdColumnsValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmcmdcolumnsvaluereadJs> {
  using type = org::imm::ImmCmdColumnsValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmCmdColumnsValueRead> {
  using type = ImmcmdcolumnsvaluereadJs;
};

struct ImmcmdnamevaluereadJs : public Napi::ObjectWrap<ImmcmdnamevaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdNameValueRead::*)() const>(&org::imm::ImmCmdNameValueRead::getName),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmcmdnamevaluereadJs", {InstanceMethod("getName", &ImmcmdnamevaluereadJs::getName)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmcmdnamevaluereadJs", func);
    return exports;
  }
  ImmcmdnamevaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmcmdnamevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmcmdnamevaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmCmdNameValueRead> const& ptr) : Napi::ObjectWrap<ImmcmdnamevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmCmdNameValueRead> _stored;
  org::imm::ImmCmdNameValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmcmdnamevaluereadJs> {
  using type = org::imm::ImmCmdNameValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmCmdNameValueRead> {
  using type = ImmcmdnamevaluereadJs;
};

struct ImmcmdcustomargsvaluereadJs : public Napi::ObjectWrap<ImmcmdcustomargsvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdCustomArgsValueRead::*)() const>(&org::imm::ImmCmdCustomArgsValueRead::getName),
                                        std::make_tuple()));
  }
  Napi::Value getIsattached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmCmdCustomArgsValueRead::*)() const>(&org::imm::ImmCmdCustomArgsValueRead::getIsattached),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmcmdcustomargsvaluereadJs", {InstanceMethod("getName", &ImmcmdcustomargsvaluereadJs::getName),
                                                                           InstanceMethod("getIsattached", &ImmcmdcustomargsvaluereadJs::getIsattached)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmcmdcustomargsvaluereadJs", func);
    return exports;
  }
  ImmcmdcustomargsvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmcmdcustomargsvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmcmdcustomargsvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmCmdCustomArgsValueRead> const& ptr) : Napi::ObjectWrap<ImmcmdcustomargsvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmCmdCustomArgsValueRead> _stored;
  org::imm::ImmCmdCustomArgsValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmcmdcustomargsvaluereadJs> {
  using type = org::imm::ImmCmdCustomArgsValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmCmdCustomArgsValueRead> {
  using type = ImmcmdcustomargsvaluereadJs;
};

struct ImmcmdcustomrawvaluereadJs : public Napi::ObjectWrap<ImmcmdcustomrawvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdCustomRawValueRead::*)() const>(&org::imm::ImmCmdCustomRawValueRead::getName),
                                        std::make_tuple()));
  }
  Napi::Value getIsattached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmCmdCustomRawValueRead::*)() const>(&org::imm::ImmCmdCustomRawValueRead::getIsattached),
                                        std::make_tuple()));
  }
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdCustomRawValueRead::*)() const>(&org::imm::ImmCmdCustomRawValueRead::getText),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmcmdcustomrawvaluereadJs", {InstanceMethod("getName", &ImmcmdcustomrawvaluereadJs::getName),
                                                                          InstanceMethod("getIsattached", &ImmcmdcustomrawvaluereadJs::getIsattached),
                                                                          InstanceMethod("getText", &ImmcmdcustomrawvaluereadJs::getText)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmcmdcustomrawvaluereadJs", func);
    return exports;
  }
  ImmcmdcustomrawvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmcmdcustomrawvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmcmdcustomrawvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmCmdCustomRawValueRead> const& ptr) : Napi::ObjectWrap<ImmcmdcustomrawvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmCmdCustomRawValueRead> _stored;
  org::imm::ImmCmdCustomRawValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmcmdcustomrawvaluereadJs> {
  using type = org::imm::ImmCmdCustomRawValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmCmdCustomRawValueRead> {
  using type = ImmcmdcustomrawvaluereadJs;
};

struct ImmcmdcustomtextvaluereadJs : public Napi::ObjectWrap<ImmcmdcustomtextvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdCustomTextValueRead::*)() const>(&org::imm::ImmCmdCustomTextValueRead::getName),
                                        std::make_tuple()));
  }
  Napi::Value getIsattached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmCmdCustomTextValueRead::*)() const>(&org::imm::ImmCmdCustomTextValueRead::getIsattached),
                                        std::make_tuple()));
  }
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmIdT<org::imm::ImmParagraph> const&(org::imm::ImmCmdCustomTextValueRead::*)() const>(&org::imm::ImmCmdCustomTextValueRead::getText),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmcmdcustomtextvaluereadJs", {InstanceMethod("getName", &ImmcmdcustomtextvaluereadJs::getName),
                                                                           InstanceMethod("getIsattached", &ImmcmdcustomtextvaluereadJs::getIsattached),
                                                                           InstanceMethod("getText", &ImmcmdcustomtextvaluereadJs::getText)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmcmdcustomtextvaluereadJs", func);
    return exports;
  }
  ImmcmdcustomtextvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmcmdcustomtextvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmcmdcustomtextvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmCmdCustomTextValueRead> const& ptr) : Napi::ObjectWrap<ImmcmdcustomtextvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmCmdCustomTextValueRead> _stored;
  org::imm::ImmCmdCustomTextValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmcmdcustomtextvaluereadJs> {
  using type = org::imm::ImmCmdCustomTextValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmCmdCustomTextValueRead> {
  using type = ImmcmdcustomtextvaluereadJs;
};

struct ImmcmdcallvaluereadJs : public Napi::ObjectWrap<ImmcmdcallvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdCallValueRead::*)() const>(&org::imm::ImmCmdCallValueRead::getName),
                                        std::make_tuple()));
  }
  Napi::Value getFilename(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmCmdCallValueRead::*)() const>(&org::imm::ImmCmdCallValueRead::getFilename),
                                        std::make_tuple()));
  }
  Napi::Value getInsideheaderattrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrGroup const&(org::imm::ImmCmdCallValueRead::*)() const>(&org::imm::ImmCmdCallValueRead::getInsideheaderattrs),
                                        std::make_tuple()));
  }
  Napi::Value getCallattrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrGroup const&(org::imm::ImmCmdCallValueRead::*)() const>(&org::imm::ImmCmdCallValueRead::getCallattrs),
                                        std::make_tuple()));
  }
  Napi::Value getEndheaderattrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrGroup const&(org::imm::ImmCmdCallValueRead::*)() const>(&org::imm::ImmCmdCallValueRead::getEndheaderattrs),
                                        std::make_tuple()));
  }
  Napi::Value getResult(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>> const&(org::imm::ImmCmdCallValueRead::*)() const>(&org::imm::ImmCmdCallValueRead::getResult),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmcmdcallvaluereadJs", {InstanceMethod("getName", &ImmcmdcallvaluereadJs::getName),
                                                                     InstanceMethod("getFilename", &ImmcmdcallvaluereadJs::getFilename),
                                                                     InstanceMethod("getInsideheaderattrs", &ImmcmdcallvaluereadJs::getInsideheaderattrs),
                                                                     InstanceMethod("getCallattrs", &ImmcmdcallvaluereadJs::getCallattrs),
                                                                     InstanceMethod("getEndheaderattrs", &ImmcmdcallvaluereadJs::getEndheaderattrs),
                                                                     InstanceMethod("getResult", &ImmcmdcallvaluereadJs::getResult)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmcmdcallvaluereadJs", func);
    return exports;
  }
  ImmcmdcallvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmcmdcallvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmcmdcallvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmCmdCallValueRead> const& ptr) : Napi::ObjectWrap<ImmcmdcallvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmCmdCallValueRead> _stored;
  org::imm::ImmCmdCallValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmcmdcallvaluereadJs> {
  using type = org::imm::ImmCmdCallValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmCmdCallValueRead> {
  using type = ImmcmdcallvaluereadJs;
};

struct ImmcmdtblfmvaluereadJs : public Napi::ObjectWrap<ImmcmdtblfmvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getExpr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::Tblfm const&(org::imm::ImmCmdTblfmValueRead::*)() const>(&org::imm::ImmCmdTblfmValueRead::getExpr),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmcmdtblfmvaluereadJs", {InstanceMethod("getExpr", &ImmcmdtblfmvaluereadJs::getExpr)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmcmdtblfmvaluereadJs", func);
    return exports;
  }
  ImmcmdtblfmvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmcmdtblfmvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmcmdtblfmvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmCmdTblfmValueRead> const& ptr) : Napi::ObjectWrap<ImmcmdtblfmvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmCmdTblfmValueRead> _stored;
  org::imm::ImmCmdTblfmValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmcmdtblfmvaluereadJs> {
  using type = org::imm::ImmCmdTblfmValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmCmdTblfmValueRead> {
  using type = ImmcmdtblfmvaluereadJs;
};

struct ImmhashtagvaluereadJs : public Napi::ObjectWrap<ImmhashtagvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::HashTagText const&(org::imm::ImmHashTagValueRead::*)() const>(&org::imm::ImmHashTagValueRead::getText),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmhashtagvaluereadJs", {InstanceMethod("getText", &ImmhashtagvaluereadJs::getText)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmhashtagvaluereadJs", func);
    return exports;
  }
  ImmhashtagvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmhashtagvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmhashtagvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmHashTagValueRead> const& ptr) : Napi::ObjectWrap<ImmhashtagvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmHashTagValueRead> _stored;
  org::imm::ImmHashTagValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmhashtagvaluereadJs> {
  using type = org::imm::ImmHashTagValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmHashTagValueRead> {
  using type = ImmhashtagvaluereadJs;
};

struct ImminlinefootnotevaluereadJs : public Napi::ObjectWrap<ImminlinefootnotevaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getTag(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmInlineFootnoteValueRead::*)() const>(&org::imm::ImmInlineFootnoteValueRead::getTag),
                                        std::make_tuple()));
  }
  Napi::Value getDefinition(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmOrg>>> const&(org::imm::ImmInlineFootnoteValueRead::*)() const>(&org::imm::ImmInlineFootnoteValueRead::getDefinition),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImminlinefootnotevaluereadJs", {InstanceMethod("getTag", &ImminlinefootnotevaluereadJs::getTag),
                                                                            InstanceMethod("getDefinition", &ImminlinefootnotevaluereadJs::getDefinition)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImminlinefootnotevaluereadJs", func);
    return exports;
  }
  ImminlinefootnotevaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImminlinefootnotevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImminlinefootnotevaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmInlineFootnoteValueRead> const& ptr) : Napi::ObjectWrap<ImminlinefootnotevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmInlineFootnoteValueRead> _stored;
  org::imm::ImmInlineFootnoteValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImminlinefootnotevaluereadJs> {
  using type = org::imm::ImmInlineFootnoteValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmInlineFootnoteValueRead> {
  using type = ImminlinefootnotevaluereadJs;
};

struct ImminlineexportvaluereadJs : public Napi::ObjectWrap<ImminlineexportvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getExporter(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmInlineExportValueRead::*)() const>(&org::imm::ImmInlineExportValueRead::getExporter),
                                        std::make_tuple()));
  }
  Napi::Value getContent(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmInlineExportValueRead::*)() const>(&org::imm::ImmInlineExportValueRead::getContent),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImminlineexportvaluereadJs", {InstanceMethod("getExporter", &ImminlineexportvaluereadJs::getExporter),
                                                                          InstanceMethod("getContent", &ImminlineexportvaluereadJs::getContent)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImminlineexportvaluereadJs", func);
    return exports;
  }
  ImminlineexportvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImminlineexportvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImminlineexportvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmInlineExportValueRead> const& ptr) : Napi::ObjectWrap<ImminlineexportvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmInlineExportValueRead> _stored;
  org::imm::ImmInlineExportValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImminlineexportvaluereadJs> {
  using type = org::imm::ImmInlineExportValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmInlineExportValueRead> {
  using type = ImminlineexportvaluereadJs;
};

struct ImmtimevaluereadJs : public Napi::ObjectWrap<ImmtimevaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getIsactive(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmTimeValueRead::*)() const>(&org::imm::ImmTimeValueRead::getIsactive),
                                        std::make_tuple()));
  }
  Napi::Value getTime(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmTime::TimeVariant const&(org::imm::ImmTimeValueRead::*)() const>(&org::imm::ImmTimeValueRead::getTime),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmtimevaluereadJs", {InstanceMethod("getIsactive", &ImmtimevaluereadJs::getIsactive),
                                                                  InstanceMethod("getTime", &ImmtimevaluereadJs::getTime)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmtimevaluereadJs", func);
    return exports;
  }
  ImmtimevaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmtimevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmtimevaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmTimeValueRead> const& ptr) : Napi::ObjectWrap<ImmtimevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmTimeValueRead> _stored;
  org::imm::ImmTimeValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmtimevaluereadJs> {
  using type = org::imm::ImmTimeValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmTimeValueRead> {
  using type = ImmtimevaluereadJs;
};

struct ImmtimerangevaluereadJs : public Napi::ObjectWrap<ImmtimerangevaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getFrom(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmIdT<org::imm::ImmTime> const&(org::imm::ImmTimeRangeValueRead::*)() const>(&org::imm::ImmTimeRangeValueRead::getFrom),
                                        std::make_tuple()));
  }
  Napi::Value getTo(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmIdT<org::imm::ImmTime> const&(org::imm::ImmTimeRangeValueRead::*)() const>(&org::imm::ImmTimeRangeValueRead::getTo),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmtimerangevaluereadJs", {InstanceMethod("getFrom", &ImmtimerangevaluereadJs::getFrom),
                                                                       InstanceMethod("getTo", &ImmtimerangevaluereadJs::getTo)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmtimerangevaluereadJs", func);
    return exports;
  }
  ImmtimerangevaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmtimerangevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmtimerangevaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmTimeRangeValueRead> const& ptr) : Napi::ObjectWrap<ImmtimerangevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmTimeRangeValueRead> _stored;
  org::imm::ImmTimeRangeValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmtimerangevaluereadJs> {
  using type = org::imm::ImmTimeRangeValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmTimeRangeValueRead> {
  using type = ImmtimerangevaluereadJs;
};

struct ImmmacrovaluereadJs : public Napi::ObjectWrap<ImmmacrovaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmMacroValueRead::*)() const>(&org::imm::ImmMacroValueRead::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrGroup const&(org::imm::ImmMacroValueRead::*)() const>(&org::imm::ImmMacroValueRead::getAttrs),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmmacrovaluereadJs", {InstanceMethod("getName", &ImmmacrovaluereadJs::getName),
                                                                   InstanceMethod("getAttrs", &ImmmacrovaluereadJs::getAttrs)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmmacrovaluereadJs", func);
    return exports;
  }
  ImmmacrovaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmmacrovaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmmacrovaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmMacroValueRead> const& ptr) : Napi::ObjectWrap<ImmmacrovaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmMacroValueRead> _stored;
  org::imm::ImmMacroValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmmacrovaluereadJs> {
  using type = org::imm::ImmMacroValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmMacroValueRead> {
  using type = ImmmacrovaluereadJs;
};

struct ImmsymbolvaluereadJs : public Napi::ObjectWrap<ImmsymbolvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmSymbolValueRead::*)() const>(&org::imm::ImmSymbolValueRead::getName),
                                        std::make_tuple()));
  }
  Napi::Value getParameters(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmSymbol::Param> const&(org::imm::ImmSymbolValueRead::*)() const>(&org::imm::ImmSymbolValueRead::getParameters),
                                        std::make_tuple()));
  }
  Napi::Value getPositional(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmOrg>> const&(org::imm::ImmSymbolValueRead::*)() const>(&org::imm::ImmSymbolValueRead::getPositional),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmsymbolvaluereadJs", {InstanceMethod("getName", &ImmsymbolvaluereadJs::getName),
                                                                    InstanceMethod("getParameters", &ImmsymbolvaluereadJs::getParameters),
                                                                    InstanceMethod("getPositional", &ImmsymbolvaluereadJs::getPositional)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmsymbolvaluereadJs", func);
    return exports;
  }
  ImmsymbolvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmsymbolvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmsymbolvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmSymbolValueRead> const& ptr) : Napi::ObjectWrap<ImmsymbolvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmSymbolValueRead> _stored;
  org::imm::ImmSymbolValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmsymbolvaluereadJs> {
  using type = org::imm::ImmSymbolValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmSymbolValueRead> {
  using type = ImmsymbolvaluereadJs;
};

struct ImmescapedvaluereadJs : public Napi::ObjectWrap<ImmescapedvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmescapedvaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmescapedvaluereadJs", func);
    return exports;
  }
  ImmescapedvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmescapedvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmescapedvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmEscapedValueRead> const& ptr) : Napi::ObjectWrap<ImmescapedvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmEscapedValueRead> _stored;
  org::imm::ImmEscapedValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmescapedvaluereadJs> {
  using type = org::imm::ImmEscapedValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmEscapedValueRead> {
  using type = ImmescapedvaluereadJs;
};

struct ImmnewlinevaluereadJs : public Napi::ObjectWrap<ImmnewlinevaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmnewlinevaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmnewlinevaluereadJs", func);
    return exports;
  }
  ImmnewlinevaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmnewlinevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmnewlinevaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmNewlineValueRead> const& ptr) : Napi::ObjectWrap<ImmnewlinevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmNewlineValueRead> _stored;
  org::imm::ImmNewlineValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmnewlinevaluereadJs> {
  using type = org::imm::ImmNewlineValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmNewlineValueRead> {
  using type = ImmnewlinevaluereadJs;
};

struct ImmspacevaluereadJs : public Napi::ObjectWrap<ImmspacevaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmspacevaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmspacevaluereadJs", func);
    return exports;
  }
  ImmspacevaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmspacevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmspacevaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmSpaceValueRead> const& ptr) : Napi::ObjectWrap<ImmspacevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmSpaceValueRead> _stored;
  org::imm::ImmSpaceValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmspacevaluereadJs> {
  using type = org::imm::ImmSpaceValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmSpaceValueRead> {
  using type = ImmspacevaluereadJs;
};

struct ImmwordvaluereadJs : public Napi::ObjectWrap<ImmwordvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmwordvaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmwordvaluereadJs", func);
    return exports;
  }
  ImmwordvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmwordvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmwordvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmWordValueRead> const& ptr) : Napi::ObjectWrap<ImmwordvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmWordValueRead> _stored;
  org::imm::ImmWordValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmwordvaluereadJs> {
  using type = org::imm::ImmWordValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmWordValueRead> {
  using type = ImmwordvaluereadJs;
};

struct ImmatmentionvaluereadJs : public Napi::ObjectWrap<ImmatmentionvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmatmentionvaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmatmentionvaluereadJs", func);
    return exports;
  }
  ImmatmentionvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmatmentionvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmatmentionvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAtMentionValueRead> const& ptr) : Napi::ObjectWrap<ImmatmentionvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAtMentionValueRead> _stored;
  org::imm::ImmAtMentionValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmatmentionvaluereadJs> {
  using type = org::imm::ImmAtMentionValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmAtMentionValueRead> {
  using type = ImmatmentionvaluereadJs;
};

struct ImmrawtextvaluereadJs : public Napi::ObjectWrap<ImmrawtextvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmrawtextvaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmrawtextvaluereadJs", func);
    return exports;
  }
  ImmrawtextvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmrawtextvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmrawtextvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmRawTextValueRead> const& ptr) : Napi::ObjectWrap<ImmrawtextvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmRawTextValueRead> _stored;
  org::imm::ImmRawTextValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmrawtextvaluereadJs> {
  using type = org::imm::ImmRawTextValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmRawTextValueRead> {
  using type = ImmrawtextvaluereadJs;
};

struct ImmpunctuationvaluereadJs : public Napi::ObjectWrap<ImmpunctuationvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmpunctuationvaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmpunctuationvaluereadJs", func);
    return exports;
  }
  ImmpunctuationvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmpunctuationvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmpunctuationvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmPunctuationValueRead> const& ptr) : Napi::ObjectWrap<ImmpunctuationvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmPunctuationValueRead> _stored;
  org::imm::ImmPunctuationValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmpunctuationvaluereadJs> {
  using type = org::imm::ImmPunctuationValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmPunctuationValueRead> {
  using type = ImmpunctuationvaluereadJs;
};

struct ImmplaceholdervaluereadJs : public Napi::ObjectWrap<ImmplaceholdervaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmplaceholdervaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmplaceholdervaluereadJs", func);
    return exports;
  }
  ImmplaceholdervaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmplaceholdervaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmplaceholdervaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmPlaceholderValueRead> const& ptr) : Napi::ObjectWrap<ImmplaceholdervaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmPlaceholderValueRead> _stored;
  org::imm::ImmPlaceholderValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmplaceholdervaluereadJs> {
  using type = org::imm::ImmPlaceholderValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmPlaceholderValueRead> {
  using type = ImmplaceholdervaluereadJs;
};

struct ImmbigidentvaluereadJs : public Napi::ObjectWrap<ImmbigidentvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmbigidentvaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmbigidentvaluereadJs", func);
    return exports;
  }
  ImmbigidentvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmbigidentvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmbigidentvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmBigIdentValueRead> const& ptr) : Napi::ObjectWrap<ImmbigidentvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmBigIdentValueRead> _stored;
  org::imm::ImmBigIdentValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmbigidentvaluereadJs> {
  using type = org::imm::ImmBigIdentValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmBigIdentValueRead> {
  using type = ImmbigidentvaluereadJs;
};

struct ImmtexttargetvaluereadJs : public Napi::ObjectWrap<ImmtexttargetvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmtexttargetvaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmtexttargetvaluereadJs", func);
    return exports;
  }
  ImmtexttargetvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmtexttargetvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmtexttargetvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmTextTargetValueRead> const& ptr) : Napi::ObjectWrap<ImmtexttargetvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmTextTargetValueRead> _stored;
  org::imm::ImmTextTargetValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmtexttargetvaluereadJs> {
  using type = org::imm::ImmTextTargetValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmTextTargetValueRead> {
  using type = ImmtexttargetvaluereadJs;
};

struct ImmboldvaluereadJs : public Napi::ObjectWrap<ImmboldvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmboldvaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmboldvaluereadJs", func);
    return exports;
  }
  ImmboldvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmboldvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmboldvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmBoldValueRead> const& ptr) : Napi::ObjectWrap<ImmboldvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmBoldValueRead> _stored;
  org::imm::ImmBoldValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmboldvaluereadJs> {
  using type = org::imm::ImmBoldValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmBoldValueRead> {
  using type = ImmboldvaluereadJs;
};

struct ImmunderlinevaluereadJs : public Napi::ObjectWrap<ImmunderlinevaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmunderlinevaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmunderlinevaluereadJs", func);
    return exports;
  }
  ImmunderlinevaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmunderlinevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmunderlinevaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmUnderlineValueRead> const& ptr) : Napi::ObjectWrap<ImmunderlinevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmUnderlineValueRead> _stored;
  org::imm::ImmUnderlineValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmunderlinevaluereadJs> {
  using type = org::imm::ImmUnderlineValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmUnderlineValueRead> {
  using type = ImmunderlinevaluereadJs;
};

struct ImmmonospacevaluereadJs : public Napi::ObjectWrap<ImmmonospacevaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmmonospacevaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmmonospacevaluereadJs", func);
    return exports;
  }
  ImmmonospacevaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmmonospacevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmmonospacevaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmMonospaceValueRead> const& ptr) : Napi::ObjectWrap<ImmmonospacevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmMonospaceValueRead> _stored;
  org::imm::ImmMonospaceValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmmonospacevaluereadJs> {
  using type = org::imm::ImmMonospaceValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmMonospaceValueRead> {
  using type = ImmmonospacevaluereadJs;
};

struct ImmmarkquotevaluereadJs : public Napi::ObjectWrap<ImmmarkquotevaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmmarkquotevaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmmarkquotevaluereadJs", func);
    return exports;
  }
  ImmmarkquotevaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmmarkquotevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmmarkquotevaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmMarkQuoteValueRead> const& ptr) : Napi::ObjectWrap<ImmmarkquotevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmMarkQuoteValueRead> _stored;
  org::imm::ImmMarkQuoteValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmmarkquotevaluereadJs> {
  using type = org::imm::ImmMarkQuoteValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmMarkQuoteValueRead> {
  using type = ImmmarkquotevaluereadJs;
};

struct ImmverbatimvaluereadJs : public Napi::ObjectWrap<ImmverbatimvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmverbatimvaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmverbatimvaluereadJs", func);
    return exports;
  }
  ImmverbatimvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmverbatimvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmverbatimvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmVerbatimValueRead> const& ptr) : Napi::ObjectWrap<ImmverbatimvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmVerbatimValueRead> _stored;
  org::imm::ImmVerbatimValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmverbatimvaluereadJs> {
  using type = org::imm::ImmVerbatimValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmVerbatimValueRead> {
  using type = ImmverbatimvaluereadJs;
};

struct ImmitalicvaluereadJs : public Napi::ObjectWrap<ImmitalicvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmitalicvaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmitalicvaluereadJs", func);
    return exports;
  }
  ImmitalicvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmitalicvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmitalicvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmItalicValueRead> const& ptr) : Napi::ObjectWrap<ImmitalicvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmItalicValueRead> _stored;
  org::imm::ImmItalicValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmitalicvaluereadJs> {
  using type = org::imm::ImmItalicValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmItalicValueRead> {
  using type = ImmitalicvaluereadJs;
};

struct ImmstrikevaluereadJs : public Napi::ObjectWrap<ImmstrikevaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmstrikevaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmstrikevaluereadJs", func);
    return exports;
  }
  ImmstrikevaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmstrikevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmstrikevaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmStrikeValueRead> const& ptr) : Napi::ObjectWrap<ImmstrikevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmStrikeValueRead> _stored;
  org::imm::ImmStrikeValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmstrikevaluereadJs> {
  using type = org::imm::ImmStrikeValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmStrikeValueRead> {
  using type = ImmstrikevaluereadJs;
};

struct ImmparvaluereadJs : public Napi::ObjectWrap<ImmparvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmparvaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmparvaluereadJs", func);
    return exports;
  }
  ImmparvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmparvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmparvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmParValueRead> const& ptr) : Napi::ObjectWrap<ImmparvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmParValueRead> _stored;
  org::imm::ImmParValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmparvaluereadJs> {
  using type = org::imm::ImmParValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmParValueRead> {
  using type = ImmparvaluereadJs;
};

struct ImmradiotargetvaluereadJs : public Napi::ObjectWrap<ImmradiotargetvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getWords(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<hstd::Str> const&(org::imm::ImmRadioTargetValueRead::*)() const>(&org::imm::ImmRadioTargetValueRead::getWords),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmradiotargetvaluereadJs", {InstanceMethod("getWords", &ImmradiotargetvaluereadJs::getWords)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmradiotargetvaluereadJs", func);
    return exports;
  }
  ImmradiotargetvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmradiotargetvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmradiotargetvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmRadioTargetValueRead> const& ptr) : Napi::ObjectWrap<ImmradiotargetvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmRadioTargetValueRead> _stored;
  org::imm::ImmRadioTargetValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmradiotargetvaluereadJs> {
  using type = org::imm::ImmRadioTargetValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmRadioTargetValueRead> {
  using type = ImmradiotargetvaluereadJs;
};

struct ImmlatexvaluereadJs : public Napi::ObjectWrap<ImmlatexvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmlatexvaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmlatexvaluereadJs", func);
    return exports;
  }
  ImmlatexvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmlatexvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmlatexvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmLatexValueRead> const& ptr) : Napi::ObjectWrap<ImmlatexvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmLatexValueRead> _stored;
  org::imm::ImmLatexValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmlatexvaluereadJs> {
  using type = org::imm::ImmLatexValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmLatexValueRead> {
  using type = ImmlatexvaluereadJs;
};

struct ImmlinkvaluereadJs : public Napi::ObjectWrap<ImmlinkvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getDescription(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&(org::imm::ImmLinkValueRead::*)() const>(&org::imm::ImmLinkValueRead::getDescription),
                                        std::make_tuple()));
  }
  Napi::Value getTarget(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::LinkTarget const&(org::imm::ImmLinkValueRead::*)() const>(&org::imm::ImmLinkValueRead::getTarget),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmlinkvaluereadJs", {InstanceMethod("getDescription", &ImmlinkvaluereadJs::getDescription),
                                                                  InstanceMethod("getTarget", &ImmlinkvaluereadJs::getTarget)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmlinkvaluereadJs", func);
    return exports;
  }
  ImmlinkvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmlinkvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmlinkvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmLinkValueRead> const& ptr) : Napi::ObjectWrap<ImmlinkvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmLinkValueRead> _stored;
  org::imm::ImmLinkValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmlinkvaluereadJs> {
  using type = org::imm::ImmLinkValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmLinkValueRead> {
  using type = ImmlinkvaluereadJs;
};

struct ImmblockcentervaluereadJs : public Napi::ObjectWrap<ImmblockcentervaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmblockcentervaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmblockcentervaluereadJs", func);
    return exports;
  }
  ImmblockcentervaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmblockcentervaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmblockcentervaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmBlockCenterValueRead> const& ptr) : Napi::ObjectWrap<ImmblockcentervaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmBlockCenterValueRead> _stored;
  org::imm::ImmBlockCenterValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmblockcentervaluereadJs> {
  using type = org::imm::ImmBlockCenterValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmBlockCenterValueRead> {
  using type = ImmblockcentervaluereadJs;
};

struct ImmblockquotevaluereadJs : public Napi::ObjectWrap<ImmblockquotevaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmblockquotevaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmblockquotevaluereadJs", func);
    return exports;
  }
  ImmblockquotevaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmblockquotevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmblockquotevaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmBlockQuoteValueRead> const& ptr) : Napi::ObjectWrap<ImmblockquotevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmBlockQuoteValueRead> _stored;
  org::imm::ImmBlockQuoteValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmblockquotevaluereadJs> {
  using type = org::imm::ImmBlockQuoteValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmBlockQuoteValueRead> {
  using type = ImmblockquotevaluereadJs;
};

struct ImmblockcommentvaluereadJs : public Napi::ObjectWrap<ImmblockcommentvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmblockcommentvaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmblockcommentvaluereadJs", func);
    return exports;
  }
  ImmblockcommentvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmblockcommentvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmblockcommentvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmBlockCommentValueRead> const& ptr) : Napi::ObjectWrap<ImmblockcommentvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmBlockCommentValueRead> _stored;
  org::imm::ImmBlockCommentValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmblockcommentvaluereadJs> {
  using type = org::imm::ImmBlockCommentValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmBlockCommentValueRead> {
  using type = ImmblockcommentvaluereadJs;
};

struct ImmblockversevaluereadJs : public Napi::ObjectWrap<ImmblockversevaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmblockversevaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmblockversevaluereadJs", func);
    return exports;
  }
  ImmblockversevaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmblockversevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmblockversevaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmBlockVerseValueRead> const& ptr) : Napi::ObjectWrap<ImmblockversevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmBlockVerseValueRead> _stored;
  org::imm::ImmBlockVerseValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmblockversevaluereadJs> {
  using type = org::imm::ImmBlockVerseValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmBlockVerseValueRead> {
  using type = ImmblockversevaluereadJs;
};

struct ImmblockdynamicfallbackvaluereadJs : public Napi::ObjectWrap<ImmblockdynamicfallbackvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmBlockDynamicFallbackValueRead::*)() const>(&org::imm::ImmBlockDynamicFallbackValueRead::getName),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmblockdynamicfallbackvaluereadJs", {InstanceMethod("getName", &ImmblockdynamicfallbackvaluereadJs::getName)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmblockdynamicfallbackvaluereadJs", func);
    return exports;
  }
  ImmblockdynamicfallbackvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmblockdynamicfallbackvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmblockdynamicfallbackvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmBlockDynamicFallbackValueRead> const& ptr) : Napi::ObjectWrap<ImmblockdynamicfallbackvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmBlockDynamicFallbackValueRead> _stored;
  org::imm::ImmBlockDynamicFallbackValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmblockdynamicfallbackvaluereadJs> {
  using type = org::imm::ImmBlockDynamicFallbackValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmBlockDynamicFallbackValueRead> {
  using type = ImmblockdynamicfallbackvaluereadJs;
};

struct ImmblockexamplevaluereadJs : public Napi::ObjectWrap<ImmblockexamplevaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmblockexamplevaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmblockexamplevaluereadJs", func);
    return exports;
  }
  ImmblockexamplevaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmblockexamplevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmblockexamplevaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmBlockExampleValueRead> const& ptr) : Napi::ObjectWrap<ImmblockexamplevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmBlockExampleValueRead> _stored;
  org::imm::ImmBlockExampleValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmblockexamplevaluereadJs> {
  using type = org::imm::ImmBlockExampleValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmBlockExampleValueRead> {
  using type = ImmblockexamplevaluereadJs;
};

struct ImmblockexportvaluereadJs : public Napi::ObjectWrap<ImmblockexportvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getExporter(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmBlockExportValueRead::*)() const>(&org::imm::ImmBlockExportValueRead::getExporter),
                                        std::make_tuple()));
  }
  Napi::Value getContent(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmBlockExportValueRead::*)() const>(&org::imm::ImmBlockExportValueRead::getContent),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmblockexportvaluereadJs", {InstanceMethod("getExporter", &ImmblockexportvaluereadJs::getExporter),
                                                                         InstanceMethod("getContent", &ImmblockexportvaluereadJs::getContent)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmblockexportvaluereadJs", func);
    return exports;
  }
  ImmblockexportvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmblockexportvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmblockexportvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmBlockExportValueRead> const& ptr) : Napi::ObjectWrap<ImmblockexportvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmBlockExportValueRead> _stored;
  org::imm::ImmBlockExportValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmblockexportvaluereadJs> {
  using type = org::imm::ImmBlockExportValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmBlockExportValueRead> {
  using type = ImmblockexportvaluereadJs;
};

struct ImmblockadmonitionvaluereadJs : public Napi::ObjectWrap<ImmblockadmonitionvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmblockadmonitionvaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmblockadmonitionvaluereadJs", func);
    return exports;
  }
  ImmblockadmonitionvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmblockadmonitionvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmblockadmonitionvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmBlockAdmonitionValueRead> const& ptr) : Napi::ObjectWrap<ImmblockadmonitionvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmBlockAdmonitionValueRead> _stored;
  org::imm::ImmBlockAdmonitionValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmblockadmonitionvaluereadJs> {
  using type = org::imm::ImmBlockAdmonitionValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmBlockAdmonitionValueRead> {
  using type = ImmblockadmonitionvaluereadJs;
};

struct ImmblockcodeevalresultvaluereadJs : public Napi::ObjectWrap<ImmblockcodeevalresultvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getRaw(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::sem::OrgCodeEvalOutput> const&(org::imm::ImmBlockCodeEvalResultValueRead::*)() const>(&org::imm::ImmBlockCodeEvalResultValueRead::getRaw),
                                        std::make_tuple()));
  }
  Napi::Value getNode(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmIdT<org::imm::ImmOrg> const&(org::imm::ImmBlockCodeEvalResultValueRead::*)() const>(&org::imm::ImmBlockCodeEvalResultValueRead::getNode),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmblockcodeevalresultvaluereadJs", {InstanceMethod("getRaw", &ImmblockcodeevalresultvaluereadJs::getRaw),
                                                                                 InstanceMethod("getNode", &ImmblockcodeevalresultvaluereadJs::getNode)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmblockcodeevalresultvaluereadJs", func);
    return exports;
  }
  ImmblockcodeevalresultvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmblockcodeevalresultvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmblockcodeevalresultvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmBlockCodeEvalResultValueRead> const& ptr) : Napi::ObjectWrap<ImmblockcodeevalresultvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmBlockCodeEvalResultValueRead> _stored;
  org::imm::ImmBlockCodeEvalResultValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmblockcodeevalresultvaluereadJs> {
  using type = org::imm::ImmBlockCodeEvalResultValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmBlockCodeEvalResultValueRead> {
  using type = ImmblockcodeevalresultvaluereadJs;
};

struct ImmblockcodevaluereadJs : public Napi::ObjectWrap<ImmblockcodevaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getLang(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmBlockCodeValueRead::*)() const>(&org::imm::ImmBlockCodeValueRead::getLang),
                                        std::make_tuple()));
  }
  Napi::Value getExports(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<BlockCodeExports const&(org::imm::ImmBlockCodeValueRead::*)() const>(&org::imm::ImmBlockCodeValueRead::getExports),
                                        std::make_tuple()));
  }
  Napi::Value getResult(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>> const&(org::imm::ImmBlockCodeValueRead::*)() const>(&org::imm::ImmBlockCodeValueRead::getResult),
                                        std::make_tuple()));
  }
  Napi::Value getLines(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::sem::BlockCodeLine> const&(org::imm::ImmBlockCodeValueRead::*)() const>(&org::imm::ImmBlockCodeValueRead::getLines),
                                        std::make_tuple()));
  }
  Napi::Value getCache(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmBlockCodeValueRead::*)() const>(&org::imm::ImmBlockCodeValueRead::getCache),
                                        std::make_tuple()));
  }
  Napi::Value getEval(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmBlockCodeValueRead::*)() const>(&org::imm::ImmBlockCodeValueRead::getEval),
                                        std::make_tuple()));
  }
  Napi::Value getNoweb(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmBlockCodeValueRead::*)() const>(&org::imm::ImmBlockCodeValueRead::getNoweb),
                                        std::make_tuple()));
  }
  Napi::Value getHlines(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmBlockCodeValueRead::*)() const>(&org::imm::ImmBlockCodeValueRead::getHlines),
                                        std::make_tuple()));
  }
  Napi::Value getTangle(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmBlockCodeValueRead::*)() const>(&org::imm::ImmBlockCodeValueRead::getTangle),
                                        std::make_tuple()));
  }
  Napi::Value getSwitches(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrGroup const&(org::imm::ImmBlockCodeValueRead::*)() const>(&org::imm::ImmBlockCodeValueRead::getSwitches),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmblockcodevaluereadJs", {InstanceMethod("getLang", &ImmblockcodevaluereadJs::getLang),
                                                                       InstanceMethod("getExports", &ImmblockcodevaluereadJs::getExports),
                                                                       InstanceMethod("getResult", &ImmblockcodevaluereadJs::getResult),
                                                                       InstanceMethod("getLines", &ImmblockcodevaluereadJs::getLines),
                                                                       InstanceMethod("getCache", &ImmblockcodevaluereadJs::getCache),
                                                                       InstanceMethod("getEval", &ImmblockcodevaluereadJs::getEval),
                                                                       InstanceMethod("getNoweb", &ImmblockcodevaluereadJs::getNoweb),
                                                                       InstanceMethod("getHlines", &ImmblockcodevaluereadJs::getHlines),
                                                                       InstanceMethod("getTangle", &ImmblockcodevaluereadJs::getTangle),
                                                                       InstanceMethod("getSwitches", &ImmblockcodevaluereadJs::getSwitches)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmblockcodevaluereadJs", func);
    return exports;
  }
  ImmblockcodevaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmblockcodevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmblockcodevaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmBlockCodeValueRead> const& ptr) : Napi::ObjectWrap<ImmblockcodevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmBlockCodeValueRead> _stored;
  org::imm::ImmBlockCodeValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmblockcodevaluereadJs> {
  using type = org::imm::ImmBlockCodeValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmBlockCodeValueRead> {
  using type = ImmblockcodevaluereadJs;
};

struct ImmsubtreelogvaluereadJs : public Napi::ObjectWrap<ImmsubtreelogvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getHead(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SubtreeLogHead const&(org::imm::ImmSubtreeLogValueRead::*)() const>(&org::imm::ImmSubtreeLogValueRead::getHead),
                                        std::make_tuple()));
  }
  Napi::Value getDesc(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmStmtList>>> const&(org::imm::ImmSubtreeLogValueRead::*)() const>(&org::imm::ImmSubtreeLogValueRead::getDesc),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmsubtreelogvaluereadJs", {InstanceMethod("getHead", &ImmsubtreelogvaluereadJs::getHead),
                                                                        InstanceMethod("getDesc", &ImmsubtreelogvaluereadJs::getDesc)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmsubtreelogvaluereadJs", func);
    return exports;
  }
  ImmsubtreelogvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmsubtreelogvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmsubtreelogvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmSubtreeLogValueRead> const& ptr) : Napi::ObjectWrap<ImmsubtreelogvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmSubtreeLogValueRead> _stored;
  org::imm::ImmSubtreeLogValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmsubtreelogvaluereadJs> {
  using type = org::imm::ImmSubtreeLogValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmSubtreeLogValueRead> {
  using type = ImmsubtreelogvaluereadJs;
};

struct ImmsubtreevaluereadJs : public Napi::ObjectWrap<ImmsubtreevaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getLevel(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int const&(org::imm::ImmSubtreeValueRead::*)() const>(&org::imm::ImmSubtreeValueRead::getLevel),
                                        std::make_tuple()));
  }
  Napi::Value getTreeid(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmSubtreeValueRead::*)() const>(&org::imm::ImmSubtreeValueRead::getTreeid),
                                        std::make_tuple()));
  }
  Napi::Value getTodo(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmSubtreeValueRead::*)() const>(&org::imm::ImmSubtreeValueRead::getTodo),
                                        std::make_tuple()));
  }
  Napi::Value getCompletion(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::sem::SubtreeCompletion>> const&(org::imm::ImmSubtreeValueRead::*)() const>(&org::imm::ImmSubtreeValueRead::getCompletion),
                                        std::make_tuple()));
  }
  Napi::Value getDescription(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&(org::imm::ImmSubtreeValueRead::*)() const>(&org::imm::ImmSubtreeValueRead::getDescription),
                                        std::make_tuple()));
  }
  Napi::Value getTags(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmHashTag>> const&(org::imm::ImmSubtreeValueRead::*)() const>(&org::imm::ImmSubtreeValueRead::getTags),
                                        std::make_tuple()));
  }
  Napi::Value getTitle(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmIdT<org::imm::ImmParagraph> const&(org::imm::ImmSubtreeValueRead::*)() const>(&org::imm::ImmSubtreeValueRead::getTitle),
                                        std::make_tuple()));
  }
  Napi::Value getLogbook(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmSubtreeLog>> const&(org::imm::ImmSubtreeValueRead::*)() const>(&org::imm::ImmSubtreeValueRead::getLogbook),
                                        std::make_tuple()));
  }
  Napi::Value getProperties(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::sem::NamedProperty> const&(org::imm::ImmSubtreeValueRead::*)() const>(&org::imm::ImmSubtreeValueRead::getProperties),
                                        std::make_tuple()));
  }
  Napi::Value getClosed(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::UserTime>> const&(org::imm::ImmSubtreeValueRead::*)() const>(&org::imm::ImmSubtreeValueRead::getClosed),
                                        std::make_tuple()));
  }
  Napi::Value getDeadline(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::UserTime>> const&(org::imm::ImmSubtreeValueRead::*)() const>(&org::imm::ImmSubtreeValueRead::getDeadline),
                                        std::make_tuple()));
  }
  Napi::Value getScheduled(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::UserTime>> const&(org::imm::ImmSubtreeValueRead::*)() const>(&org::imm::ImmSubtreeValueRead::getScheduled),
                                        std::make_tuple()));
  }
  Napi::Value getIscomment(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmSubtreeValueRead::*)() const>(&org::imm::ImmSubtreeValueRead::getIscomment),
                                        std::make_tuple()));
  }
  Napi::Value getIsarchived(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmSubtreeValueRead::*)() const>(&org::imm::ImmSubtreeValueRead::getIsarchived),
                                        std::make_tuple()));
  }
  Napi::Value getPriority(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmSubtreeValueRead::*)() const>(&org::imm::ImmSubtreeValueRead::getPriority),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmsubtreevaluereadJs", {InstanceMethod("getLevel", &ImmsubtreevaluereadJs::getLevel),
                                                                     InstanceMethod("getTreeid", &ImmsubtreevaluereadJs::getTreeid),
                                                                     InstanceMethod("getTodo", &ImmsubtreevaluereadJs::getTodo),
                                                                     InstanceMethod("getCompletion", &ImmsubtreevaluereadJs::getCompletion),
                                                                     InstanceMethod("getDescription", &ImmsubtreevaluereadJs::getDescription),
                                                                     InstanceMethod("getTags", &ImmsubtreevaluereadJs::getTags),
                                                                     InstanceMethod("getTitle", &ImmsubtreevaluereadJs::getTitle),
                                                                     InstanceMethod("getLogbook", &ImmsubtreevaluereadJs::getLogbook),
                                                                     InstanceMethod("getProperties", &ImmsubtreevaluereadJs::getProperties),
                                                                     InstanceMethod("getClosed", &ImmsubtreevaluereadJs::getClosed),
                                                                     InstanceMethod("getDeadline", &ImmsubtreevaluereadJs::getDeadline),
                                                                     InstanceMethod("getScheduled", &ImmsubtreevaluereadJs::getScheduled),
                                                                     InstanceMethod("getIscomment", &ImmsubtreevaluereadJs::getIscomment),
                                                                     InstanceMethod("getIsarchived", &ImmsubtreevaluereadJs::getIsarchived),
                                                                     InstanceMethod("getPriority", &ImmsubtreevaluereadJs::getPriority)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmsubtreevaluereadJs", func);
    return exports;
  }
  ImmsubtreevaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmsubtreevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmsubtreevaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmSubtreeValueRead> const& ptr) : Napi::ObjectWrap<ImmsubtreevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmSubtreeValueRead> _stored;
  org::imm::ImmSubtreeValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmsubtreevaluereadJs> {
  using type = org::imm::ImmSubtreeValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmSubtreeValueRead> {
  using type = ImmsubtreevaluereadJs;
};

struct ImmcellvaluereadJs : public Napi::ObjectWrap<ImmcellvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getIsblock(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmCellValueRead::*)() const>(&org::imm::ImmCellValueRead::getIsblock),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmcellvaluereadJs", {InstanceMethod("getIsblock", &ImmcellvaluereadJs::getIsblock)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmcellvaluereadJs", func);
    return exports;
  }
  ImmcellvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmcellvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmcellvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmCellValueRead> const& ptr) : Napi::ObjectWrap<ImmcellvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmCellValueRead> _stored;
  org::imm::ImmCellValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmcellvaluereadJs> {
  using type = org::imm::ImmCellValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmCellValueRead> {
  using type = ImmcellvaluereadJs;
};

struct ImmrowvaluereadJs : public Napi::ObjectWrap<ImmrowvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getCells(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmCell>> const&(org::imm::ImmRowValueRead::*)() const>(&org::imm::ImmRowValueRead::getCells),
                                        std::make_tuple()));
  }
  Napi::Value getIsblock(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmRowValueRead::*)() const>(&org::imm::ImmRowValueRead::getIsblock),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmrowvaluereadJs", {InstanceMethod("getCells", &ImmrowvaluereadJs::getCells),
                                                                 InstanceMethod("getIsblock", &ImmrowvaluereadJs::getIsblock)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmrowvaluereadJs", func);
    return exports;
  }
  ImmrowvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmrowvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmrowvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmRowValueRead> const& ptr) : Napi::ObjectWrap<ImmrowvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmRowValueRead> _stored;
  org::imm::ImmRowValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmrowvaluereadJs> {
  using type = org::imm::ImmRowValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmRowValueRead> {
  using type = ImmrowvaluereadJs;
};

struct ImmtablevaluereadJs : public Napi::ObjectWrap<ImmtablevaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getRows(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmRow>> const&(org::imm::ImmTableValueRead::*)() const>(&org::imm::ImmTableValueRead::getRows),
                                        std::make_tuple()));
  }
  Napi::Value getIsblock(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmTableValueRead::*)() const>(&org::imm::ImmTableValueRead::getIsblock),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmtablevaluereadJs", {InstanceMethod("getRows", &ImmtablevaluereadJs::getRows),
                                                                   InstanceMethod("getIsblock", &ImmtablevaluereadJs::getIsblock)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmtablevaluereadJs", func);
    return exports;
  }
  ImmtablevaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmtablevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmtablevaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmTableValueRead> const& ptr) : Napi::ObjectWrap<ImmtablevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmTableValueRead> _stored;
  org::imm::ImmTableValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmtablevaluereadJs> {
  using type = org::imm::ImmTableValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmTableValueRead> {
  using type = ImmtablevaluereadJs;
};

struct ImmparagraphvaluereadJs : public Napi::ObjectWrap<ImmparagraphvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmparagraphvaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmparagraphvaluereadJs", func);
    return exports;
  }
  ImmparagraphvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmparagraphvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmparagraphvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmParagraphValueRead> const& ptr) : Napi::ObjectWrap<ImmparagraphvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmParagraphValueRead> _stored;
  org::imm::ImmParagraphValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmparagraphvaluereadJs> {
  using type = org::imm::ImmParagraphValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmParagraphValueRead> {
  using type = ImmparagraphvaluereadJs;
};

struct ImmcolonexamplevaluereadJs : public Napi::ObjectWrap<ImmcolonexamplevaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmcolonexamplevaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmcolonexamplevaluereadJs", func);
    return exports;
  }
  ImmcolonexamplevaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmcolonexamplevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmcolonexamplevaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmColonExampleValueRead> const& ptr) : Napi::ObjectWrap<ImmcolonexamplevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmColonExampleValueRead> _stored;
  org::imm::ImmColonExampleValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmcolonexamplevaluereadJs> {
  using type = org::imm::ImmColonExampleValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmColonExampleValueRead> {
  using type = ImmcolonexamplevaluereadJs;
};

struct ImmcmdattrvaluereadJs : public Napi::ObjectWrap<ImmcmdattrvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getTarget(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdAttrValueRead::*)() const>(&org::imm::ImmCmdAttrValueRead::getTarget),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmcmdattrvaluereadJs", {InstanceMethod("getTarget", &ImmcmdattrvaluereadJs::getTarget)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmcmdattrvaluereadJs", func);
    return exports;
  }
  ImmcmdattrvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmcmdattrvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmcmdattrvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmCmdAttrValueRead> const& ptr) : Napi::ObjectWrap<ImmcmdattrvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmCmdAttrValueRead> _stored;
  org::imm::ImmCmdAttrValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmcmdattrvaluereadJs> {
  using type = org::imm::ImmCmdAttrValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmCmdAttrValueRead> {
  using type = ImmcmdattrvaluereadJs;
};

struct ImmcmdexportvaluereadJs : public Napi::ObjectWrap<ImmcmdexportvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getExporter(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdExportValueRead::*)() const>(&org::imm::ImmCmdExportValueRead::getExporter),
                                        std::make_tuple()));
  }
  Napi::Value getContent(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdExportValueRead::*)() const>(&org::imm::ImmCmdExportValueRead::getContent),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmcmdexportvaluereadJs", {InstanceMethod("getExporter", &ImmcmdexportvaluereadJs::getExporter),
                                                                       InstanceMethod("getContent", &ImmcmdexportvaluereadJs::getContent)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmcmdexportvaluereadJs", func);
    return exports;
  }
  ImmcmdexportvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmcmdexportvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmcmdexportvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmCmdExportValueRead> const& ptr) : Napi::ObjectWrap<ImmcmdexportvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmCmdExportValueRead> _stored;
  org::imm::ImmCmdExportValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmcmdexportvaluereadJs> {
  using type = org::imm::ImmCmdExportValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmCmdExportValueRead> {
  using type = ImmcmdexportvaluereadJs;
};

struct ImmcallvaluereadJs : public Napi::ObjectWrap<ImmcallvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCallValueRead::*)() const>(&org::imm::ImmCallValueRead::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrGroup const&(org::imm::ImmCallValueRead::*)() const>(&org::imm::ImmCallValueRead::getAttrs),
                                        std::make_tuple()));
  }
  Napi::Value getIscommand(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmCallValueRead::*)() const>(&org::imm::ImmCallValueRead::getIscommand),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmcallvaluereadJs", {InstanceMethod("getName", &ImmcallvaluereadJs::getName),
                                                                  InstanceMethod("getAttrs", &ImmcallvaluereadJs::getAttrs),
                                                                  InstanceMethod("getIscommand", &ImmcallvaluereadJs::getIscommand)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmcallvaluereadJs", func);
    return exports;
  }
  ImmcallvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmcallvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmcallvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmCallValueRead> const& ptr) : Napi::ObjectWrap<ImmcallvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmCallValueRead> _stored;
  org::imm::ImmCallValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmcallvaluereadJs> {
  using type = org::imm::ImmCallValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmCallValueRead> {
  using type = ImmcallvaluereadJs;
};

struct ImmlistvaluereadJs : public Napi::ObjectWrap<ImmlistvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmlistvaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmlistvaluereadJs", func);
    return exports;
  }
  ImmlistvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmlistvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmlistvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmListValueRead> const& ptr) : Napi::ObjectWrap<ImmlistvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmListValueRead> _stored;
  org::imm::ImmListValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmlistvaluereadJs> {
  using type = org::imm::ImmListValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmListValueRead> {
  using type = ImmlistvaluereadJs;
};

struct ImmlistitemvaluereadJs : public Napi::ObjectWrap<ImmlistitemvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getCheckbox(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmListItem::Checkbox const&(org::imm::ImmListItemValueRead::*)() const>(&org::imm::ImmListItemValueRead::getCheckbox),
                                        std::make_tuple()));
  }
  Napi::Value getHeader(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&(org::imm::ImmListItemValueRead::*)() const>(&org::imm::ImmListItemValueRead::getHeader),
                                        std::make_tuple()));
  }
  Napi::Value getBullet(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmListItemValueRead::*)() const>(&org::imm::ImmListItemValueRead::getBullet),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmlistitemvaluereadJs", {InstanceMethod("getCheckbox", &ImmlistitemvaluereadJs::getCheckbox),
                                                                      InstanceMethod("getHeader", &ImmlistitemvaluereadJs::getHeader),
                                                                      InstanceMethod("getBullet", &ImmlistitemvaluereadJs::getBullet)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmlistitemvaluereadJs", func);
    return exports;
  }
  ImmlistitemvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmlistitemvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmlistitemvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmListItemValueRead> const& ptr) : Napi::ObjectWrap<ImmlistitemvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmListItemValueRead> _stored;
  org::imm::ImmListItemValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmlistitemvaluereadJs> {
  using type = org::imm::ImmListItemValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmListItemValueRead> {
  using type = ImmlistitemvaluereadJs;
};

struct ImmdocumentoptionsvaluereadJs : public Napi::ObjectWrap<ImmdocumentoptionsvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getInitialvisibility(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<InitialSubtreeVisibility const&(org::imm::ImmDocumentOptionsValueRead::*)() const>(&org::imm::ImmDocumentOptionsValueRead::getInitialvisibility),
                                        std::make_tuple()));
  }
  Napi::Value getProperties(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::sem::NamedProperty> const&(org::imm::ImmDocumentOptionsValueRead::*)() const>(&org::imm::ImmDocumentOptionsValueRead::getProperties),
                                        std::make_tuple()));
  }
  Napi::Value getExportconfig(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::DocumentExportConfig const&(org::imm::ImmDocumentOptionsValueRead::*)() const>(&org::imm::ImmDocumentOptionsValueRead::getExportconfig),
                                        std::make_tuple()));
  }
  Napi::Value getFixedwidthsections(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<bool>> const&(org::imm::ImmDocumentOptionsValueRead::*)() const>(&org::imm::ImmDocumentOptionsValueRead::getFixedwidthsections),
                                        std::make_tuple()));
  }
  Napi::Value getStartupindented(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<bool>> const&(org::imm::ImmDocumentOptionsValueRead::*)() const>(&org::imm::ImmDocumentOptionsValueRead::getStartupindented),
                                        std::make_tuple()));
  }
  Napi::Value getCategory(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmDocumentOptionsValueRead::*)() const>(&org::imm::ImmDocumentOptionsValueRead::getCategory),
                                        std::make_tuple()));
  }
  Napi::Value getSetupfile(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmDocumentOptionsValueRead::*)() const>(&org::imm::ImmDocumentOptionsValueRead::getSetupfile),
                                        std::make_tuple()));
  }
  Napi::Value getMaxsubtreelevelexport(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<int>> const&(org::imm::ImmDocumentOptionsValueRead::*)() const>(&org::imm::ImmDocumentOptionsValueRead::getMaxsubtreelevelexport),
                                        std::make_tuple()));
  }
  Napi::Value getColumns(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::sem::ColumnView>> const&(org::imm::ImmDocumentOptionsValueRead::*)() const>(&org::imm::ImmDocumentOptionsValueRead::getColumns),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmdocumentoptionsvaluereadJs", {InstanceMethod("getInitialvisibility", &ImmdocumentoptionsvaluereadJs::getInitialvisibility),
                                                                             InstanceMethod("getProperties", &ImmdocumentoptionsvaluereadJs::getProperties),
                                                                             InstanceMethod("getExportconfig", &ImmdocumentoptionsvaluereadJs::getExportconfig),
                                                                             InstanceMethod("getFixedwidthsections", &ImmdocumentoptionsvaluereadJs::getFixedwidthsections),
                                                                             InstanceMethod("getStartupindented", &ImmdocumentoptionsvaluereadJs::getStartupindented),
                                                                             InstanceMethod("getCategory", &ImmdocumentoptionsvaluereadJs::getCategory),
                                                                             InstanceMethod("getSetupfile", &ImmdocumentoptionsvaluereadJs::getSetupfile),
                                                                             InstanceMethod("getMaxsubtreelevelexport", &ImmdocumentoptionsvaluereadJs::getMaxsubtreelevelexport),
                                                                             InstanceMethod("getColumns", &ImmdocumentoptionsvaluereadJs::getColumns)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmdocumentoptionsvaluereadJs", func);
    return exports;
  }
  ImmdocumentoptionsvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmdocumentoptionsvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmdocumentoptionsvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmDocumentOptionsValueRead> const& ptr) : Napi::ObjectWrap<ImmdocumentoptionsvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmDocumentOptionsValueRead> _stored;
  org::imm::ImmDocumentOptionsValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmdocumentoptionsvaluereadJs> {
  using type = org::imm::ImmDocumentOptionsValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmDocumentOptionsValueRead> {
  using type = ImmdocumentoptionsvaluereadJs;
};

struct ImmdocumentfragmentvaluereadJs : public Napi::ObjectWrap<ImmdocumentfragmentvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getBaseline(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int const&(org::imm::ImmDocumentFragmentValueRead::*)() const>(&org::imm::ImmDocumentFragmentValueRead::getBaseline),
                                        std::make_tuple()));
  }
  Napi::Value getBasecol(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int const&(org::imm::ImmDocumentFragmentValueRead::*)() const>(&org::imm::ImmDocumentFragmentValueRead::getBasecol),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmdocumentfragmentvaluereadJs", {InstanceMethod("getBaseline", &ImmdocumentfragmentvaluereadJs::getBaseline),
                                                                              InstanceMethod("getBasecol", &ImmdocumentfragmentvaluereadJs::getBasecol)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmdocumentfragmentvaluereadJs", func);
    return exports;
  }
  ImmdocumentfragmentvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmdocumentfragmentvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmdocumentfragmentvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmDocumentFragmentValueRead> const& ptr) : Napi::ObjectWrap<ImmdocumentfragmentvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmDocumentFragmentValueRead> _stored;
  org::imm::ImmDocumentFragmentValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmdocumentfragmentvaluereadJs> {
  using type = org::imm::ImmDocumentFragmentValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmDocumentFragmentValueRead> {
  using type = ImmdocumentfragmentvaluereadJs;
};

struct ImmcriticmarkupvaluereadJs : public Napi::ObjectWrap<ImmcriticmarkupvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCriticMarkup::Kind const&(org::imm::ImmCriticMarkupValueRead::*)() const>(&org::imm::ImmCriticMarkupValueRead::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmcriticmarkupvaluereadJs", {InstanceMethod("getKind", &ImmcriticmarkupvaluereadJs::getKind)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmcriticmarkupvaluereadJs", func);
    return exports;
  }
  ImmcriticmarkupvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmcriticmarkupvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmcriticmarkupvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmCriticMarkupValueRead> const& ptr) : Napi::ObjectWrap<ImmcriticmarkupvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmCriticMarkupValueRead> _stored;
  org::imm::ImmCriticMarkupValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmcriticmarkupvaluereadJs> {
  using type = org::imm::ImmCriticMarkupValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmCriticMarkupValueRead> {
  using type = ImmcriticmarkupvaluereadJs;
};

struct ImmdocumentvaluereadJs : public Napi::ObjectWrap<ImmdocumentvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getTitle(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&(org::imm::ImmDocumentValueRead::*)() const>(&org::imm::ImmDocumentValueRead::getTitle),
                                        std::make_tuple()));
  }
  Napi::Value getAuthor(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&(org::imm::ImmDocumentValueRead::*)() const>(&org::imm::ImmDocumentValueRead::getAuthor),
                                        std::make_tuple()));
  }
  Napi::Value getCreator(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&(org::imm::ImmDocumentValueRead::*)() const>(&org::imm::ImmDocumentValueRead::getCreator),
                                        std::make_tuple()));
  }
  Napi::Value getFiletags(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmHashTag>> const&(org::imm::ImmDocumentValueRead::*)() const>(&org::imm::ImmDocumentValueRead::getFiletags),
                                        std::make_tuple()));
  }
  Napi::Value getEmail(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmRawText>>> const&(org::imm::ImmDocumentValueRead::*)() const>(&org::imm::ImmDocumentValueRead::getEmail),
                                        std::make_tuple()));
  }
  Napi::Value getLanguage(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<hstd::Str> const&(org::imm::ImmDocumentValueRead::*)() const>(&org::imm::ImmDocumentValueRead::getLanguage),
                                        std::make_tuple()));
  }
  Napi::Value getOptions(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmIdT<org::imm::ImmDocumentOptions> const&(org::imm::ImmDocumentValueRead::*)() const>(&org::imm::ImmDocumentValueRead::getOptions),
                                        std::make_tuple()));
  }
  Napi::Value getExportfilename(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmDocumentValueRead::*)() const>(&org::imm::ImmDocumentValueRead::getExportfilename),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmdocumentvaluereadJs", {InstanceMethod("getTitle", &ImmdocumentvaluereadJs::getTitle),
                                                                      InstanceMethod("getAuthor", &ImmdocumentvaluereadJs::getAuthor),
                                                                      InstanceMethod("getCreator", &ImmdocumentvaluereadJs::getCreator),
                                                                      InstanceMethod("getFiletags", &ImmdocumentvaluereadJs::getFiletags),
                                                                      InstanceMethod("getEmail", &ImmdocumentvaluereadJs::getEmail),
                                                                      InstanceMethod("getLanguage", &ImmdocumentvaluereadJs::getLanguage),
                                                                      InstanceMethod("getOptions", &ImmdocumentvaluereadJs::getOptions),
                                                                      InstanceMethod("getExportfilename", &ImmdocumentvaluereadJs::getExportfilename)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmdocumentvaluereadJs", func);
    return exports;
  }
  ImmdocumentvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmdocumentvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmdocumentvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmDocumentValueRead> const& ptr) : Napi::ObjectWrap<ImmdocumentvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmDocumentValueRead> _stored;
  org::imm::ImmDocumentValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmdocumentvaluereadJs> {
  using type = org::imm::ImmDocumentValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmDocumentValueRead> {
  using type = ImmdocumentvaluereadJs;
};

struct ImmfiletargetvaluereadJs : public Napi::ObjectWrap<ImmfiletargetvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getPath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmFileTargetValueRead::*)() const>(&org::imm::ImmFileTargetValueRead::getPath),
                                        std::make_tuple()));
  }
  Napi::Value getLine(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<int>> const&(org::imm::ImmFileTargetValueRead::*)() const>(&org::imm::ImmFileTargetValueRead::getLine),
                                        std::make_tuple()));
  }
  Napi::Value getSearchtarget(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmFileTargetValueRead::*)() const>(&org::imm::ImmFileTargetValueRead::getSearchtarget),
                                        std::make_tuple()));
  }
  Napi::Value getRestricttoheadlines(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmFileTargetValueRead::*)() const>(&org::imm::ImmFileTargetValueRead::getRestricttoheadlines),
                                        std::make_tuple()));
  }
  Napi::Value getTargetid(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmFileTargetValueRead::*)() const>(&org::imm::ImmFileTargetValueRead::getTargetid),
                                        std::make_tuple()));
  }
  Napi::Value getRegexp(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmFileTargetValueRead::*)() const>(&org::imm::ImmFileTargetValueRead::getRegexp),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmfiletargetvaluereadJs", {InstanceMethod("getPath", &ImmfiletargetvaluereadJs::getPath),
                                                                        InstanceMethod("getLine", &ImmfiletargetvaluereadJs::getLine),
                                                                        InstanceMethod("getSearchtarget", &ImmfiletargetvaluereadJs::getSearchtarget),
                                                                        InstanceMethod("getRestricttoheadlines", &ImmfiletargetvaluereadJs::getRestricttoheadlines),
                                                                        InstanceMethod("getTargetid", &ImmfiletargetvaluereadJs::getTargetid),
                                                                        InstanceMethod("getRegexp", &ImmfiletargetvaluereadJs::getRegexp)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmfiletargetvaluereadJs", func);
    return exports;
  }
  ImmfiletargetvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmfiletargetvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmfiletargetvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmFileTargetValueRead> const& ptr) : Napi::ObjectWrap<ImmfiletargetvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmFileTargetValueRead> _stored;
  org::imm::ImmFileTargetValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmfiletargetvaluereadJs> {
  using type = org::imm::ImmFileTargetValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmFileTargetValueRead> {
  using type = ImmfiletargetvaluereadJs;
};

struct ImmtextseparatorvaluereadJs : public Napi::ObjectWrap<ImmtextseparatorvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmtextseparatorvaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmtextseparatorvaluereadJs", func);
    return exports;
  }
  ImmtextseparatorvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmtextseparatorvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmtextseparatorvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmTextSeparatorValueRead> const& ptr) : Napi::ObjectWrap<ImmtextseparatorvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmTextSeparatorValueRead> _stored;
  org::imm::ImmTextSeparatorValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmtextseparatorvaluereadJs> {
  using type = org::imm::ImmTextSeparatorValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmTextSeparatorValueRead> {
  using type = ImmtextseparatorvaluereadJs;
};

struct ImmdocumentgroupvaluereadJs : public Napi::ObjectWrap<ImmdocumentgroupvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmdocumentgroupvaluereadJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmdocumentgroupvaluereadJs", func);
    return exports;
  }
  ImmdocumentgroupvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmdocumentgroupvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmdocumentgroupvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmDocumentGroupValueRead> const& ptr) : Napi::ObjectWrap<ImmdocumentgroupvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmDocumentGroupValueRead> _stored;
  org::imm::ImmDocumentGroupValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmdocumentgroupvaluereadJs> {
  using type = org::imm::ImmDocumentGroupValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmDocumentGroupValueRead> {
  using type = ImmdocumentgroupvaluereadJs;
};

struct ImmfilevaluereadJs : public Napi::ObjectWrap<ImmfilevaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getRelpath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmFileValueRead::*)() const>(&org::imm::ImmFileValueRead::getRelpath),
                                        std::make_tuple()));
  }
  Napi::Value getAbspath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmFileValueRead::*)() const>(&org::imm::ImmFileValueRead::getAbspath),
                                        std::make_tuple()));
  }
  Napi::Value getData(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmFile::Data const&(org::imm::ImmFileValueRead::*)() const>(&org::imm::ImmFileValueRead::getData),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmfilevaluereadJs", {InstanceMethod("getRelpath", &ImmfilevaluereadJs::getRelpath),
                                                                  InstanceMethod("getAbspath", &ImmfilevaluereadJs::getAbspath),
                                                                  InstanceMethod("getData", &ImmfilevaluereadJs::getData)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmfilevaluereadJs", func);
    return exports;
  }
  ImmfilevaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmfilevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmfilevaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmFileValueRead> const& ptr) : Napi::ObjectWrap<ImmfilevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmFileValueRead> _stored;
  org::imm::ImmFileValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmfilevaluereadJs> {
  using type = org::imm::ImmFileValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmFileValueRead> {
  using type = ImmfilevaluereadJs;
};

struct ImmdirectoryvaluereadJs : public Napi::ObjectWrap<ImmdirectoryvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getRelpath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmDirectoryValueRead::*)() const>(&org::imm::ImmDirectoryValueRead::getRelpath),
                                        std::make_tuple()));
  }
  Napi::Value getAbspath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmDirectoryValueRead::*)() const>(&org::imm::ImmDirectoryValueRead::getAbspath),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmdirectoryvaluereadJs", {InstanceMethod("getRelpath", &ImmdirectoryvaluereadJs::getRelpath),
                                                                       InstanceMethod("getAbspath", &ImmdirectoryvaluereadJs::getAbspath)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmdirectoryvaluereadJs", func);
    return exports;
  }
  ImmdirectoryvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmdirectoryvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmdirectoryvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmDirectoryValueRead> const& ptr) : Napi::ObjectWrap<ImmdirectoryvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmDirectoryValueRead> _stored;
  org::imm::ImmDirectoryValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmdirectoryvaluereadJs> {
  using type = org::imm::ImmDirectoryValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmDirectoryValueRead> {
  using type = ImmdirectoryvaluereadJs;
};

struct ImmsymlinkvaluereadJs : public Napi::ObjectWrap<ImmsymlinkvaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getIsdirectory(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmSymlinkValueRead::*)() const>(&org::imm::ImmSymlinkValueRead::getIsdirectory),
                                        std::make_tuple()));
  }
  Napi::Value getAbspath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmSymlinkValueRead::*)() const>(&org::imm::ImmSymlinkValueRead::getAbspath),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmsymlinkvaluereadJs", {InstanceMethod("getIsdirectory", &ImmsymlinkvaluereadJs::getIsdirectory),
                                                                     InstanceMethod("getAbspath", &ImmsymlinkvaluereadJs::getAbspath)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmsymlinkvaluereadJs", func);
    return exports;
  }
  ImmsymlinkvaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmsymlinkvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmsymlinkvaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmSymlinkValueRead> const& ptr) : Napi::ObjectWrap<ImmsymlinkvaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmSymlinkValueRead> _stored;
  org::imm::ImmSymlinkValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmsymlinkvaluereadJs> {
  using type = org::imm::ImmSymlinkValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmSymlinkValueRead> {
  using type = ImmsymlinkvaluereadJs;
};

struct ImmcmdincludevaluereadJs : public Napi::ObjectWrap<ImmcmdincludevaluereadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getPath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdIncludeValueRead::*)() const>(&org::imm::ImmCmdIncludeValueRead::getPath),
                                        std::make_tuple()));
  }
  Napi::Value getFirstline(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<int>> const&(org::imm::ImmCmdIncludeValueRead::*)() const>(&org::imm::ImmCmdIncludeValueRead::getFirstline),
                                        std::make_tuple()));
  }
  Napi::Value getLastline(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<int>> const&(org::imm::ImmCmdIncludeValueRead::*)() const>(&org::imm::ImmCmdIncludeValueRead::getLastline),
                                        std::make_tuple()));
  }
  Napi::Value getData(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCmdInclude::Data const&(org::imm::ImmCmdIncludeValueRead::*)() const>(&org::imm::ImmCmdIncludeValueRead::getData),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmcmdincludevaluereadJs", {InstanceMethod("getPath", &ImmcmdincludevaluereadJs::getPath),
                                                                        InstanceMethod("getFirstline", &ImmcmdincludevaluereadJs::getFirstline),
                                                                        InstanceMethod("getLastline", &ImmcmdincludevaluereadJs::getLastline),
                                                                        InstanceMethod("getData", &ImmcmdincludevaluereadJs::getData)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmcmdincludevaluereadJs", func);
    return exports;
  }
  ImmcmdincludevaluereadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmcmdincludevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmcmdincludevaluereadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmCmdIncludeValueRead> const& ptr) : Napi::ObjectWrap<ImmcmdincludevaluereadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmCmdIncludeValueRead> _stored;
  org::imm::ImmCmdIncludeValueRead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmcmdincludevaluereadJs> {
  using type = org::imm::ImmCmdIncludeValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmCmdIncludeValueRead> {
  using type = ImmcmdincludevaluereadJs;
};

struct ImmastcontextJs : public Napi::ObjectWrap<ImmastcontextJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value addRoot(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::imm::ImmAstVersion(org::imm::ImmAstContext::*)(org::sem::SemId<org::sem::Org>)>(&org::imm::ImmAstContext::addRoot),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"data"})));
  }
  Napi::Value get(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::imm::ImmAstContext::*)(org::imm::ImmId)>(&org::imm::ImmAstContext::get),
                                   std::make_tuple(CxxArgSpec<org::imm::ImmId>{"id"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmastcontextJs", {InstanceMethod("addRoot", &ImmastcontextJs::addRoot),
                                                               InstanceMethod("get", &ImmastcontextJs::get)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmastcontextJs", func);
    return exports;
  }
  ImmastcontextJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmastcontextJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmastcontextJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAstContext> const& ptr) : Napi::ObjectWrap<ImmastcontextJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAstContext> _stored;
  org::imm::ImmAstContext* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmastcontextJs> {
  using type = org::imm::ImmAstContext;
};

template <>
struct org_to_js_type<org::imm::ImmAstContext> {
  using type = ImmastcontextJs;
};

struct ImmastversionJs : public Napi::ObjectWrap<ImmastversionJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getRoot(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId(org::imm::ImmAstVersion::*)() const>(&org::imm::ImmAstVersion::getRoot),
                                        std::make_tuple()));
  }
  Napi::Value getRootAdapter(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmAdapter(org::imm::ImmAstVersion::*)() const>(&org::imm::ImmAstVersion::getRootAdapter),
                                        std::make_tuple()));
  }
  Napi::Value getContext(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::shared_ptr<org::imm::ImmAstContext>(org::imm::ImmAstVersion::*)() const>(&org::imm::ImmAstVersion::getContext),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmastversionJs", {InstanceMethod("getRoot", &ImmastversionJs::getRoot),
                                                               InstanceMethod("getRootAdapter", &ImmastversionJs::getRootAdapter),
                                                               InstanceMethod("getContext", &ImmastversionJs::getContext)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmastversionJs", func);
    return exports;
  }
  ImmastversionJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmastversionJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmAstVersion>();
  }
  ImmastversionJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAstVersion> const& ptr) : Napi::ObjectWrap<ImmastversionJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAstVersion> _stored;
  org::imm::ImmAstVersion* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmastversionJs> {
  using type = org::imm::ImmAstVersion;
};

template <>
struct org_to_js_type<org::imm::ImmAstVersion> {
  using type = ImmastversionJs;
};

struct ImmadapterJs : public Napi::ObjectWrap<ImmadapterJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::imm::ImmAdapter::*)() const>(&org::imm::ImmAdapter::size),
                                        std::make_tuple()));
  }
  Napi::Value isNil(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmAdapter::*)() const>(&org::imm::ImmAdapter::isNil),
                                        std::make_tuple()));
  }
  Napi::Value isRoot(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmAdapter::*)() const>(&org::imm::ImmAdapter::isRoot),
                                        std::make_tuple()));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmAdapter::*)() const>(&org::imm::ImmAdapter::getKind),
                                        std::make_tuple()));
  }
  Napi::Value uniq(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmUniqId(org::imm::ImmAdapter::*)() const>(&org::imm::ImmAdapter::uniq),
                                        std::make_tuple()));
  }
  Napi::Value treeReprString(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmAdapter::*)() const>(&org::imm::ImmAdapter::treeReprString),
                                        std::make_tuple()));
  }
  Napi::Value treeReprStringOpts(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmAdapter::*)(org::imm::ImmAdapter::TreeReprConf const&) const>(&org::imm::ImmAdapter::treeReprStringOpts),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmAdapter::TreeReprConf>{"conf"})));
  }
  Napi::Value isDirectParentOf(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmAdapter::*)(org::imm::ImmAdapter const&) const>(&org::imm::ImmAdapter::isDirectParentOf),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmAdapter>{"other"})));
  }
  Napi::Value isIndirectParentOf(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmAdapter::*)(org::imm::ImmAdapter const&) const>(&org::imm::ImmAdapter::isIndirectParentOf),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmAdapter>{"other"})));
  }
  Napi::Value isSubnodeOf(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmAdapter::*)(org::imm::ImmAdapter const&) const>(&org::imm::ImmAdapter::isSubnodeOf),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmAdapter>{"other"})));
  }
  Napi::Value getParent(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::optional<org::imm::ImmAdapter>(org::imm::ImmAdapter::*)() const>(&org::imm::ImmAdapter::getParent),
                                        std::make_tuple()));
  }
  Napi::Value getSelfIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::imm::ImmAdapter::*)() const>(&org::imm::ImmAdapter::getSelfIndex),
                                        std::make_tuple()));
  }
  Napi::Value atPath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmAdapter(org::imm::ImmAdapter::*)(hstd::Vec<int> const&, bool) const>(&org::imm::ImmAdapter::at),
                                        std::make_tuple(CxxArgSpec<hstd::Vec<int>>{"path"},
                                                        CxxArgSpec<bool>{"withPath", 1})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmAdapter::*)(OrgSemKind) const>(&org::imm::ImmAdapter::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value sub(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::imm::ImmAdapter>(org::imm::ImmAdapter::*)(bool) const>(&org::imm::ImmAdapter::sub),
                                        std::make_tuple(CxxArgSpec<bool>{"withPath", 1})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmadapterJs", {InstanceMethod("size", &ImmadapterJs::size),
                                                            InstanceMethod("isNil", &ImmadapterJs::isNil),
                                                            InstanceMethod("isRoot", &ImmadapterJs::isRoot),
                                                            InstanceMethod("getKind", &ImmadapterJs::getKind),
                                                            InstanceMethod("uniq", &ImmadapterJs::uniq),
                                                            InstanceMethod("treeReprString", &ImmadapterJs::treeReprString),
                                                            InstanceMethod("treeReprStringOpts", &ImmadapterJs::treeReprStringOpts),
                                                            InstanceMethod("isDirectParentOf", &ImmadapterJs::isDirectParentOf),
                                                            InstanceMethod("isIndirectParentOf", &ImmadapterJs::isIndirectParentOf),
                                                            InstanceMethod("isSubnodeOf", &ImmadapterJs::isSubnodeOf),
                                                            InstanceMethod("getParent", &ImmadapterJs::getParent),
                                                            InstanceMethod("getSelfIndex", &ImmadapterJs::getSelfIndex),
                                                            InstanceMethod("atPath", &ImmadapterJs::atPath),
                                                            InstanceMethod("is", &ImmadapterJs::is),
                                                            InstanceMethod("sub", &ImmadapterJs::sub)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmadapterJs", func);
    return exports;
  }
  ImmadapterJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmadapterJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmadapterJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapter> const& ptr) : Napi::ObjectWrap<ImmadapterJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapter> _stored;
  org::imm::ImmAdapter* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmadapterJs> {
  using type = org::imm::ImmAdapter;
};

template <>
struct org_to_js_type<org::imm::ImmAdapter> {
  using type = ImmadapterJs;
};

struct ImmadapterTreereprconfJs : public Napi::ObjectWrap<ImmadapterTreereprconfJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmadapterTreereprconfJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmadapterTreereprconfJs", func);
    return exports;
  }
  ImmadapterTreereprconfJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmadapterTreereprconfJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmAdapter::TreeReprConf>();
  }
  ImmadapterTreereprconfJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapter::TreeReprConf> const& ptr) : Napi::ObjectWrap<ImmadapterTreereprconfJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapter::TreeReprConf> _stored;
  org::imm::ImmAdapter::TreeReprConf* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmadapterTreereprconfJs> {
  using type = org::imm::ImmAdapter::TreeReprConf;
};

template <>
struct org_to_js_type<org::imm::ImmAdapter::TreeReprConf> {
  using type = ImmadapterTreereprconfJs;
};

struct OrgparsefragmentJs : public Napi::ObjectWrap<OrgparsefragmentJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "OrgparsefragmentJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("OrgparsefragmentJs", func);
    return exports;
  }
  OrgparsefragmentJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<OrgparsefragmentJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::OrgParseFragment>();
  }
  OrgparsefragmentJs(Napi::CallbackInfo const& info, std::shared_ptr<org::OrgParseFragment> const& ptr) : Napi::ObjectWrap<OrgparsefragmentJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::OrgParseFragment> _stored;
  org::OrgParseFragment* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<OrgparsefragmentJs> {
  using type = org::OrgParseFragment;
};

template <>
struct org_to_js_type<org::OrgParseFragment> {
  using type = OrgparsefragmentJs;
};

struct OrgparseparametersJs : public Napi::ObjectWrap<OrgparseparametersJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "OrgparseparametersJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("OrgparseparametersJs", func);
    return exports;
  }
  OrgparseparametersJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<OrgparseparametersJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::OrgParseParameters>();
  }
  OrgparseparametersJs(Napi::CallbackInfo const& info, std::shared_ptr<org::OrgParseParameters> const& ptr) : Napi::ObjectWrap<OrgparseparametersJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::OrgParseParameters> _stored;
  org::OrgParseParameters* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<OrgparseparametersJs> {
  using type = org::OrgParseParameters;
};

template <>
struct org_to_js_type<org::OrgParseParameters> {
  using type = OrgparseparametersJs;
};

struct OrgdirectoryparseparametersJs : public Napi::ObjectWrap<OrgdirectoryparseparametersJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "OrgdirectoryparseparametersJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("OrgdirectoryparseparametersJs", func);
    return exports;
  }
  OrgdirectoryparseparametersJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<OrgdirectoryparseparametersJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::OrgDirectoryParseParameters>();
  }
  OrgdirectoryparseparametersJs(Napi::CallbackInfo const& info, std::shared_ptr<org::OrgDirectoryParseParameters> const& ptr) : Napi::ObjectWrap<OrgdirectoryparseparametersJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::OrgDirectoryParseParameters> _stored;
  org::OrgDirectoryParseParameters* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<OrgdirectoryparseparametersJs> {
  using type = org::OrgDirectoryParseParameters;
};

template <>
struct org_to_js_type<org::OrgDirectoryParseParameters> {
  using type = OrgdirectoryparseparametersJs;
};

struct OrgyamlexportoptsJs : public Napi::ObjectWrap<OrgyamlexportoptsJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "OrgyamlexportoptsJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("OrgyamlexportoptsJs", func);
    return exports;
  }
  OrgyamlexportoptsJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<OrgyamlexportoptsJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::OrgYamlExportOpts>();
  }
  OrgyamlexportoptsJs(Napi::CallbackInfo const& info, std::shared_ptr<org::OrgYamlExportOpts> const& ptr) : Napi::ObjectWrap<OrgyamlexportoptsJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::OrgYamlExportOpts> _stored;
  org::OrgYamlExportOpts* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<OrgyamlexportoptsJs> {
  using type = org::OrgYamlExportOpts;
};

template <>
struct org_to_js_type<org::OrgYamlExportOpts> {
  using type = OrgyamlexportoptsJs;
};

struct OrgtreeexportoptsJs : public Napi::ObjectWrap<OrgtreeexportoptsJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "OrgtreeexportoptsJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("OrgtreeexportoptsJs", func);
    return exports;
  }
  OrgtreeexportoptsJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<OrgtreeexportoptsJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::OrgTreeExportOpts>();
  }
  OrgtreeexportoptsJs(Napi::CallbackInfo const& info, std::shared_ptr<org::OrgTreeExportOpts> const& ptr) : Napi::ObjectWrap<OrgtreeexportoptsJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::OrgTreeExportOpts> _stored;
  org::OrgTreeExportOpts* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<OrgtreeexportoptsJs> {
  using type = org::OrgTreeExportOpts;
};

template <>
struct org_to_js_type<org::OrgTreeExportOpts> {
  using type = OrgtreeexportoptsJs;
};

struct AsttrackingpathJs : public Napi::ObjectWrap<AsttrackingpathJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getParent(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::AstTrackingPath::*)(int) const>(&org::AstTrackingPath::getParent),
                                        std::make_tuple(CxxArgSpec<int>{"offset", 0})));
  }
  Napi::Value getNode(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::AstTrackingPath::*)() const>(&org::AstTrackingPath::getNode),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "AsttrackingpathJs", {InstanceMethod("getParent", &AsttrackingpathJs::getParent),
                                                                 InstanceMethod("getNode", &AsttrackingpathJs::getNode)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("AsttrackingpathJs", func);
    return exports;
  }
  AsttrackingpathJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<AsttrackingpathJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::AstTrackingPath>();
  }
  AsttrackingpathJs(Napi::CallbackInfo const& info, std::shared_ptr<org::AstTrackingPath> const& ptr) : Napi::ObjectWrap<AsttrackingpathJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::AstTrackingPath> _stored;
  org::AstTrackingPath* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<AsttrackingpathJs> {
  using type = org::AstTrackingPath;
};

template <>
struct org_to_js_type<org::AstTrackingPath> {
  using type = AsttrackingpathJs;
};

struct AsttrackingalternativesJs : public Napi::ObjectWrap<AsttrackingalternativesJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getAllNodes(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::AstTrackingAlternatives::*)() const>(&org::AstTrackingAlternatives::getAllNodes),
                                        std::make_tuple()));
  }
  Napi::Value getNode(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::AstTrackingAlternatives::*)() const>(&org::AstTrackingAlternatives::getNode),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "AsttrackingalternativesJs", {InstanceMethod("getAllNodes", &AsttrackingalternativesJs::getAllNodes),
                                                                         InstanceMethod("getNode", &AsttrackingalternativesJs::getNode)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("AsttrackingalternativesJs", func);
    return exports;
  }
  AsttrackingalternativesJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<AsttrackingalternativesJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::AstTrackingAlternatives>();
  }
  AsttrackingalternativesJs(Napi::CallbackInfo const& info, std::shared_ptr<org::AstTrackingAlternatives> const& ptr) : Napi::ObjectWrap<AsttrackingalternativesJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::AstTrackingAlternatives> _stored;
  org::AstTrackingAlternatives* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<AsttrackingalternativesJs> {
  using type = org::AstTrackingAlternatives;
};

template <>
struct org_to_js_type<org::AstTrackingAlternatives> {
  using type = AsttrackingalternativesJs;
};

struct AsttrackinggroupJs : public Napi::ObjectWrap<AsttrackinggroupJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getRadioTargetMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::AstTrackingGroup::RadioTarget&(org::AstTrackingGroup::*)()>(&org::AstTrackingGroup::getRadioTarget),
                                   std::make_tuple()));
  }
  Napi::Value getTrackedHashtagMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::AstTrackingGroup::TrackedHashtag&(org::AstTrackingGroup::*)()>(&org::AstTrackingGroup::getTrackedHashtag),
                                   std::make_tuple()));
  }
  Napi::Value getSingleMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::AstTrackingGroup::Single&(org::AstTrackingGroup::*)()>(&org::AstTrackingGroup::getSingle),
                                   std::make_tuple()));
  }
  Napi::Value isSingle(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::AstTrackingGroup::*)() const>(&org::AstTrackingGroup::isSingle),
                                        std::make_tuple()));
  }
  Napi::Value isTrackedHashtag(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::AstTrackingGroup::*)() const>(&org::AstTrackingGroup::isTrackedHashtag),
                                        std::make_tuple()));
  }
  Napi::Value isRadioTarget(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::AstTrackingGroup::*)() const>(&org::AstTrackingGroup::isRadioTarget),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "AsttrackinggroupJs", {InstanceMethod("getRadioTargetMut", &AsttrackinggroupJs::getRadioTargetMut),
                                                                  InstanceMethod("getTrackedHashtagMut", &AsttrackinggroupJs::getTrackedHashtagMut),
                                                                  InstanceMethod("getSingleMut", &AsttrackinggroupJs::getSingleMut),
                                                                  InstanceMethod("isSingle", &AsttrackinggroupJs::isSingle),
                                                                  InstanceMethod("isTrackedHashtag", &AsttrackinggroupJs::isTrackedHashtag),
                                                                  InstanceMethod("isRadioTarget", &AsttrackinggroupJs::isRadioTarget)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("AsttrackinggroupJs", func);
    return exports;
  }
  AsttrackinggroupJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<AsttrackinggroupJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::AstTrackingGroup>();
  }
  AsttrackinggroupJs(Napi::CallbackInfo const& info, std::shared_ptr<org::AstTrackingGroup> const& ptr) : Napi::ObjectWrap<AsttrackinggroupJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::AstTrackingGroup> _stored;
  org::AstTrackingGroup* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<AsttrackinggroupJs> {
  using type = org::AstTrackingGroup;
};

template <>
struct org_to_js_type<org::AstTrackingGroup> {
  using type = AsttrackinggroupJs;
};

struct AsttrackinggroupRadiotargetJs : public Napi::ObjectWrap<AsttrackinggroupRadiotargetJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "AsttrackinggroupRadiotargetJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("AsttrackinggroupRadiotargetJs", func);
    return exports;
  }
  AsttrackinggroupRadiotargetJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<AsttrackinggroupRadiotargetJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::AstTrackingGroup::RadioTarget>();
  }
  AsttrackinggroupRadiotargetJs(Napi::CallbackInfo const& info, std::shared_ptr<org::AstTrackingGroup::RadioTarget> const& ptr) : Napi::ObjectWrap<AsttrackinggroupRadiotargetJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::AstTrackingGroup::RadioTarget> _stored;
  org::AstTrackingGroup::RadioTarget* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<AsttrackinggroupRadiotargetJs> {
  using type = org::AstTrackingGroup::RadioTarget;
};

template <>
struct org_to_js_type<org::AstTrackingGroup::RadioTarget> {
  using type = AsttrackinggroupRadiotargetJs;
};

struct AsttrackinggroupSingleJs : public Napi::ObjectWrap<AsttrackinggroupSingleJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "AsttrackinggroupSingleJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("AsttrackinggroupSingleJs", func);
    return exports;
  }
  AsttrackinggroupSingleJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<AsttrackinggroupSingleJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::AstTrackingGroup::Single>();
  }
  AsttrackinggroupSingleJs(Napi::CallbackInfo const& info, std::shared_ptr<org::AstTrackingGroup::Single> const& ptr) : Napi::ObjectWrap<AsttrackinggroupSingleJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::AstTrackingGroup::Single> _stored;
  org::AstTrackingGroup::Single* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<AsttrackinggroupSingleJs> {
  using type = org::AstTrackingGroup::Single;
};

template <>
struct org_to_js_type<org::AstTrackingGroup::Single> {
  using type = AsttrackinggroupSingleJs;
};

struct AsttrackinggroupTrackedhashtagJs : public Napi::ObjectWrap<AsttrackinggroupTrackedhashtagJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "AsttrackinggroupTrackedhashtagJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("AsttrackinggroupTrackedhashtagJs", func);
    return exports;
  }
  AsttrackinggroupTrackedhashtagJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<AsttrackinggroupTrackedhashtagJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::AstTrackingGroup::TrackedHashtag>();
  }
  AsttrackinggroupTrackedhashtagJs(Napi::CallbackInfo const& info, std::shared_ptr<org::AstTrackingGroup::TrackedHashtag> const& ptr) : Napi::ObjectWrap<AsttrackinggroupTrackedhashtagJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::AstTrackingGroup::TrackedHashtag> _stored;
  org::AstTrackingGroup::TrackedHashtag* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<AsttrackinggroupTrackedhashtagJs> {
  using type = org::AstTrackingGroup::TrackedHashtag;
};

template <>
struct org_to_js_type<org::AstTrackingGroup::TrackedHashtag> {
  using type = AsttrackinggroupTrackedhashtagJs;
};

struct AsttrackingmapJs : public Napi::ObjectWrap<AsttrackingmapJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getIdPath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::optional<org::AstTrackingAlternatives>(org::AstTrackingMap::*)(hstd::Str const&) const>(&org::AstTrackingMap::getIdPath),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"id"})));
  }
  Napi::Value getNamePath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::optional<org::AstTrackingAlternatives>(org::AstTrackingMap::*)(hstd::Str const&) const>(&org::AstTrackingMap::getNamePath),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"id"})));
  }
  Napi::Value getAnchorTarget(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::optional<org::AstTrackingAlternatives>(org::AstTrackingMap::*)(hstd::Str const&) const>(&org::AstTrackingMap::getAnchorTarget),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"id"})));
  }
  Napi::Value getFootnotePath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::optional<org::AstTrackingAlternatives>(org::AstTrackingMap::*)(hstd::Str const&) const>(&org::AstTrackingMap::getFootnotePath),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"id"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "AsttrackingmapJs", {InstanceMethod("getIdPath", &AsttrackingmapJs::getIdPath),
                                                                InstanceMethod("getNamePath", &AsttrackingmapJs::getNamePath),
                                                                InstanceMethod("getAnchorTarget", &AsttrackingmapJs::getAnchorTarget),
                                                                InstanceMethod("getFootnotePath", &AsttrackingmapJs::getFootnotePath)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("AsttrackingmapJs", func);
    return exports;
  }
  AsttrackingmapJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<AsttrackingmapJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::AstTrackingMap>();
  }
  AsttrackingmapJs(Napi::CallbackInfo const& info, std::shared_ptr<org::AstTrackingMap> const& ptr) : Napi::ObjectWrap<AsttrackingmapJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::AstTrackingMap> _stored;
  org::AstTrackingMap* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<AsttrackingmapJs> {
  using type = org::AstTrackingMap;
};

template <>
struct org_to_js_type<org::AstTrackingMap> {
  using type = AsttrackingmapJs;
};

struct SequencesegmentJs : public Napi::ObjectWrap<SequencesegmentJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "SequencesegmentJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("SequencesegmentJs", func);
    return exports;
  }
  SequencesegmentJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<SequencesegmentJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<hstd::SequenceSegment>();
  }
  SequencesegmentJs(Napi::CallbackInfo const& info, std::shared_ptr<hstd::SequenceSegment> const& ptr) : Napi::ObjectWrap<SequencesegmentJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<hstd::SequenceSegment> _stored;
  hstd::SequenceSegment* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<SequencesegmentJs> {
  using type = hstd::SequenceSegment;
};

template <>
struct org_to_js_type<hstd::SequenceSegment> {
  using type = SequencesegmentJs;
};

struct SequencesegmentgroupJs : public Napi::ObjectWrap<SequencesegmentgroupJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "SequencesegmentgroupJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("SequencesegmentgroupJs", func);
    return exports;
  }
  SequencesegmentgroupJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<SequencesegmentgroupJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<hstd::SequenceSegmentGroup>();
  }
  SequencesegmentgroupJs(Napi::CallbackInfo const& info, std::shared_ptr<hstd::SequenceSegmentGroup> const& ptr) : Napi::ObjectWrap<SequencesegmentgroupJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<hstd::SequenceSegmentGroup> _stored;
  hstd::SequenceSegmentGroup* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<SequencesegmentgroupJs> {
  using type = hstd::SequenceSegmentGroup;
};

template <>
struct org_to_js_type<hstd::SequenceSegmentGroup> {
  using type = SequencesegmentgroupJs;
};

struct SequenceannotationtagJs : public Napi::ObjectWrap<SequenceannotationtagJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "SequenceannotationtagJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("SequenceannotationtagJs", func);
    return exports;
  }
  SequenceannotationtagJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<SequenceannotationtagJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<hstd::SequenceAnnotationTag>();
  }
  SequenceannotationtagJs(Napi::CallbackInfo const& info, std::shared_ptr<hstd::SequenceAnnotationTag> const& ptr) : Napi::ObjectWrap<SequenceannotationtagJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<hstd::SequenceAnnotationTag> _stored;
  hstd::SequenceAnnotationTag* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<SequenceannotationtagJs> {
  using type = hstd::SequenceAnnotationTag;
};

template <>
struct org_to_js_type<hstd::SequenceAnnotationTag> {
  using type = SequenceannotationtagJs;
};

struct SequenceannotationJs : public Napi::ObjectWrap<SequenceannotationJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value isAnnotatedWith(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(hstd::SequenceAnnotation::*)(int, int) const>(&hstd::SequenceAnnotation::isAnnotatedWith),
                                        std::make_tuple(CxxArgSpec<int>{"groupKind"},
                                                        CxxArgSpec<int>{"segmentKind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "SequenceannotationJs", {InstanceMethod("isAnnotatedWith", &SequenceannotationJs::isAnnotatedWith)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("SequenceannotationJs", func);
    return exports;
  }
  SequenceannotationJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<SequenceannotationJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<hstd::SequenceAnnotation>();
  }
  SequenceannotationJs(Napi::CallbackInfo const& info, std::shared_ptr<hstd::SequenceAnnotation> const& ptr) : Napi::ObjectWrap<SequenceannotationJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<hstd::SequenceAnnotation> _stored;
  hstd::SequenceAnnotation* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<SequenceannotationJs> {
  using type = hstd::SequenceAnnotation;
};

template <>
struct org_to_js_type<hstd::SequenceAnnotation> {
  using type = SequenceannotationJs;
};

struct GraphMaplinkJs : public Napi::ObjectWrap<GraphMaplinkJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "GraphMaplinkJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("GraphMaplinkJs", func);
    return exports;
  }
  GraphMaplinkJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<GraphMaplinkJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::graph::MapLink>();
  }
  GraphMaplinkJs(Napi::CallbackInfo const& info, std::shared_ptr<org::graph::MapLink> const& ptr) : Napi::ObjectWrap<GraphMaplinkJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::graph::MapLink> _stored;
  org::graph::MapLink* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<GraphMaplinkJs> {
  using type = org::graph::MapLink;
};

template <>
struct org_to_js_type<org::graph::MapLink> {
  using type = GraphMaplinkJs;
};

struct GraphMaplinkLinkJs : public Napi::ObjectWrap<GraphMaplinkLinkJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "GraphMaplinkLinkJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("GraphMaplinkLinkJs", func);
    return exports;
  }
  GraphMaplinkLinkJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<GraphMaplinkLinkJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::graph::MapLink::Link>();
  }
  GraphMaplinkLinkJs(Napi::CallbackInfo const& info, std::shared_ptr<org::graph::MapLink::Link> const& ptr) : Napi::ObjectWrap<GraphMaplinkLinkJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::graph::MapLink::Link> _stored;
  org::graph::MapLink::Link* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<GraphMaplinkLinkJs> {
  using type = org::graph::MapLink::Link;
};

template <>
struct org_to_js_type<org::graph::MapLink::Link> {
  using type = GraphMaplinkLinkJs;
};

struct GraphMaplinkRadioJs : public Napi::ObjectWrap<GraphMaplinkRadioJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "GraphMaplinkRadioJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("GraphMaplinkRadioJs", func);
    return exports;
  }
  GraphMaplinkRadioJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<GraphMaplinkRadioJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::graph::MapLink::Radio>();
  }
  GraphMaplinkRadioJs(Napi::CallbackInfo const& info, std::shared_ptr<org::graph::MapLink::Radio> const& ptr) : Napi::ObjectWrap<GraphMaplinkRadioJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::graph::MapLink::Radio> _stored;
  org::graph::MapLink::Radio* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<GraphMaplinkRadioJs> {
  using type = org::graph::MapLink::Radio;
};

template <>
struct org_to_js_type<org::graph::MapLink::Radio> {
  using type = GraphMaplinkRadioJs;
};

struct GraphMapnodepropJs : public Napi::ObjectWrap<GraphMapnodepropJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getSubtreeId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::optional<hstd::Str>(org::graph::MapNodeProp::*)() const>(&org::graph::MapNodeProp::getSubtreeId),
                                        std::make_tuple()));
  }
  Napi::Value getFootnoteName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::optional<hstd::Str>(org::graph::MapNodeProp::*)() const>(&org::graph::MapNodeProp::getFootnoteName),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "GraphMapnodepropJs", {InstanceMethod("getSubtreeId", &GraphMapnodepropJs::getSubtreeId),
                                                                  InstanceMethod("getFootnoteName", &GraphMapnodepropJs::getFootnoteName)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("GraphMapnodepropJs", func);
    return exports;
  }
  GraphMapnodepropJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<GraphMapnodepropJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::graph::MapNodeProp>();
  }
  GraphMapnodepropJs(Napi::CallbackInfo const& info, std::shared_ptr<org::graph::MapNodeProp> const& ptr) : Napi::ObjectWrap<GraphMapnodepropJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::graph::MapNodeProp> _stored;
  org::graph::MapNodeProp* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<GraphMapnodepropJs> {
  using type = org::graph::MapNodeProp;
};

template <>
struct org_to_js_type<org::graph::MapNodeProp> {
  using type = GraphMapnodepropJs;
};

struct GraphMapedgepropJs : public Napi::ObjectWrap<GraphMapedgepropJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "GraphMapedgepropJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("GraphMapedgepropJs", func);
    return exports;
  }
  GraphMapedgepropJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<GraphMapedgepropJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::graph::MapEdgeProp>();
  }
  GraphMapedgepropJs(Napi::CallbackInfo const& info, std::shared_ptr<org::graph::MapEdgeProp> const& ptr) : Napi::ObjectWrap<GraphMapedgepropJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::graph::MapEdgeProp> _stored;
  org::graph::MapEdgeProp* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<GraphMapedgepropJs> {
  using type = org::graph::MapEdgeProp;
};

template <>
struct org_to_js_type<org::graph::MapEdgeProp> {
  using type = GraphMapedgepropJs;
};

struct GraphMapnodeJs : public Napi::ObjectWrap<GraphMapnodeJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::graph::MapNode::*)(org::graph::MapNode const&) const>(&org::graph::MapNode::operator==),
                                        std::make_tuple(CxxArgSpec<org::graph::MapNode>{"other"})));
  }
  Napi::Value operator<(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::graph::MapNode::*)(org::graph::MapNode const&) const>(&org::graph::MapNode::operator<),
                                        std::make_tuple(CxxArgSpec<org::graph::MapNode>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "GraphMapnodeJs", {InstanceMethod("operator==", &GraphMapnodeJs::operator==),
                                                              InstanceMethod("operator<", &GraphMapnodeJs::operator<)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("GraphMapnodeJs", func);
    return exports;
  }
  GraphMapnodeJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<GraphMapnodeJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::graph::MapNode>();
  }
  GraphMapnodeJs(Napi::CallbackInfo const& info, std::shared_ptr<org::graph::MapNode> const& ptr) : Napi::ObjectWrap<GraphMapnodeJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::graph::MapNode> _stored;
  org::graph::MapNode* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<GraphMapnodeJs> {
  using type = org::graph::MapNode;
};

template <>
struct org_to_js_type<org::graph::MapNode> {
  using type = GraphMapnodeJs;
};

struct GraphMapedgeJs : public Napi::ObjectWrap<GraphMapedgeJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "GraphMapedgeJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("GraphMapedgeJs", func);
    return exports;
  }
  GraphMapedgeJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<GraphMapedgeJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::graph::MapEdge>();
  }
  GraphMapedgeJs(Napi::CallbackInfo const& info, std::shared_ptr<org::graph::MapEdge> const& ptr) : Napi::ObjectWrap<GraphMapedgeJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::graph::MapEdge> _stored;
  org::graph::MapEdge* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<GraphMapedgeJs> {
  using type = org::graph::MapEdge;
};

template <>
struct org_to_js_type<org::graph::MapEdge> {
  using type = GraphMapedgeJs;
};

struct GraphMapgraphJs : public Napi::ObjectWrap<GraphMapgraphJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value nodeCount(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::graph::MapGraph::*)() const>(&org::graph::MapGraph::nodeCount),
                                        std::make_tuple()));
  }
  Napi::Value edgeCount(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::graph::MapGraph::*)() const>(&org::graph::MapGraph::edgeCount),
                                        std::make_tuple()));
  }
  Napi::Value outNodes(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::graph::AdjNodesList const&(org::graph::MapGraph::*)(org::graph::MapNode const&) const>(&org::graph::MapGraph::outNodes),
                                        std::make_tuple(CxxArgSpec<org::graph::MapNode>{"node"})));
  }
  Napi::Value inNodes(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::graph::AdjNodesList const&(org::graph::MapGraph::*)(org::graph::MapNode const&) const>(&org::graph::MapGraph::inNodes),
                                        std::make_tuple(CxxArgSpec<org::graph::MapNode>{"node"})));
  }
  Napi::Value adjEdges(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::graph::MapEdge>(org::graph::MapGraph::*)(org::graph::MapNode const&) const>(&org::graph::MapGraph::adjEdges),
                                        std::make_tuple(CxxArgSpec<org::graph::MapNode>{"node"})));
  }
  Napi::Value adjNodes(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::graph::MapNode>(org::graph::MapGraph::*)(org::graph::MapNode const&) const>(&org::graph::MapGraph::adjNodes),
                                        std::make_tuple(CxxArgSpec<org::graph::MapNode>{"node"})));
  }
  Napi::Value outEdges(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::graph::MapEdge>(org::graph::MapGraph::*)(org::graph::MapNode const&) const>(&org::graph::MapGraph::outEdges),
                                        std::make_tuple(CxxArgSpec<org::graph::MapNode>{"node"})));
  }
  Napi::Value inEdges(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::graph::MapEdge>(org::graph::MapGraph::*)(org::graph::MapNode const&) const>(&org::graph::MapGraph::inEdges),
                                        std::make_tuple(CxxArgSpec<org::graph::MapNode>{"node"})));
  }
  Napi::Value outDegree(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::graph::MapGraph::*)(org::graph::MapNode const&) const>(&org::graph::MapGraph::outDegree),
                                        std::make_tuple(CxxArgSpec<org::graph::MapNode>{"node"})));
  }
  Napi::Value inDegree(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::graph::MapGraph::*)(org::graph::MapNode const&) const>(&org::graph::MapGraph::inDegree),
                                        std::make_tuple(CxxArgSpec<org::graph::MapNode>{"node"})));
  }
  Napi::Value isRegisteredNodeById(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::graph::MapGraph::*)(org::imm::ImmUniqId const&) const>(&org::graph::MapGraph::isRegisteredNode),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmUniqId>{"id"})));
  }
  Napi::Value atMapEdge(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::graph::MapEdgeProp const&(org::graph::MapGraph::*)(org::graph::MapEdge const&) const>(&org::graph::MapGraph::at),
                                        std::make_tuple(CxxArgSpec<org::graph::MapEdge>{"edge"})));
  }
  Napi::Value addEdgeWithProp(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::graph::MapGraph::*)(org::graph::MapEdge const&, org::graph::MapEdgeProp const&)>(&org::graph::MapGraph::addEdge),
                                   std::make_tuple(CxxArgSpec<org::graph::MapEdge>{"edge"},
                                                   CxxArgSpec<org::graph::MapEdgeProp>{"prop"})));
  }
  Napi::Value addNodeWithProp(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::graph::MapGraph::*)(org::graph::MapNode const&, org::graph::MapNodeProp const&)>(&org::graph::MapGraph::addNode),
                                   std::make_tuple(CxxArgSpec<org::graph::MapNode>{"node"},
                                                   CxxArgSpec<org::graph::MapNodeProp>{"prop"})));
  }
  Napi::Value has2AdapterEdge(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::graph::MapGraph::*)(org::imm::ImmAdapter const&, org::imm::ImmAdapter const&) const>(&org::graph::MapGraph::hasEdge),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmAdapter>{"source"},
                                                        CxxArgSpec<org::imm::ImmAdapter>{"target"})));
  }
  Napi::Value hasNode(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::graph::MapGraph::*)(org::graph::MapNode const&) const>(&org::graph::MapGraph::hasNode),
                                        std::make_tuple(CxxArgSpec<org::graph::MapNode>{"node"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "GraphMapgraphJs", {InstanceMethod("nodeCount", &GraphMapgraphJs::nodeCount),
                                                               InstanceMethod("edgeCount", &GraphMapgraphJs::edgeCount),
                                                               InstanceMethod("outNodes", &GraphMapgraphJs::outNodes),
                                                               InstanceMethod("inNodes", &GraphMapgraphJs::inNodes),
                                                               InstanceMethod("adjEdges", &GraphMapgraphJs::adjEdges),
                                                               InstanceMethod("adjNodes", &GraphMapgraphJs::adjNodes),
                                                               InstanceMethod("outEdges", &GraphMapgraphJs::outEdges),
                                                               InstanceMethod("inEdges", &GraphMapgraphJs::inEdges),
                                                               InstanceMethod("outDegree", &GraphMapgraphJs::outDegree),
                                                               InstanceMethod("inDegree", &GraphMapgraphJs::inDegree),
                                                               InstanceMethod("isRegisteredNodeById", &GraphMapgraphJs::isRegisteredNodeById),
                                                               InstanceMethod("atMapEdge", &GraphMapgraphJs::atMapEdge),
                                                               InstanceMethod("addEdgeWithProp", &GraphMapgraphJs::addEdgeWithProp),
                                                               InstanceMethod("addNodeWithProp", &GraphMapgraphJs::addNodeWithProp),
                                                               InstanceMethod("has2AdapterEdge", &GraphMapgraphJs::has2AdapterEdge),
                                                               InstanceMethod("hasNode", &GraphMapgraphJs::hasNode)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("GraphMapgraphJs", func);
    return exports;
  }
  GraphMapgraphJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<GraphMapgraphJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::graph::MapGraph>();
  }
  GraphMapgraphJs(Napi::CallbackInfo const& info, std::shared_ptr<org::graph::MapGraph> const& ptr) : Napi::ObjectWrap<GraphMapgraphJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::graph::MapGraph> _stored;
  org::graph::MapGraph* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<GraphMapgraphJs> {
  using type = org::graph::MapGraph;
};

template <>
struct org_to_js_type<org::graph::MapGraph> {
  using type = GraphMapgraphJs;
};

struct GraphMapgraphstateJs : public Napi::ObjectWrap<GraphMapgraphstateJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value registerNode(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::graph::MapGraphState::*)(org::graph::MapNodeProp const&, org::graph::MapConfig*)>(&org::graph::MapGraphState::registerNode),
                                   std::make_tuple(CxxArgSpec<org::graph::MapNodeProp>{"node"},
                                                   CxxArgSpec<org::graph::MapConfig*>{"conf"})));
  }
  Napi::Value addNode(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::graph::MapGraphState::*)(org::imm::ImmAdapter const&, org::graph::MapConfig*)>(&org::graph::MapGraphState::addNode),
                                   std::make_tuple(CxxArgSpec<org::imm::ImmAdapter>{"node"},
                                                   CxxArgSpec<org::graph::MapConfig*>{"conf"})));
  }
  Napi::Value addNodeRec(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::graph::MapGraphState::*)(org::imm::ImmAdapter const&, org::graph::MapConfig*)>(&org::graph::MapGraphState::addNodeRec),
                                   std::make_tuple(CxxArgSpec<org::imm::ImmAdapter>{"node"},
                                                   CxxArgSpec<org::graph::MapConfig*>{"conf"})));
  }
  Napi::Value getUnresolvedSubtreeLinks(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::graph::MapLink>(org::graph::MapGraphState::*)(org::imm::ImmAdapterT<org::imm::ImmSubtree>, org::graph::MapConfig*) const>(&org::graph::MapGraphState::getUnresolvedSubtreeLinks),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmAdapterT<org::imm::ImmSubtree>>{"node"},
                                                        CxxArgSpec<org::graph::MapConfig*>{"conf"})));
  }
  Napi::Value getUnresolvedLink(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::optional<org::graph::MapLink>(org::graph::MapGraphState::*)(org::imm::ImmAdapterT<org::imm::ImmLink>, org::graph::MapConfig*) const>(&org::graph::MapGraphState::getUnresolvedLink),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmAdapterT<org::imm::ImmLink>>{"node"},
                                                        CxxArgSpec<org::graph::MapConfig*>{"conf"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "GraphMapgraphstateJs", {InstanceMethod("registerNode", &GraphMapgraphstateJs::registerNode),
                                                                    InstanceMethod("addNode", &GraphMapgraphstateJs::addNode),
                                                                    InstanceMethod("addNodeRec", &GraphMapgraphstateJs::addNodeRec),
                                                                    InstanceMethod("getUnresolvedSubtreeLinks", &GraphMapgraphstateJs::getUnresolvedSubtreeLinks),
                                                                    InstanceMethod("getUnresolvedLink", &GraphMapgraphstateJs::getUnresolvedLink)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("GraphMapgraphstateJs", func);
    return exports;
  }
  GraphMapgraphstateJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<GraphMapgraphstateJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  GraphMapgraphstateJs(Napi::CallbackInfo const& info, std::shared_ptr<org::graph::MapGraphState> const& ptr) : Napi::ObjectWrap<GraphMapgraphstateJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::graph::MapGraphState> _stored;
  org::graph::MapGraphState* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<GraphMapgraphstateJs> {
  using type = org::graph::MapGraphState;
};

template <>
struct org_to_js_type<org::graph::MapGraphState> {
  using type = GraphMapgraphstateJs;
};

struct LispcodeJs : public Napi::ObjectWrap<LispcodeJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::*)(org::sem::LispCode const&) const>(&org::sem::LispCode::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LispCode>{"other"})));
  }
  Napi::Value isCall(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::*)() const>(&org::sem::LispCode::isCall),
                                        std::make_tuple()));
  }
  Napi::Value getCallMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LispCode::Call&(org::sem::LispCode::*)()>(&org::sem::LispCode::getCall),
                                   std::make_tuple()));
  }
  Napi::Value isList(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::*)() const>(&org::sem::LispCode::isList),
                                        std::make_tuple()));
  }
  Napi::Value getListMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LispCode::List&(org::sem::LispCode::*)()>(&org::sem::LispCode::getList),
                                   std::make_tuple()));
  }
  Napi::Value isKeyValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::*)() const>(&org::sem::LispCode::isKeyValue),
                                        std::make_tuple()));
  }
  Napi::Value getKeyValueMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LispCode::KeyValue&(org::sem::LispCode::*)()>(&org::sem::LispCode::getKeyValue),
                                   std::make_tuple()));
  }
  Napi::Value isNumber(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::*)() const>(&org::sem::LispCode::isNumber),
                                        std::make_tuple()));
  }
  Napi::Value getNumberMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LispCode::Number&(org::sem::LispCode::*)()>(&org::sem::LispCode::getNumber),
                                   std::make_tuple()));
  }
  Napi::Value isText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::*)() const>(&org::sem::LispCode::isText),
                                        std::make_tuple()));
  }
  Napi::Value getTextMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LispCode::Text&(org::sem::LispCode::*)()>(&org::sem::LispCode::getText),
                                   std::make_tuple()));
  }
  Napi::Value isIdent(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::*)() const>(&org::sem::LispCode::isIdent),
                                        std::make_tuple()));
  }
  Napi::Value getIdentMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LispCode::Ident&(org::sem::LispCode::*)()>(&org::sem::LispCode::getIdent),
                                   std::make_tuple()));
  }
  Napi::Value isBoolean(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::*)() const>(&org::sem::LispCode::isBoolean),
                                        std::make_tuple()));
  }
  Napi::Value getBooleanMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LispCode::Boolean&(org::sem::LispCode::*)()>(&org::sem::LispCode::getBoolean),
                                   std::make_tuple()));
  }
  Napi::Value isReal(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::*)() const>(&org::sem::LispCode::isReal),
                                        std::make_tuple()));
  }
  Napi::Value getRealMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LispCode::Real&(org::sem::LispCode::*)()>(&org::sem::LispCode::getReal),
                                   std::make_tuple()));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::LispCode::Kind(org::sem::LispCode::*)() const>(&org::sem::LispCode::getKind),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_name(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<char const*(org::sem::LispCode::*)() const>(&org::sem::LispCode::sub_variant_get_name),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_data(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::LispCode::Data const&(org::sem::LispCode::*)() const>(&org::sem::LispCode::sub_variant_get_data),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_kind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::LispCode::Kind(org::sem::LispCode::*)() const>(&org::sem::LispCode::sub_variant_get_kind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "LispcodeJs", {InstanceMethod("operator==", &LispcodeJs::operator==),
                                                          InstanceMethod("isCall", &LispcodeJs::isCall),
                                                          InstanceMethod("getCallMut", &LispcodeJs::getCallMut),
                                                          InstanceMethod("isList", &LispcodeJs::isList),
                                                          InstanceMethod("getListMut", &LispcodeJs::getListMut),
                                                          InstanceMethod("isKeyValue", &LispcodeJs::isKeyValue),
                                                          InstanceMethod("getKeyValueMut", &LispcodeJs::getKeyValueMut),
                                                          InstanceMethod("isNumber", &LispcodeJs::isNumber),
                                                          InstanceMethod("getNumberMut", &LispcodeJs::getNumberMut),
                                                          InstanceMethod("isText", &LispcodeJs::isText),
                                                          InstanceMethod("getTextMut", &LispcodeJs::getTextMut),
                                                          InstanceMethod("isIdent", &LispcodeJs::isIdent),
                                                          InstanceMethod("getIdentMut", &LispcodeJs::getIdentMut),
                                                          InstanceMethod("isBoolean", &LispcodeJs::isBoolean),
                                                          InstanceMethod("getBooleanMut", &LispcodeJs::getBooleanMut),
                                                          InstanceMethod("isReal", &LispcodeJs::isReal),
                                                          InstanceMethod("getRealMut", &LispcodeJs::getRealMut),
                                                          InstanceMethod("getKind", &LispcodeJs::getKind),
                                                          InstanceMethod("sub_variant_get_name", &LispcodeJs::sub_variant_get_name),
                                                          InstanceMethod("sub_variant_get_data", &LispcodeJs::sub_variant_get_data),
                                                          InstanceMethod("sub_variant_get_kind", &LispcodeJs::sub_variant_get_kind)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("LispcodeJs", func);
    return exports;
  }
  LispcodeJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<LispcodeJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::LispCode>();
  }
  LispcodeJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::LispCode> const& ptr) : Napi::ObjectWrap<LispcodeJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::LispCode> _stored;
  org::sem::LispCode* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<LispcodeJs> {
  using type = org::sem::LispCode;
};

template <>
struct org_to_js_type<org::sem::LispCode> {
  using type = LispcodeJs;
};

struct LispcodeCallJs : public Napi::ObjectWrap<LispcodeCallJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::Call::*)(org::sem::LispCode::Call const&) const>(&org::sem::LispCode::Call::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LispCode::Call>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "LispcodeCallJs", {InstanceMethod("operator==", &LispcodeCallJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("LispcodeCallJs", func);
    return exports;
  }
  LispcodeCallJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<LispcodeCallJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::LispCode::Call>();
  }
  LispcodeCallJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::LispCode::Call> const& ptr) : Napi::ObjectWrap<LispcodeCallJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::LispCode::Call> _stored;
  org::sem::LispCode::Call* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<LispcodeCallJs> {
  using type = org::sem::LispCode::Call;
};

template <>
struct org_to_js_type<org::sem::LispCode::Call> {
  using type = LispcodeCallJs;
};

struct LispcodeListJs : public Napi::ObjectWrap<LispcodeListJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::List::*)(org::sem::LispCode::List const&) const>(&org::sem::LispCode::List::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LispCode::List>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "LispcodeListJs", {InstanceMethod("operator==", &LispcodeListJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("LispcodeListJs", func);
    return exports;
  }
  LispcodeListJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<LispcodeListJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::LispCode::List>();
  }
  LispcodeListJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::LispCode::List> const& ptr) : Napi::ObjectWrap<LispcodeListJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::LispCode::List> _stored;
  org::sem::LispCode::List* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<LispcodeListJs> {
  using type = org::sem::LispCode::List;
};

template <>
struct org_to_js_type<org::sem::LispCode::List> {
  using type = LispcodeListJs;
};

struct LispcodeKeyvalueJs : public Napi::ObjectWrap<LispcodeKeyvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::KeyValue::*)(org::sem::LispCode::KeyValue const&) const>(&org::sem::LispCode::KeyValue::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LispCode::KeyValue>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "LispcodeKeyvalueJs", {InstanceMethod("operator==", &LispcodeKeyvalueJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("LispcodeKeyvalueJs", func);
    return exports;
  }
  LispcodeKeyvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<LispcodeKeyvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::LispCode::KeyValue>();
  }
  LispcodeKeyvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::LispCode::KeyValue> const& ptr) : Napi::ObjectWrap<LispcodeKeyvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::LispCode::KeyValue> _stored;
  org::sem::LispCode::KeyValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<LispcodeKeyvalueJs> {
  using type = org::sem::LispCode::KeyValue;
};

template <>
struct org_to_js_type<org::sem::LispCode::KeyValue> {
  using type = LispcodeKeyvalueJs;
};

struct LispcodeNumberJs : public Napi::ObjectWrap<LispcodeNumberJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::Number::*)(org::sem::LispCode::Number const&) const>(&org::sem::LispCode::Number::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LispCode::Number>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "LispcodeNumberJs", {InstanceMethod("operator==", &LispcodeNumberJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("LispcodeNumberJs", func);
    return exports;
  }
  LispcodeNumberJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<LispcodeNumberJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::LispCode::Number>();
  }
  LispcodeNumberJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::LispCode::Number> const& ptr) : Napi::ObjectWrap<LispcodeNumberJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::LispCode::Number> _stored;
  org::sem::LispCode::Number* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<LispcodeNumberJs> {
  using type = org::sem::LispCode::Number;
};

template <>
struct org_to_js_type<org::sem::LispCode::Number> {
  using type = LispcodeNumberJs;
};

struct LispcodeTextJs : public Napi::ObjectWrap<LispcodeTextJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::Text::*)(org::sem::LispCode::Text const&) const>(&org::sem::LispCode::Text::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LispCode::Text>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "LispcodeTextJs", {InstanceMethod("operator==", &LispcodeTextJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("LispcodeTextJs", func);
    return exports;
  }
  LispcodeTextJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<LispcodeTextJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::LispCode::Text>();
  }
  LispcodeTextJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::LispCode::Text> const& ptr) : Napi::ObjectWrap<LispcodeTextJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::LispCode::Text> _stored;
  org::sem::LispCode::Text* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<LispcodeTextJs> {
  using type = org::sem::LispCode::Text;
};

template <>
struct org_to_js_type<org::sem::LispCode::Text> {
  using type = LispcodeTextJs;
};

struct LispcodeIdentJs : public Napi::ObjectWrap<LispcodeIdentJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::Ident::*)(org::sem::LispCode::Ident const&) const>(&org::sem::LispCode::Ident::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LispCode::Ident>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "LispcodeIdentJs", {InstanceMethod("operator==", &LispcodeIdentJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("LispcodeIdentJs", func);
    return exports;
  }
  LispcodeIdentJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<LispcodeIdentJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::LispCode::Ident>();
  }
  LispcodeIdentJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::LispCode::Ident> const& ptr) : Napi::ObjectWrap<LispcodeIdentJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::LispCode::Ident> _stored;
  org::sem::LispCode::Ident* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<LispcodeIdentJs> {
  using type = org::sem::LispCode::Ident;
};

template <>
struct org_to_js_type<org::sem::LispCode::Ident> {
  using type = LispcodeIdentJs;
};

struct LispcodeBooleanJs : public Napi::ObjectWrap<LispcodeBooleanJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::Boolean::*)(org::sem::LispCode::Boolean const&) const>(&org::sem::LispCode::Boolean::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LispCode::Boolean>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "LispcodeBooleanJs", {InstanceMethod("operator==", &LispcodeBooleanJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("LispcodeBooleanJs", func);
    return exports;
  }
  LispcodeBooleanJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<LispcodeBooleanJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::LispCode::Boolean>();
  }
  LispcodeBooleanJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::LispCode::Boolean> const& ptr) : Napi::ObjectWrap<LispcodeBooleanJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::LispCode::Boolean> _stored;
  org::sem::LispCode::Boolean* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<LispcodeBooleanJs> {
  using type = org::sem::LispCode::Boolean;
};

template <>
struct org_to_js_type<org::sem::LispCode::Boolean> {
  using type = LispcodeBooleanJs;
};

struct LispcodeRealJs : public Napi::ObjectWrap<LispcodeRealJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::Real::*)(org::sem::LispCode::Real const&) const>(&org::sem::LispCode::Real::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LispCode::Real>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "LispcodeRealJs", {InstanceMethod("operator==", &LispcodeRealJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("LispcodeRealJs", func);
    return exports;
  }
  LispcodeRealJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<LispcodeRealJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::LispCode::Real>();
  }
  LispcodeRealJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::LispCode::Real> const& ptr) : Napi::ObjectWrap<LispcodeRealJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::LispCode::Real> _stored;
  org::sem::LispCode::Real* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<LispcodeRealJs> {
  using type = org::sem::LispCode::Real;
};

template <>
struct org_to_js_type<org::sem::LispCode::Real> {
  using type = LispcodeRealJs;
};

struct TblfmJs : public Napi::ObjectWrap<TblfmJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::*)(org::sem::Tblfm const&) const>(&org::sem::Tblfm::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::Tblfm>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "TblfmJs", {InstanceMethod("operator==", &TblfmJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("TblfmJs", func);
    return exports;
  }
  TblfmJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<TblfmJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Tblfm>();
  }
  TblfmJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Tblfm> const& ptr) : Napi::ObjectWrap<TblfmJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Tblfm> _stored;
  org::sem::Tblfm* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<TblfmJs> {
  using type = org::sem::Tblfm;
};

template <>
struct org_to_js_type<org::sem::Tblfm> {
  using type = TblfmJs;
};

struct TblfmExprJs : public Napi::ObjectWrap<TblfmExprJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::*)(org::sem::Tblfm::Expr const&) const>(&org::sem::Tblfm::Expr::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::Tblfm::Expr>{"other"})));
  }
  Napi::Value isAxisRef(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::*)() const>(&org::sem::Tblfm::Expr::isAxisRef),
                                        std::make_tuple()));
  }
  Napi::Value getAxisRefMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::Tblfm::Expr::AxisRef&(org::sem::Tblfm::Expr::*)()>(&org::sem::Tblfm::Expr::getAxisRef),
                                   std::make_tuple()));
  }
  Napi::Value isAxisName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::*)() const>(&org::sem::Tblfm::Expr::isAxisName),
                                        std::make_tuple()));
  }
  Napi::Value getAxisNameMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::Tblfm::Expr::AxisName&(org::sem::Tblfm::Expr::*)()>(&org::sem::Tblfm::Expr::getAxisName),
                                   std::make_tuple()));
  }
  Napi::Value isIntLiteral(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::*)() const>(&org::sem::Tblfm::Expr::isIntLiteral),
                                        std::make_tuple()));
  }
  Napi::Value getIntLiteralMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::Tblfm::Expr::IntLiteral&(org::sem::Tblfm::Expr::*)()>(&org::sem::Tblfm::Expr::getIntLiteral),
                                   std::make_tuple()));
  }
  Napi::Value isFloatLiteral(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::*)() const>(&org::sem::Tblfm::Expr::isFloatLiteral),
                                        std::make_tuple()));
  }
  Napi::Value getFloatLiteralMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::Tblfm::Expr::FloatLiteral&(org::sem::Tblfm::Expr::*)()>(&org::sem::Tblfm::Expr::getFloatLiteral),
                                   std::make_tuple()));
  }
  Napi::Value isRangeRef(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::*)() const>(&org::sem::Tblfm::Expr::isRangeRef),
                                        std::make_tuple()));
  }
  Napi::Value getRangeRefMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::Tblfm::Expr::RangeRef&(org::sem::Tblfm::Expr::*)()>(&org::sem::Tblfm::Expr::getRangeRef),
                                   std::make_tuple()));
  }
  Napi::Value isCall(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::*)() const>(&org::sem::Tblfm::Expr::isCall),
                                        std::make_tuple()));
  }
  Napi::Value getCallMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::Tblfm::Expr::Call&(org::sem::Tblfm::Expr::*)()>(&org::sem::Tblfm::Expr::getCall),
                                   std::make_tuple()));
  }
  Napi::Value isElisp(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::*)() const>(&org::sem::Tblfm::Expr::isElisp),
                                        std::make_tuple()));
  }
  Napi::Value getElispMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::Tblfm::Expr::Elisp&(org::sem::Tblfm::Expr::*)()>(&org::sem::Tblfm::Expr::getElisp),
                                   std::make_tuple()));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::Tblfm::Expr::Kind(org::sem::Tblfm::Expr::*)() const>(&org::sem::Tblfm::Expr::getKind),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_name(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<char const*(org::sem::Tblfm::Expr::*)() const>(&org::sem::Tblfm::Expr::sub_variant_get_name),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_data(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::Tblfm::Expr::Data const&(org::sem::Tblfm::Expr::*)() const>(&org::sem::Tblfm::Expr::sub_variant_get_data),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_kind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::Tblfm::Expr::Kind(org::sem::Tblfm::Expr::*)() const>(&org::sem::Tblfm::Expr::sub_variant_get_kind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "TblfmExprJs", {InstanceMethod("operator==", &TblfmExprJs::operator==),
                                                           InstanceMethod("isAxisRef", &TblfmExprJs::isAxisRef),
                                                           InstanceMethod("getAxisRefMut", &TblfmExprJs::getAxisRefMut),
                                                           InstanceMethod("isAxisName", &TblfmExprJs::isAxisName),
                                                           InstanceMethod("getAxisNameMut", &TblfmExprJs::getAxisNameMut),
                                                           InstanceMethod("isIntLiteral", &TblfmExprJs::isIntLiteral),
                                                           InstanceMethod("getIntLiteralMut", &TblfmExprJs::getIntLiteralMut),
                                                           InstanceMethod("isFloatLiteral", &TblfmExprJs::isFloatLiteral),
                                                           InstanceMethod("getFloatLiteralMut", &TblfmExprJs::getFloatLiteralMut),
                                                           InstanceMethod("isRangeRef", &TblfmExprJs::isRangeRef),
                                                           InstanceMethod("getRangeRefMut", &TblfmExprJs::getRangeRefMut),
                                                           InstanceMethod("isCall", &TblfmExprJs::isCall),
                                                           InstanceMethod("getCallMut", &TblfmExprJs::getCallMut),
                                                           InstanceMethod("isElisp", &TblfmExprJs::isElisp),
                                                           InstanceMethod("getElispMut", &TblfmExprJs::getElispMut),
                                                           InstanceMethod("getKind", &TblfmExprJs::getKind),
                                                           InstanceMethod("sub_variant_get_name", &TblfmExprJs::sub_variant_get_name),
                                                           InstanceMethod("sub_variant_get_data", &TblfmExprJs::sub_variant_get_data),
                                                           InstanceMethod("sub_variant_get_kind", &TblfmExprJs::sub_variant_get_kind)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("TblfmExprJs", func);
    return exports;
  }
  TblfmExprJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<TblfmExprJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Tblfm::Expr>();
  }
  TblfmExprJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Tblfm::Expr> const& ptr) : Napi::ObjectWrap<TblfmExprJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Tblfm::Expr> _stored;
  org::sem::Tblfm::Expr* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<TblfmExprJs> {
  using type = org::sem::Tblfm::Expr;
};

template <>
struct org_to_js_type<org::sem::Tblfm::Expr> {
  using type = TblfmExprJs;
};

struct TblfmExprAxisrefJs : public Napi::ObjectWrap<TblfmExprAxisrefJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::AxisRef::*)(org::sem::Tblfm::Expr::AxisRef const&) const>(&org::sem::Tblfm::Expr::AxisRef::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::Tblfm::Expr::AxisRef>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "TblfmExprAxisrefJs", {InstanceMethod("operator==", &TblfmExprAxisrefJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("TblfmExprAxisrefJs", func);
    return exports;
  }
  TblfmExprAxisrefJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<TblfmExprAxisrefJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Tblfm::Expr::AxisRef>();
  }
  TblfmExprAxisrefJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Tblfm::Expr::AxisRef> const& ptr) : Napi::ObjectWrap<TblfmExprAxisrefJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Tblfm::Expr::AxisRef> _stored;
  org::sem::Tblfm::Expr::AxisRef* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<TblfmExprAxisrefJs> {
  using type = org::sem::Tblfm::Expr::AxisRef;
};

template <>
struct org_to_js_type<org::sem::Tblfm::Expr::AxisRef> {
  using type = TblfmExprAxisrefJs;
};

struct TblfmExprAxisrefPositionJs : public Napi::ObjectWrap<TblfmExprAxisrefPositionJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::AxisRef::Position::*)(org::sem::Tblfm::Expr::AxisRef::Position const&) const>(&org::sem::Tblfm::Expr::AxisRef::Position::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::Tblfm::Expr::AxisRef::Position>{"other"})));
  }
  Napi::Value isIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::AxisRef::Position::*)() const>(&org::sem::Tblfm::Expr::AxisRef::Position::isIndex),
                                        std::make_tuple()));
  }
  Napi::Value getIndexMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::Tblfm::Expr::AxisRef::Position::Index&(org::sem::Tblfm::Expr::AxisRef::Position::*)()>(&org::sem::Tblfm::Expr::AxisRef::Position::getIndex),
                                   std::make_tuple()));
  }
  Napi::Value isName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::AxisRef::Position::*)() const>(&org::sem::Tblfm::Expr::AxisRef::Position::isName),
                                        std::make_tuple()));
  }
  Napi::Value getNameMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::Tblfm::Expr::AxisRef::Position::Name&(org::sem::Tblfm::Expr::AxisRef::Position::*)()>(&org::sem::Tblfm::Expr::AxisRef::Position::getName),
                                   std::make_tuple()));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::Tblfm::Expr::AxisRef::Position::Kind(org::sem::Tblfm::Expr::AxisRef::Position::*)() const>(&org::sem::Tblfm::Expr::AxisRef::Position::getKind),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_name(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<char const*(org::sem::Tblfm::Expr::AxisRef::Position::*)() const>(&org::sem::Tblfm::Expr::AxisRef::Position::sub_variant_get_name),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_data(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::Tblfm::Expr::AxisRef::Position::Data const&(org::sem::Tblfm::Expr::AxisRef::Position::*)() const>(&org::sem::Tblfm::Expr::AxisRef::Position::sub_variant_get_data),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_kind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::Tblfm::Expr::AxisRef::Position::Kind(org::sem::Tblfm::Expr::AxisRef::Position::*)() const>(&org::sem::Tblfm::Expr::AxisRef::Position::sub_variant_get_kind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "TblfmExprAxisrefPositionJs", {InstanceMethod("operator==", &TblfmExprAxisrefPositionJs::operator==),
                                                                          InstanceMethod("isIndex", &TblfmExprAxisrefPositionJs::isIndex),
                                                                          InstanceMethod("getIndexMut", &TblfmExprAxisrefPositionJs::getIndexMut),
                                                                          InstanceMethod("isName", &TblfmExprAxisrefPositionJs::isName),
                                                                          InstanceMethod("getNameMut", &TblfmExprAxisrefPositionJs::getNameMut),
                                                                          InstanceMethod("getKind", &TblfmExprAxisrefPositionJs::getKind),
                                                                          InstanceMethod("sub_variant_get_name", &TblfmExprAxisrefPositionJs::sub_variant_get_name),
                                                                          InstanceMethod("sub_variant_get_data", &TblfmExprAxisrefPositionJs::sub_variant_get_data),
                                                                          InstanceMethod("sub_variant_get_kind", &TblfmExprAxisrefPositionJs::sub_variant_get_kind)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("TblfmExprAxisrefPositionJs", func);
    return exports;
  }
  TblfmExprAxisrefPositionJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<TblfmExprAxisrefPositionJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Tblfm::Expr::AxisRef::Position>();
  }
  TblfmExprAxisrefPositionJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Tblfm::Expr::AxisRef::Position> const& ptr) : Napi::ObjectWrap<TblfmExprAxisrefPositionJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Tblfm::Expr::AxisRef::Position> _stored;
  org::sem::Tblfm::Expr::AxisRef::Position* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<TblfmExprAxisrefPositionJs> {
  using type = org::sem::Tblfm::Expr::AxisRef::Position;
};

template <>
struct org_to_js_type<org::sem::Tblfm::Expr::AxisRef::Position> {
  using type = TblfmExprAxisrefPositionJs;
};

struct TblfmExprAxisrefPositionIndexJs : public Napi::ObjectWrap<TblfmExprAxisrefPositionIndexJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::AxisRef::Position::Index::*)(org::sem::Tblfm::Expr::AxisRef::Position::Index const&) const>(&org::sem::Tblfm::Expr::AxisRef::Position::Index::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::Tblfm::Expr::AxisRef::Position::Index>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "TblfmExprAxisrefPositionIndexJs", {InstanceMethod("operator==", &TblfmExprAxisrefPositionIndexJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("TblfmExprAxisrefPositionIndexJs", func);
    return exports;
  }
  TblfmExprAxisrefPositionIndexJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<TblfmExprAxisrefPositionIndexJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Tblfm::Expr::AxisRef::Position::Index>();
  }
  TblfmExprAxisrefPositionIndexJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Tblfm::Expr::AxisRef::Position::Index> const& ptr) : Napi::ObjectWrap<TblfmExprAxisrefPositionIndexJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Tblfm::Expr::AxisRef::Position::Index> _stored;
  org::sem::Tblfm::Expr::AxisRef::Position::Index* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<TblfmExprAxisrefPositionIndexJs> {
  using type = org::sem::Tblfm::Expr::AxisRef::Position::Index;
};

template <>
struct org_to_js_type<org::sem::Tblfm::Expr::AxisRef::Position::Index> {
  using type = TblfmExprAxisrefPositionIndexJs;
};

struct TblfmExprAxisrefPositionNameJs : public Napi::ObjectWrap<TblfmExprAxisrefPositionNameJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::AxisRef::Position::Name::*)(org::sem::Tblfm::Expr::AxisRef::Position::Name const&) const>(&org::sem::Tblfm::Expr::AxisRef::Position::Name::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::Tblfm::Expr::AxisRef::Position::Name>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "TblfmExprAxisrefPositionNameJs", {InstanceMethod("operator==", &TblfmExprAxisrefPositionNameJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("TblfmExprAxisrefPositionNameJs", func);
    return exports;
  }
  TblfmExprAxisrefPositionNameJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<TblfmExprAxisrefPositionNameJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Tblfm::Expr::AxisRef::Position::Name>();
  }
  TblfmExprAxisrefPositionNameJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Tblfm::Expr::AxisRef::Position::Name> const& ptr) : Napi::ObjectWrap<TblfmExprAxisrefPositionNameJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Tblfm::Expr::AxisRef::Position::Name> _stored;
  org::sem::Tblfm::Expr::AxisRef::Position::Name* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<TblfmExprAxisrefPositionNameJs> {
  using type = org::sem::Tblfm::Expr::AxisRef::Position::Name;
};

template <>
struct org_to_js_type<org::sem::Tblfm::Expr::AxisRef::Position::Name> {
  using type = TblfmExprAxisrefPositionNameJs;
};

struct TblfmExprAxisnameJs : public Napi::ObjectWrap<TblfmExprAxisnameJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::AxisName::*)(org::sem::Tblfm::Expr::AxisName const&) const>(&org::sem::Tblfm::Expr::AxisName::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::Tblfm::Expr::AxisName>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "TblfmExprAxisnameJs", {InstanceMethod("operator==", &TblfmExprAxisnameJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("TblfmExprAxisnameJs", func);
    return exports;
  }
  TblfmExprAxisnameJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<TblfmExprAxisnameJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Tblfm::Expr::AxisName>();
  }
  TblfmExprAxisnameJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Tblfm::Expr::AxisName> const& ptr) : Napi::ObjectWrap<TblfmExprAxisnameJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Tblfm::Expr::AxisName> _stored;
  org::sem::Tblfm::Expr::AxisName* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<TblfmExprAxisnameJs> {
  using type = org::sem::Tblfm::Expr::AxisName;
};

template <>
struct org_to_js_type<org::sem::Tblfm::Expr::AxisName> {
  using type = TblfmExprAxisnameJs;
};

struct TblfmExprIntliteralJs : public Napi::ObjectWrap<TblfmExprIntliteralJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::IntLiteral::*)(org::sem::Tblfm::Expr::IntLiteral const&) const>(&org::sem::Tblfm::Expr::IntLiteral::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::Tblfm::Expr::IntLiteral>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "TblfmExprIntliteralJs", {InstanceMethod("operator==", &TblfmExprIntliteralJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("TblfmExprIntliteralJs", func);
    return exports;
  }
  TblfmExprIntliteralJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<TblfmExprIntliteralJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Tblfm::Expr::IntLiteral>();
  }
  TblfmExprIntliteralJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Tblfm::Expr::IntLiteral> const& ptr) : Napi::ObjectWrap<TblfmExprIntliteralJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Tblfm::Expr::IntLiteral> _stored;
  org::sem::Tblfm::Expr::IntLiteral* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<TblfmExprIntliteralJs> {
  using type = org::sem::Tblfm::Expr::IntLiteral;
};

template <>
struct org_to_js_type<org::sem::Tblfm::Expr::IntLiteral> {
  using type = TblfmExprIntliteralJs;
};

struct TblfmExprFloatliteralJs : public Napi::ObjectWrap<TblfmExprFloatliteralJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::FloatLiteral::*)(org::sem::Tblfm::Expr::FloatLiteral const&) const>(&org::sem::Tblfm::Expr::FloatLiteral::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::Tblfm::Expr::FloatLiteral>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "TblfmExprFloatliteralJs", {InstanceMethod("operator==", &TblfmExprFloatliteralJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("TblfmExprFloatliteralJs", func);
    return exports;
  }
  TblfmExprFloatliteralJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<TblfmExprFloatliteralJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Tblfm::Expr::FloatLiteral>();
  }
  TblfmExprFloatliteralJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Tblfm::Expr::FloatLiteral> const& ptr) : Napi::ObjectWrap<TblfmExprFloatliteralJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Tblfm::Expr::FloatLiteral> _stored;
  org::sem::Tblfm::Expr::FloatLiteral* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<TblfmExprFloatliteralJs> {
  using type = org::sem::Tblfm::Expr::FloatLiteral;
};

template <>
struct org_to_js_type<org::sem::Tblfm::Expr::FloatLiteral> {
  using type = TblfmExprFloatliteralJs;
};

struct TblfmExprRangerefJs : public Napi::ObjectWrap<TblfmExprRangerefJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::RangeRef::*)(org::sem::Tblfm::Expr::RangeRef const&) const>(&org::sem::Tblfm::Expr::RangeRef::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::Tblfm::Expr::RangeRef>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "TblfmExprRangerefJs", {InstanceMethod("operator==", &TblfmExprRangerefJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("TblfmExprRangerefJs", func);
    return exports;
  }
  TblfmExprRangerefJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<TblfmExprRangerefJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Tblfm::Expr::RangeRef>();
  }
  TblfmExprRangerefJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Tblfm::Expr::RangeRef> const& ptr) : Napi::ObjectWrap<TblfmExprRangerefJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Tblfm::Expr::RangeRef> _stored;
  org::sem::Tblfm::Expr::RangeRef* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<TblfmExprRangerefJs> {
  using type = org::sem::Tblfm::Expr::RangeRef;
};

template <>
struct org_to_js_type<org::sem::Tblfm::Expr::RangeRef> {
  using type = TblfmExprRangerefJs;
};

struct TblfmExprCallJs : public Napi::ObjectWrap<TblfmExprCallJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::Call::*)(org::sem::Tblfm::Expr::Call const&) const>(&org::sem::Tblfm::Expr::Call::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::Tblfm::Expr::Call>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "TblfmExprCallJs", {InstanceMethod("operator==", &TblfmExprCallJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("TblfmExprCallJs", func);
    return exports;
  }
  TblfmExprCallJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<TblfmExprCallJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Tblfm::Expr::Call>();
  }
  TblfmExprCallJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Tblfm::Expr::Call> const& ptr) : Napi::ObjectWrap<TblfmExprCallJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Tblfm::Expr::Call> _stored;
  org::sem::Tblfm::Expr::Call* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<TblfmExprCallJs> {
  using type = org::sem::Tblfm::Expr::Call;
};

template <>
struct org_to_js_type<org::sem::Tblfm::Expr::Call> {
  using type = TblfmExprCallJs;
};

struct TblfmExprElispJs : public Napi::ObjectWrap<TblfmExprElispJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::Elisp::*)(org::sem::Tblfm::Expr::Elisp const&) const>(&org::sem::Tblfm::Expr::Elisp::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::Tblfm::Expr::Elisp>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "TblfmExprElispJs", {InstanceMethod("operator==", &TblfmExprElispJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("TblfmExprElispJs", func);
    return exports;
  }
  TblfmExprElispJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<TblfmExprElispJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Tblfm::Expr::Elisp>();
  }
  TblfmExprElispJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Tblfm::Expr::Elisp> const& ptr) : Napi::ObjectWrap<TblfmExprElispJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Tblfm::Expr::Elisp> _stored;
  org::sem::Tblfm::Expr::Elisp* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<TblfmExprElispJs> {
  using type = org::sem::Tblfm::Expr::Elisp;
};

template <>
struct org_to_js_type<org::sem::Tblfm::Expr::Elisp> {
  using type = TblfmExprElispJs;
};

struct TblfmAssignJs : public Napi::ObjectWrap<TblfmAssignJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Assign::*)(org::sem::Tblfm::Assign const&) const>(&org::sem::Tblfm::Assign::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::Tblfm::Assign>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "TblfmAssignJs", {InstanceMethod("operator==", &TblfmAssignJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("TblfmAssignJs", func);
    return exports;
  }
  TblfmAssignJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<TblfmAssignJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Tblfm::Assign>();
  }
  TblfmAssignJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Tblfm::Assign> const& ptr) : Napi::ObjectWrap<TblfmAssignJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Tblfm::Assign> _stored;
  org::sem::Tblfm::Assign* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<TblfmAssignJs> {
  using type = org::sem::Tblfm::Assign;
};

template <>
struct org_to_js_type<org::sem::Tblfm::Assign> {
  using type = TblfmAssignJs;
};

struct AttrvalueJs : public Napi::ObjectWrap<AttrvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getBool(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<bool>(org::sem::AttrValue::*)() const>(&org::sem::AttrValue::getBool),
                                        std::make_tuple()));
  }
  Napi::Value getInt(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<int>(org::sem::AttrValue::*)() const>(&org::sem::AttrValue::getInt),
                                        std::make_tuple()));
  }
  Napi::Value getString(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Str(org::sem::AttrValue::*)() const>(&org::sem::AttrValue::getString),
                                        std::make_tuple()));
  }
  Napi::Value getFile(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Str(org::sem::AttrValue::*)() const>(&org::sem::AttrValue::getFile),
                                        std::make_tuple()));
  }
  Napi::Value getReference(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Str(org::sem::AttrValue::*)() const>(&org::sem::AttrValue::getReference),
                                        std::make_tuple()));
  }
  Napi::Value getDouble(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<double>(org::sem::AttrValue::*)() const>(&org::sem::AttrValue::getDouble),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::AttrValue::*)(org::sem::AttrValue const&) const>(&org::sem::AttrValue::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::AttrValue>{"other"})));
  }
  Napi::Value isTextValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::AttrValue::*)() const>(&org::sem::AttrValue::isTextValue),
                                        std::make_tuple()));
  }
  Napi::Value getTextValueMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::AttrValue::TextValue&(org::sem::AttrValue::*)()>(&org::sem::AttrValue::getTextValue),
                                   std::make_tuple()));
  }
  Napi::Value isFileReference(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::AttrValue::*)() const>(&org::sem::AttrValue::isFileReference),
                                        std::make_tuple()));
  }
  Napi::Value getFileReferenceMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::AttrValue::FileReference&(org::sem::AttrValue::*)()>(&org::sem::AttrValue::getFileReference),
                                   std::make_tuple()));
  }
  Napi::Value isLispValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::AttrValue::*)() const>(&org::sem::AttrValue::isLispValue),
                                        std::make_tuple()));
  }
  Napi::Value getLispValueMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::AttrValue::LispValue&(org::sem::AttrValue::*)()>(&org::sem::AttrValue::getLispValue),
                                   std::make_tuple()));
  }
  Napi::Value getDataKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrValue::DataKind(org::sem::AttrValue::*)() const>(&org::sem::AttrValue::getDataKind),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_name(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<char const*(org::sem::AttrValue::*)() const>(&org::sem::AttrValue::sub_variant_get_name),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_data(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrValue::DataVariant const&(org::sem::AttrValue::*)() const>(&org::sem::AttrValue::sub_variant_get_data),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_kind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrValue::DataKind(org::sem::AttrValue::*)() const>(&org::sem::AttrValue::sub_variant_get_kind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "AttrvalueJs", {InstanceMethod("getBool", &AttrvalueJs::getBool),
                                                           InstanceMethod("getInt", &AttrvalueJs::getInt),
                                                           InstanceMethod("getString", &AttrvalueJs::getString),
                                                           InstanceMethod("getFile", &AttrvalueJs::getFile),
                                                           InstanceMethod("getReference", &AttrvalueJs::getReference),
                                                           InstanceMethod("getDouble", &AttrvalueJs::getDouble),
                                                           InstanceMethod("operator==", &AttrvalueJs::operator==),
                                                           InstanceMethod("isTextValue", &AttrvalueJs::isTextValue),
                                                           InstanceMethod("getTextValueMut", &AttrvalueJs::getTextValueMut),
                                                           InstanceMethod("isFileReference", &AttrvalueJs::isFileReference),
                                                           InstanceMethod("getFileReferenceMut", &AttrvalueJs::getFileReferenceMut),
                                                           InstanceMethod("isLispValue", &AttrvalueJs::isLispValue),
                                                           InstanceMethod("getLispValueMut", &AttrvalueJs::getLispValueMut),
                                                           InstanceMethod("getDataKind", &AttrvalueJs::getDataKind),
                                                           InstanceMethod("sub_variant_get_name", &AttrvalueJs::sub_variant_get_name),
                                                           InstanceMethod("sub_variant_get_data", &AttrvalueJs::sub_variant_get_data),
                                                           InstanceMethod("sub_variant_get_kind", &AttrvalueJs::sub_variant_get_kind)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("AttrvalueJs", func);
    return exports;
  }
  AttrvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<AttrvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::AttrValue>();
  }
  AttrvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::AttrValue> const& ptr) : Napi::ObjectWrap<AttrvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::AttrValue> _stored;
  org::sem::AttrValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<AttrvalueJs> {
  using type = org::sem::AttrValue;
};

template <>
struct org_to_js_type<org::sem::AttrValue> {
  using type = AttrvalueJs;
};

struct AttrvalueDimensionspanJs : public Napi::ObjectWrap<AttrvalueDimensionspanJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::AttrValue::DimensionSpan::*)(org::sem::AttrValue::DimensionSpan const&) const>(&org::sem::AttrValue::DimensionSpan::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::AttrValue::DimensionSpan>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "AttrvalueDimensionspanJs", {InstanceMethod("operator==", &AttrvalueDimensionspanJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("AttrvalueDimensionspanJs", func);
    return exports;
  }
  AttrvalueDimensionspanJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<AttrvalueDimensionspanJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::AttrValue::DimensionSpan>();
  }
  AttrvalueDimensionspanJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::AttrValue::DimensionSpan> const& ptr) : Napi::ObjectWrap<AttrvalueDimensionspanJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::AttrValue::DimensionSpan> _stored;
  org::sem::AttrValue::DimensionSpan* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<AttrvalueDimensionspanJs> {
  using type = org::sem::AttrValue::DimensionSpan;
};

template <>
struct org_to_js_type<org::sem::AttrValue::DimensionSpan> {
  using type = AttrvalueDimensionspanJs;
};

struct AttrvalueTextvalueJs : public Napi::ObjectWrap<AttrvalueTextvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::AttrValue::TextValue::*)(org::sem::AttrValue::TextValue const&) const>(&org::sem::AttrValue::TextValue::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::AttrValue::TextValue>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "AttrvalueTextvalueJs", {InstanceMethod("operator==", &AttrvalueTextvalueJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("AttrvalueTextvalueJs", func);
    return exports;
  }
  AttrvalueTextvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<AttrvalueTextvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::AttrValue::TextValue>();
  }
  AttrvalueTextvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::AttrValue::TextValue> const& ptr) : Napi::ObjectWrap<AttrvalueTextvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::AttrValue::TextValue> _stored;
  org::sem::AttrValue::TextValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<AttrvalueTextvalueJs> {
  using type = org::sem::AttrValue::TextValue;
};

template <>
struct org_to_js_type<org::sem::AttrValue::TextValue> {
  using type = AttrvalueTextvalueJs;
};

struct AttrvalueFilereferenceJs : public Napi::ObjectWrap<AttrvalueFilereferenceJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::AttrValue::FileReference::*)(org::sem::AttrValue::FileReference const&) const>(&org::sem::AttrValue::FileReference::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::AttrValue::FileReference>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "AttrvalueFilereferenceJs", {InstanceMethod("operator==", &AttrvalueFilereferenceJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("AttrvalueFilereferenceJs", func);
    return exports;
  }
  AttrvalueFilereferenceJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<AttrvalueFilereferenceJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::AttrValue::FileReference>();
  }
  AttrvalueFilereferenceJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::AttrValue::FileReference> const& ptr) : Napi::ObjectWrap<AttrvalueFilereferenceJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::AttrValue::FileReference> _stored;
  org::sem::AttrValue::FileReference* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<AttrvalueFilereferenceJs> {
  using type = org::sem::AttrValue::FileReference;
};

template <>
struct org_to_js_type<org::sem::AttrValue::FileReference> {
  using type = AttrvalueFilereferenceJs;
};

struct AttrvalueLispvalueJs : public Napi::ObjectWrap<AttrvalueLispvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::AttrValue::LispValue::*)(org::sem::AttrValue::LispValue const&) const>(&org::sem::AttrValue::LispValue::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::AttrValue::LispValue>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "AttrvalueLispvalueJs", {InstanceMethod("operator==", &AttrvalueLispvalueJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("AttrvalueLispvalueJs", func);
    return exports;
  }
  AttrvalueLispvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<AttrvalueLispvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::AttrValue::LispValue>();
  }
  AttrvalueLispvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::AttrValue::LispValue> const& ptr) : Napi::ObjectWrap<AttrvalueLispvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::AttrValue::LispValue> _stored;
  org::sem::AttrValue::LispValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<AttrvalueLispvalueJs> {
  using type = org::sem::AttrValue::LispValue;
};

template <>
struct org_to_js_type<org::sem::AttrValue::LispValue> {
  using type = AttrvalueLispvalueJs;
};

struct HashtagflatJs : public Napi::ObjectWrap<HashtagflatJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::HashTagFlat::*)(org::sem::HashTagFlat const&) const>(&org::sem::HashTagFlat::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::HashTagFlat>{"other"})));
  }
  Napi::Value operator<(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::HashTagFlat::*)(org::sem::HashTagFlat const&) const>(&org::sem::HashTagFlat::operator<),
                                        std::make_tuple(CxxArgSpec<org::sem::HashTagFlat>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "HashtagflatJs", {InstanceMethod("operator==", &HashtagflatJs::operator==),
                                                             InstanceMethod("operator<", &HashtagflatJs::operator<)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("HashtagflatJs", func);
    return exports;
  }
  HashtagflatJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<HashtagflatJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::HashTagFlat>();
  }
  HashtagflatJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::HashTagFlat> const& ptr) : Napi::ObjectWrap<HashtagflatJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::HashTagFlat> _stored;
  org::sem::HashTagFlat* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<HashtagflatJs> {
  using type = org::sem::HashTagFlat;
};

template <>
struct org_to_js_type<org::sem::HashTagFlat> {
  using type = HashtagflatJs;
};

struct HashtagtextJs : public Napi::ObjectWrap<HashtagtextJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::HashTagText::*)(org::sem::HashTagText const&) const>(&org::sem::HashTagText::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::HashTagText>{"other"})));
  }
  Napi::Value prefixMatch(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::HashTagText::*)(hstd::Vec<hstd::Str> const&) const>(&org::sem::HashTagText::prefixMatch),
                                        std::make_tuple(CxxArgSpec<hstd::Vec<hstd::Str>>{"prefix"})));
  }
  Napi::Value getFlatHashes(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::HashTagFlat>(org::sem::HashTagText::*)(bool) const>(&org::sem::HashTagText::getFlatHashes),
                                        std::make_tuple(CxxArgSpec<bool>{"withIntermediate", true})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "HashtagtextJs", {InstanceMethod("operator==", &HashtagtextJs::operator==),
                                                             InstanceMethod("prefixMatch", &HashtagtextJs::prefixMatch),
                                                             InstanceMethod("getFlatHashes", &HashtagtextJs::getFlatHashes)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("HashtagtextJs", func);
    return exports;
  }
  HashtagtextJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<HashtagtextJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::HashTagText>();
  }
  HashtagtextJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::HashTagText> const& ptr) : Napi::ObjectWrap<HashtagtextJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::HashTagText> _stored;
  org::sem::HashTagText* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<HashtagtextJs> {
  using type = org::sem::HashTagText;
};

template <>
struct org_to_js_type<org::sem::HashTagText> {
  using type = HashtagtextJs;
};

struct SubtreepathJs : public Napi::ObjectWrap<SubtreepathJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreePath::*)(org::sem::SubtreePath const&) const>(&org::sem::SubtreePath::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::SubtreePath>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "SubtreepathJs", {InstanceMethod("operator==", &SubtreepathJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("SubtreepathJs", func);
    return exports;
  }
  SubtreepathJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<SubtreepathJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::SubtreePath>();
  }
  SubtreepathJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::SubtreePath> const& ptr) : Napi::ObjectWrap<SubtreepathJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::SubtreePath> _stored;
  org::sem::SubtreePath* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<SubtreepathJs> {
  using type = org::sem::SubtreePath;
};

template <>
struct org_to_js_type<org::sem::SubtreePath> {
  using type = SubtreepathJs;
};

struct LinktargetJs : public Napi::ObjectWrap<LinktargetJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::*)(org::sem::LinkTarget const&) const>(&org::sem::LinkTarget::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LinkTarget>{"other"})));
  }
  Napi::Value isRaw(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::*)() const>(&org::sem::LinkTarget::isRaw),
                                        std::make_tuple()));
  }
  Napi::Value getRawMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LinkTarget::Raw&(org::sem::LinkTarget::*)()>(&org::sem::LinkTarget::getRaw),
                                   std::make_tuple()));
  }
  Napi::Value isId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::*)() const>(&org::sem::LinkTarget::isId),
                                        std::make_tuple()));
  }
  Napi::Value getIdMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LinkTarget::Id&(org::sem::LinkTarget::*)()>(&org::sem::LinkTarget::getId),
                                   std::make_tuple()));
  }
  Napi::Value isCustomId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::*)() const>(&org::sem::LinkTarget::isCustomId),
                                        std::make_tuple()));
  }
  Napi::Value getCustomIdMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LinkTarget::CustomId&(org::sem::LinkTarget::*)()>(&org::sem::LinkTarget::getCustomId),
                                   std::make_tuple()));
  }
  Napi::Value isSubtreeTitle(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::*)() const>(&org::sem::LinkTarget::isSubtreeTitle),
                                        std::make_tuple()));
  }
  Napi::Value getSubtreeTitleMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LinkTarget::SubtreeTitle&(org::sem::LinkTarget::*)()>(&org::sem::LinkTarget::getSubtreeTitle),
                                   std::make_tuple()));
  }
  Napi::Value isPerson(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::*)() const>(&org::sem::LinkTarget::isPerson),
                                        std::make_tuple()));
  }
  Napi::Value getPersonMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LinkTarget::Person&(org::sem::LinkTarget::*)()>(&org::sem::LinkTarget::getPerson),
                                   std::make_tuple()));
  }
  Napi::Value isUserProtocol(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::*)() const>(&org::sem::LinkTarget::isUserProtocol),
                                        std::make_tuple()));
  }
  Napi::Value getUserProtocolMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LinkTarget::UserProtocol&(org::sem::LinkTarget::*)()>(&org::sem::LinkTarget::getUserProtocol),
                                   std::make_tuple()));
  }
  Napi::Value isInternal(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::*)() const>(&org::sem::LinkTarget::isInternal),
                                        std::make_tuple()));
  }
  Napi::Value getInternalMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LinkTarget::Internal&(org::sem::LinkTarget::*)()>(&org::sem::LinkTarget::getInternal),
                                   std::make_tuple()));
  }
  Napi::Value isFootnote(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::*)() const>(&org::sem::LinkTarget::isFootnote),
                                        std::make_tuple()));
  }
  Napi::Value getFootnoteMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LinkTarget::Footnote&(org::sem::LinkTarget::*)()>(&org::sem::LinkTarget::getFootnote),
                                   std::make_tuple()));
  }
  Napi::Value isFile(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::*)() const>(&org::sem::LinkTarget::isFile),
                                        std::make_tuple()));
  }
  Napi::Value getFileMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LinkTarget::File&(org::sem::LinkTarget::*)()>(&org::sem::LinkTarget::getFile),
                                   std::make_tuple()));
  }
  Napi::Value isAttachment(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::*)() const>(&org::sem::LinkTarget::isAttachment),
                                        std::make_tuple()));
  }
  Napi::Value getAttachmentMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LinkTarget::Attachment&(org::sem::LinkTarget::*)()>(&org::sem::LinkTarget::getAttachment),
                                   std::make_tuple()));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::LinkTarget::Kind(org::sem::LinkTarget::*)() const>(&org::sem::LinkTarget::getKind),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_name(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<char const*(org::sem::LinkTarget::*)() const>(&org::sem::LinkTarget::sub_variant_get_name),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_data(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::LinkTarget::Data const&(org::sem::LinkTarget::*)() const>(&org::sem::LinkTarget::sub_variant_get_data),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_kind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::LinkTarget::Kind(org::sem::LinkTarget::*)() const>(&org::sem::LinkTarget::sub_variant_get_kind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "LinktargetJs", {InstanceMethod("operator==", &LinktargetJs::operator==),
                                                            InstanceMethod("isRaw", &LinktargetJs::isRaw),
                                                            InstanceMethod("getRawMut", &LinktargetJs::getRawMut),
                                                            InstanceMethod("isId", &LinktargetJs::isId),
                                                            InstanceMethod("getIdMut", &LinktargetJs::getIdMut),
                                                            InstanceMethod("isCustomId", &LinktargetJs::isCustomId),
                                                            InstanceMethod("getCustomIdMut", &LinktargetJs::getCustomIdMut),
                                                            InstanceMethod("isSubtreeTitle", &LinktargetJs::isSubtreeTitle),
                                                            InstanceMethod("getSubtreeTitleMut", &LinktargetJs::getSubtreeTitleMut),
                                                            InstanceMethod("isPerson", &LinktargetJs::isPerson),
                                                            InstanceMethod("getPersonMut", &LinktargetJs::getPersonMut),
                                                            InstanceMethod("isUserProtocol", &LinktargetJs::isUserProtocol),
                                                            InstanceMethod("getUserProtocolMut", &LinktargetJs::getUserProtocolMut),
                                                            InstanceMethod("isInternal", &LinktargetJs::isInternal),
                                                            InstanceMethod("getInternalMut", &LinktargetJs::getInternalMut),
                                                            InstanceMethod("isFootnote", &LinktargetJs::isFootnote),
                                                            InstanceMethod("getFootnoteMut", &LinktargetJs::getFootnoteMut),
                                                            InstanceMethod("isFile", &LinktargetJs::isFile),
                                                            InstanceMethod("getFileMut", &LinktargetJs::getFileMut),
                                                            InstanceMethod("isAttachment", &LinktargetJs::isAttachment),
                                                            InstanceMethod("getAttachmentMut", &LinktargetJs::getAttachmentMut),
                                                            InstanceMethod("getKind", &LinktargetJs::getKind),
                                                            InstanceMethod("sub_variant_get_name", &LinktargetJs::sub_variant_get_name),
                                                            InstanceMethod("sub_variant_get_data", &LinktargetJs::sub_variant_get_data),
                                                            InstanceMethod("sub_variant_get_kind", &LinktargetJs::sub_variant_get_kind)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("LinktargetJs", func);
    return exports;
  }
  LinktargetJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<LinktargetJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::LinkTarget>();
  }
  LinktargetJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::LinkTarget> const& ptr) : Napi::ObjectWrap<LinktargetJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::LinkTarget> _stored;
  org::sem::LinkTarget* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<LinktargetJs> {
  using type = org::sem::LinkTarget;
};

template <>
struct org_to_js_type<org::sem::LinkTarget> {
  using type = LinktargetJs;
};

struct LinktargetRawJs : public Napi::ObjectWrap<LinktargetRawJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::Raw::*)(org::sem::LinkTarget::Raw const&) const>(&org::sem::LinkTarget::Raw::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LinkTarget::Raw>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "LinktargetRawJs", {InstanceMethod("operator==", &LinktargetRawJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("LinktargetRawJs", func);
    return exports;
  }
  LinktargetRawJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<LinktargetRawJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::LinkTarget::Raw>();
  }
  LinktargetRawJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::LinkTarget::Raw> const& ptr) : Napi::ObjectWrap<LinktargetRawJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::LinkTarget::Raw> _stored;
  org::sem::LinkTarget::Raw* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<LinktargetRawJs> {
  using type = org::sem::LinkTarget::Raw;
};

template <>
struct org_to_js_type<org::sem::LinkTarget::Raw> {
  using type = LinktargetRawJs;
};

struct LinktargetIdJs : public Napi::ObjectWrap<LinktargetIdJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::Id::*)(org::sem::LinkTarget::Id const&) const>(&org::sem::LinkTarget::Id::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LinkTarget::Id>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "LinktargetIdJs", {InstanceMethod("operator==", &LinktargetIdJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("LinktargetIdJs", func);
    return exports;
  }
  LinktargetIdJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<LinktargetIdJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::LinkTarget::Id>();
  }
  LinktargetIdJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::LinkTarget::Id> const& ptr) : Napi::ObjectWrap<LinktargetIdJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::LinkTarget::Id> _stored;
  org::sem::LinkTarget::Id* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<LinktargetIdJs> {
  using type = org::sem::LinkTarget::Id;
};

template <>
struct org_to_js_type<org::sem::LinkTarget::Id> {
  using type = LinktargetIdJs;
};

struct LinktargetCustomidJs : public Napi::ObjectWrap<LinktargetCustomidJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::CustomId::*)(org::sem::LinkTarget::CustomId const&) const>(&org::sem::LinkTarget::CustomId::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LinkTarget::CustomId>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "LinktargetCustomidJs", {InstanceMethod("operator==", &LinktargetCustomidJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("LinktargetCustomidJs", func);
    return exports;
  }
  LinktargetCustomidJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<LinktargetCustomidJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::LinkTarget::CustomId>();
  }
  LinktargetCustomidJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::LinkTarget::CustomId> const& ptr) : Napi::ObjectWrap<LinktargetCustomidJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::LinkTarget::CustomId> _stored;
  org::sem::LinkTarget::CustomId* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<LinktargetCustomidJs> {
  using type = org::sem::LinkTarget::CustomId;
};

template <>
struct org_to_js_type<org::sem::LinkTarget::CustomId> {
  using type = LinktargetCustomidJs;
};

struct LinktargetSubtreetitleJs : public Napi::ObjectWrap<LinktargetSubtreetitleJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::SubtreeTitle::*)(org::sem::LinkTarget::SubtreeTitle const&) const>(&org::sem::LinkTarget::SubtreeTitle::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LinkTarget::SubtreeTitle>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "LinktargetSubtreetitleJs", {InstanceMethod("operator==", &LinktargetSubtreetitleJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("LinktargetSubtreetitleJs", func);
    return exports;
  }
  LinktargetSubtreetitleJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<LinktargetSubtreetitleJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::LinkTarget::SubtreeTitle>();
  }
  LinktargetSubtreetitleJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::LinkTarget::SubtreeTitle> const& ptr) : Napi::ObjectWrap<LinktargetSubtreetitleJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::LinkTarget::SubtreeTitle> _stored;
  org::sem::LinkTarget::SubtreeTitle* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<LinktargetSubtreetitleJs> {
  using type = org::sem::LinkTarget::SubtreeTitle;
};

template <>
struct org_to_js_type<org::sem::LinkTarget::SubtreeTitle> {
  using type = LinktargetSubtreetitleJs;
};

struct LinktargetPersonJs : public Napi::ObjectWrap<LinktargetPersonJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::Person::*)(org::sem::LinkTarget::Person const&) const>(&org::sem::LinkTarget::Person::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LinkTarget::Person>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "LinktargetPersonJs", {InstanceMethod("operator==", &LinktargetPersonJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("LinktargetPersonJs", func);
    return exports;
  }
  LinktargetPersonJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<LinktargetPersonJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::LinkTarget::Person>();
  }
  LinktargetPersonJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::LinkTarget::Person> const& ptr) : Napi::ObjectWrap<LinktargetPersonJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::LinkTarget::Person> _stored;
  org::sem::LinkTarget::Person* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<LinktargetPersonJs> {
  using type = org::sem::LinkTarget::Person;
};

template <>
struct org_to_js_type<org::sem::LinkTarget::Person> {
  using type = LinktargetPersonJs;
};

struct LinktargetUserprotocolJs : public Napi::ObjectWrap<LinktargetUserprotocolJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::UserProtocol::*)(org::sem::LinkTarget::UserProtocol const&) const>(&org::sem::LinkTarget::UserProtocol::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LinkTarget::UserProtocol>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "LinktargetUserprotocolJs", {InstanceMethod("operator==", &LinktargetUserprotocolJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("LinktargetUserprotocolJs", func);
    return exports;
  }
  LinktargetUserprotocolJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<LinktargetUserprotocolJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::LinkTarget::UserProtocol>();
  }
  LinktargetUserprotocolJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::LinkTarget::UserProtocol> const& ptr) : Napi::ObjectWrap<LinktargetUserprotocolJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::LinkTarget::UserProtocol> _stored;
  org::sem::LinkTarget::UserProtocol* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<LinktargetUserprotocolJs> {
  using type = org::sem::LinkTarget::UserProtocol;
};

template <>
struct org_to_js_type<org::sem::LinkTarget::UserProtocol> {
  using type = LinktargetUserprotocolJs;
};

struct LinktargetInternalJs : public Napi::ObjectWrap<LinktargetInternalJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::Internal::*)(org::sem::LinkTarget::Internal const&) const>(&org::sem::LinkTarget::Internal::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LinkTarget::Internal>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "LinktargetInternalJs", {InstanceMethod("operator==", &LinktargetInternalJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("LinktargetInternalJs", func);
    return exports;
  }
  LinktargetInternalJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<LinktargetInternalJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::LinkTarget::Internal>();
  }
  LinktargetInternalJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::LinkTarget::Internal> const& ptr) : Napi::ObjectWrap<LinktargetInternalJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::LinkTarget::Internal> _stored;
  org::sem::LinkTarget::Internal* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<LinktargetInternalJs> {
  using type = org::sem::LinkTarget::Internal;
};

template <>
struct org_to_js_type<org::sem::LinkTarget::Internal> {
  using type = LinktargetInternalJs;
};

struct LinktargetFootnoteJs : public Napi::ObjectWrap<LinktargetFootnoteJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::Footnote::*)(org::sem::LinkTarget::Footnote const&) const>(&org::sem::LinkTarget::Footnote::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LinkTarget::Footnote>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "LinktargetFootnoteJs", {InstanceMethod("operator==", &LinktargetFootnoteJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("LinktargetFootnoteJs", func);
    return exports;
  }
  LinktargetFootnoteJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<LinktargetFootnoteJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::LinkTarget::Footnote>();
  }
  LinktargetFootnoteJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::LinkTarget::Footnote> const& ptr) : Napi::ObjectWrap<LinktargetFootnoteJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::LinkTarget::Footnote> _stored;
  org::sem::LinkTarget::Footnote* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<LinktargetFootnoteJs> {
  using type = org::sem::LinkTarget::Footnote;
};

template <>
struct org_to_js_type<org::sem::LinkTarget::Footnote> {
  using type = LinktargetFootnoteJs;
};

struct LinktargetFileJs : public Napi::ObjectWrap<LinktargetFileJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::File::*)(org::sem::LinkTarget::File const&) const>(&org::sem::LinkTarget::File::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LinkTarget::File>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "LinktargetFileJs", {InstanceMethod("operator==", &LinktargetFileJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("LinktargetFileJs", func);
    return exports;
  }
  LinktargetFileJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<LinktargetFileJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::LinkTarget::File>();
  }
  LinktargetFileJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::LinkTarget::File> const& ptr) : Napi::ObjectWrap<LinktargetFileJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::LinkTarget::File> _stored;
  org::sem::LinkTarget::File* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<LinktargetFileJs> {
  using type = org::sem::LinkTarget::File;
};

template <>
struct org_to_js_type<org::sem::LinkTarget::File> {
  using type = LinktargetFileJs;
};

struct LinktargetAttachmentJs : public Napi::ObjectWrap<LinktargetAttachmentJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::Attachment::*)(org::sem::LinkTarget::Attachment const&) const>(&org::sem::LinkTarget::Attachment::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LinkTarget::Attachment>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "LinktargetAttachmentJs", {InstanceMethod("operator==", &LinktargetAttachmentJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("LinktargetAttachmentJs", func);
    return exports;
  }
  LinktargetAttachmentJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<LinktargetAttachmentJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::LinkTarget::Attachment>();
  }
  LinktargetAttachmentJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::LinkTarget::Attachment> const& ptr) : Napi::ObjectWrap<LinktargetAttachmentJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::LinkTarget::Attachment> _stored;
  org::sem::LinkTarget::Attachment* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<LinktargetAttachmentJs> {
  using type = org::sem::LinkTarget::Attachment;
};

template <>
struct org_to_js_type<org::sem::LinkTarget::Attachment> {
  using type = LinktargetAttachmentJs;
};

struct SubtreelogheadJs : public Napi::ObjectWrap<SubtreelogheadJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::*)(org::sem::SubtreeLogHead const&) const>(&org::sem::SubtreeLogHead::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::SubtreeLogHead>{"other"})));
  }
  Napi::Value isPriority(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::*)() const>(&org::sem::SubtreeLogHead::isPriority),
                                        std::make_tuple()));
  }
  Napi::Value getPriorityMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::SubtreeLogHead::Priority&(org::sem::SubtreeLogHead::*)()>(&org::sem::SubtreeLogHead::getPriority),
                                   std::make_tuple()));
  }
  Napi::Value isNote(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::*)() const>(&org::sem::SubtreeLogHead::isNote),
                                        std::make_tuple()));
  }
  Napi::Value getNoteMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::SubtreeLogHead::Note&(org::sem::SubtreeLogHead::*)()>(&org::sem::SubtreeLogHead::getNote),
                                   std::make_tuple()));
  }
  Napi::Value isRefile(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::*)() const>(&org::sem::SubtreeLogHead::isRefile),
                                        std::make_tuple()));
  }
  Napi::Value getRefileMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::SubtreeLogHead::Refile&(org::sem::SubtreeLogHead::*)()>(&org::sem::SubtreeLogHead::getRefile),
                                   std::make_tuple()));
  }
  Napi::Value isClock(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::*)() const>(&org::sem::SubtreeLogHead::isClock),
                                        std::make_tuple()));
  }
  Napi::Value getClockMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::SubtreeLogHead::Clock&(org::sem::SubtreeLogHead::*)()>(&org::sem::SubtreeLogHead::getClock),
                                   std::make_tuple()));
  }
  Napi::Value isState(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::*)() const>(&org::sem::SubtreeLogHead::isState),
                                        std::make_tuple()));
  }
  Napi::Value getStateMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::SubtreeLogHead::State&(org::sem::SubtreeLogHead::*)()>(&org::sem::SubtreeLogHead::getState),
                                   std::make_tuple()));
  }
  Napi::Value isDeadline(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::*)() const>(&org::sem::SubtreeLogHead::isDeadline),
                                        std::make_tuple()));
  }
  Napi::Value getDeadlineMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::SubtreeLogHead::Deadline&(org::sem::SubtreeLogHead::*)()>(&org::sem::SubtreeLogHead::getDeadline),
                                   std::make_tuple()));
  }
  Napi::Value isSchedule(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::*)() const>(&org::sem::SubtreeLogHead::isSchedule),
                                        std::make_tuple()));
  }
  Napi::Value getScheduleMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::SubtreeLogHead::Schedule&(org::sem::SubtreeLogHead::*)()>(&org::sem::SubtreeLogHead::getSchedule),
                                   std::make_tuple()));
  }
  Napi::Value isTag(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::*)() const>(&org::sem::SubtreeLogHead::isTag),
                                        std::make_tuple()));
  }
  Napi::Value getTagMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::SubtreeLogHead::Tag&(org::sem::SubtreeLogHead::*)()>(&org::sem::SubtreeLogHead::getTag),
                                   std::make_tuple()));
  }
  Napi::Value isUnknown(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::*)() const>(&org::sem::SubtreeLogHead::isUnknown),
                                        std::make_tuple()));
  }
  Napi::Value getUnknownMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::SubtreeLogHead::Unknown&(org::sem::SubtreeLogHead::*)()>(&org::sem::SubtreeLogHead::getUnknown),
                                   std::make_tuple()));
  }
  Napi::Value getLogKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SubtreeLogHead::Kind(org::sem::SubtreeLogHead::*)() const>(&org::sem::SubtreeLogHead::getLogKind),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_name(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<char const*(org::sem::SubtreeLogHead::*)() const>(&org::sem::SubtreeLogHead::sub_variant_get_name),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_data(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SubtreeLogHead::LogEntry const&(org::sem::SubtreeLogHead::*)() const>(&org::sem::SubtreeLogHead::sub_variant_get_data),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_kind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SubtreeLogHead::Kind(org::sem::SubtreeLogHead::*)() const>(&org::sem::SubtreeLogHead::sub_variant_get_kind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "SubtreelogheadJs", {InstanceMethod("operator==", &SubtreelogheadJs::operator==),
                                                                InstanceMethod("isPriority", &SubtreelogheadJs::isPriority),
                                                                InstanceMethod("getPriorityMut", &SubtreelogheadJs::getPriorityMut),
                                                                InstanceMethod("isNote", &SubtreelogheadJs::isNote),
                                                                InstanceMethod("getNoteMut", &SubtreelogheadJs::getNoteMut),
                                                                InstanceMethod("isRefile", &SubtreelogheadJs::isRefile),
                                                                InstanceMethod("getRefileMut", &SubtreelogheadJs::getRefileMut),
                                                                InstanceMethod("isClock", &SubtreelogheadJs::isClock),
                                                                InstanceMethod("getClockMut", &SubtreelogheadJs::getClockMut),
                                                                InstanceMethod("isState", &SubtreelogheadJs::isState),
                                                                InstanceMethod("getStateMut", &SubtreelogheadJs::getStateMut),
                                                                InstanceMethod("isDeadline", &SubtreelogheadJs::isDeadline),
                                                                InstanceMethod("getDeadlineMut", &SubtreelogheadJs::getDeadlineMut),
                                                                InstanceMethod("isSchedule", &SubtreelogheadJs::isSchedule),
                                                                InstanceMethod("getScheduleMut", &SubtreelogheadJs::getScheduleMut),
                                                                InstanceMethod("isTag", &SubtreelogheadJs::isTag),
                                                                InstanceMethod("getTagMut", &SubtreelogheadJs::getTagMut),
                                                                InstanceMethod("isUnknown", &SubtreelogheadJs::isUnknown),
                                                                InstanceMethod("getUnknownMut", &SubtreelogheadJs::getUnknownMut),
                                                                InstanceMethod("getLogKind", &SubtreelogheadJs::getLogKind),
                                                                InstanceMethod("sub_variant_get_name", &SubtreelogheadJs::sub_variant_get_name),
                                                                InstanceMethod("sub_variant_get_data", &SubtreelogheadJs::sub_variant_get_data),
                                                                InstanceMethod("sub_variant_get_kind", &SubtreelogheadJs::sub_variant_get_kind)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("SubtreelogheadJs", func);
    return exports;
  }
  SubtreelogheadJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<SubtreelogheadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::SubtreeLogHead>();
  }
  SubtreelogheadJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::SubtreeLogHead> const& ptr) : Napi::ObjectWrap<SubtreelogheadJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::SubtreeLogHead> _stored;
  org::sem::SubtreeLogHead* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<SubtreelogheadJs> {
  using type = org::sem::SubtreeLogHead;
};

template <>
struct org_to_js_type<org::sem::SubtreeLogHead> {
  using type = SubtreelogheadJs;
};

struct SubtreelogheadPriorityJs : public Napi::ObjectWrap<SubtreelogheadPriorityJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::Priority::*)(org::sem::SubtreeLogHead::Priority const&) const>(&org::sem::SubtreeLogHead::Priority::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::SubtreeLogHead::Priority>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "SubtreelogheadPriorityJs", {InstanceMethod("operator==", &SubtreelogheadPriorityJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("SubtreelogheadPriorityJs", func);
    return exports;
  }
  SubtreelogheadPriorityJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<SubtreelogheadPriorityJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::SubtreeLogHead::Priority>();
  }
  SubtreelogheadPriorityJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::SubtreeLogHead::Priority> const& ptr) : Napi::ObjectWrap<SubtreelogheadPriorityJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::SubtreeLogHead::Priority> _stored;
  org::sem::SubtreeLogHead::Priority* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<SubtreelogheadPriorityJs> {
  using type = org::sem::SubtreeLogHead::Priority;
};

template <>
struct org_to_js_type<org::sem::SubtreeLogHead::Priority> {
  using type = SubtreelogheadPriorityJs;
};

struct SubtreelogheadNoteJs : public Napi::ObjectWrap<SubtreelogheadNoteJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::Note::*)(org::sem::SubtreeLogHead::Note const&) const>(&org::sem::SubtreeLogHead::Note::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::SubtreeLogHead::Note>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "SubtreelogheadNoteJs", {InstanceMethod("operator==", &SubtreelogheadNoteJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("SubtreelogheadNoteJs", func);
    return exports;
  }
  SubtreelogheadNoteJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<SubtreelogheadNoteJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::SubtreeLogHead::Note>();
  }
  SubtreelogheadNoteJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::SubtreeLogHead::Note> const& ptr) : Napi::ObjectWrap<SubtreelogheadNoteJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::SubtreeLogHead::Note> _stored;
  org::sem::SubtreeLogHead::Note* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<SubtreelogheadNoteJs> {
  using type = org::sem::SubtreeLogHead::Note;
};

template <>
struct org_to_js_type<org::sem::SubtreeLogHead::Note> {
  using type = SubtreelogheadNoteJs;
};

struct SubtreelogheadRefileJs : public Napi::ObjectWrap<SubtreelogheadRefileJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::Refile::*)(org::sem::SubtreeLogHead::Refile const&) const>(&org::sem::SubtreeLogHead::Refile::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::SubtreeLogHead::Refile>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "SubtreelogheadRefileJs", {InstanceMethod("operator==", &SubtreelogheadRefileJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("SubtreelogheadRefileJs", func);
    return exports;
  }
  SubtreelogheadRefileJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<SubtreelogheadRefileJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::SubtreeLogHead::Refile>();
  }
  SubtreelogheadRefileJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::SubtreeLogHead::Refile> const& ptr) : Napi::ObjectWrap<SubtreelogheadRefileJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::SubtreeLogHead::Refile> _stored;
  org::sem::SubtreeLogHead::Refile* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<SubtreelogheadRefileJs> {
  using type = org::sem::SubtreeLogHead::Refile;
};

template <>
struct org_to_js_type<org::sem::SubtreeLogHead::Refile> {
  using type = SubtreelogheadRefileJs;
};

struct SubtreelogheadClockJs : public Napi::ObjectWrap<SubtreelogheadClockJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::Clock::*)(org::sem::SubtreeLogHead::Clock const&) const>(&org::sem::SubtreeLogHead::Clock::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::SubtreeLogHead::Clock>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "SubtreelogheadClockJs", {InstanceMethod("operator==", &SubtreelogheadClockJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("SubtreelogheadClockJs", func);
    return exports;
  }
  SubtreelogheadClockJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<SubtreelogheadClockJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::SubtreeLogHead::Clock>();
  }
  SubtreelogheadClockJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::SubtreeLogHead::Clock> const& ptr) : Napi::ObjectWrap<SubtreelogheadClockJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::SubtreeLogHead::Clock> _stored;
  org::sem::SubtreeLogHead::Clock* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<SubtreelogheadClockJs> {
  using type = org::sem::SubtreeLogHead::Clock;
};

template <>
struct org_to_js_type<org::sem::SubtreeLogHead::Clock> {
  using type = SubtreelogheadClockJs;
};

struct SubtreelogheadStateJs : public Napi::ObjectWrap<SubtreelogheadStateJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::State::*)(org::sem::SubtreeLogHead::State const&) const>(&org::sem::SubtreeLogHead::State::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::SubtreeLogHead::State>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "SubtreelogheadStateJs", {InstanceMethod("operator==", &SubtreelogheadStateJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("SubtreelogheadStateJs", func);
    return exports;
  }
  SubtreelogheadStateJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<SubtreelogheadStateJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::SubtreeLogHead::State>();
  }
  SubtreelogheadStateJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::SubtreeLogHead::State> const& ptr) : Napi::ObjectWrap<SubtreelogheadStateJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::SubtreeLogHead::State> _stored;
  org::sem::SubtreeLogHead::State* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<SubtreelogheadStateJs> {
  using type = org::sem::SubtreeLogHead::State;
};

template <>
struct org_to_js_type<org::sem::SubtreeLogHead::State> {
  using type = SubtreelogheadStateJs;
};

struct SubtreelogheadDeadlineJs : public Napi::ObjectWrap<SubtreelogheadDeadlineJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::Deadline::*)(org::sem::SubtreeLogHead::Deadline const&) const>(&org::sem::SubtreeLogHead::Deadline::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::SubtreeLogHead::Deadline>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "SubtreelogheadDeadlineJs", {InstanceMethod("operator==", &SubtreelogheadDeadlineJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("SubtreelogheadDeadlineJs", func);
    return exports;
  }
  SubtreelogheadDeadlineJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<SubtreelogheadDeadlineJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::SubtreeLogHead::Deadline>();
  }
  SubtreelogheadDeadlineJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::SubtreeLogHead::Deadline> const& ptr) : Napi::ObjectWrap<SubtreelogheadDeadlineJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::SubtreeLogHead::Deadline> _stored;
  org::sem::SubtreeLogHead::Deadline* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<SubtreelogheadDeadlineJs> {
  using type = org::sem::SubtreeLogHead::Deadline;
};

template <>
struct org_to_js_type<org::sem::SubtreeLogHead::Deadline> {
  using type = SubtreelogheadDeadlineJs;
};

struct SubtreelogheadScheduleJs : public Napi::ObjectWrap<SubtreelogheadScheduleJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::Schedule::*)(org::sem::SubtreeLogHead::Schedule const&) const>(&org::sem::SubtreeLogHead::Schedule::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::SubtreeLogHead::Schedule>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "SubtreelogheadScheduleJs", {InstanceMethod("operator==", &SubtreelogheadScheduleJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("SubtreelogheadScheduleJs", func);
    return exports;
  }
  SubtreelogheadScheduleJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<SubtreelogheadScheduleJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::SubtreeLogHead::Schedule>();
  }
  SubtreelogheadScheduleJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::SubtreeLogHead::Schedule> const& ptr) : Napi::ObjectWrap<SubtreelogheadScheduleJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::SubtreeLogHead::Schedule> _stored;
  org::sem::SubtreeLogHead::Schedule* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<SubtreelogheadScheduleJs> {
  using type = org::sem::SubtreeLogHead::Schedule;
};

template <>
struct org_to_js_type<org::sem::SubtreeLogHead::Schedule> {
  using type = SubtreelogheadScheduleJs;
};

struct SubtreelogheadTagJs : public Napi::ObjectWrap<SubtreelogheadTagJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::Tag::*)(org::sem::SubtreeLogHead::Tag const&) const>(&org::sem::SubtreeLogHead::Tag::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::SubtreeLogHead::Tag>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "SubtreelogheadTagJs", {InstanceMethod("operator==", &SubtreelogheadTagJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("SubtreelogheadTagJs", func);
    return exports;
  }
  SubtreelogheadTagJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<SubtreelogheadTagJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::SubtreeLogHead::Tag>();
  }
  SubtreelogheadTagJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::SubtreeLogHead::Tag> const& ptr) : Napi::ObjectWrap<SubtreelogheadTagJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::SubtreeLogHead::Tag> _stored;
  org::sem::SubtreeLogHead::Tag* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<SubtreelogheadTagJs> {
  using type = org::sem::SubtreeLogHead::Tag;
};

template <>
struct org_to_js_type<org::sem::SubtreeLogHead::Tag> {
  using type = SubtreelogheadTagJs;
};

struct SubtreelogheadUnknownJs : public Napi::ObjectWrap<SubtreelogheadUnknownJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::Unknown::*)(org::sem::SubtreeLogHead::Unknown const&) const>(&org::sem::SubtreeLogHead::Unknown::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::SubtreeLogHead::Unknown>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "SubtreelogheadUnknownJs", {InstanceMethod("operator==", &SubtreelogheadUnknownJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("SubtreelogheadUnknownJs", func);
    return exports;
  }
  SubtreelogheadUnknownJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<SubtreelogheadUnknownJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::SubtreeLogHead::Unknown>();
  }
  SubtreelogheadUnknownJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::SubtreeLogHead::Unknown> const& ptr) : Napi::ObjectWrap<SubtreelogheadUnknownJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::SubtreeLogHead::Unknown> _stored;
  org::sem::SubtreeLogHead::Unknown* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<SubtreelogheadUnknownJs> {
  using type = org::sem::SubtreeLogHead::Unknown;
};

template <>
struct org_to_js_type<org::sem::SubtreeLogHead::Unknown> {
  using type = SubtreelogheadUnknownJs;
};

struct SubtreecompletionJs : public Napi::ObjectWrap<SubtreecompletionJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeCompletion::*)(org::sem::SubtreeCompletion const&) const>(&org::sem::SubtreeCompletion::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::SubtreeCompletion>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "SubtreecompletionJs", {InstanceMethod("operator==", &SubtreecompletionJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("SubtreecompletionJs", func);
    return exports;
  }
  SubtreecompletionJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<SubtreecompletionJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::SubtreeCompletion>();
  }
  SubtreecompletionJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::SubtreeCompletion> const& ptr) : Napi::ObjectWrap<SubtreecompletionJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::SubtreeCompletion> _stored;
  org::sem::SubtreeCompletion* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<SubtreecompletionJs> {
  using type = org::sem::SubtreeCompletion;
};

template <>
struct org_to_js_type<org::sem::SubtreeCompletion> {
  using type = SubtreecompletionJs;
};

struct AttrlistJs : public Napi::ObjectWrap<AttrlistJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::AttrList::*)(org::sem::AttrList const&) const>(&org::sem::AttrList::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::AttrList>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "AttrlistJs", {InstanceMethod("operator==", &AttrlistJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("AttrlistJs", func);
    return exports;
  }
  AttrlistJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<AttrlistJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::AttrList>();
  }
  AttrlistJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::AttrList> const& ptr) : Napi::ObjectWrap<AttrlistJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::AttrList> _stored;
  org::sem::AttrList* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<AttrlistJs> {
  using type = org::sem::AttrList;
};

template <>
struct org_to_js_type<org::sem::AttrList> {
  using type = AttrlistJs;
};

struct AttrgroupJs : public Napi::ObjectWrap<AttrgroupJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getFlatArgs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::AttrGroup::*)() const>(&org::sem::AttrGroup::getFlatArgs),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::AttrGroup::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::AttrGroup::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value setNamedAttr(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::AttrGroup::*)(hstd::Str const&, hstd::Vec<org::sem::AttrValue> const&)>(&org::sem::AttrGroup::setNamedAttr),
                                   std::make_tuple(CxxArgSpec<hstd::Str>{"key"},
                                                   CxxArgSpec<hstd::Vec<org::sem::AttrValue>>{"attrs"})));
  }
  Napi::Value setPositionalAttr(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::AttrGroup::*)(hstd::Vec<org::sem::AttrValue> const&)>(&org::sem::AttrGroup::setPositionalAttr),
                                   std::make_tuple(CxxArgSpec<hstd::Vec<org::sem::AttrValue>>{"items"})));
  }
  Napi::Value getPositionalSize(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::AttrGroup::*)() const>(&org::sem::AttrGroup::getPositionalSize),
                                        std::make_tuple()));
  }
  Napi::Value getNamedSize(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::AttrGroup::*)() const>(&org::sem::AttrGroup::getNamedSize),
                                        std::make_tuple()));
  }
  Napi::Value isEmpty(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::AttrGroup::*)() const>(&org::sem::AttrGroup::isEmpty),
                                        std::make_tuple()));
  }
  Napi::Value getAll(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrList(org::sem::AttrGroup::*)() const>(&org::sem::AttrGroup::getAll),
                                        std::make_tuple()));
  }
  Napi::Value atPositional(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrValue const&(org::sem::AttrGroup::*)(int) const>(&org::sem::AttrGroup::atPositional),
                                        std::make_tuple(CxxArgSpec<int>{"index"})));
  }
  Napi::Value getPositional(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::AttrGroup::*)(int) const>(&org::sem::AttrGroup::getPositional),
                                        std::make_tuple(CxxArgSpec<int>{"index"})));
  }
  Napi::Value atNamed(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrList const&(org::sem::AttrGroup::*)(hstd::Str const&) const>(&org::sem::AttrGroup::atNamed),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"index"})));
  }
  Napi::Value getNamed(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrList>(org::sem::AttrGroup::*)(hstd::Str const&) const>(&org::sem::AttrGroup::getNamed),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"index"})));
  }
  Napi::Value atFirstNamed(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrValue const&(org::sem::AttrGroup::*)(hstd::Str const&) const>(&org::sem::AttrGroup::atFirstNamed),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"index"})));
  }
  Napi::Value getFirstNamed(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::AttrGroup::*)(hstd::Str const&) const>(&org::sem::AttrGroup::getFirstNamed),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"index"})));
  }
  Napi::Value atVarNamed(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrList(org::sem::AttrGroup::*)(hstd::Str const&) const>(&org::sem::AttrGroup::atVarNamed),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"index"})));
  }
  Napi::Value getVarNamed(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrList>(org::sem::AttrGroup::*)(hstd::Str const&) const>(&org::sem::AttrGroup::getVarNamed),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"index"})));
  }
  Napi::Value atFirstVarNamed(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrValue(org::sem::AttrGroup::*)(hstd::Str const&) const>(&org::sem::AttrGroup::atFirstVarNamed),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"index"})));
  }
  Napi::Value getFirstVarNamed(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::AttrGroup::*)(hstd::Str const&) const>(&org::sem::AttrGroup::getFirstVarNamed),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"index"})));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::AttrGroup::*)(org::sem::AttrGroup const&) const>(&org::sem::AttrGroup::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::AttrGroup>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "AttrgroupJs", {InstanceMethod("getFlatArgs", &AttrgroupJs::getFlatArgs),
                                                           InstanceMethod("getAttrs", &AttrgroupJs::getAttrs),
                                                           InstanceMethod("setNamedAttr", &AttrgroupJs::setNamedAttr),
                                                           InstanceMethod("setPositionalAttr", &AttrgroupJs::setPositionalAttr),
                                                           InstanceMethod("getPositionalSize", &AttrgroupJs::getPositionalSize),
                                                           InstanceMethod("getNamedSize", &AttrgroupJs::getNamedSize),
                                                           InstanceMethod("isEmpty", &AttrgroupJs::isEmpty),
                                                           InstanceMethod("getAll", &AttrgroupJs::getAll),
                                                           InstanceMethod("atPositional", &AttrgroupJs::atPositional),
                                                           InstanceMethod("getPositional", &AttrgroupJs::getPositional),
                                                           InstanceMethod("atNamed", &AttrgroupJs::atNamed),
                                                           InstanceMethod("getNamed", &AttrgroupJs::getNamed),
                                                           InstanceMethod("atFirstNamed", &AttrgroupJs::atFirstNamed),
                                                           InstanceMethod("getFirstNamed", &AttrgroupJs::getFirstNamed),
                                                           InstanceMethod("atVarNamed", &AttrgroupJs::atVarNamed),
                                                           InstanceMethod("getVarNamed", &AttrgroupJs::getVarNamed),
                                                           InstanceMethod("atFirstVarNamed", &AttrgroupJs::atFirstVarNamed),
                                                           InstanceMethod("getFirstVarNamed", &AttrgroupJs::getFirstVarNamed),
                                                           InstanceMethod("operator==", &AttrgroupJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("AttrgroupJs", func);
    return exports;
  }
  AttrgroupJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<AttrgroupJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::AttrGroup>();
  }
  AttrgroupJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::AttrGroup> const& ptr) : Napi::ObjectWrap<AttrgroupJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::AttrGroup> _stored;
  org::sem::AttrGroup* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<AttrgroupJs> {
  using type = org::sem::AttrGroup;
};

template <>
struct org_to_js_type<org::sem::AttrGroup> {
  using type = AttrgroupJs;
};

struct OrgcodeevalinputJs : public Napi::ObjectWrap<OrgcodeevalinputJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::OrgCodeEvalInput::*)(org::sem::OrgCodeEvalInput const&) const>(&org::sem::OrgCodeEvalInput::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::OrgCodeEvalInput>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "OrgcodeevalinputJs", {InstanceMethod("operator==", &OrgcodeevalinputJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("OrgcodeevalinputJs", func);
    return exports;
  }
  OrgcodeevalinputJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<OrgcodeevalinputJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::OrgCodeEvalInput>();
  }
  OrgcodeevalinputJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::OrgCodeEvalInput> const& ptr) : Napi::ObjectWrap<OrgcodeevalinputJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::OrgCodeEvalInput> _stored;
  org::sem::OrgCodeEvalInput* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<OrgcodeevalinputJs> {
  using type = org::sem::OrgCodeEvalInput;
};

template <>
struct org_to_js_type<org::sem::OrgCodeEvalInput> {
  using type = OrgcodeevalinputJs;
};

struct OrgcodeevalinputVarJs : public Napi::ObjectWrap<OrgcodeevalinputVarJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::OrgCodeEvalInput::Var::*)(org::sem::OrgCodeEvalInput::Var const&) const>(&org::sem::OrgCodeEvalInput::Var::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::OrgCodeEvalInput::Var>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "OrgcodeevalinputVarJs", {InstanceMethod("operator==", &OrgcodeevalinputVarJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("OrgcodeevalinputVarJs", func);
    return exports;
  }
  OrgcodeevalinputVarJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<OrgcodeevalinputVarJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::OrgCodeEvalInput::Var>();
  }
  OrgcodeevalinputVarJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::OrgCodeEvalInput::Var> const& ptr) : Napi::ObjectWrap<OrgcodeevalinputVarJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::OrgCodeEvalInput::Var> _stored;
  org::sem::OrgCodeEvalInput::Var* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<OrgcodeevalinputVarJs> {
  using type = org::sem::OrgCodeEvalInput::Var;
};

template <>
struct org_to_js_type<org::sem::OrgCodeEvalInput::Var> {
  using type = OrgcodeevalinputVarJs;
};

struct OrgcodeevaloutputJs : public Napi::ObjectWrap<OrgcodeevaloutputJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::OrgCodeEvalOutput::*)(org::sem::OrgCodeEvalOutput const&) const>(&org::sem::OrgCodeEvalOutput::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::OrgCodeEvalOutput>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "OrgcodeevaloutputJs", {InstanceMethod("operator==", &OrgcodeevaloutputJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("OrgcodeevaloutputJs", func);
    return exports;
  }
  OrgcodeevaloutputJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<OrgcodeevaloutputJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::OrgCodeEvalOutput>();
  }
  OrgcodeevaloutputJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::OrgCodeEvalOutput> const& ptr) : Napi::ObjectWrap<OrgcodeevaloutputJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::OrgCodeEvalOutput> _stored;
  org::sem::OrgCodeEvalOutput* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<OrgcodeevaloutputJs> {
  using type = org::sem::OrgCodeEvalOutput;
};

template <>
struct org_to_js_type<org::sem::OrgCodeEvalOutput> {
  using type = OrgcodeevaloutputJs;
};

struct ColumnviewJs : public Napi::ObjectWrap<ColumnviewJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ColumnView::*)(org::sem::ColumnView const&) const>(&org::sem::ColumnView::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::ColumnView>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ColumnviewJs", {InstanceMethod("operator==", &ColumnviewJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ColumnviewJs", func);
    return exports;
  }
  ColumnviewJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ColumnviewJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::ColumnView>();
  }
  ColumnviewJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::ColumnView> const& ptr) : Napi::ObjectWrap<ColumnviewJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::ColumnView> _stored;
  org::sem::ColumnView* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ColumnviewJs> {
  using type = org::sem::ColumnView;
};

template <>
struct org_to_js_type<org::sem::ColumnView> {
  using type = ColumnviewJs;
};

struct ColumnviewSummaryJs : public Napi::ObjectWrap<ColumnviewSummaryJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ColumnView::Summary::*)(org::sem::ColumnView::Summary const&) const>(&org::sem::ColumnView::Summary::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::ColumnView::Summary>{"other"})));
  }
  Napi::Value isCheckboxAggregate(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ColumnView::Summary::*)() const>(&org::sem::ColumnView::Summary::isCheckboxAggregate),
                                        std::make_tuple()));
  }
  Napi::Value getCheckboxAggregateMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::ColumnView::Summary::CheckboxAggregate&(org::sem::ColumnView::Summary::*)()>(&org::sem::ColumnView::Summary::getCheckboxAggregate),
                                   std::make_tuple()));
  }
  Napi::Value isMathAggregate(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ColumnView::Summary::*)() const>(&org::sem::ColumnView::Summary::isMathAggregate),
                                        std::make_tuple()));
  }
  Napi::Value getMathAggregateMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::ColumnView::Summary::MathAggregate&(org::sem::ColumnView::Summary::*)()>(&org::sem::ColumnView::Summary::getMathAggregate),
                                   std::make_tuple()));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::ColumnView::Summary::Kind(org::sem::ColumnView::Summary::*)() const>(&org::sem::ColumnView::Summary::getKind),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_name(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<char const*(org::sem::ColumnView::Summary::*)() const>(&org::sem::ColumnView::Summary::sub_variant_get_name),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_data(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::ColumnView::Summary::Data const&(org::sem::ColumnView::Summary::*)() const>(&org::sem::ColumnView::Summary::sub_variant_get_data),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_kind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::ColumnView::Summary::Kind(org::sem::ColumnView::Summary::*)() const>(&org::sem::ColumnView::Summary::sub_variant_get_kind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ColumnviewSummaryJs", {InstanceMethod("operator==", &ColumnviewSummaryJs::operator==),
                                                                   InstanceMethod("isCheckboxAggregate", &ColumnviewSummaryJs::isCheckboxAggregate),
                                                                   InstanceMethod("getCheckboxAggregateMut", &ColumnviewSummaryJs::getCheckboxAggregateMut),
                                                                   InstanceMethod("isMathAggregate", &ColumnviewSummaryJs::isMathAggregate),
                                                                   InstanceMethod("getMathAggregateMut", &ColumnviewSummaryJs::getMathAggregateMut),
                                                                   InstanceMethod("getKind", &ColumnviewSummaryJs::getKind),
                                                                   InstanceMethod("sub_variant_get_name", &ColumnviewSummaryJs::sub_variant_get_name),
                                                                   InstanceMethod("sub_variant_get_data", &ColumnviewSummaryJs::sub_variant_get_data),
                                                                   InstanceMethod("sub_variant_get_kind", &ColumnviewSummaryJs::sub_variant_get_kind)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ColumnviewSummaryJs", func);
    return exports;
  }
  ColumnviewSummaryJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ColumnviewSummaryJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::ColumnView::Summary>();
  }
  ColumnviewSummaryJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::ColumnView::Summary> const& ptr) : Napi::ObjectWrap<ColumnviewSummaryJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::ColumnView::Summary> _stored;
  org::sem::ColumnView::Summary* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ColumnviewSummaryJs> {
  using type = org::sem::ColumnView::Summary;
};

template <>
struct org_to_js_type<org::sem::ColumnView::Summary> {
  using type = ColumnviewSummaryJs;
};

struct ColumnviewSummaryCheckboxaggregateJs : public Napi::ObjectWrap<ColumnviewSummaryCheckboxaggregateJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ColumnView::Summary::CheckboxAggregate::*)(org::sem::ColumnView::Summary::CheckboxAggregate const&) const>(&org::sem::ColumnView::Summary::CheckboxAggregate::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::ColumnView::Summary::CheckboxAggregate>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ColumnviewSummaryCheckboxaggregateJs", {InstanceMethod("operator==", &ColumnviewSummaryCheckboxaggregateJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ColumnviewSummaryCheckboxaggregateJs", func);
    return exports;
  }
  ColumnviewSummaryCheckboxaggregateJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ColumnviewSummaryCheckboxaggregateJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::ColumnView::Summary::CheckboxAggregate>();
  }
  ColumnviewSummaryCheckboxaggregateJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::ColumnView::Summary::CheckboxAggregate> const& ptr) : Napi::ObjectWrap<ColumnviewSummaryCheckboxaggregateJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::ColumnView::Summary::CheckboxAggregate> _stored;
  org::sem::ColumnView::Summary::CheckboxAggregate* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ColumnviewSummaryCheckboxaggregateJs> {
  using type = org::sem::ColumnView::Summary::CheckboxAggregate;
};

template <>
struct org_to_js_type<org::sem::ColumnView::Summary::CheckboxAggregate> {
  using type = ColumnviewSummaryCheckboxaggregateJs;
};

struct ColumnviewSummaryMathaggregateJs : public Napi::ObjectWrap<ColumnviewSummaryMathaggregateJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ColumnView::Summary::MathAggregate::*)(org::sem::ColumnView::Summary::MathAggregate const&) const>(&org::sem::ColumnView::Summary::MathAggregate::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::ColumnView::Summary::MathAggregate>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ColumnviewSummaryMathaggregateJs", {InstanceMethod("operator==", &ColumnviewSummaryMathaggregateJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ColumnviewSummaryMathaggregateJs", func);
    return exports;
  }
  ColumnviewSummaryMathaggregateJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ColumnviewSummaryMathaggregateJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::ColumnView::Summary::MathAggregate>();
  }
  ColumnviewSummaryMathaggregateJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::ColumnView::Summary::MathAggregate> const& ptr) : Napi::ObjectWrap<ColumnviewSummaryMathaggregateJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::ColumnView::Summary::MathAggregate> _stored;
  org::sem::ColumnView::Summary::MathAggregate* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ColumnviewSummaryMathaggregateJs> {
  using type = org::sem::ColumnView::Summary::MathAggregate;
};

template <>
struct org_to_js_type<org::sem::ColumnView::Summary::MathAggregate> {
  using type = ColumnviewSummaryMathaggregateJs;
};

struct ColumnviewColumnJs : public Napi::ObjectWrap<ColumnviewColumnJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ColumnView::Column::*)(org::sem::ColumnView::Column const&) const>(&org::sem::ColumnView::Column::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::ColumnView::Column>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ColumnviewColumnJs", {InstanceMethod("operator==", &ColumnviewColumnJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ColumnviewColumnJs", func);
    return exports;
  }
  ColumnviewColumnJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ColumnviewColumnJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::ColumnView::Column>();
  }
  ColumnviewColumnJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::ColumnView::Column> const& ptr) : Napi::ObjectWrap<ColumnviewColumnJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::ColumnView::Column> _stored;
  org::sem::ColumnView::Column* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ColumnviewColumnJs> {
  using type = org::sem::ColumnView::Column;
};

template <>
struct org_to_js_type<org::sem::ColumnView::Column> {
  using type = ColumnviewColumnJs;
};

struct BlockcodelineJs : public Napi::ObjectWrap<BlockcodelineJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockCodeLine::*)(org::sem::BlockCodeLine const&) const>(&org::sem::BlockCodeLine::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::BlockCodeLine>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "BlockcodelineJs", {InstanceMethod("operator==", &BlockcodelineJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("BlockcodelineJs", func);
    return exports;
  }
  BlockcodelineJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<BlockcodelineJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::BlockCodeLine>();
  }
  BlockcodelineJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::BlockCodeLine> const& ptr) : Napi::ObjectWrap<BlockcodelineJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::BlockCodeLine> _stored;
  org::sem::BlockCodeLine* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<BlockcodelineJs> {
  using type = org::sem::BlockCodeLine;
};

template <>
struct org_to_js_type<org::sem::BlockCodeLine> {
  using type = BlockcodelineJs;
};

struct BlockcodelinePartJs : public Napi::ObjectWrap<BlockcodelinePartJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockCodeLine::Part::*)(org::sem::BlockCodeLine::Part const&) const>(&org::sem::BlockCodeLine::Part::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::BlockCodeLine::Part>{"other"})));
  }
  Napi::Value isRaw(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockCodeLine::Part::*)() const>(&org::sem::BlockCodeLine::Part::isRaw),
                                        std::make_tuple()));
  }
  Napi::Value getRawMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::BlockCodeLine::Part::Raw&(org::sem::BlockCodeLine::Part::*)()>(&org::sem::BlockCodeLine::Part::getRaw),
                                   std::make_tuple()));
  }
  Napi::Value isCallout(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockCodeLine::Part::*)() const>(&org::sem::BlockCodeLine::Part::isCallout),
                                        std::make_tuple()));
  }
  Napi::Value getCalloutMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::BlockCodeLine::Part::Callout&(org::sem::BlockCodeLine::Part::*)()>(&org::sem::BlockCodeLine::Part::getCallout),
                                   std::make_tuple()));
  }
  Napi::Value isTangle(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockCodeLine::Part::*)() const>(&org::sem::BlockCodeLine::Part::isTangle),
                                        std::make_tuple()));
  }
  Napi::Value getTangleMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::BlockCodeLine::Part::Tangle&(org::sem::BlockCodeLine::Part::*)()>(&org::sem::BlockCodeLine::Part::getTangle),
                                   std::make_tuple()));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::BlockCodeLine::Part::Kind(org::sem::BlockCodeLine::Part::*)() const>(&org::sem::BlockCodeLine::Part::getKind),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_name(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<char const*(org::sem::BlockCodeLine::Part::*)() const>(&org::sem::BlockCodeLine::Part::sub_variant_get_name),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_data(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::BlockCodeLine::Part::Data const&(org::sem::BlockCodeLine::Part::*)() const>(&org::sem::BlockCodeLine::Part::sub_variant_get_data),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_kind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::BlockCodeLine::Part::Kind(org::sem::BlockCodeLine::Part::*)() const>(&org::sem::BlockCodeLine::Part::sub_variant_get_kind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "BlockcodelinePartJs", {InstanceMethod("operator==", &BlockcodelinePartJs::operator==),
                                                                   InstanceMethod("isRaw", &BlockcodelinePartJs::isRaw),
                                                                   InstanceMethod("getRawMut", &BlockcodelinePartJs::getRawMut),
                                                                   InstanceMethod("isCallout", &BlockcodelinePartJs::isCallout),
                                                                   InstanceMethod("getCalloutMut", &BlockcodelinePartJs::getCalloutMut),
                                                                   InstanceMethod("isTangle", &BlockcodelinePartJs::isTangle),
                                                                   InstanceMethod("getTangleMut", &BlockcodelinePartJs::getTangleMut),
                                                                   InstanceMethod("getKind", &BlockcodelinePartJs::getKind),
                                                                   InstanceMethod("sub_variant_get_name", &BlockcodelinePartJs::sub_variant_get_name),
                                                                   InstanceMethod("sub_variant_get_data", &BlockcodelinePartJs::sub_variant_get_data),
                                                                   InstanceMethod("sub_variant_get_kind", &BlockcodelinePartJs::sub_variant_get_kind)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("BlockcodelinePartJs", func);
    return exports;
  }
  BlockcodelinePartJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<BlockcodelinePartJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::BlockCodeLine::Part>();
  }
  BlockcodelinePartJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::BlockCodeLine::Part> const& ptr) : Napi::ObjectWrap<BlockcodelinePartJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::BlockCodeLine::Part> _stored;
  org::sem::BlockCodeLine::Part* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<BlockcodelinePartJs> {
  using type = org::sem::BlockCodeLine::Part;
};

template <>
struct org_to_js_type<org::sem::BlockCodeLine::Part> {
  using type = BlockcodelinePartJs;
};

struct BlockcodelinePartRawJs : public Napi::ObjectWrap<BlockcodelinePartRawJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockCodeLine::Part::Raw::*)(org::sem::BlockCodeLine::Part::Raw const&) const>(&org::sem::BlockCodeLine::Part::Raw::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::BlockCodeLine::Part::Raw>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "BlockcodelinePartRawJs", {InstanceMethod("operator==", &BlockcodelinePartRawJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("BlockcodelinePartRawJs", func);
    return exports;
  }
  BlockcodelinePartRawJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<BlockcodelinePartRawJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::BlockCodeLine::Part::Raw>();
  }
  BlockcodelinePartRawJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::BlockCodeLine::Part::Raw> const& ptr) : Napi::ObjectWrap<BlockcodelinePartRawJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::BlockCodeLine::Part::Raw> _stored;
  org::sem::BlockCodeLine::Part::Raw* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<BlockcodelinePartRawJs> {
  using type = org::sem::BlockCodeLine::Part::Raw;
};

template <>
struct org_to_js_type<org::sem::BlockCodeLine::Part::Raw> {
  using type = BlockcodelinePartRawJs;
};

struct BlockcodelinePartCalloutJs : public Napi::ObjectWrap<BlockcodelinePartCalloutJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockCodeLine::Part::Callout::*)(org::sem::BlockCodeLine::Part::Callout const&) const>(&org::sem::BlockCodeLine::Part::Callout::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::BlockCodeLine::Part::Callout>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "BlockcodelinePartCalloutJs", {InstanceMethod("operator==", &BlockcodelinePartCalloutJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("BlockcodelinePartCalloutJs", func);
    return exports;
  }
  BlockcodelinePartCalloutJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<BlockcodelinePartCalloutJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::BlockCodeLine::Part::Callout>();
  }
  BlockcodelinePartCalloutJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::BlockCodeLine::Part::Callout> const& ptr) : Napi::ObjectWrap<BlockcodelinePartCalloutJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::BlockCodeLine::Part::Callout> _stored;
  org::sem::BlockCodeLine::Part::Callout* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<BlockcodelinePartCalloutJs> {
  using type = org::sem::BlockCodeLine::Part::Callout;
};

template <>
struct org_to_js_type<org::sem::BlockCodeLine::Part::Callout> {
  using type = BlockcodelinePartCalloutJs;
};

struct BlockcodelinePartTangleJs : public Napi::ObjectWrap<BlockcodelinePartTangleJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockCodeLine::Part::Tangle::*)(org::sem::BlockCodeLine::Part::Tangle const&) const>(&org::sem::BlockCodeLine::Part::Tangle::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::BlockCodeLine::Part::Tangle>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "BlockcodelinePartTangleJs", {InstanceMethod("operator==", &BlockcodelinePartTangleJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("BlockcodelinePartTangleJs", func);
    return exports;
  }
  BlockcodelinePartTangleJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<BlockcodelinePartTangleJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::BlockCodeLine::Part::Tangle>();
  }
  BlockcodelinePartTangleJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::BlockCodeLine::Part::Tangle> const& ptr) : Napi::ObjectWrap<BlockcodelinePartTangleJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::BlockCodeLine::Part::Tangle> _stored;
  org::sem::BlockCodeLine::Part::Tangle* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<BlockcodelinePartTangleJs> {
  using type = org::sem::BlockCodeLine::Part::Tangle;
};

template <>
struct org_to_js_type<org::sem::BlockCodeLine::Part::Tangle> {
  using type = BlockcodelinePartTangleJs;
};

struct DocumentexportconfigJs : public Napi::ObjectWrap<DocumentexportconfigJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::DocumentExportConfig::*)(org::sem::DocumentExportConfig const&) const>(&org::sem::DocumentExportConfig::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::DocumentExportConfig>{"other"})));
  }
  Napi::Value isDoExport(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::DocumentExportConfig::*)() const>(&org::sem::DocumentExportConfig::isDoExport),
                                        std::make_tuple()));
  }
  Napi::Value getDoExportMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::DocumentExportConfig::DoExport&(org::sem::DocumentExportConfig::*)()>(&org::sem::DocumentExportConfig::getDoExport),
                                   std::make_tuple()));
  }
  Napi::Value isExportFixed(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::DocumentExportConfig::*)() const>(&org::sem::DocumentExportConfig::isExportFixed),
                                        std::make_tuple()));
  }
  Napi::Value getExportFixedMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::DocumentExportConfig::ExportFixed&(org::sem::DocumentExportConfig::*)()>(&org::sem::DocumentExportConfig::getExportFixed),
                                   std::make_tuple()));
  }
  Napi::Value getTocExportKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::DocumentExportConfig::TocExportKind(org::sem::DocumentExportConfig::*)() const>(&org::sem::DocumentExportConfig::getTocExportKind),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_name(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<char const*(org::sem::DocumentExportConfig::*)() const>(&org::sem::DocumentExportConfig::sub_variant_get_name),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_data(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::DocumentExportConfig::TocExport const&(org::sem::DocumentExportConfig::*)() const>(&org::sem::DocumentExportConfig::sub_variant_get_data),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_kind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::DocumentExportConfig::TocExportKind(org::sem::DocumentExportConfig::*)() const>(&org::sem::DocumentExportConfig::sub_variant_get_kind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "DocumentexportconfigJs", {InstanceMethod("operator==", &DocumentexportconfigJs::operator==),
                                                                      InstanceMethod("isDoExport", &DocumentexportconfigJs::isDoExport),
                                                                      InstanceMethod("getDoExportMut", &DocumentexportconfigJs::getDoExportMut),
                                                                      InstanceMethod("isExportFixed", &DocumentexportconfigJs::isExportFixed),
                                                                      InstanceMethod("getExportFixedMut", &DocumentexportconfigJs::getExportFixedMut),
                                                                      InstanceMethod("getTocExportKind", &DocumentexportconfigJs::getTocExportKind),
                                                                      InstanceMethod("sub_variant_get_name", &DocumentexportconfigJs::sub_variant_get_name),
                                                                      InstanceMethod("sub_variant_get_data", &DocumentexportconfigJs::sub_variant_get_data),
                                                                      InstanceMethod("sub_variant_get_kind", &DocumentexportconfigJs::sub_variant_get_kind)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("DocumentexportconfigJs", func);
    return exports;
  }
  DocumentexportconfigJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<DocumentexportconfigJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::DocumentExportConfig>();
  }
  DocumentexportconfigJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::DocumentExportConfig> const& ptr) : Napi::ObjectWrap<DocumentexportconfigJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::DocumentExportConfig> _stored;
  org::sem::DocumentExportConfig* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<DocumentexportconfigJs> {
  using type = org::sem::DocumentExportConfig;
};

template <>
struct org_to_js_type<org::sem::DocumentExportConfig> {
  using type = DocumentexportconfigJs;
};

struct DocumentexportconfigTaskexportJs : public Napi::ObjectWrap<DocumentexportconfigTaskexportJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::DocumentExportConfig::TaskExport::*)(org::sem::DocumentExportConfig::TaskExport const&) const>(&org::sem::DocumentExportConfig::TaskExport::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::DocumentExportConfig::TaskExport>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "DocumentexportconfigTaskexportJs", {InstanceMethod("operator==", &DocumentexportconfigTaskexportJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("DocumentexportconfigTaskexportJs", func);
    return exports;
  }
  DocumentexportconfigTaskexportJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<DocumentexportconfigTaskexportJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::DocumentExportConfig::TaskExport>();
  }
  DocumentexportconfigTaskexportJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::DocumentExportConfig::TaskExport> const& ptr) : Napi::ObjectWrap<DocumentexportconfigTaskexportJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::DocumentExportConfig::TaskExport> _stored;
  org::sem::DocumentExportConfig::TaskExport* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<DocumentexportconfigTaskexportJs> {
  using type = org::sem::DocumentExportConfig::TaskExport;
};

template <>
struct org_to_js_type<org::sem::DocumentExportConfig::TaskExport> {
  using type = DocumentexportconfigTaskexportJs;
};

struct DocumentexportconfigDoexportJs : public Napi::ObjectWrap<DocumentexportconfigDoexportJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::DocumentExportConfig::DoExport::*)(org::sem::DocumentExportConfig::DoExport const&) const>(&org::sem::DocumentExportConfig::DoExport::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::DocumentExportConfig::DoExport>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "DocumentexportconfigDoexportJs", {InstanceMethod("operator==", &DocumentexportconfigDoexportJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("DocumentexportconfigDoexportJs", func);
    return exports;
  }
  DocumentexportconfigDoexportJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<DocumentexportconfigDoexportJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::DocumentExportConfig::DoExport>();
  }
  DocumentexportconfigDoexportJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::DocumentExportConfig::DoExport> const& ptr) : Napi::ObjectWrap<DocumentexportconfigDoexportJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::DocumentExportConfig::DoExport> _stored;
  org::sem::DocumentExportConfig::DoExport* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<DocumentexportconfigDoexportJs> {
  using type = org::sem::DocumentExportConfig::DoExport;
};

template <>
struct org_to_js_type<org::sem::DocumentExportConfig::DoExport> {
  using type = DocumentexportconfigDoexportJs;
};

struct DocumentexportconfigExportfixedJs : public Napi::ObjectWrap<DocumentexportconfigExportfixedJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::DocumentExportConfig::ExportFixed::*)(org::sem::DocumentExportConfig::ExportFixed const&) const>(&org::sem::DocumentExportConfig::ExportFixed::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::DocumentExportConfig::ExportFixed>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "DocumentexportconfigExportfixedJs", {InstanceMethod("operator==", &DocumentexportconfigExportfixedJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("DocumentexportconfigExportfixedJs", func);
    return exports;
  }
  DocumentexportconfigExportfixedJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<DocumentexportconfigExportfixedJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::DocumentExportConfig::ExportFixed>();
  }
  DocumentexportconfigExportfixedJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::DocumentExportConfig::ExportFixed> const& ptr) : Napi::ObjectWrap<DocumentexportconfigExportfixedJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::DocumentExportConfig::ExportFixed> _stored;
  org::sem::DocumentExportConfig::ExportFixed* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<DocumentexportconfigExportfixedJs> {
  using type = org::sem::DocumentExportConfig::ExportFixed;
};

template <>
struct org_to_js_type<org::sem::DocumentExportConfig::ExportFixed> {
  using type = DocumentexportconfigExportfixedJs;
};

struct SubtreeperiodJs : public Napi::ObjectWrap<SubtreeperiodJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreePeriod::*)(org::sem::SubtreePeriod const&) const>(&org::sem::SubtreePeriod::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::SubtreePeriod>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "SubtreeperiodJs", {InstanceMethod("operator==", &SubtreeperiodJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("SubtreeperiodJs", func);
    return exports;
  }
  SubtreeperiodJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<SubtreeperiodJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::SubtreePeriod>();
  }
  SubtreeperiodJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::SubtreePeriod> const& ptr) : Napi::ObjectWrap<SubtreeperiodJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::SubtreePeriod> _stored;
  org::sem::SubtreePeriod* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<SubtreeperiodJs> {
  using type = org::sem::SubtreePeriod;
};

template <>
struct org_to_js_type<org::sem::SubtreePeriod> {
  using type = SubtreeperiodJs;
};

struct NamedpropertyJs : public Napi::ObjectWrap<NamedpropertyJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value isMatching(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)(hstd::Str const&, hstd::Opt<hstd::Str> const&) const>(&org::sem::NamedProperty::isMatching),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"},
                                                        CxxArgSpec<hstd::Opt<hstd::Str>>{"subKind", std::nullopt})));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Str(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::getName),
                                        std::make_tuple()));
  }
  Napi::Value getSubKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<hstd::Str>(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::getSubKind),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)(org::sem::NamedProperty const&) const>(&org::sem::NamedProperty::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty>{"other"})));
  }
  Napi::Value isNonblocking(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isNonblocking),
                                        std::make_tuple()));
  }
  Napi::Value getNonblockingMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::Nonblocking&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getNonblocking),
                                   std::make_tuple()));
  }
  Napi::Value isArchiveTime(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isArchiveTime),
                                        std::make_tuple()));
  }
  Napi::Value getArchiveTimeMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::ArchiveTime&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getArchiveTime),
                                   std::make_tuple()));
  }
  Napi::Value isArchiveFile(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isArchiveFile),
                                        std::make_tuple()));
  }
  Napi::Value getArchiveFileMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::ArchiveFile&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getArchiveFile),
                                   std::make_tuple()));
  }
  Napi::Value isArchiveOlpath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isArchiveOlpath),
                                        std::make_tuple()));
  }
  Napi::Value getArchiveOlpathMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::ArchiveOlpath&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getArchiveOlpath),
                                   std::make_tuple()));
  }
  Napi::Value isArchiveTarget(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isArchiveTarget),
                                        std::make_tuple()));
  }
  Napi::Value getArchiveTargetMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::ArchiveTarget&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getArchiveTarget),
                                   std::make_tuple()));
  }
  Napi::Value isArchiveCategory(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isArchiveCategory),
                                        std::make_tuple()));
  }
  Napi::Value getArchiveCategoryMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::ArchiveCategory&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getArchiveCategory),
                                   std::make_tuple()));
  }
  Napi::Value isArchiveTodo(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isArchiveTodo),
                                        std::make_tuple()));
  }
  Napi::Value getArchiveTodoMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::ArchiveTodo&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getArchiveTodo),
                                   std::make_tuple()));
  }
  Napi::Value isTrigger(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isTrigger),
                                        std::make_tuple()));
  }
  Napi::Value getTriggerMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::Trigger&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getTrigger),
                                   std::make_tuple()));
  }
  Napi::Value isExportLatexClass(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isExportLatexClass),
                                        std::make_tuple()));
  }
  Napi::Value getExportLatexClassMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::ExportLatexClass&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getExportLatexClass),
                                   std::make_tuple()));
  }
  Napi::Value isCookieData(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isCookieData),
                                        std::make_tuple()));
  }
  Napi::Value getCookieDataMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::CookieData&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getCookieData),
                                   std::make_tuple()));
  }
  Napi::Value isExportLatexClassOptions(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isExportLatexClassOptions),
                                        std::make_tuple()));
  }
  Napi::Value getExportLatexClassOptionsMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::ExportLatexClassOptions&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getExportLatexClassOptions),
                                   std::make_tuple()));
  }
  Napi::Value isExportLatexHeader(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isExportLatexHeader),
                                        std::make_tuple()));
  }
  Napi::Value getExportLatexHeaderMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::ExportLatexHeader&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getExportLatexHeader),
                                   std::make_tuple()));
  }
  Napi::Value isExportLatexCompiler(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isExportLatexCompiler),
                                        std::make_tuple()));
  }
  Napi::Value getExportLatexCompilerMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::ExportLatexCompiler&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getExportLatexCompiler),
                                   std::make_tuple()));
  }
  Napi::Value isOrdered(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isOrdered),
                                        std::make_tuple()));
  }
  Napi::Value getOrderedMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::Ordered&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getOrdered),
                                   std::make_tuple()));
  }
  Napi::Value isEffort(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isEffort),
                                        std::make_tuple()));
  }
  Napi::Value getEffortMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::Effort&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getEffort),
                                   std::make_tuple()));
  }
  Napi::Value isVisibility(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isVisibility),
                                        std::make_tuple()));
  }
  Napi::Value getVisibilityMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::Visibility&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getVisibility),
                                   std::make_tuple()));
  }
  Napi::Value isExportOptions(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isExportOptions),
                                        std::make_tuple()));
  }
  Napi::Value getExportOptionsMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::ExportOptions&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getExportOptions),
                                   std::make_tuple()));
  }
  Napi::Value isBlocker(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isBlocker),
                                        std::make_tuple()));
  }
  Napi::Value getBlockerMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::Blocker&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getBlocker),
                                   std::make_tuple()));
  }
  Napi::Value isUnnumbered(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isUnnumbered),
                                        std::make_tuple()));
  }
  Napi::Value getUnnumberedMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::Unnumbered&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getUnnumbered),
                                   std::make_tuple()));
  }
  Napi::Value isCreated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isCreated),
                                        std::make_tuple()));
  }
  Napi::Value getCreatedMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::Created&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getCreated),
                                   std::make_tuple()));
  }
  Napi::Value isRadioId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isRadioId),
                                        std::make_tuple()));
  }
  Napi::Value getRadioIdMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::RadioId&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getRadioId),
                                   std::make_tuple()));
  }
  Napi::Value isHashtagDef(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isHashtagDef),
                                        std::make_tuple()));
  }
  Napi::Value getHashtagDefMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::HashtagDef&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getHashtagDef),
                                   std::make_tuple()));
  }
  Napi::Value isCustomArgs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isCustomArgs),
                                        std::make_tuple()));
  }
  Napi::Value getCustomArgsMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::CustomArgs&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getCustomArgs),
                                   std::make_tuple()));
  }
  Napi::Value isCustomRaw(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isCustomRaw),
                                        std::make_tuple()));
  }
  Napi::Value getCustomRawMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::CustomRaw&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getCustomRaw),
                                   std::make_tuple()));
  }
  Napi::Value isCustomSubtreeJson(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isCustomSubtreeJson),
                                        std::make_tuple()));
  }
  Napi::Value getCustomSubtreeJsonMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::CustomSubtreeJson&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getCustomSubtreeJson),
                                   std::make_tuple()));
  }
  Napi::Value isCustomSubtreeFlags(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isCustomSubtreeFlags),
                                        std::make_tuple()));
  }
  Napi::Value getCustomSubtreeFlagsMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::CustomSubtreeFlags&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getCustomSubtreeFlags),
                                   std::make_tuple()));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::NamedProperty::Kind(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::getKind),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_name(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<char const*(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::sub_variant_get_name),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_data(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::NamedProperty::Data const&(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::sub_variant_get_data),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_kind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::NamedProperty::Kind(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::sub_variant_get_kind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "NamedpropertyJs", {InstanceMethod("isMatching", &NamedpropertyJs::isMatching),
                                                               InstanceMethod("getName", &NamedpropertyJs::getName),
                                                               InstanceMethod("getSubKind", &NamedpropertyJs::getSubKind),
                                                               InstanceMethod("operator==", &NamedpropertyJs::operator==),
                                                               InstanceMethod("isNonblocking", &NamedpropertyJs::isNonblocking),
                                                               InstanceMethod("getNonblockingMut", &NamedpropertyJs::getNonblockingMut),
                                                               InstanceMethod("isArchiveTime", &NamedpropertyJs::isArchiveTime),
                                                               InstanceMethod("getArchiveTimeMut", &NamedpropertyJs::getArchiveTimeMut),
                                                               InstanceMethod("isArchiveFile", &NamedpropertyJs::isArchiveFile),
                                                               InstanceMethod("getArchiveFileMut", &NamedpropertyJs::getArchiveFileMut),
                                                               InstanceMethod("isArchiveOlpath", &NamedpropertyJs::isArchiveOlpath),
                                                               InstanceMethod("getArchiveOlpathMut", &NamedpropertyJs::getArchiveOlpathMut),
                                                               InstanceMethod("isArchiveTarget", &NamedpropertyJs::isArchiveTarget),
                                                               InstanceMethod("getArchiveTargetMut", &NamedpropertyJs::getArchiveTargetMut),
                                                               InstanceMethod("isArchiveCategory", &NamedpropertyJs::isArchiveCategory),
                                                               InstanceMethod("getArchiveCategoryMut", &NamedpropertyJs::getArchiveCategoryMut),
                                                               InstanceMethod("isArchiveTodo", &NamedpropertyJs::isArchiveTodo),
                                                               InstanceMethod("getArchiveTodoMut", &NamedpropertyJs::getArchiveTodoMut),
                                                               InstanceMethod("isTrigger", &NamedpropertyJs::isTrigger),
                                                               InstanceMethod("getTriggerMut", &NamedpropertyJs::getTriggerMut),
                                                               InstanceMethod("isExportLatexClass", &NamedpropertyJs::isExportLatexClass),
                                                               InstanceMethod("getExportLatexClassMut", &NamedpropertyJs::getExportLatexClassMut),
                                                               InstanceMethod("isCookieData", &NamedpropertyJs::isCookieData),
                                                               InstanceMethod("getCookieDataMut", &NamedpropertyJs::getCookieDataMut),
                                                               InstanceMethod("isExportLatexClassOptions", &NamedpropertyJs::isExportLatexClassOptions),
                                                               InstanceMethod("getExportLatexClassOptionsMut", &NamedpropertyJs::getExportLatexClassOptionsMut),
                                                               InstanceMethod("isExportLatexHeader", &NamedpropertyJs::isExportLatexHeader),
                                                               InstanceMethod("getExportLatexHeaderMut", &NamedpropertyJs::getExportLatexHeaderMut),
                                                               InstanceMethod("isExportLatexCompiler", &NamedpropertyJs::isExportLatexCompiler),
                                                               InstanceMethod("getExportLatexCompilerMut", &NamedpropertyJs::getExportLatexCompilerMut),
                                                               InstanceMethod("isOrdered", &NamedpropertyJs::isOrdered),
                                                               InstanceMethod("getOrderedMut", &NamedpropertyJs::getOrderedMut),
                                                               InstanceMethod("isEffort", &NamedpropertyJs::isEffort),
                                                               InstanceMethod("getEffortMut", &NamedpropertyJs::getEffortMut),
                                                               InstanceMethod("isVisibility", &NamedpropertyJs::isVisibility),
                                                               InstanceMethod("getVisibilityMut", &NamedpropertyJs::getVisibilityMut),
                                                               InstanceMethod("isExportOptions", &NamedpropertyJs::isExportOptions),
                                                               InstanceMethod("getExportOptionsMut", &NamedpropertyJs::getExportOptionsMut),
                                                               InstanceMethod("isBlocker", &NamedpropertyJs::isBlocker),
                                                               InstanceMethod("getBlockerMut", &NamedpropertyJs::getBlockerMut),
                                                               InstanceMethod("isUnnumbered", &NamedpropertyJs::isUnnumbered),
                                                               InstanceMethod("getUnnumberedMut", &NamedpropertyJs::getUnnumberedMut),
                                                               InstanceMethod("isCreated", &NamedpropertyJs::isCreated),
                                                               InstanceMethod("getCreatedMut", &NamedpropertyJs::getCreatedMut),
                                                               InstanceMethod("isRadioId", &NamedpropertyJs::isRadioId),
                                                               InstanceMethod("getRadioIdMut", &NamedpropertyJs::getRadioIdMut),
                                                               InstanceMethod("isHashtagDef", &NamedpropertyJs::isHashtagDef),
                                                               InstanceMethod("getHashtagDefMut", &NamedpropertyJs::getHashtagDefMut),
                                                               InstanceMethod("isCustomArgs", &NamedpropertyJs::isCustomArgs),
                                                               InstanceMethod("getCustomArgsMut", &NamedpropertyJs::getCustomArgsMut),
                                                               InstanceMethod("isCustomRaw", &NamedpropertyJs::isCustomRaw),
                                                               InstanceMethod("getCustomRawMut", &NamedpropertyJs::getCustomRawMut),
                                                               InstanceMethod("isCustomSubtreeJson", &NamedpropertyJs::isCustomSubtreeJson),
                                                               InstanceMethod("getCustomSubtreeJsonMut", &NamedpropertyJs::getCustomSubtreeJsonMut),
                                                               InstanceMethod("isCustomSubtreeFlags", &NamedpropertyJs::isCustomSubtreeFlags),
                                                               InstanceMethod("getCustomSubtreeFlagsMut", &NamedpropertyJs::getCustomSubtreeFlagsMut),
                                                               InstanceMethod("getKind", &NamedpropertyJs::getKind),
                                                               InstanceMethod("sub_variant_get_name", &NamedpropertyJs::sub_variant_get_name),
                                                               InstanceMethod("sub_variant_get_data", &NamedpropertyJs::sub_variant_get_data),
                                                               InstanceMethod("sub_variant_get_kind", &NamedpropertyJs::sub_variant_get_kind)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("NamedpropertyJs", func);
    return exports;
  }
  NamedpropertyJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<NamedpropertyJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::NamedProperty>();
  }
  NamedpropertyJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::NamedProperty> const& ptr) : Napi::ObjectWrap<NamedpropertyJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::NamedProperty> _stored;
  org::sem::NamedProperty* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<NamedpropertyJs> {
  using type = org::sem::NamedProperty;
};

template <>
struct org_to_js_type<org::sem::NamedProperty> {
  using type = NamedpropertyJs;
};

struct NamedpropertyNonblockingJs : public Napi::ObjectWrap<NamedpropertyNonblockingJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::Nonblocking::*)(org::sem::NamedProperty::Nonblocking const&) const>(&org::sem::NamedProperty::Nonblocking::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::Nonblocking>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "NamedpropertyNonblockingJs", {InstanceMethod("operator==", &NamedpropertyNonblockingJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("NamedpropertyNonblockingJs", func);
    return exports;
  }
  NamedpropertyNonblockingJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<NamedpropertyNonblockingJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::NamedProperty::Nonblocking>();
  }
  NamedpropertyNonblockingJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::NamedProperty::Nonblocking> const& ptr) : Napi::ObjectWrap<NamedpropertyNonblockingJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::NamedProperty::Nonblocking> _stored;
  org::sem::NamedProperty::Nonblocking* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<NamedpropertyNonblockingJs> {
  using type = org::sem::NamedProperty::Nonblocking;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::Nonblocking> {
  using type = NamedpropertyNonblockingJs;
};

struct NamedpropertyArchivetimeJs : public Napi::ObjectWrap<NamedpropertyArchivetimeJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::ArchiveTime::*)(org::sem::NamedProperty::ArchiveTime const&) const>(&org::sem::NamedProperty::ArchiveTime::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::ArchiveTime>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "NamedpropertyArchivetimeJs", {InstanceMethod("operator==", &NamedpropertyArchivetimeJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("NamedpropertyArchivetimeJs", func);
    return exports;
  }
  NamedpropertyArchivetimeJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<NamedpropertyArchivetimeJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::NamedProperty::ArchiveTime>();
  }
  NamedpropertyArchivetimeJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::NamedProperty::ArchiveTime> const& ptr) : Napi::ObjectWrap<NamedpropertyArchivetimeJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::NamedProperty::ArchiveTime> _stored;
  org::sem::NamedProperty::ArchiveTime* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<NamedpropertyArchivetimeJs> {
  using type = org::sem::NamedProperty::ArchiveTime;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::ArchiveTime> {
  using type = NamedpropertyArchivetimeJs;
};

struct NamedpropertyArchivefileJs : public Napi::ObjectWrap<NamedpropertyArchivefileJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::ArchiveFile::*)(org::sem::NamedProperty::ArchiveFile const&) const>(&org::sem::NamedProperty::ArchiveFile::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::ArchiveFile>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "NamedpropertyArchivefileJs", {InstanceMethod("operator==", &NamedpropertyArchivefileJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("NamedpropertyArchivefileJs", func);
    return exports;
  }
  NamedpropertyArchivefileJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<NamedpropertyArchivefileJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::NamedProperty::ArchiveFile>();
  }
  NamedpropertyArchivefileJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::NamedProperty::ArchiveFile> const& ptr) : Napi::ObjectWrap<NamedpropertyArchivefileJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::NamedProperty::ArchiveFile> _stored;
  org::sem::NamedProperty::ArchiveFile* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<NamedpropertyArchivefileJs> {
  using type = org::sem::NamedProperty::ArchiveFile;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::ArchiveFile> {
  using type = NamedpropertyArchivefileJs;
};

struct NamedpropertyArchiveolpathJs : public Napi::ObjectWrap<NamedpropertyArchiveolpathJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::ArchiveOlpath::*)(org::sem::NamedProperty::ArchiveOlpath const&) const>(&org::sem::NamedProperty::ArchiveOlpath::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::ArchiveOlpath>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "NamedpropertyArchiveolpathJs", {InstanceMethod("operator==", &NamedpropertyArchiveolpathJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("NamedpropertyArchiveolpathJs", func);
    return exports;
  }
  NamedpropertyArchiveolpathJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<NamedpropertyArchiveolpathJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::NamedProperty::ArchiveOlpath>();
  }
  NamedpropertyArchiveolpathJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::NamedProperty::ArchiveOlpath> const& ptr) : Napi::ObjectWrap<NamedpropertyArchiveolpathJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::NamedProperty::ArchiveOlpath> _stored;
  org::sem::NamedProperty::ArchiveOlpath* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<NamedpropertyArchiveolpathJs> {
  using type = org::sem::NamedProperty::ArchiveOlpath;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::ArchiveOlpath> {
  using type = NamedpropertyArchiveolpathJs;
};

struct NamedpropertyArchivetargetJs : public Napi::ObjectWrap<NamedpropertyArchivetargetJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::ArchiveTarget::*)(org::sem::NamedProperty::ArchiveTarget const&) const>(&org::sem::NamedProperty::ArchiveTarget::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::ArchiveTarget>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "NamedpropertyArchivetargetJs", {InstanceMethod("operator==", &NamedpropertyArchivetargetJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("NamedpropertyArchivetargetJs", func);
    return exports;
  }
  NamedpropertyArchivetargetJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<NamedpropertyArchivetargetJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::NamedProperty::ArchiveTarget>();
  }
  NamedpropertyArchivetargetJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::NamedProperty::ArchiveTarget> const& ptr) : Napi::ObjectWrap<NamedpropertyArchivetargetJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::NamedProperty::ArchiveTarget> _stored;
  org::sem::NamedProperty::ArchiveTarget* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<NamedpropertyArchivetargetJs> {
  using type = org::sem::NamedProperty::ArchiveTarget;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::ArchiveTarget> {
  using type = NamedpropertyArchivetargetJs;
};

struct NamedpropertyArchivecategoryJs : public Napi::ObjectWrap<NamedpropertyArchivecategoryJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::ArchiveCategory::*)(org::sem::NamedProperty::ArchiveCategory const&) const>(&org::sem::NamedProperty::ArchiveCategory::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::ArchiveCategory>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "NamedpropertyArchivecategoryJs", {InstanceMethod("operator==", &NamedpropertyArchivecategoryJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("NamedpropertyArchivecategoryJs", func);
    return exports;
  }
  NamedpropertyArchivecategoryJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<NamedpropertyArchivecategoryJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::NamedProperty::ArchiveCategory>();
  }
  NamedpropertyArchivecategoryJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::NamedProperty::ArchiveCategory> const& ptr) : Napi::ObjectWrap<NamedpropertyArchivecategoryJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::NamedProperty::ArchiveCategory> _stored;
  org::sem::NamedProperty::ArchiveCategory* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<NamedpropertyArchivecategoryJs> {
  using type = org::sem::NamedProperty::ArchiveCategory;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::ArchiveCategory> {
  using type = NamedpropertyArchivecategoryJs;
};

struct NamedpropertyArchivetodoJs : public Napi::ObjectWrap<NamedpropertyArchivetodoJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::ArchiveTodo::*)(org::sem::NamedProperty::ArchiveTodo const&) const>(&org::sem::NamedProperty::ArchiveTodo::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::ArchiveTodo>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "NamedpropertyArchivetodoJs", {InstanceMethod("operator==", &NamedpropertyArchivetodoJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("NamedpropertyArchivetodoJs", func);
    return exports;
  }
  NamedpropertyArchivetodoJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<NamedpropertyArchivetodoJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::NamedProperty::ArchiveTodo>();
  }
  NamedpropertyArchivetodoJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::NamedProperty::ArchiveTodo> const& ptr) : Napi::ObjectWrap<NamedpropertyArchivetodoJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::NamedProperty::ArchiveTodo> _stored;
  org::sem::NamedProperty::ArchiveTodo* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<NamedpropertyArchivetodoJs> {
  using type = org::sem::NamedProperty::ArchiveTodo;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::ArchiveTodo> {
  using type = NamedpropertyArchivetodoJs;
};

struct NamedpropertyTriggerJs : public Napi::ObjectWrap<NamedpropertyTriggerJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::Trigger::*)(org::sem::NamedProperty::Trigger const&) const>(&org::sem::NamedProperty::Trigger::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::Trigger>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "NamedpropertyTriggerJs", {InstanceMethod("operator==", &NamedpropertyTriggerJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("NamedpropertyTriggerJs", func);
    return exports;
  }
  NamedpropertyTriggerJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<NamedpropertyTriggerJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::NamedProperty::Trigger>();
  }
  NamedpropertyTriggerJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::NamedProperty::Trigger> const& ptr) : Napi::ObjectWrap<NamedpropertyTriggerJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::NamedProperty::Trigger> _stored;
  org::sem::NamedProperty::Trigger* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<NamedpropertyTriggerJs> {
  using type = org::sem::NamedProperty::Trigger;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::Trigger> {
  using type = NamedpropertyTriggerJs;
};

struct NamedpropertyExportlatexclassJs : public Napi::ObjectWrap<NamedpropertyExportlatexclassJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::ExportLatexClass::*)(org::sem::NamedProperty::ExportLatexClass const&) const>(&org::sem::NamedProperty::ExportLatexClass::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::ExportLatexClass>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "NamedpropertyExportlatexclassJs", {InstanceMethod("operator==", &NamedpropertyExportlatexclassJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("NamedpropertyExportlatexclassJs", func);
    return exports;
  }
  NamedpropertyExportlatexclassJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<NamedpropertyExportlatexclassJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::NamedProperty::ExportLatexClass>();
  }
  NamedpropertyExportlatexclassJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::NamedProperty::ExportLatexClass> const& ptr) : Napi::ObjectWrap<NamedpropertyExportlatexclassJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::NamedProperty::ExportLatexClass> _stored;
  org::sem::NamedProperty::ExportLatexClass* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<NamedpropertyExportlatexclassJs> {
  using type = org::sem::NamedProperty::ExportLatexClass;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::ExportLatexClass> {
  using type = NamedpropertyExportlatexclassJs;
};

struct NamedpropertyCookiedataJs : public Napi::ObjectWrap<NamedpropertyCookiedataJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::CookieData::*)(org::sem::NamedProperty::CookieData const&) const>(&org::sem::NamedProperty::CookieData::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::CookieData>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "NamedpropertyCookiedataJs", {InstanceMethod("operator==", &NamedpropertyCookiedataJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("NamedpropertyCookiedataJs", func);
    return exports;
  }
  NamedpropertyCookiedataJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<NamedpropertyCookiedataJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::NamedProperty::CookieData>();
  }
  NamedpropertyCookiedataJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::NamedProperty::CookieData> const& ptr) : Napi::ObjectWrap<NamedpropertyCookiedataJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::NamedProperty::CookieData> _stored;
  org::sem::NamedProperty::CookieData* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<NamedpropertyCookiedataJs> {
  using type = org::sem::NamedProperty::CookieData;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::CookieData> {
  using type = NamedpropertyCookiedataJs;
};

struct NamedpropertyExportlatexclassoptionsJs : public Napi::ObjectWrap<NamedpropertyExportlatexclassoptionsJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::ExportLatexClassOptions::*)(org::sem::NamedProperty::ExportLatexClassOptions const&) const>(&org::sem::NamedProperty::ExportLatexClassOptions::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::ExportLatexClassOptions>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "NamedpropertyExportlatexclassoptionsJs", {InstanceMethod("operator==", &NamedpropertyExportlatexclassoptionsJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("NamedpropertyExportlatexclassoptionsJs", func);
    return exports;
  }
  NamedpropertyExportlatexclassoptionsJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<NamedpropertyExportlatexclassoptionsJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::NamedProperty::ExportLatexClassOptions>();
  }
  NamedpropertyExportlatexclassoptionsJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::NamedProperty::ExportLatexClassOptions> const& ptr) : Napi::ObjectWrap<NamedpropertyExportlatexclassoptionsJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::NamedProperty::ExportLatexClassOptions> _stored;
  org::sem::NamedProperty::ExportLatexClassOptions* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<NamedpropertyExportlatexclassoptionsJs> {
  using type = org::sem::NamedProperty::ExportLatexClassOptions;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::ExportLatexClassOptions> {
  using type = NamedpropertyExportlatexclassoptionsJs;
};

struct NamedpropertyExportlatexheaderJs : public Napi::ObjectWrap<NamedpropertyExportlatexheaderJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::ExportLatexHeader::*)(org::sem::NamedProperty::ExportLatexHeader const&) const>(&org::sem::NamedProperty::ExportLatexHeader::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::ExportLatexHeader>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "NamedpropertyExportlatexheaderJs", {InstanceMethod("operator==", &NamedpropertyExportlatexheaderJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("NamedpropertyExportlatexheaderJs", func);
    return exports;
  }
  NamedpropertyExportlatexheaderJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<NamedpropertyExportlatexheaderJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::NamedProperty::ExportLatexHeader>();
  }
  NamedpropertyExportlatexheaderJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::NamedProperty::ExportLatexHeader> const& ptr) : Napi::ObjectWrap<NamedpropertyExportlatexheaderJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::NamedProperty::ExportLatexHeader> _stored;
  org::sem::NamedProperty::ExportLatexHeader* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<NamedpropertyExportlatexheaderJs> {
  using type = org::sem::NamedProperty::ExportLatexHeader;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::ExportLatexHeader> {
  using type = NamedpropertyExportlatexheaderJs;
};

struct NamedpropertyExportlatexcompilerJs : public Napi::ObjectWrap<NamedpropertyExportlatexcompilerJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::ExportLatexCompiler::*)(org::sem::NamedProperty::ExportLatexCompiler const&) const>(&org::sem::NamedProperty::ExportLatexCompiler::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::ExportLatexCompiler>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "NamedpropertyExportlatexcompilerJs", {InstanceMethod("operator==", &NamedpropertyExportlatexcompilerJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("NamedpropertyExportlatexcompilerJs", func);
    return exports;
  }
  NamedpropertyExportlatexcompilerJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<NamedpropertyExportlatexcompilerJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::NamedProperty::ExportLatexCompiler>();
  }
  NamedpropertyExportlatexcompilerJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::NamedProperty::ExportLatexCompiler> const& ptr) : Napi::ObjectWrap<NamedpropertyExportlatexcompilerJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::NamedProperty::ExportLatexCompiler> _stored;
  org::sem::NamedProperty::ExportLatexCompiler* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<NamedpropertyExportlatexcompilerJs> {
  using type = org::sem::NamedProperty::ExportLatexCompiler;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::ExportLatexCompiler> {
  using type = NamedpropertyExportlatexcompilerJs;
};

struct NamedpropertyOrderedJs : public Napi::ObjectWrap<NamedpropertyOrderedJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::Ordered::*)(org::sem::NamedProperty::Ordered const&) const>(&org::sem::NamedProperty::Ordered::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::Ordered>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "NamedpropertyOrderedJs", {InstanceMethod("operator==", &NamedpropertyOrderedJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("NamedpropertyOrderedJs", func);
    return exports;
  }
  NamedpropertyOrderedJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<NamedpropertyOrderedJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::NamedProperty::Ordered>();
  }
  NamedpropertyOrderedJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::NamedProperty::Ordered> const& ptr) : Napi::ObjectWrap<NamedpropertyOrderedJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::NamedProperty::Ordered> _stored;
  org::sem::NamedProperty::Ordered* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<NamedpropertyOrderedJs> {
  using type = org::sem::NamedProperty::Ordered;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::Ordered> {
  using type = NamedpropertyOrderedJs;
};

struct NamedpropertyEffortJs : public Napi::ObjectWrap<NamedpropertyEffortJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::Effort::*)(org::sem::NamedProperty::Effort const&) const>(&org::sem::NamedProperty::Effort::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::Effort>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "NamedpropertyEffortJs", {InstanceMethod("operator==", &NamedpropertyEffortJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("NamedpropertyEffortJs", func);
    return exports;
  }
  NamedpropertyEffortJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<NamedpropertyEffortJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::NamedProperty::Effort>();
  }
  NamedpropertyEffortJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::NamedProperty::Effort> const& ptr) : Napi::ObjectWrap<NamedpropertyEffortJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::NamedProperty::Effort> _stored;
  org::sem::NamedProperty::Effort* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<NamedpropertyEffortJs> {
  using type = org::sem::NamedProperty::Effort;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::Effort> {
  using type = NamedpropertyEffortJs;
};

struct NamedpropertyVisibilityJs : public Napi::ObjectWrap<NamedpropertyVisibilityJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::Visibility::*)(org::sem::NamedProperty::Visibility const&) const>(&org::sem::NamedProperty::Visibility::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::Visibility>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "NamedpropertyVisibilityJs", {InstanceMethod("operator==", &NamedpropertyVisibilityJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("NamedpropertyVisibilityJs", func);
    return exports;
  }
  NamedpropertyVisibilityJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<NamedpropertyVisibilityJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::NamedProperty::Visibility>();
  }
  NamedpropertyVisibilityJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::NamedProperty::Visibility> const& ptr) : Napi::ObjectWrap<NamedpropertyVisibilityJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::NamedProperty::Visibility> _stored;
  org::sem::NamedProperty::Visibility* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<NamedpropertyVisibilityJs> {
  using type = org::sem::NamedProperty::Visibility;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::Visibility> {
  using type = NamedpropertyVisibilityJs;
};

struct NamedpropertyExportoptionsJs : public Napi::ObjectWrap<NamedpropertyExportoptionsJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::ExportOptions::*)(org::sem::NamedProperty::ExportOptions const&) const>(&org::sem::NamedProperty::ExportOptions::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::ExportOptions>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "NamedpropertyExportoptionsJs", {InstanceMethod("operator==", &NamedpropertyExportoptionsJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("NamedpropertyExportoptionsJs", func);
    return exports;
  }
  NamedpropertyExportoptionsJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<NamedpropertyExportoptionsJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::NamedProperty::ExportOptions>();
  }
  NamedpropertyExportoptionsJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::NamedProperty::ExportOptions> const& ptr) : Napi::ObjectWrap<NamedpropertyExportoptionsJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::NamedProperty::ExportOptions> _stored;
  org::sem::NamedProperty::ExportOptions* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<NamedpropertyExportoptionsJs> {
  using type = org::sem::NamedProperty::ExportOptions;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::ExportOptions> {
  using type = NamedpropertyExportoptionsJs;
};

struct NamedpropertyBlockerJs : public Napi::ObjectWrap<NamedpropertyBlockerJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::Blocker::*)(org::sem::NamedProperty::Blocker const&) const>(&org::sem::NamedProperty::Blocker::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::Blocker>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "NamedpropertyBlockerJs", {InstanceMethod("operator==", &NamedpropertyBlockerJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("NamedpropertyBlockerJs", func);
    return exports;
  }
  NamedpropertyBlockerJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<NamedpropertyBlockerJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::NamedProperty::Blocker>();
  }
  NamedpropertyBlockerJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::NamedProperty::Blocker> const& ptr) : Napi::ObjectWrap<NamedpropertyBlockerJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::NamedProperty::Blocker> _stored;
  org::sem::NamedProperty::Blocker* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<NamedpropertyBlockerJs> {
  using type = org::sem::NamedProperty::Blocker;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::Blocker> {
  using type = NamedpropertyBlockerJs;
};

struct NamedpropertyUnnumberedJs : public Napi::ObjectWrap<NamedpropertyUnnumberedJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::Unnumbered::*)(org::sem::NamedProperty::Unnumbered const&) const>(&org::sem::NamedProperty::Unnumbered::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::Unnumbered>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "NamedpropertyUnnumberedJs", {InstanceMethod("operator==", &NamedpropertyUnnumberedJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("NamedpropertyUnnumberedJs", func);
    return exports;
  }
  NamedpropertyUnnumberedJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<NamedpropertyUnnumberedJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::NamedProperty::Unnumbered>();
  }
  NamedpropertyUnnumberedJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::NamedProperty::Unnumbered> const& ptr) : Napi::ObjectWrap<NamedpropertyUnnumberedJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::NamedProperty::Unnumbered> _stored;
  org::sem::NamedProperty::Unnumbered* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<NamedpropertyUnnumberedJs> {
  using type = org::sem::NamedProperty::Unnumbered;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::Unnumbered> {
  using type = NamedpropertyUnnumberedJs;
};

struct NamedpropertyCreatedJs : public Napi::ObjectWrap<NamedpropertyCreatedJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::Created::*)(org::sem::NamedProperty::Created const&) const>(&org::sem::NamedProperty::Created::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::Created>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "NamedpropertyCreatedJs", {InstanceMethod("operator==", &NamedpropertyCreatedJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("NamedpropertyCreatedJs", func);
    return exports;
  }
  NamedpropertyCreatedJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<NamedpropertyCreatedJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::NamedProperty::Created>();
  }
  NamedpropertyCreatedJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::NamedProperty::Created> const& ptr) : Napi::ObjectWrap<NamedpropertyCreatedJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::NamedProperty::Created> _stored;
  org::sem::NamedProperty::Created* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<NamedpropertyCreatedJs> {
  using type = org::sem::NamedProperty::Created;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::Created> {
  using type = NamedpropertyCreatedJs;
};

struct NamedpropertyRadioidJs : public Napi::ObjectWrap<NamedpropertyRadioidJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::RadioId::*)(org::sem::NamedProperty::RadioId const&) const>(&org::sem::NamedProperty::RadioId::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::RadioId>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "NamedpropertyRadioidJs", {InstanceMethod("operator==", &NamedpropertyRadioidJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("NamedpropertyRadioidJs", func);
    return exports;
  }
  NamedpropertyRadioidJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<NamedpropertyRadioidJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::NamedProperty::RadioId>();
  }
  NamedpropertyRadioidJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::NamedProperty::RadioId> const& ptr) : Napi::ObjectWrap<NamedpropertyRadioidJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::NamedProperty::RadioId> _stored;
  org::sem::NamedProperty::RadioId* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<NamedpropertyRadioidJs> {
  using type = org::sem::NamedProperty::RadioId;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::RadioId> {
  using type = NamedpropertyRadioidJs;
};

struct NamedpropertyHashtagdefJs : public Napi::ObjectWrap<NamedpropertyHashtagdefJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::HashtagDef::*)(org::sem::NamedProperty::HashtagDef const&) const>(&org::sem::NamedProperty::HashtagDef::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::HashtagDef>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "NamedpropertyHashtagdefJs", {InstanceMethod("operator==", &NamedpropertyHashtagdefJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("NamedpropertyHashtagdefJs", func);
    return exports;
  }
  NamedpropertyHashtagdefJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<NamedpropertyHashtagdefJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::NamedProperty::HashtagDef>();
  }
  NamedpropertyHashtagdefJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::NamedProperty::HashtagDef> const& ptr) : Napi::ObjectWrap<NamedpropertyHashtagdefJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::NamedProperty::HashtagDef> _stored;
  org::sem::NamedProperty::HashtagDef* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<NamedpropertyHashtagdefJs> {
  using type = org::sem::NamedProperty::HashtagDef;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::HashtagDef> {
  using type = NamedpropertyHashtagdefJs;
};

struct NamedpropertyCustomargsJs : public Napi::ObjectWrap<NamedpropertyCustomargsJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::CustomArgs::*)(org::sem::NamedProperty::CustomArgs const&) const>(&org::sem::NamedProperty::CustomArgs::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::CustomArgs>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "NamedpropertyCustomargsJs", {InstanceMethod("operator==", &NamedpropertyCustomargsJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("NamedpropertyCustomargsJs", func);
    return exports;
  }
  NamedpropertyCustomargsJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<NamedpropertyCustomargsJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::NamedProperty::CustomArgs>();
  }
  NamedpropertyCustomargsJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::NamedProperty::CustomArgs> const& ptr) : Napi::ObjectWrap<NamedpropertyCustomargsJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::NamedProperty::CustomArgs> _stored;
  org::sem::NamedProperty::CustomArgs* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<NamedpropertyCustomargsJs> {
  using type = org::sem::NamedProperty::CustomArgs;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::CustomArgs> {
  using type = NamedpropertyCustomargsJs;
};

struct NamedpropertyCustomrawJs : public Napi::ObjectWrap<NamedpropertyCustomrawJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::CustomRaw::*)(org::sem::NamedProperty::CustomRaw const&) const>(&org::sem::NamedProperty::CustomRaw::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::CustomRaw>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "NamedpropertyCustomrawJs", {InstanceMethod("operator==", &NamedpropertyCustomrawJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("NamedpropertyCustomrawJs", func);
    return exports;
  }
  NamedpropertyCustomrawJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<NamedpropertyCustomrawJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::NamedProperty::CustomRaw>();
  }
  NamedpropertyCustomrawJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::NamedProperty::CustomRaw> const& ptr) : Napi::ObjectWrap<NamedpropertyCustomrawJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::NamedProperty::CustomRaw> _stored;
  org::sem::NamedProperty::CustomRaw* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<NamedpropertyCustomrawJs> {
  using type = org::sem::NamedProperty::CustomRaw;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::CustomRaw> {
  using type = NamedpropertyCustomrawJs;
};

struct NamedpropertyCustomsubtreejsonJs : public Napi::ObjectWrap<NamedpropertyCustomsubtreejsonJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::CustomSubtreeJson::*)(org::sem::NamedProperty::CustomSubtreeJson const&) const>(&org::sem::NamedProperty::CustomSubtreeJson::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::CustomSubtreeJson>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "NamedpropertyCustomsubtreejsonJs", {InstanceMethod("operator==", &NamedpropertyCustomsubtreejsonJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("NamedpropertyCustomsubtreejsonJs", func);
    return exports;
  }
  NamedpropertyCustomsubtreejsonJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<NamedpropertyCustomsubtreejsonJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::NamedProperty::CustomSubtreeJson>();
  }
  NamedpropertyCustomsubtreejsonJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::NamedProperty::CustomSubtreeJson> const& ptr) : Napi::ObjectWrap<NamedpropertyCustomsubtreejsonJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::NamedProperty::CustomSubtreeJson> _stored;
  org::sem::NamedProperty::CustomSubtreeJson* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<NamedpropertyCustomsubtreejsonJs> {
  using type = org::sem::NamedProperty::CustomSubtreeJson;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::CustomSubtreeJson> {
  using type = NamedpropertyCustomsubtreejsonJs;
};

struct NamedpropertyCustomsubtreeflagsJs : public Napi::ObjectWrap<NamedpropertyCustomsubtreeflagsJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::CustomSubtreeFlags::*)(org::sem::NamedProperty::CustomSubtreeFlags const&) const>(&org::sem::NamedProperty::CustomSubtreeFlags::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::CustomSubtreeFlags>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "NamedpropertyCustomsubtreeflagsJs", {InstanceMethod("operator==", &NamedpropertyCustomsubtreeflagsJs::operator==)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("NamedpropertyCustomsubtreeflagsJs", func);
    return exports;
  }
  NamedpropertyCustomsubtreeflagsJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<NamedpropertyCustomsubtreeflagsJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::NamedProperty::CustomSubtreeFlags>();
  }
  NamedpropertyCustomsubtreeflagsJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::NamedProperty::CustomSubtreeFlags> const& ptr) : Napi::ObjectWrap<NamedpropertyCustomsubtreeflagsJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::NamedProperty::CustomSubtreeFlags> _stored;
  org::sem::NamedProperty::CustomSubtreeFlags* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<NamedpropertyCustomsubtreeflagsJs> {
  using type = org::sem::NamedProperty::CustomSubtreeFlags;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::CustomSubtreeFlags> {
  using type = NamedpropertyCustomsubtreeflagsJs;
};

struct NoneJs : public Napi::ObjectWrap<NoneJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::None::*)() const>(&org::sem::None::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::None::*)() const>(&org::sem::None::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::None::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::None::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::None::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::None::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::None::*)(int) const>(&org::sem::None::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::None::*)(OrgSemKind) const>(&org::sem::None::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "NoneJs", {InstanceMethod("getKind", &NoneJs::getKind),
                                                      InstanceMethod("isGenerated", &NoneJs::isGenerated),
                                                      InstanceMethod("push_back", &NoneJs::push_back),
                                                      InstanceMethod("insert", &NoneJs::insert),
                                                      InstanceMethod("at", &NoneJs::at),
                                                      InstanceMethod("is", &NoneJs::is)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("NoneJs", func);
    return exports;
  }
  NoneJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<NoneJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::None>();
  }
  NoneJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::None> const& ptr) : Napi::ObjectWrap<NoneJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::None> _stored;
  org::sem::None* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<NoneJs> {
  using type = org::sem::None;
};

template <>
struct org_to_js_type<org::sem::None> {
  using type = NoneJs;
};

struct ErroritemJs : public Napi::ObjectWrap<ErroritemJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::ErrorItem::*)() const>(&org::sem::ErrorItem::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ErrorItem::*)() const>(&org::sem::ErrorItem::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::ErrorItem::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::ErrorItem::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::ErrorItem::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::ErrorItem::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::ErrorItem::*)(int) const>(&org::sem::ErrorItem::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ErrorItem::*)(OrgSemKind) const>(&org::sem::ErrorItem::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ErroritemJs", {InstanceMethod("getKind", &ErroritemJs::getKind),
                                                           InstanceMethod("isGenerated", &ErroritemJs::isGenerated),
                                                           InstanceMethod("push_back", &ErroritemJs::push_back),
                                                           InstanceMethod("insert", &ErroritemJs::insert),
                                                           InstanceMethod("at", &ErroritemJs::at),
                                                           InstanceMethod("is", &ErroritemJs::is)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ErroritemJs", func);
    return exports;
  }
  ErroritemJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ErroritemJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::ErrorItem>();
  }
  ErroritemJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::ErrorItem> const& ptr) : Napi::ObjectWrap<ErroritemJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::ErrorItem> _stored;
  org::sem::ErrorItem* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ErroritemJs> {
  using type = org::sem::ErrorItem;
};

template <>
struct org_to_js_type<org::sem::ErrorItem> {
  using type = ErroritemJs;
};

struct ErrorgroupJs : public Napi::ObjectWrap<ErrorgroupJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::ErrorGroup::*)() const>(&org::sem::ErrorGroup::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ErrorGroup::*)() const>(&org::sem::ErrorGroup::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::ErrorGroup::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::ErrorGroup::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::ErrorGroup::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::ErrorGroup::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::ErrorGroup::*)(int) const>(&org::sem::ErrorGroup::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ErrorGroup::*)(OrgSemKind) const>(&org::sem::ErrorGroup::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ErrorgroupJs", {InstanceMethod("getKind", &ErrorgroupJs::getKind),
                                                            InstanceMethod("isGenerated", &ErrorgroupJs::isGenerated),
                                                            InstanceMethod("push_back", &ErrorgroupJs::push_back),
                                                            InstanceMethod("insert", &ErrorgroupJs::insert),
                                                            InstanceMethod("at", &ErrorgroupJs::at),
                                                            InstanceMethod("is", &ErrorgroupJs::is)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ErrorgroupJs", func);
    return exports;
  }
  ErrorgroupJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ErrorgroupJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::ErrorGroup>();
  }
  ErrorgroupJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::ErrorGroup> const& ptr) : Napi::ObjectWrap<ErrorgroupJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::ErrorGroup> _stored;
  org::sem::ErrorGroup* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ErrorgroupJs> {
  using type = org::sem::ErrorGroup;
};

template <>
struct org_to_js_type<org::sem::ErrorGroup> {
  using type = ErrorgroupJs;
};

struct StmtlistJs : public Napi::ObjectWrap<StmtlistJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::StmtList::*)() const>(&org::sem::StmtList::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::StmtList::*)() const>(&org::sem::StmtList::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::StmtList::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::StmtList::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::StmtList::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::StmtList::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::StmtList::*)(int) const>(&org::sem::StmtList::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::StmtList::*)(OrgSemKind) const>(&org::sem::StmtList::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "StmtlistJs", {InstanceMethod("getKind", &StmtlistJs::getKind),
                                                          InstanceMethod("isGenerated", &StmtlistJs::isGenerated),
                                                          InstanceMethod("push_back", &StmtlistJs::push_back),
                                                          InstanceMethod("insert", &StmtlistJs::insert),
                                                          InstanceMethod("at", &StmtlistJs::at),
                                                          InstanceMethod("is", &StmtlistJs::is)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("StmtlistJs", func);
    return exports;
  }
  StmtlistJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<StmtlistJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::StmtList>();
  }
  StmtlistJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::StmtList> const& ptr) : Napi::ObjectWrap<StmtlistJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::StmtList> _stored;
  org::sem::StmtList* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<StmtlistJs> {
  using type = org::sem::StmtList;
};

template <>
struct org_to_js_type<org::sem::StmtList> {
  using type = StmtlistJs;
};

struct EmptyJs : public Napi::ObjectWrap<EmptyJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Empty::*)() const>(&org::sem::Empty::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Empty::*)() const>(&org::sem::Empty::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Empty::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Empty::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Empty::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Empty::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Empty::*)(int) const>(&org::sem::Empty::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Empty::*)(OrgSemKind) const>(&org::sem::Empty::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "EmptyJs", {InstanceMethod("getKind", &EmptyJs::getKind),
                                                       InstanceMethod("isGenerated", &EmptyJs::isGenerated),
                                                       InstanceMethod("push_back", &EmptyJs::push_back),
                                                       InstanceMethod("insert", &EmptyJs::insert),
                                                       InstanceMethod("at", &EmptyJs::at),
                                                       InstanceMethod("is", &EmptyJs::is)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("EmptyJs", func);
    return exports;
  }
  EmptyJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<EmptyJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Empty>();
  }
  EmptyJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Empty> const& ptr) : Napi::ObjectWrap<EmptyJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Empty> _stored;
  org::sem::Empty* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<EmptyJs> {
  using type = org::sem::Empty;
};

template <>
struct org_to_js_type<org::sem::Empty> {
  using type = EmptyJs;
};

struct TimeJs : public Napi::ObjectWrap<TimeJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Time::*)() const>(&org::sem::Time::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Time::*)() const>(&org::sem::Time::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Time::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Time::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Time::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Time::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Time::*)(int) const>(&org::sem::Time::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Time::*)(OrgSemKind) const>(&org::sem::Time::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getYear(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<int>(org::sem::Time::*)() const>(&org::sem::Time::getYear),
                                        std::make_tuple()));
  }
  Napi::Value getMonth(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<int>(org::sem::Time::*)() const>(&org::sem::Time::getMonth),
                                        std::make_tuple()));
  }
  Napi::Value getDay(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<int>(org::sem::Time::*)() const>(&org::sem::Time::getDay),
                                        std::make_tuple()));
  }
  Napi::Value getHour(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<int>(org::sem::Time::*)() const>(&org::sem::Time::getHour),
                                        std::make_tuple()));
  }
  Napi::Value getMinute(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<int>(org::sem::Time::*)() const>(&org::sem::Time::getMinute),
                                        std::make_tuple()));
  }
  Napi::Value getSecond(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<int>(org::sem::Time::*)() const>(&org::sem::Time::getSecond),
                                        std::make_tuple()));
  }
  Napi::Value getStaticTime(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::UserTime(org::sem::Time::*)() const>(&org::sem::Time::getStaticTime),
                                        std::make_tuple()));
  }
  Napi::Value isStatic(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Time::*)() const>(&org::sem::Time::isStatic),
                                        std::make_tuple()));
  }
  Napi::Value getStaticMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::Time::Static&(org::sem::Time::*)()>(&org::sem::Time::getStatic),
                                   std::make_tuple()));
  }
  Napi::Value isDynamic(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Time::*)() const>(&org::sem::Time::isDynamic),
                                        std::make_tuple()));
  }
  Napi::Value getDynamicMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::Time::Dynamic&(org::sem::Time::*)()>(&org::sem::Time::getDynamic),
                                   std::make_tuple()));
  }
  Napi::Value getTimeKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::Time::TimeKind(org::sem::Time::*)() const>(&org::sem::Time::getTimeKind),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_name(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<char const*(org::sem::Time::*)() const>(&org::sem::Time::sub_variant_get_name),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_data(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::Time::TimeVariant const&(org::sem::Time::*)() const>(&org::sem::Time::sub_variant_get_data),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_kind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::Time::TimeKind(org::sem::Time::*)() const>(&org::sem::Time::sub_variant_get_kind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "TimeJs", {InstanceMethod("getKind", &TimeJs::getKind),
                                                      InstanceMethod("isGenerated", &TimeJs::isGenerated),
                                                      InstanceMethod("push_back", &TimeJs::push_back),
                                                      InstanceMethod("insert", &TimeJs::insert),
                                                      InstanceMethod("at", &TimeJs::at),
                                                      InstanceMethod("is", &TimeJs::is),
                                                      InstanceMethod("getYear", &TimeJs::getYear),
                                                      InstanceMethod("getMonth", &TimeJs::getMonth),
                                                      InstanceMethod("getDay", &TimeJs::getDay),
                                                      InstanceMethod("getHour", &TimeJs::getHour),
                                                      InstanceMethod("getMinute", &TimeJs::getMinute),
                                                      InstanceMethod("getSecond", &TimeJs::getSecond),
                                                      InstanceMethod("getStaticTime", &TimeJs::getStaticTime),
                                                      InstanceMethod("isStatic", &TimeJs::isStatic),
                                                      InstanceMethod("getStaticMut", &TimeJs::getStaticMut),
                                                      InstanceMethod("isDynamic", &TimeJs::isDynamic),
                                                      InstanceMethod("getDynamicMut", &TimeJs::getDynamicMut),
                                                      InstanceMethod("getTimeKind", &TimeJs::getTimeKind),
                                                      InstanceMethod("sub_variant_get_name", &TimeJs::sub_variant_get_name),
                                                      InstanceMethod("sub_variant_get_data", &TimeJs::sub_variant_get_data),
                                                      InstanceMethod("sub_variant_get_kind", &TimeJs::sub_variant_get_kind)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("TimeJs", func);
    return exports;
  }
  TimeJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<TimeJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Time>();
  }
  TimeJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Time> const& ptr) : Napi::ObjectWrap<TimeJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Time> _stored;
  org::sem::Time* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<TimeJs> {
  using type = org::sem::Time;
};

template <>
struct org_to_js_type<org::sem::Time> {
  using type = TimeJs;
};

struct TimeRepeatJs : public Napi::ObjectWrap<TimeRepeatJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "TimeRepeatJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("TimeRepeatJs", func);
    return exports;
  }
  TimeRepeatJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<TimeRepeatJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Time::Repeat>();
  }
  TimeRepeatJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Time::Repeat> const& ptr) : Napi::ObjectWrap<TimeRepeatJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Time::Repeat> _stored;
  org::sem::Time::Repeat* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<TimeRepeatJs> {
  using type = org::sem::Time::Repeat;
};

template <>
struct org_to_js_type<org::sem::Time::Repeat> {
  using type = TimeRepeatJs;
};

struct TimeStaticJs : public Napi::ObjectWrap<TimeStaticJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "TimeStaticJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("TimeStaticJs", func);
    return exports;
  }
  TimeStaticJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<TimeStaticJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Time::Static>();
  }
  TimeStaticJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Time::Static> const& ptr) : Napi::ObjectWrap<TimeStaticJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Time::Static> _stored;
  org::sem::Time::Static* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<TimeStaticJs> {
  using type = org::sem::Time::Static;
};

template <>
struct org_to_js_type<org::sem::Time::Static> {
  using type = TimeStaticJs;
};

struct TimeDynamicJs : public Napi::ObjectWrap<TimeDynamicJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "TimeDynamicJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("TimeDynamicJs", func);
    return exports;
  }
  TimeDynamicJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<TimeDynamicJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Time::Dynamic>();
  }
  TimeDynamicJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Time::Dynamic> const& ptr) : Napi::ObjectWrap<TimeDynamicJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Time::Dynamic> _stored;
  org::sem::Time::Dynamic* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<TimeDynamicJs> {
  using type = org::sem::Time::Dynamic;
};

template <>
struct org_to_js_type<org::sem::Time::Dynamic> {
  using type = TimeDynamicJs;
};

struct TimerangeJs : public Napi::ObjectWrap<TimerangeJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::TimeRange::*)() const>(&org::sem::TimeRange::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::TimeRange::*)() const>(&org::sem::TimeRange::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::TimeRange::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::TimeRange::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::TimeRange::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::TimeRange::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::TimeRange::*)(int) const>(&org::sem::TimeRange::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::TimeRange::*)(OrgSemKind) const>(&org::sem::TimeRange::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "TimerangeJs", {InstanceMethod("getKind", &TimerangeJs::getKind),
                                                           InstanceMethod("isGenerated", &TimerangeJs::isGenerated),
                                                           InstanceMethod("push_back", &TimerangeJs::push_back),
                                                           InstanceMethod("insert", &TimerangeJs::insert),
                                                           InstanceMethod("at", &TimerangeJs::at),
                                                           InstanceMethod("is", &TimerangeJs::is)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("TimerangeJs", func);
    return exports;
  }
  TimerangeJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<TimerangeJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::TimeRange>();
  }
  TimerangeJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::TimeRange> const& ptr) : Napi::ObjectWrap<TimerangeJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::TimeRange> _stored;
  org::sem::TimeRange* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<TimerangeJs> {
  using type = org::sem::TimeRange;
};

template <>
struct org_to_js_type<org::sem::TimeRange> {
  using type = TimerangeJs;
};

struct MacroJs : public Napi::ObjectWrap<MacroJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Macro::*)() const>(&org::sem::Macro::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Macro::*)() const>(&org::sem::Macro::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Macro::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Macro::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Macro::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Macro::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Macro::*)(int) const>(&org::sem::Macro::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Macro::*)(OrgSemKind) const>(&org::sem::Macro::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "MacroJs", {InstanceMethod("getKind", &MacroJs::getKind),
                                                       InstanceMethod("isGenerated", &MacroJs::isGenerated),
                                                       InstanceMethod("push_back", &MacroJs::push_back),
                                                       InstanceMethod("insert", &MacroJs::insert),
                                                       InstanceMethod("at", &MacroJs::at),
                                                       InstanceMethod("is", &MacroJs::is)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("MacroJs", func);
    return exports;
  }
  MacroJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<MacroJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Macro>();
  }
  MacroJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Macro> const& ptr) : Napi::ObjectWrap<MacroJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Macro> _stored;
  org::sem::Macro* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<MacroJs> {
  using type = org::sem::Macro;
};

template <>
struct org_to_js_type<org::sem::Macro> {
  using type = MacroJs;
};

struct SymbolJs : public Napi::ObjectWrap<SymbolJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Symbol::*)() const>(&org::sem::Symbol::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Symbol::*)() const>(&org::sem::Symbol::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Symbol::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Symbol::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Symbol::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Symbol::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Symbol::*)(int) const>(&org::sem::Symbol::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Symbol::*)(OrgSemKind) const>(&org::sem::Symbol::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "SymbolJs", {InstanceMethod("getKind", &SymbolJs::getKind),
                                                        InstanceMethod("isGenerated", &SymbolJs::isGenerated),
                                                        InstanceMethod("push_back", &SymbolJs::push_back),
                                                        InstanceMethod("insert", &SymbolJs::insert),
                                                        InstanceMethod("at", &SymbolJs::at),
                                                        InstanceMethod("is", &SymbolJs::is)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("SymbolJs", func);
    return exports;
  }
  SymbolJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<SymbolJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Symbol>();
  }
  SymbolJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Symbol> const& ptr) : Napi::ObjectWrap<SymbolJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Symbol> _stored;
  org::sem::Symbol* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<SymbolJs> {
  using type = org::sem::Symbol;
};

template <>
struct org_to_js_type<org::sem::Symbol> {
  using type = SymbolJs;
};

struct SymbolParamJs : public Napi::ObjectWrap<SymbolParamJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "SymbolParamJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("SymbolParamJs", func);
    return exports;
  }
  SymbolParamJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<SymbolParamJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Symbol::Param>();
  }
  SymbolParamJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Symbol::Param> const& ptr) : Napi::ObjectWrap<SymbolParamJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Symbol::Param> _stored;
  org::sem::Symbol::Param* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<SymbolParamJs> {
  using type = org::sem::Symbol::Param;
};

template <>
struct org_to_js_type<org::sem::Symbol::Param> {
  using type = SymbolParamJs;
};

struct RadiotargetJs : public Napi::ObjectWrap<RadiotargetJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::RadioTarget::*)() const>(&org::sem::RadioTarget::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::RadioTarget::*)() const>(&org::sem::RadioTarget::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::RadioTarget::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::RadioTarget::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::RadioTarget::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::RadioTarget::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::RadioTarget::*)(int) const>(&org::sem::RadioTarget::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::RadioTarget::*)(OrgSemKind) const>(&org::sem::RadioTarget::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "RadiotargetJs", {InstanceMethod("getKind", &RadiotargetJs::getKind),
                                                             InstanceMethod("isGenerated", &RadiotargetJs::isGenerated),
                                                             InstanceMethod("push_back", &RadiotargetJs::push_back),
                                                             InstanceMethod("insert", &RadiotargetJs::insert),
                                                             InstanceMethod("at", &RadiotargetJs::at),
                                                             InstanceMethod("is", &RadiotargetJs::is)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("RadiotargetJs", func);
    return exports;
  }
  RadiotargetJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<RadiotargetJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::RadioTarget>();
  }
  RadiotargetJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::RadioTarget> const& ptr) : Napi::ObjectWrap<RadiotargetJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::RadioTarget> _stored;
  org::sem::RadioTarget* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<RadiotargetJs> {
  using type = org::sem::RadioTarget;
};

template <>
struct org_to_js_type<org::sem::RadioTarget> {
  using type = RadiotargetJs;
};

struct LatexJs : public Napi::ObjectWrap<LatexJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Latex::*)() const>(&org::sem::Latex::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Latex::*)() const>(&org::sem::Latex::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Latex::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Latex::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Latex::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Latex::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Latex::*)(int) const>(&org::sem::Latex::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Latex::*)(OrgSemKind) const>(&org::sem::Latex::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "LatexJs", {InstanceMethod("getKind", &LatexJs::getKind),
                                                       InstanceMethod("isGenerated", &LatexJs::isGenerated),
                                                       InstanceMethod("push_back", &LatexJs::push_back),
                                                       InstanceMethod("insert", &LatexJs::insert),
                                                       InstanceMethod("at", &LatexJs::at),
                                                       InstanceMethod("is", &LatexJs::is)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("LatexJs", func);
    return exports;
  }
  LatexJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<LatexJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Latex>();
  }
  LatexJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Latex> const& ptr) : Napi::ObjectWrap<LatexJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Latex> _stored;
  org::sem::Latex* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<LatexJs> {
  using type = org::sem::Latex;
};

template <>
struct org_to_js_type<org::sem::Latex> {
  using type = LatexJs;
};

struct SubtreelogJs : public Napi::ObjectWrap<SubtreelogJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::SubtreeLog::*)() const>(&org::sem::SubtreeLog::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLog::*)() const>(&org::sem::SubtreeLog::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::SubtreeLog::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::SubtreeLog::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::SubtreeLog::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::SubtreeLog::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::SubtreeLog::*)(int) const>(&org::sem::SubtreeLog::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLog::*)(OrgSemKind) const>(&org::sem::SubtreeLog::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value setDescription(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::SubtreeLog::*)(org::sem::SemId<org::sem::StmtList>)>(&org::sem::SubtreeLog::setDescription),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::StmtList>>{"desc"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "SubtreelogJs", {InstanceMethod("getKind", &SubtreelogJs::getKind),
                                                            InstanceMethod("isGenerated", &SubtreelogJs::isGenerated),
                                                            InstanceMethod("push_back", &SubtreelogJs::push_back),
                                                            InstanceMethod("insert", &SubtreelogJs::insert),
                                                            InstanceMethod("at", &SubtreelogJs::at),
                                                            InstanceMethod("is", &SubtreelogJs::is),
                                                            InstanceMethod("setDescription", &SubtreelogJs::setDescription)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("SubtreelogJs", func);
    return exports;
  }
  SubtreelogJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<SubtreelogJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::SubtreeLog>();
  }
  SubtreelogJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::SubtreeLog> const& ptr) : Napi::ObjectWrap<SubtreelogJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::SubtreeLog> _stored;
  org::sem::SubtreeLog* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<SubtreelogJs> {
  using type = org::sem::SubtreeLog;
};

template <>
struct org_to_js_type<org::sem::SubtreeLog> {
  using type = SubtreelogJs;
};

struct SubtreeJs : public Napi::ObjectWrap<SubtreeJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Subtree::*)() const>(&org::sem::Subtree::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Subtree::*)() const>(&org::sem::Subtree::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Subtree::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Subtree::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Subtree::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Subtree::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Subtree::*)(int) const>(&org::sem::Subtree::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Subtree::*)(OrgSemKind) const>(&org::sem::Subtree::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getTimePeriods(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SubtreePeriod>(org::sem::Subtree::*)(hstd::IntSet<org::sem::SubtreePeriod::Kind>) const>(&org::sem::Subtree::getTimePeriods),
                                        std::make_tuple(CxxArgSpec<hstd::IntSet<org::sem::SubtreePeriod::Kind>>{"kinds"})));
  }
  Napi::Value getProperties(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::NamedProperty>(org::sem::Subtree::*)(hstd::Str const&, hstd::Opt<hstd::Str> const&) const>(&org::sem::Subtree::getProperties),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"},
                                                        CxxArgSpec<hstd::Opt<hstd::Str>>{"subkind", std::nullopt})));
  }
  Napi::Value getProperty(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::NamedProperty>(org::sem::Subtree::*)(hstd::Str const&, hstd::Opt<hstd::Str> const&) const>(&org::sem::Subtree::getProperty),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"},
                                                        CxxArgSpec<hstd::Opt<hstd::Str>>{"subkind", std::nullopt})));
  }
  Napi::Value removeProperty(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Subtree::*)(hstd::Str const&, hstd::Opt<hstd::Str> const&)>(&org::sem::Subtree::removeProperty),
                                   std::make_tuple(CxxArgSpec<hstd::Str>{"kind"},
                                                   CxxArgSpec<hstd::Opt<hstd::Str>>{"subkind", std::nullopt})));
  }
  Napi::Value setProperty(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Subtree::*)(org::sem::NamedProperty const&)>(&org::sem::Subtree::setProperty),
                                   std::make_tuple(CxxArgSpec<org::sem::NamedProperty>{"value"})));
  }
  Napi::Value setPropertyStrValue(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Subtree::*)(hstd::Str const&, hstd::Str const&, hstd::Opt<hstd::Str> const&)>(&org::sem::Subtree::setPropertyStrValue),
                                   std::make_tuple(CxxArgSpec<hstd::Str>{"value"},
                                                   CxxArgSpec<hstd::Str>{"kind"},
                                                   CxxArgSpec<hstd::Opt<hstd::Str>>{"subkind", std::nullopt})));
  }
  Napi::Value getCleanTitle(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Str(org::sem::Subtree::*)() const>(&org::sem::Subtree::getCleanTitle),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "SubtreeJs", {InstanceMethod("getKind", &SubtreeJs::getKind),
                                                         InstanceMethod("isGenerated", &SubtreeJs::isGenerated),
                                                         InstanceMethod("push_back", &SubtreeJs::push_back),
                                                         InstanceMethod("insert", &SubtreeJs::insert),
                                                         InstanceMethod("at", &SubtreeJs::at),
                                                         InstanceMethod("is", &SubtreeJs::is),
                                                         InstanceMethod("getTimePeriods", &SubtreeJs::getTimePeriods),
                                                         InstanceMethod("getProperties", &SubtreeJs::getProperties),
                                                         InstanceMethod("getProperty", &SubtreeJs::getProperty),
                                                         InstanceMethod("removeProperty", &SubtreeJs::removeProperty),
                                                         InstanceMethod("setProperty", &SubtreeJs::setProperty),
                                                         InstanceMethod("setPropertyStrValue", &SubtreeJs::setPropertyStrValue),
                                                         InstanceMethod("getCleanTitle", &SubtreeJs::getCleanTitle)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("SubtreeJs", func);
    return exports;
  }
  SubtreeJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<SubtreeJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Subtree>();
  }
  SubtreeJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Subtree> const& ptr) : Napi::ObjectWrap<SubtreeJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Subtree> _stored;
  org::sem::Subtree* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<SubtreeJs> {
  using type = org::sem::Subtree;
};

template <>
struct org_to_js_type<org::sem::Subtree> {
  using type = SubtreeJs;
};

struct ColonexampleJs : public Napi::ObjectWrap<ColonexampleJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::ColonExample::*)() const>(&org::sem::ColonExample::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ColonExample::*)() const>(&org::sem::ColonExample::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::ColonExample::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::ColonExample::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::ColonExample::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::ColonExample::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::ColonExample::*)(int) const>(&org::sem::ColonExample::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ColonExample::*)(OrgSemKind) const>(&org::sem::ColonExample::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ColonexampleJs", {InstanceMethod("getKind", &ColonexampleJs::getKind),
                                                              InstanceMethod("isGenerated", &ColonexampleJs::isGenerated),
                                                              InstanceMethod("push_back", &ColonexampleJs::push_back),
                                                              InstanceMethod("insert", &ColonexampleJs::insert),
                                                              InstanceMethod("at", &ColonexampleJs::at),
                                                              InstanceMethod("is", &ColonexampleJs::is)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ColonexampleJs", func);
    return exports;
  }
  ColonexampleJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ColonexampleJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::ColonExample>();
  }
  ColonexampleJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::ColonExample> const& ptr) : Napi::ObjectWrap<ColonexampleJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::ColonExample> _stored;
  org::sem::ColonExample* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ColonexampleJs> {
  using type = org::sem::ColonExample;
};

template <>
struct org_to_js_type<org::sem::ColonExample> {
  using type = ColonexampleJs;
};

struct CallJs : public Napi::ObjectWrap<CallJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Call::*)() const>(&org::sem::Call::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Call::*)() const>(&org::sem::Call::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Call::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Call::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Call::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Call::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Call::*)(int) const>(&org::sem::Call::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Call::*)(OrgSemKind) const>(&org::sem::Call::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "CallJs", {InstanceMethod("getKind", &CallJs::getKind),
                                                      InstanceMethod("isGenerated", &CallJs::isGenerated),
                                                      InstanceMethod("push_back", &CallJs::push_back),
                                                      InstanceMethod("insert", &CallJs::insert),
                                                      InstanceMethod("at", &CallJs::at),
                                                      InstanceMethod("is", &CallJs::is)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("CallJs", func);
    return exports;
  }
  CallJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<CallJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Call>();
  }
  CallJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Call> const& ptr) : Napi::ObjectWrap<CallJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Call> _stored;
  org::sem::Call* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<CallJs> {
  using type = org::sem::Call;
};

template <>
struct org_to_js_type<org::sem::Call> {
  using type = CallJs;
};

struct ListitemJs : public Napi::ObjectWrap<ListitemJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::ListItem::*)() const>(&org::sem::ListItem::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ListItem::*)() const>(&org::sem::ListItem::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::ListItem::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::ListItem::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::ListItem::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::ListItem::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::ListItem::*)(int) const>(&org::sem::ListItem::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ListItem::*)(OrgSemKind) const>(&org::sem::ListItem::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value isDescriptionItem(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ListItem::*)() const>(&org::sem::ListItem::isDescriptionItem),
                                        std::make_tuple()));
  }
  Napi::Value getCleanHeader(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<hstd::Str>(org::sem::ListItem::*)() const>(&org::sem::ListItem::getCleanHeader),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ListitemJs", {InstanceMethod("getKind", &ListitemJs::getKind),
                                                          InstanceMethod("isGenerated", &ListitemJs::isGenerated),
                                                          InstanceMethod("push_back", &ListitemJs::push_back),
                                                          InstanceMethod("insert", &ListitemJs::insert),
                                                          InstanceMethod("at", &ListitemJs::at),
                                                          InstanceMethod("is", &ListitemJs::is),
                                                          InstanceMethod("isDescriptionItem", &ListitemJs::isDescriptionItem),
                                                          InstanceMethod("getCleanHeader", &ListitemJs::getCleanHeader)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ListitemJs", func);
    return exports;
  }
  ListitemJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ListitemJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::ListItem>();
  }
  ListitemJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::ListItem> const& ptr) : Napi::ObjectWrap<ListitemJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::ListItem> _stored;
  org::sem::ListItem* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ListitemJs> {
  using type = org::sem::ListItem;
};

template <>
struct org_to_js_type<org::sem::ListItem> {
  using type = ListitemJs;
};

struct DocumentoptionsJs : public Napi::ObjectWrap<DocumentoptionsJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::DocumentOptions::*)() const>(&org::sem::DocumentOptions::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::DocumentOptions::*)() const>(&org::sem::DocumentOptions::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::DocumentOptions::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::DocumentOptions::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::DocumentOptions::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::DocumentOptions::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::DocumentOptions::*)(int) const>(&org::sem::DocumentOptions::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::DocumentOptions::*)(OrgSemKind) const>(&org::sem::DocumentOptions::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getProperties(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::NamedProperty>(org::sem::DocumentOptions::*)(hstd::Str const&, hstd::Opt<hstd::Str> const&) const>(&org::sem::DocumentOptions::getProperties),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"},
                                                        CxxArgSpec<hstd::Opt<hstd::Str>>{"subKind", std::nullopt})));
  }
  Napi::Value getProperty(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::NamedProperty>(org::sem::DocumentOptions::*)(hstd::Str const&, hstd::Opt<hstd::Str> const&) const>(&org::sem::DocumentOptions::getProperty),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"},
                                                        CxxArgSpec<hstd::Opt<hstd::Str>>{"subKind", std::nullopt})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "DocumentoptionsJs", {InstanceMethod("getKind", &DocumentoptionsJs::getKind),
                                                                 InstanceMethod("isGenerated", &DocumentoptionsJs::isGenerated),
                                                                 InstanceMethod("push_back", &DocumentoptionsJs::push_back),
                                                                 InstanceMethod("insert", &DocumentoptionsJs::insert),
                                                                 InstanceMethod("at", &DocumentoptionsJs::at),
                                                                 InstanceMethod("is", &DocumentoptionsJs::is),
                                                                 InstanceMethod("getProperties", &DocumentoptionsJs::getProperties),
                                                                 InstanceMethod("getProperty", &DocumentoptionsJs::getProperty)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("DocumentoptionsJs", func);
    return exports;
  }
  DocumentoptionsJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<DocumentoptionsJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::DocumentOptions>();
  }
  DocumentoptionsJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::DocumentOptions> const& ptr) : Napi::ObjectWrap<DocumentoptionsJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::DocumentOptions> _stored;
  org::sem::DocumentOptions* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<DocumentoptionsJs> {
  using type = org::sem::DocumentOptions;
};

template <>
struct org_to_js_type<org::sem::DocumentOptions> {
  using type = DocumentoptionsJs;
};

struct DocumentfragmentJs : public Napi::ObjectWrap<DocumentfragmentJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::DocumentFragment::*)() const>(&org::sem::DocumentFragment::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::DocumentFragment::*)() const>(&org::sem::DocumentFragment::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::DocumentFragment::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::DocumentFragment::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::DocumentFragment::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::DocumentFragment::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::DocumentFragment::*)(int) const>(&org::sem::DocumentFragment::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::DocumentFragment::*)(OrgSemKind) const>(&org::sem::DocumentFragment::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "DocumentfragmentJs", {InstanceMethod("getKind", &DocumentfragmentJs::getKind),
                                                                  InstanceMethod("isGenerated", &DocumentfragmentJs::isGenerated),
                                                                  InstanceMethod("push_back", &DocumentfragmentJs::push_back),
                                                                  InstanceMethod("insert", &DocumentfragmentJs::insert),
                                                                  InstanceMethod("at", &DocumentfragmentJs::at),
                                                                  InstanceMethod("is", &DocumentfragmentJs::is)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("DocumentfragmentJs", func);
    return exports;
  }
  DocumentfragmentJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<DocumentfragmentJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::DocumentFragment>();
  }
  DocumentfragmentJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::DocumentFragment> const& ptr) : Napi::ObjectWrap<DocumentfragmentJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::DocumentFragment> _stored;
  org::sem::DocumentFragment* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<DocumentfragmentJs> {
  using type = org::sem::DocumentFragment;
};

template <>
struct org_to_js_type<org::sem::DocumentFragment> {
  using type = DocumentfragmentJs;
};

struct CriticmarkupJs : public Napi::ObjectWrap<CriticmarkupJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::CriticMarkup::*)() const>(&org::sem::CriticMarkup::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CriticMarkup::*)() const>(&org::sem::CriticMarkup::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CriticMarkup::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::CriticMarkup::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CriticMarkup::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::CriticMarkup::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::CriticMarkup::*)(int) const>(&org::sem::CriticMarkup::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CriticMarkup::*)(OrgSemKind) const>(&org::sem::CriticMarkup::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "CriticmarkupJs", {InstanceMethod("getKind", &CriticmarkupJs::getKind),
                                                              InstanceMethod("isGenerated", &CriticmarkupJs::isGenerated),
                                                              InstanceMethod("push_back", &CriticmarkupJs::push_back),
                                                              InstanceMethod("insert", &CriticmarkupJs::insert),
                                                              InstanceMethod("at", &CriticmarkupJs::at),
                                                              InstanceMethod("is", &CriticmarkupJs::is)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("CriticmarkupJs", func);
    return exports;
  }
  CriticmarkupJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<CriticmarkupJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::CriticMarkup>();
  }
  CriticmarkupJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::CriticMarkup> const& ptr) : Napi::ObjectWrap<CriticmarkupJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::CriticMarkup> _stored;
  org::sem::CriticMarkup* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<CriticmarkupJs> {
  using type = org::sem::CriticMarkup;
};

template <>
struct org_to_js_type<org::sem::CriticMarkup> {
  using type = CriticmarkupJs;
};

struct DocumentJs : public Napi::ObjectWrap<DocumentJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Document::*)() const>(&org::sem::Document::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Document::*)() const>(&org::sem::Document::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Document::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Document::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Document::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Document::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Document::*)(int) const>(&org::sem::Document::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Document::*)(OrgSemKind) const>(&org::sem::Document::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getProperties(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::NamedProperty>(org::sem::Document::*)(hstd::Str const&, hstd::Opt<hstd::Str> const&) const>(&org::sem::Document::getProperties),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"},
                                                        CxxArgSpec<hstd::Opt<hstd::Str>>{"subKind", std::nullopt})));
  }
  Napi::Value getProperty(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::NamedProperty>(org::sem::Document::*)(hstd::Str const&, hstd::Opt<hstd::Str> const&) const>(&org::sem::Document::getProperty),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"},
                                                        CxxArgSpec<hstd::Opt<hstd::Str>>{"subKind", std::nullopt})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "DocumentJs", {InstanceMethod("getKind", &DocumentJs::getKind),
                                                          InstanceMethod("isGenerated", &DocumentJs::isGenerated),
                                                          InstanceMethod("push_back", &DocumentJs::push_back),
                                                          InstanceMethod("insert", &DocumentJs::insert),
                                                          InstanceMethod("at", &DocumentJs::at),
                                                          InstanceMethod("is", &DocumentJs::is),
                                                          InstanceMethod("getProperties", &DocumentJs::getProperties),
                                                          InstanceMethod("getProperty", &DocumentJs::getProperty)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("DocumentJs", func);
    return exports;
  }
  DocumentJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<DocumentJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Document>();
  }
  DocumentJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Document> const& ptr) : Napi::ObjectWrap<DocumentJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Document> _stored;
  org::sem::Document* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<DocumentJs> {
  using type = org::sem::Document;
};

template <>
struct org_to_js_type<org::sem::Document> {
  using type = DocumentJs;
};

struct FiletargetJs : public Napi::ObjectWrap<FiletargetJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::FileTarget::*)() const>(&org::sem::FileTarget::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::FileTarget::*)() const>(&org::sem::FileTarget::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::FileTarget::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::FileTarget::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::FileTarget::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::FileTarget::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::FileTarget::*)(int) const>(&org::sem::FileTarget::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::FileTarget::*)(OrgSemKind) const>(&org::sem::FileTarget::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "FiletargetJs", {InstanceMethod("getKind", &FiletargetJs::getKind),
                                                            InstanceMethod("isGenerated", &FiletargetJs::isGenerated),
                                                            InstanceMethod("push_back", &FiletargetJs::push_back),
                                                            InstanceMethod("insert", &FiletargetJs::insert),
                                                            InstanceMethod("at", &FiletargetJs::at),
                                                            InstanceMethod("is", &FiletargetJs::is)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("FiletargetJs", func);
    return exports;
  }
  FiletargetJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<FiletargetJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::FileTarget>();
  }
  FiletargetJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::FileTarget> const& ptr) : Napi::ObjectWrap<FiletargetJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::FileTarget> _stored;
  org::sem::FileTarget* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<FiletargetJs> {
  using type = org::sem::FileTarget;
};

template <>
struct org_to_js_type<org::sem::FileTarget> {
  using type = FiletargetJs;
};

struct TextseparatorJs : public Napi::ObjectWrap<TextseparatorJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::TextSeparator::*)() const>(&org::sem::TextSeparator::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::TextSeparator::*)() const>(&org::sem::TextSeparator::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::TextSeparator::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::TextSeparator::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::TextSeparator::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::TextSeparator::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::TextSeparator::*)(int) const>(&org::sem::TextSeparator::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::TextSeparator::*)(OrgSemKind) const>(&org::sem::TextSeparator::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "TextseparatorJs", {InstanceMethod("getKind", &TextseparatorJs::getKind),
                                                               InstanceMethod("isGenerated", &TextseparatorJs::isGenerated),
                                                               InstanceMethod("push_back", &TextseparatorJs::push_back),
                                                               InstanceMethod("insert", &TextseparatorJs::insert),
                                                               InstanceMethod("at", &TextseparatorJs::at),
                                                               InstanceMethod("is", &TextseparatorJs::is)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("TextseparatorJs", func);
    return exports;
  }
  TextseparatorJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<TextseparatorJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::TextSeparator>();
  }
  TextseparatorJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::TextSeparator> const& ptr) : Napi::ObjectWrap<TextseparatorJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::TextSeparator> _stored;
  org::sem::TextSeparator* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<TextseparatorJs> {
  using type = org::sem::TextSeparator;
};

template <>
struct org_to_js_type<org::sem::TextSeparator> {
  using type = TextseparatorJs;
};

struct DocumentgroupJs : public Napi::ObjectWrap<DocumentgroupJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::DocumentGroup::*)() const>(&org::sem::DocumentGroup::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::DocumentGroup::*)() const>(&org::sem::DocumentGroup::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::DocumentGroup::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::DocumentGroup::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::DocumentGroup::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::DocumentGroup::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::DocumentGroup::*)(int) const>(&org::sem::DocumentGroup::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::DocumentGroup::*)(OrgSemKind) const>(&org::sem::DocumentGroup::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "DocumentgroupJs", {InstanceMethod("getKind", &DocumentgroupJs::getKind),
                                                               InstanceMethod("isGenerated", &DocumentgroupJs::isGenerated),
                                                               InstanceMethod("push_back", &DocumentgroupJs::push_back),
                                                               InstanceMethod("insert", &DocumentgroupJs::insert),
                                                               InstanceMethod("at", &DocumentgroupJs::at),
                                                               InstanceMethod("is", &DocumentgroupJs::is)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("DocumentgroupJs", func);
    return exports;
  }
  DocumentgroupJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<DocumentgroupJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::DocumentGroup>();
  }
  DocumentgroupJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::DocumentGroup> const& ptr) : Napi::ObjectWrap<DocumentgroupJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::DocumentGroup> _stored;
  org::sem::DocumentGroup* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<DocumentgroupJs> {
  using type = org::sem::DocumentGroup;
};

template <>
struct org_to_js_type<org::sem::DocumentGroup> {
  using type = DocumentgroupJs;
};

struct FileJs : public Napi::ObjectWrap<FileJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::File::*)() const>(&org::sem::File::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::File::*)() const>(&org::sem::File::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::File::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::File::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::File::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::File::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::File::*)(int) const>(&org::sem::File::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::File::*)(OrgSemKind) const>(&org::sem::File::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value isDocument(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::File::*)() const>(&org::sem::File::isDocument),
                                        std::make_tuple()));
  }
  Napi::Value getDocumentMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::File::Document&(org::sem::File::*)()>(&org::sem::File::getDocument),
                                   std::make_tuple()));
  }
  Napi::Value isAttachment(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::File::*)() const>(&org::sem::File::isAttachment),
                                        std::make_tuple()));
  }
  Napi::Value getAttachmentMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::File::Attachment&(org::sem::File::*)()>(&org::sem::File::getAttachment),
                                   std::make_tuple()));
  }
  Napi::Value isSource(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::File::*)() const>(&org::sem::File::isSource),
                                        std::make_tuple()));
  }
  Napi::Value getSourceMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::File::Source&(org::sem::File::*)()>(&org::sem::File::getSource),
                                   std::make_tuple()));
  }
  Napi::Value getFileKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::File::Kind(org::sem::File::*)() const>(&org::sem::File::getFileKind),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_name(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<char const*(org::sem::File::*)() const>(&org::sem::File::sub_variant_get_name),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_data(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::File::Data const&(org::sem::File::*)() const>(&org::sem::File::sub_variant_get_data),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_kind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::File::Kind(org::sem::File::*)() const>(&org::sem::File::sub_variant_get_kind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "FileJs", {InstanceMethod("getKind", &FileJs::getKind),
                                                      InstanceMethod("isGenerated", &FileJs::isGenerated),
                                                      InstanceMethod("push_back", &FileJs::push_back),
                                                      InstanceMethod("insert", &FileJs::insert),
                                                      InstanceMethod("at", &FileJs::at),
                                                      InstanceMethod("is", &FileJs::is),
                                                      InstanceMethod("isDocument", &FileJs::isDocument),
                                                      InstanceMethod("getDocumentMut", &FileJs::getDocumentMut),
                                                      InstanceMethod("isAttachment", &FileJs::isAttachment),
                                                      InstanceMethod("getAttachmentMut", &FileJs::getAttachmentMut),
                                                      InstanceMethod("isSource", &FileJs::isSource),
                                                      InstanceMethod("getSourceMut", &FileJs::getSourceMut),
                                                      InstanceMethod("getFileKind", &FileJs::getFileKind),
                                                      InstanceMethod("sub_variant_get_name", &FileJs::sub_variant_get_name),
                                                      InstanceMethod("sub_variant_get_data", &FileJs::sub_variant_get_data),
                                                      InstanceMethod("sub_variant_get_kind", &FileJs::sub_variant_get_kind)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("FileJs", func);
    return exports;
  }
  FileJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<FileJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::File>();
  }
  FileJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::File> const& ptr) : Napi::ObjectWrap<FileJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::File> _stored;
  org::sem::File* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<FileJs> {
  using type = org::sem::File;
};

template <>
struct org_to_js_type<org::sem::File> {
  using type = FileJs;
};

struct FileDocumentJs : public Napi::ObjectWrap<FileDocumentJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "FileDocumentJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("FileDocumentJs", func);
    return exports;
  }
  FileDocumentJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<FileDocumentJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::File::Document>();
  }
  FileDocumentJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::File::Document> const& ptr) : Napi::ObjectWrap<FileDocumentJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::File::Document> _stored;
  org::sem::File::Document* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<FileDocumentJs> {
  using type = org::sem::File::Document;
};

template <>
struct org_to_js_type<org::sem::File::Document> {
  using type = FileDocumentJs;
};

struct FileAttachmentJs : public Napi::ObjectWrap<FileAttachmentJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "FileAttachmentJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("FileAttachmentJs", func);
    return exports;
  }
  FileAttachmentJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<FileAttachmentJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::File::Attachment>();
  }
  FileAttachmentJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::File::Attachment> const& ptr) : Napi::ObjectWrap<FileAttachmentJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::File::Attachment> _stored;
  org::sem::File::Attachment* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<FileAttachmentJs> {
  using type = org::sem::File::Attachment;
};

template <>
struct org_to_js_type<org::sem::File::Attachment> {
  using type = FileAttachmentJs;
};

struct FileSourceJs : public Napi::ObjectWrap<FileSourceJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "FileSourceJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("FileSourceJs", func);
    return exports;
  }
  FileSourceJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<FileSourceJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::File::Source>();
  }
  FileSourceJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::File::Source> const& ptr) : Napi::ObjectWrap<FileSourceJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::File::Source> _stored;
  org::sem::File::Source* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<FileSourceJs> {
  using type = org::sem::File::Source;
};

template <>
struct org_to_js_type<org::sem::File::Source> {
  using type = FileSourceJs;
};

struct DirectoryJs : public Napi::ObjectWrap<DirectoryJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Directory::*)() const>(&org::sem::Directory::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Directory::*)() const>(&org::sem::Directory::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Directory::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Directory::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Directory::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Directory::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Directory::*)(int) const>(&org::sem::Directory::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Directory::*)(OrgSemKind) const>(&org::sem::Directory::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "DirectoryJs", {InstanceMethod("getKind", &DirectoryJs::getKind),
                                                           InstanceMethod("isGenerated", &DirectoryJs::isGenerated),
                                                           InstanceMethod("push_back", &DirectoryJs::push_back),
                                                           InstanceMethod("insert", &DirectoryJs::insert),
                                                           InstanceMethod("at", &DirectoryJs::at),
                                                           InstanceMethod("is", &DirectoryJs::is)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("DirectoryJs", func);
    return exports;
  }
  DirectoryJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<DirectoryJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Directory>();
  }
  DirectoryJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Directory> const& ptr) : Napi::ObjectWrap<DirectoryJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Directory> _stored;
  org::sem::Directory* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<DirectoryJs> {
  using type = org::sem::Directory;
};

template <>
struct org_to_js_type<org::sem::Directory> {
  using type = DirectoryJs;
};

struct SymlinkJs : public Napi::ObjectWrap<SymlinkJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Symlink::*)() const>(&org::sem::Symlink::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Symlink::*)() const>(&org::sem::Symlink::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Symlink::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Symlink::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Symlink::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Symlink::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Symlink::*)(int) const>(&org::sem::Symlink::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Symlink::*)(OrgSemKind) const>(&org::sem::Symlink::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "SymlinkJs", {InstanceMethod("getKind", &SymlinkJs::getKind),
                                                         InstanceMethod("isGenerated", &SymlinkJs::isGenerated),
                                                         InstanceMethod("push_back", &SymlinkJs::push_back),
                                                         InstanceMethod("insert", &SymlinkJs::insert),
                                                         InstanceMethod("at", &SymlinkJs::at),
                                                         InstanceMethod("is", &SymlinkJs::is)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("SymlinkJs", func);
    return exports;
  }
  SymlinkJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<SymlinkJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Symlink>();
  }
  SymlinkJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Symlink> const& ptr) : Napi::ObjectWrap<SymlinkJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Symlink> _stored;
  org::sem::Symlink* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<SymlinkJs> {
  using type = org::sem::Symlink;
};

template <>
struct org_to_js_type<org::sem::Symlink> {
  using type = SymlinkJs;
};

struct CmdincludeJs : public Napi::ObjectWrap<CmdincludeJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::CmdInclude::*)() const>(&org::sem::CmdInclude::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdInclude::*)() const>(&org::sem::CmdInclude::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdInclude::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::CmdInclude::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdInclude::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::CmdInclude::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::CmdInclude::*)(int) const>(&org::sem::CmdInclude::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdInclude::*)(OrgSemKind) const>(&org::sem::CmdInclude::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value isExample(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdInclude::*)() const>(&org::sem::CmdInclude::isExample),
                                        std::make_tuple()));
  }
  Napi::Value getExampleMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::CmdInclude::Example&(org::sem::CmdInclude::*)()>(&org::sem::CmdInclude::getExample),
                                   std::make_tuple()));
  }
  Napi::Value isExport(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdInclude::*)() const>(&org::sem::CmdInclude::isExport),
                                        std::make_tuple()));
  }
  Napi::Value getExportMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::CmdInclude::Export&(org::sem::CmdInclude::*)()>(&org::sem::CmdInclude::getExport),
                                   std::make_tuple()));
  }
  Napi::Value isCustom(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdInclude::*)() const>(&org::sem::CmdInclude::isCustom),
                                        std::make_tuple()));
  }
  Napi::Value getCustomMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::CmdInclude::Custom&(org::sem::CmdInclude::*)()>(&org::sem::CmdInclude::getCustom),
                                   std::make_tuple()));
  }
  Napi::Value isSrc(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdInclude::*)() const>(&org::sem::CmdInclude::isSrc),
                                        std::make_tuple()));
  }
  Napi::Value getSrcMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::CmdInclude::Src&(org::sem::CmdInclude::*)()>(&org::sem::CmdInclude::getSrc),
                                   std::make_tuple()));
  }
  Napi::Value isOrgDocument(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdInclude::*)() const>(&org::sem::CmdInclude::isOrgDocument),
                                        std::make_tuple()));
  }
  Napi::Value getOrgDocumentMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::CmdInclude::OrgDocument&(org::sem::CmdInclude::*)()>(&org::sem::CmdInclude::getOrgDocument),
                                   std::make_tuple()));
  }
  Napi::Value getIncludeKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::CmdInclude::Kind(org::sem::CmdInclude::*)() const>(&org::sem::CmdInclude::getIncludeKind),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_name(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<char const*(org::sem::CmdInclude::*)() const>(&org::sem::CmdInclude::sub_variant_get_name),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_data(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::CmdInclude::Data const&(org::sem::CmdInclude::*)() const>(&org::sem::CmdInclude::sub_variant_get_data),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_kind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::CmdInclude::Kind(org::sem::CmdInclude::*)() const>(&org::sem::CmdInclude::sub_variant_get_kind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "CmdincludeJs", {InstanceMethod("getKind", &CmdincludeJs::getKind),
                                                            InstanceMethod("isGenerated", &CmdincludeJs::isGenerated),
                                                            InstanceMethod("push_back", &CmdincludeJs::push_back),
                                                            InstanceMethod("insert", &CmdincludeJs::insert),
                                                            InstanceMethod("at", &CmdincludeJs::at),
                                                            InstanceMethod("is", &CmdincludeJs::is),
                                                            InstanceMethod("isExample", &CmdincludeJs::isExample),
                                                            InstanceMethod("getExampleMut", &CmdincludeJs::getExampleMut),
                                                            InstanceMethod("isExport", &CmdincludeJs::isExport),
                                                            InstanceMethod("getExportMut", &CmdincludeJs::getExportMut),
                                                            InstanceMethod("isCustom", &CmdincludeJs::isCustom),
                                                            InstanceMethod("getCustomMut", &CmdincludeJs::getCustomMut),
                                                            InstanceMethod("isSrc", &CmdincludeJs::isSrc),
                                                            InstanceMethod("getSrcMut", &CmdincludeJs::getSrcMut),
                                                            InstanceMethod("isOrgDocument", &CmdincludeJs::isOrgDocument),
                                                            InstanceMethod("getOrgDocumentMut", &CmdincludeJs::getOrgDocumentMut),
                                                            InstanceMethod("getIncludeKind", &CmdincludeJs::getIncludeKind),
                                                            InstanceMethod("sub_variant_get_name", &CmdincludeJs::sub_variant_get_name),
                                                            InstanceMethod("sub_variant_get_data", &CmdincludeJs::sub_variant_get_data),
                                                            InstanceMethod("sub_variant_get_kind", &CmdincludeJs::sub_variant_get_kind)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("CmdincludeJs", func);
    return exports;
  }
  CmdincludeJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<CmdincludeJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::CmdInclude>();
  }
  CmdincludeJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::CmdInclude> const& ptr) : Napi::ObjectWrap<CmdincludeJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::CmdInclude> _stored;
  org::sem::CmdInclude* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<CmdincludeJs> {
  using type = org::sem::CmdInclude;
};

template <>
struct org_to_js_type<org::sem::CmdInclude> {
  using type = CmdincludeJs;
};

struct CmdincludeIncludebaseJs : public Napi::ObjectWrap<CmdincludeIncludebaseJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "CmdincludeIncludebaseJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("CmdincludeIncludebaseJs", func);
    return exports;
  }
  CmdincludeIncludebaseJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<CmdincludeIncludebaseJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::CmdInclude::IncludeBase>();
  }
  CmdincludeIncludebaseJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::CmdInclude::IncludeBase> const& ptr) : Napi::ObjectWrap<CmdincludeIncludebaseJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::CmdInclude::IncludeBase> _stored;
  org::sem::CmdInclude::IncludeBase* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<CmdincludeIncludebaseJs> {
  using type = org::sem::CmdInclude::IncludeBase;
};

template <>
struct org_to_js_type<org::sem::CmdInclude::IncludeBase> {
  using type = CmdincludeIncludebaseJs;
};

struct CmdincludeExampleJs : public Napi::ObjectWrap<CmdincludeExampleJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "CmdincludeExampleJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("CmdincludeExampleJs", func);
    return exports;
  }
  CmdincludeExampleJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<CmdincludeExampleJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::CmdInclude::Example>();
  }
  CmdincludeExampleJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::CmdInclude::Example> const& ptr) : Napi::ObjectWrap<CmdincludeExampleJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::CmdInclude::Example> _stored;
  org::sem::CmdInclude::Example* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<CmdincludeExampleJs> {
  using type = org::sem::CmdInclude::Example;
};

template <>
struct org_to_js_type<org::sem::CmdInclude::Example> {
  using type = CmdincludeExampleJs;
};

struct CmdincludeExportJs : public Napi::ObjectWrap<CmdincludeExportJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "CmdincludeExportJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("CmdincludeExportJs", func);
    return exports;
  }
  CmdincludeExportJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<CmdincludeExportJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::CmdInclude::Export>();
  }
  CmdincludeExportJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::CmdInclude::Export> const& ptr) : Napi::ObjectWrap<CmdincludeExportJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::CmdInclude::Export> _stored;
  org::sem::CmdInclude::Export* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<CmdincludeExportJs> {
  using type = org::sem::CmdInclude::Export;
};

template <>
struct org_to_js_type<org::sem::CmdInclude::Export> {
  using type = CmdincludeExportJs;
};

struct CmdincludeCustomJs : public Napi::ObjectWrap<CmdincludeCustomJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "CmdincludeCustomJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("CmdincludeCustomJs", func);
    return exports;
  }
  CmdincludeCustomJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<CmdincludeCustomJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::CmdInclude::Custom>();
  }
  CmdincludeCustomJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::CmdInclude::Custom> const& ptr) : Napi::ObjectWrap<CmdincludeCustomJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::CmdInclude::Custom> _stored;
  org::sem::CmdInclude::Custom* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<CmdincludeCustomJs> {
  using type = org::sem::CmdInclude::Custom;
};

template <>
struct org_to_js_type<org::sem::CmdInclude::Custom> {
  using type = CmdincludeCustomJs;
};

struct CmdincludeSrcJs : public Napi::ObjectWrap<CmdincludeSrcJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "CmdincludeSrcJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("CmdincludeSrcJs", func);
    return exports;
  }
  CmdincludeSrcJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<CmdincludeSrcJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::CmdInclude::Src>();
  }
  CmdincludeSrcJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::CmdInclude::Src> const& ptr) : Napi::ObjectWrap<CmdincludeSrcJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::CmdInclude::Src> _stored;
  org::sem::CmdInclude::Src* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<CmdincludeSrcJs> {
  using type = org::sem::CmdInclude::Src;
};

template <>
struct org_to_js_type<org::sem::CmdInclude::Src> {
  using type = CmdincludeSrcJs;
};

struct CmdincludeOrgdocumentJs : public Napi::ObjectWrap<CmdincludeOrgdocumentJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "CmdincludeOrgdocumentJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("CmdincludeOrgdocumentJs", func);
    return exports;
  }
  CmdincludeOrgdocumentJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<CmdincludeOrgdocumentJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::CmdInclude::OrgDocument>();
  }
  CmdincludeOrgdocumentJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::CmdInclude::OrgDocument> const& ptr) : Napi::ObjectWrap<CmdincludeOrgdocumentJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::CmdInclude::OrgDocument> _stored;
  org::sem::CmdInclude::OrgDocument* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<CmdincludeOrgdocumentJs> {
  using type = org::sem::CmdInclude::OrgDocument;
};

template <>
struct org_to_js_type<org::sem::CmdInclude::OrgDocument> {
  using type = CmdincludeOrgdocumentJs;
};

struct GraphMapconfigJs : public Napi::ObjectWrap<GraphMapconfigJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value setTraceFileStr(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::graph::MapConfig::*)(std::string const&, bool)>(&org::graph::MapConfig::setTraceFileStr),
                                   std::make_tuple(CxxArgSpec<std::string>{"outfile"},
                                                   CxxArgSpec<bool>{"overwrite"})));
  }
  Napi::Value sendMessage(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::graph::MapConfig::*)(std::string const&, std::string const&, int, std::string const&)>(&org::graph::MapConfig::sendMessage),
                                   std::make_tuple(CxxArgSpec<std::string>{"value"},
                                                   CxxArgSpec<std::string>{"function"},
                                                   CxxArgSpec<int>{"line"},
                                                   CxxArgSpec<std::string>{"file"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "GraphMapconfigJs", {InstanceMethod("setTraceFileStr", &GraphMapconfigJs::setTraceFileStr),
                                                                InstanceMethod("sendMessage", &GraphMapconfigJs::sendMessage)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("GraphMapconfigJs", func);
    return exports;
  }
  GraphMapconfigJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<GraphMapconfigJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::graph::MapConfig>();
  }
  GraphMapconfigJs(Napi::CallbackInfo const& info, std::shared_ptr<org::graph::MapConfig> const& ptr) : Napi::ObjectWrap<GraphMapconfigJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::graph::MapConfig> _stored;
  org::graph::MapConfig* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<GraphMapconfigJs> {
  using type = org::graph::MapConfig;
};

template <>
struct org_to_js_type<org::graph::MapConfig> {
  using type = GraphMapconfigJs;
};

struct ImmIdTNone : public Napi::ObjectWrap<ImmIdTNone> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmNone>::*)() const>(&org::imm::ImmIdT<org::imm::ImmNone>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmNone>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmNone>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmNone>::*)() const>(&org::imm::ImmIdT<org::imm::ImmNone>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmNone>::*)() const>(&org::imm::ImmIdT<org::imm::ImmNone>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTNone", {InstanceMethod("getKind", &ImmIdTNone::getKind),
                                                          InstanceMethod("is", &ImmIdTNone::is),
                                                          InstanceMethod("getNodeIndex", &ImmIdTNone::getNodeIndex),
                                                          InstanceMethod("getReadableId", &ImmIdTNone::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTNone", func);
    return exports;
  }
  ImmIdTNone(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTNone>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmNone>>();
  }
  ImmIdTNone(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmNone>> const& ptr) : Napi::ObjectWrap<ImmIdTNone>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmNone>> _stored;
  org::imm::ImmIdT<org::imm::ImmNone>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTNone> {
  using type = org::imm::ImmIdT<org::imm::ImmNone>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmNone>> {
  using type = ImmIdTNone;
};

struct ImmIdTErrorItem : public Napi::ObjectWrap<ImmIdTErrorItem> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmErrorItem>::*)() const>(&org::imm::ImmIdT<org::imm::ImmErrorItem>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmErrorItem>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmErrorItem>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmErrorItem>::*)() const>(&org::imm::ImmIdT<org::imm::ImmErrorItem>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmErrorItem>::*)() const>(&org::imm::ImmIdT<org::imm::ImmErrorItem>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTErrorItem", {InstanceMethod("getKind", &ImmIdTErrorItem::getKind),
                                                               InstanceMethod("is", &ImmIdTErrorItem::is),
                                                               InstanceMethod("getNodeIndex", &ImmIdTErrorItem::getNodeIndex),
                                                               InstanceMethod("getReadableId", &ImmIdTErrorItem::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTErrorItem", func);
    return exports;
  }
  ImmIdTErrorItem(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTErrorItem>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmErrorItem>>();
  }
  ImmIdTErrorItem(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmErrorItem>> const& ptr) : Napi::ObjectWrap<ImmIdTErrorItem>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmErrorItem>> _stored;
  org::imm::ImmIdT<org::imm::ImmErrorItem>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTErrorItem> {
  using type = org::imm::ImmIdT<org::imm::ImmErrorItem>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmErrorItem>> {
  using type = ImmIdTErrorItem;
};

struct ImmIdTErrorGroup : public Napi::ObjectWrap<ImmIdTErrorGroup> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmErrorGroup>::*)() const>(&org::imm::ImmIdT<org::imm::ImmErrorGroup>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmErrorGroup>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmErrorGroup>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmErrorGroup>::*)() const>(&org::imm::ImmIdT<org::imm::ImmErrorGroup>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmErrorGroup>::*)() const>(&org::imm::ImmIdT<org::imm::ImmErrorGroup>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTErrorGroup", {InstanceMethod("getKind", &ImmIdTErrorGroup::getKind),
                                                                InstanceMethod("is", &ImmIdTErrorGroup::is),
                                                                InstanceMethod("getNodeIndex", &ImmIdTErrorGroup::getNodeIndex),
                                                                InstanceMethod("getReadableId", &ImmIdTErrorGroup::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTErrorGroup", func);
    return exports;
  }
  ImmIdTErrorGroup(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTErrorGroup>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmErrorGroup>>();
  }
  ImmIdTErrorGroup(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmErrorGroup>> const& ptr) : Napi::ObjectWrap<ImmIdTErrorGroup>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmErrorGroup>> _stored;
  org::imm::ImmIdT<org::imm::ImmErrorGroup>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTErrorGroup> {
  using type = org::imm::ImmIdT<org::imm::ImmErrorGroup>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmErrorGroup>> {
  using type = ImmIdTErrorGroup;
};

struct ImmIdTStmt : public Napi::ObjectWrap<ImmIdTStmt> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmStmt>::*)() const>(&org::imm::ImmIdT<org::imm::ImmStmt>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmStmt>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmStmt>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmStmt>::*)() const>(&org::imm::ImmIdT<org::imm::ImmStmt>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmStmt>::*)() const>(&org::imm::ImmIdT<org::imm::ImmStmt>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTStmt", {InstanceMethod("getKind", &ImmIdTStmt::getKind),
                                                          InstanceMethod("is", &ImmIdTStmt::is),
                                                          InstanceMethod("getNodeIndex", &ImmIdTStmt::getNodeIndex),
                                                          InstanceMethod("getReadableId", &ImmIdTStmt::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTStmt", func);
    return exports;
  }
  ImmIdTStmt(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTStmt>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmStmt>>();
  }
  ImmIdTStmt(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmStmt>> const& ptr) : Napi::ObjectWrap<ImmIdTStmt>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmStmt>> _stored;
  org::imm::ImmIdT<org::imm::ImmStmt>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTStmt> {
  using type = org::imm::ImmIdT<org::imm::ImmStmt>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmStmt>> {
  using type = ImmIdTStmt;
};

struct ImmIdTInline : public Napi::ObjectWrap<ImmIdTInline> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmInline>::*)() const>(&org::imm::ImmIdT<org::imm::ImmInline>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmInline>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmInline>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmInline>::*)() const>(&org::imm::ImmIdT<org::imm::ImmInline>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmInline>::*)() const>(&org::imm::ImmIdT<org::imm::ImmInline>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTInline", {InstanceMethod("getKind", &ImmIdTInline::getKind),
                                                            InstanceMethod("is", &ImmIdTInline::is),
                                                            InstanceMethod("getNodeIndex", &ImmIdTInline::getNodeIndex),
                                                            InstanceMethod("getReadableId", &ImmIdTInline::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTInline", func);
    return exports;
  }
  ImmIdTInline(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTInline>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmInline>>();
  }
  ImmIdTInline(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmInline>> const& ptr) : Napi::ObjectWrap<ImmIdTInline>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmInline>> _stored;
  org::imm::ImmIdT<org::imm::ImmInline>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTInline> {
  using type = org::imm::ImmIdT<org::imm::ImmInline>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmInline>> {
  using type = ImmIdTInline;
};

struct ImmIdTStmtList : public Napi::ObjectWrap<ImmIdTStmtList> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmStmtList>::*)() const>(&org::imm::ImmIdT<org::imm::ImmStmtList>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmStmtList>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmStmtList>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmStmtList>::*)() const>(&org::imm::ImmIdT<org::imm::ImmStmtList>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmStmtList>::*)() const>(&org::imm::ImmIdT<org::imm::ImmStmtList>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTStmtList", {InstanceMethod("getKind", &ImmIdTStmtList::getKind),
                                                              InstanceMethod("is", &ImmIdTStmtList::is),
                                                              InstanceMethod("getNodeIndex", &ImmIdTStmtList::getNodeIndex),
                                                              InstanceMethod("getReadableId", &ImmIdTStmtList::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTStmtList", func);
    return exports;
  }
  ImmIdTStmtList(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTStmtList>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmStmtList>>();
  }
  ImmIdTStmtList(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmStmtList>> const& ptr) : Napi::ObjectWrap<ImmIdTStmtList>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmStmtList>> _stored;
  org::imm::ImmIdT<org::imm::ImmStmtList>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTStmtList> {
  using type = org::imm::ImmIdT<org::imm::ImmStmtList>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmStmtList>> {
  using type = ImmIdTStmtList;
};

struct ImmIdTEmpty : public Napi::ObjectWrap<ImmIdTEmpty> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmEmpty>::*)() const>(&org::imm::ImmIdT<org::imm::ImmEmpty>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmEmpty>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmEmpty>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmEmpty>::*)() const>(&org::imm::ImmIdT<org::imm::ImmEmpty>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmEmpty>::*)() const>(&org::imm::ImmIdT<org::imm::ImmEmpty>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTEmpty", {InstanceMethod("getKind", &ImmIdTEmpty::getKind),
                                                           InstanceMethod("is", &ImmIdTEmpty::is),
                                                           InstanceMethod("getNodeIndex", &ImmIdTEmpty::getNodeIndex),
                                                           InstanceMethod("getReadableId", &ImmIdTEmpty::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTEmpty", func);
    return exports;
  }
  ImmIdTEmpty(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTEmpty>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmEmpty>>();
  }
  ImmIdTEmpty(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmEmpty>> const& ptr) : Napi::ObjectWrap<ImmIdTEmpty>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmEmpty>> _stored;
  org::imm::ImmIdT<org::imm::ImmEmpty>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTEmpty> {
  using type = org::imm::ImmIdT<org::imm::ImmEmpty>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmEmpty>> {
  using type = ImmIdTEmpty;
};

struct ImmIdTCmd : public Napi::ObjectWrap<ImmIdTCmd> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmCmd>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmd>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmCmd>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmCmd>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmCmd>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmd>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmCmd>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmd>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTCmd", {InstanceMethod("getKind", &ImmIdTCmd::getKind),
                                                         InstanceMethod("is", &ImmIdTCmd::is),
                                                         InstanceMethod("getNodeIndex", &ImmIdTCmd::getNodeIndex),
                                                         InstanceMethod("getReadableId", &ImmIdTCmd::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTCmd", func);
    return exports;
  }
  ImmIdTCmd(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTCmd>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmCmd>>();
  }
  ImmIdTCmd(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmCmd>> const& ptr) : Napi::ObjectWrap<ImmIdTCmd>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmCmd>> _stored;
  org::imm::ImmIdT<org::imm::ImmCmd>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTCmd> {
  using type = org::imm::ImmIdT<org::imm::ImmCmd>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmCmd>> {
  using type = ImmIdTCmd;
};

struct ImmIdTBlock : public Napi::ObjectWrap<ImmIdTBlock> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmBlock>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlock>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmBlock>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmBlock>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmBlock>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlock>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmBlock>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlock>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTBlock", {InstanceMethod("getKind", &ImmIdTBlock::getKind),
                                                           InstanceMethod("is", &ImmIdTBlock::is),
                                                           InstanceMethod("getNodeIndex", &ImmIdTBlock::getNodeIndex),
                                                           InstanceMethod("getReadableId", &ImmIdTBlock::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTBlock", func);
    return exports;
  }
  ImmIdTBlock(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTBlock>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmBlock>>();
  }
  ImmIdTBlock(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmBlock>> const& ptr) : Napi::ObjectWrap<ImmIdTBlock>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmBlock>> _stored;
  org::imm::ImmIdT<org::imm::ImmBlock>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTBlock> {
  using type = org::imm::ImmIdT<org::imm::ImmBlock>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmBlock>> {
  using type = ImmIdTBlock;
};

struct ImmIdTLineCommand : public Napi::ObjectWrap<ImmIdTLineCommand> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmLineCommand>::*)() const>(&org::imm::ImmIdT<org::imm::ImmLineCommand>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmLineCommand>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmLineCommand>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmLineCommand>::*)() const>(&org::imm::ImmIdT<org::imm::ImmLineCommand>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmLineCommand>::*)() const>(&org::imm::ImmIdT<org::imm::ImmLineCommand>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTLineCommand", {InstanceMethod("getKind", &ImmIdTLineCommand::getKind),
                                                                 InstanceMethod("is", &ImmIdTLineCommand::is),
                                                                 InstanceMethod("getNodeIndex", &ImmIdTLineCommand::getNodeIndex),
                                                                 InstanceMethod("getReadableId", &ImmIdTLineCommand::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTLineCommand", func);
    return exports;
  }
  ImmIdTLineCommand(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTLineCommand>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmLineCommand>>();
  }
  ImmIdTLineCommand(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmLineCommand>> const& ptr) : Napi::ObjectWrap<ImmIdTLineCommand>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmLineCommand>> _stored;
  org::imm::ImmIdT<org::imm::ImmLineCommand>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTLineCommand> {
  using type = org::imm::ImmIdT<org::imm::ImmLineCommand>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmLineCommand>> {
  using type = ImmIdTLineCommand;
};

struct ImmIdTAttached : public Napi::ObjectWrap<ImmIdTAttached> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmAttached>::*)() const>(&org::imm::ImmIdT<org::imm::ImmAttached>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmAttached>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmAttached>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmAttached>::*)() const>(&org::imm::ImmIdT<org::imm::ImmAttached>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmAttached>::*)() const>(&org::imm::ImmIdT<org::imm::ImmAttached>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTAttached", {InstanceMethod("getKind", &ImmIdTAttached::getKind),
                                                              InstanceMethod("is", &ImmIdTAttached::is),
                                                              InstanceMethod("getNodeIndex", &ImmIdTAttached::getNodeIndex),
                                                              InstanceMethod("getReadableId", &ImmIdTAttached::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTAttached", func);
    return exports;
  }
  ImmIdTAttached(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTAttached>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmAttached>>();
  }
  ImmIdTAttached(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmAttached>> const& ptr) : Napi::ObjectWrap<ImmIdTAttached>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmAttached>> _stored;
  org::imm::ImmIdT<org::imm::ImmAttached>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTAttached> {
  using type = org::imm::ImmIdT<org::imm::ImmAttached>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmAttached>> {
  using type = ImmIdTAttached;
};

struct ImmIdTLeaf : public Napi::ObjectWrap<ImmIdTLeaf> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmLeaf>::*)() const>(&org::imm::ImmIdT<org::imm::ImmLeaf>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmLeaf>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmLeaf>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmLeaf>::*)() const>(&org::imm::ImmIdT<org::imm::ImmLeaf>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmLeaf>::*)() const>(&org::imm::ImmIdT<org::imm::ImmLeaf>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTLeaf", {InstanceMethod("getKind", &ImmIdTLeaf::getKind),
                                                          InstanceMethod("is", &ImmIdTLeaf::is),
                                                          InstanceMethod("getNodeIndex", &ImmIdTLeaf::getNodeIndex),
                                                          InstanceMethod("getReadableId", &ImmIdTLeaf::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTLeaf", func);
    return exports;
  }
  ImmIdTLeaf(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTLeaf>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmLeaf>>();
  }
  ImmIdTLeaf(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmLeaf>> const& ptr) : Napi::ObjectWrap<ImmIdTLeaf>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmLeaf>> _stored;
  org::imm::ImmIdT<org::imm::ImmLeaf>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTLeaf> {
  using type = org::imm::ImmIdT<org::imm::ImmLeaf>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmLeaf>> {
  using type = ImmIdTLeaf;
};

struct ImmIdTCmdCaption : public Napi::ObjectWrap<ImmIdTCmdCaption> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmCmdCaption>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdCaption>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmCmdCaption>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmCmdCaption>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmCmdCaption>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdCaption>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmCmdCaption>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdCaption>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTCmdCaption", {InstanceMethod("getKind", &ImmIdTCmdCaption::getKind),
                                                                InstanceMethod("is", &ImmIdTCmdCaption::is),
                                                                InstanceMethod("getNodeIndex", &ImmIdTCmdCaption::getNodeIndex),
                                                                InstanceMethod("getReadableId", &ImmIdTCmdCaption::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTCmdCaption", func);
    return exports;
  }
  ImmIdTCmdCaption(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTCmdCaption>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmCmdCaption>>();
  }
  ImmIdTCmdCaption(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmCmdCaption>> const& ptr) : Napi::ObjectWrap<ImmIdTCmdCaption>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmCmdCaption>> _stored;
  org::imm::ImmIdT<org::imm::ImmCmdCaption>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTCmdCaption> {
  using type = org::imm::ImmIdT<org::imm::ImmCmdCaption>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmCmdCaption>> {
  using type = ImmIdTCmdCaption;
};

struct ImmIdTCmdColumns : public Napi::ObjectWrap<ImmIdTCmdColumns> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmCmdColumns>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdColumns>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmCmdColumns>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmCmdColumns>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmCmdColumns>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdColumns>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmCmdColumns>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdColumns>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTCmdColumns", {InstanceMethod("getKind", &ImmIdTCmdColumns::getKind),
                                                                InstanceMethod("is", &ImmIdTCmdColumns::is),
                                                                InstanceMethod("getNodeIndex", &ImmIdTCmdColumns::getNodeIndex),
                                                                InstanceMethod("getReadableId", &ImmIdTCmdColumns::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTCmdColumns", func);
    return exports;
  }
  ImmIdTCmdColumns(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTCmdColumns>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmCmdColumns>>();
  }
  ImmIdTCmdColumns(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmCmdColumns>> const& ptr) : Napi::ObjectWrap<ImmIdTCmdColumns>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmCmdColumns>> _stored;
  org::imm::ImmIdT<org::imm::ImmCmdColumns>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTCmdColumns> {
  using type = org::imm::ImmIdT<org::imm::ImmCmdColumns>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmCmdColumns>> {
  using type = ImmIdTCmdColumns;
};

struct ImmIdTCmdName : public Napi::ObjectWrap<ImmIdTCmdName> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmCmdName>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdName>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmCmdName>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmCmdName>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmCmdName>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdName>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmCmdName>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdName>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTCmdName", {InstanceMethod("getKind", &ImmIdTCmdName::getKind),
                                                             InstanceMethod("is", &ImmIdTCmdName::is),
                                                             InstanceMethod("getNodeIndex", &ImmIdTCmdName::getNodeIndex),
                                                             InstanceMethod("getReadableId", &ImmIdTCmdName::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTCmdName", func);
    return exports;
  }
  ImmIdTCmdName(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTCmdName>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmCmdName>>();
  }
  ImmIdTCmdName(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmCmdName>> const& ptr) : Napi::ObjectWrap<ImmIdTCmdName>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmCmdName>> _stored;
  org::imm::ImmIdT<org::imm::ImmCmdName>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTCmdName> {
  using type = org::imm::ImmIdT<org::imm::ImmCmdName>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmCmdName>> {
  using type = ImmIdTCmdName;
};

struct ImmIdTCmdCustomArgs : public Napi::ObjectWrap<ImmIdTCmdCustomArgs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmCmdCustomArgs>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdCustomArgs>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmCmdCustomArgs>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmCmdCustomArgs>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmCmdCustomArgs>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdCustomArgs>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmCmdCustomArgs>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdCustomArgs>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTCmdCustomArgs", {InstanceMethod("getKind", &ImmIdTCmdCustomArgs::getKind),
                                                                   InstanceMethod("is", &ImmIdTCmdCustomArgs::is),
                                                                   InstanceMethod("getNodeIndex", &ImmIdTCmdCustomArgs::getNodeIndex),
                                                                   InstanceMethod("getReadableId", &ImmIdTCmdCustomArgs::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTCmdCustomArgs", func);
    return exports;
  }
  ImmIdTCmdCustomArgs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTCmdCustomArgs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmCmdCustomArgs>>();
  }
  ImmIdTCmdCustomArgs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmCmdCustomArgs>> const& ptr) : Napi::ObjectWrap<ImmIdTCmdCustomArgs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmCmdCustomArgs>> _stored;
  org::imm::ImmIdT<org::imm::ImmCmdCustomArgs>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTCmdCustomArgs> {
  using type = org::imm::ImmIdT<org::imm::ImmCmdCustomArgs>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmCmdCustomArgs>> {
  using type = ImmIdTCmdCustomArgs;
};

struct ImmIdTCmdCustomRaw : public Napi::ObjectWrap<ImmIdTCmdCustomRaw> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmCmdCustomRaw>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdCustomRaw>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmCmdCustomRaw>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmCmdCustomRaw>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmCmdCustomRaw>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdCustomRaw>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmCmdCustomRaw>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdCustomRaw>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTCmdCustomRaw", {InstanceMethod("getKind", &ImmIdTCmdCustomRaw::getKind),
                                                                  InstanceMethod("is", &ImmIdTCmdCustomRaw::is),
                                                                  InstanceMethod("getNodeIndex", &ImmIdTCmdCustomRaw::getNodeIndex),
                                                                  InstanceMethod("getReadableId", &ImmIdTCmdCustomRaw::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTCmdCustomRaw", func);
    return exports;
  }
  ImmIdTCmdCustomRaw(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTCmdCustomRaw>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmCmdCustomRaw>>();
  }
  ImmIdTCmdCustomRaw(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmCmdCustomRaw>> const& ptr) : Napi::ObjectWrap<ImmIdTCmdCustomRaw>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmCmdCustomRaw>> _stored;
  org::imm::ImmIdT<org::imm::ImmCmdCustomRaw>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTCmdCustomRaw> {
  using type = org::imm::ImmIdT<org::imm::ImmCmdCustomRaw>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmCmdCustomRaw>> {
  using type = ImmIdTCmdCustomRaw;
};

struct ImmIdTCmdCustomText : public Napi::ObjectWrap<ImmIdTCmdCustomText> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmCmdCustomText>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdCustomText>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmCmdCustomText>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmCmdCustomText>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmCmdCustomText>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdCustomText>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmCmdCustomText>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdCustomText>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTCmdCustomText", {InstanceMethod("getKind", &ImmIdTCmdCustomText::getKind),
                                                                   InstanceMethod("is", &ImmIdTCmdCustomText::is),
                                                                   InstanceMethod("getNodeIndex", &ImmIdTCmdCustomText::getNodeIndex),
                                                                   InstanceMethod("getReadableId", &ImmIdTCmdCustomText::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTCmdCustomText", func);
    return exports;
  }
  ImmIdTCmdCustomText(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTCmdCustomText>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmCmdCustomText>>();
  }
  ImmIdTCmdCustomText(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmCmdCustomText>> const& ptr) : Napi::ObjectWrap<ImmIdTCmdCustomText>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmCmdCustomText>> _stored;
  org::imm::ImmIdT<org::imm::ImmCmdCustomText>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTCmdCustomText> {
  using type = org::imm::ImmIdT<org::imm::ImmCmdCustomText>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmCmdCustomText>> {
  using type = ImmIdTCmdCustomText;
};

struct ImmIdTCmdCall : public Napi::ObjectWrap<ImmIdTCmdCall> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmCmdCall>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdCall>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmCmdCall>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmCmdCall>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmCmdCall>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdCall>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmCmdCall>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdCall>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTCmdCall", {InstanceMethod("getKind", &ImmIdTCmdCall::getKind),
                                                             InstanceMethod("is", &ImmIdTCmdCall::is),
                                                             InstanceMethod("getNodeIndex", &ImmIdTCmdCall::getNodeIndex),
                                                             InstanceMethod("getReadableId", &ImmIdTCmdCall::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTCmdCall", func);
    return exports;
  }
  ImmIdTCmdCall(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTCmdCall>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmCmdCall>>();
  }
  ImmIdTCmdCall(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmCmdCall>> const& ptr) : Napi::ObjectWrap<ImmIdTCmdCall>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmCmdCall>> _stored;
  org::imm::ImmIdT<org::imm::ImmCmdCall>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTCmdCall> {
  using type = org::imm::ImmIdT<org::imm::ImmCmdCall>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmCmdCall>> {
  using type = ImmIdTCmdCall;
};

struct ImmIdTCmdTblfm : public Napi::ObjectWrap<ImmIdTCmdTblfm> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmCmdTblfm>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdTblfm>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmCmdTblfm>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmCmdTblfm>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmCmdTblfm>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdTblfm>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmCmdTblfm>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdTblfm>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTCmdTblfm", {InstanceMethod("getKind", &ImmIdTCmdTblfm::getKind),
                                                              InstanceMethod("is", &ImmIdTCmdTblfm::is),
                                                              InstanceMethod("getNodeIndex", &ImmIdTCmdTblfm::getNodeIndex),
                                                              InstanceMethod("getReadableId", &ImmIdTCmdTblfm::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTCmdTblfm", func);
    return exports;
  }
  ImmIdTCmdTblfm(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTCmdTblfm>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmCmdTblfm>>();
  }
  ImmIdTCmdTblfm(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmCmdTblfm>> const& ptr) : Napi::ObjectWrap<ImmIdTCmdTblfm>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmCmdTblfm>> _stored;
  org::imm::ImmIdT<org::imm::ImmCmdTblfm>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTCmdTblfm> {
  using type = org::imm::ImmIdT<org::imm::ImmCmdTblfm>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmCmdTblfm>> {
  using type = ImmIdTCmdTblfm;
};

struct ImmIdTHashTag : public Napi::ObjectWrap<ImmIdTHashTag> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmHashTag>::*)() const>(&org::imm::ImmIdT<org::imm::ImmHashTag>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmHashTag>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmHashTag>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmHashTag>::*)() const>(&org::imm::ImmIdT<org::imm::ImmHashTag>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmHashTag>::*)() const>(&org::imm::ImmIdT<org::imm::ImmHashTag>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTHashTag", {InstanceMethod("getKind", &ImmIdTHashTag::getKind),
                                                             InstanceMethod("is", &ImmIdTHashTag::is),
                                                             InstanceMethod("getNodeIndex", &ImmIdTHashTag::getNodeIndex),
                                                             InstanceMethod("getReadableId", &ImmIdTHashTag::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTHashTag", func);
    return exports;
  }
  ImmIdTHashTag(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTHashTag>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmHashTag>>();
  }
  ImmIdTHashTag(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmHashTag>> const& ptr) : Napi::ObjectWrap<ImmIdTHashTag>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmHashTag>> _stored;
  org::imm::ImmIdT<org::imm::ImmHashTag>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTHashTag> {
  using type = org::imm::ImmIdT<org::imm::ImmHashTag>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmHashTag>> {
  using type = ImmIdTHashTag;
};

struct ImmIdTInlineFootnote : public Napi::ObjectWrap<ImmIdTInlineFootnote> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmInlineFootnote>::*)() const>(&org::imm::ImmIdT<org::imm::ImmInlineFootnote>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmInlineFootnote>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmInlineFootnote>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmInlineFootnote>::*)() const>(&org::imm::ImmIdT<org::imm::ImmInlineFootnote>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmInlineFootnote>::*)() const>(&org::imm::ImmIdT<org::imm::ImmInlineFootnote>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTInlineFootnote", {InstanceMethod("getKind", &ImmIdTInlineFootnote::getKind),
                                                                    InstanceMethod("is", &ImmIdTInlineFootnote::is),
                                                                    InstanceMethod("getNodeIndex", &ImmIdTInlineFootnote::getNodeIndex),
                                                                    InstanceMethod("getReadableId", &ImmIdTInlineFootnote::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTInlineFootnote", func);
    return exports;
  }
  ImmIdTInlineFootnote(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTInlineFootnote>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmInlineFootnote>>();
  }
  ImmIdTInlineFootnote(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmInlineFootnote>> const& ptr) : Napi::ObjectWrap<ImmIdTInlineFootnote>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmInlineFootnote>> _stored;
  org::imm::ImmIdT<org::imm::ImmInlineFootnote>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTInlineFootnote> {
  using type = org::imm::ImmIdT<org::imm::ImmInlineFootnote>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmInlineFootnote>> {
  using type = ImmIdTInlineFootnote;
};

struct ImmIdTInlineExport : public Napi::ObjectWrap<ImmIdTInlineExport> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmInlineExport>::*)() const>(&org::imm::ImmIdT<org::imm::ImmInlineExport>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmInlineExport>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmInlineExport>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmInlineExport>::*)() const>(&org::imm::ImmIdT<org::imm::ImmInlineExport>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmInlineExport>::*)() const>(&org::imm::ImmIdT<org::imm::ImmInlineExport>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTInlineExport", {InstanceMethod("getKind", &ImmIdTInlineExport::getKind),
                                                                  InstanceMethod("is", &ImmIdTInlineExport::is),
                                                                  InstanceMethod("getNodeIndex", &ImmIdTInlineExport::getNodeIndex),
                                                                  InstanceMethod("getReadableId", &ImmIdTInlineExport::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTInlineExport", func);
    return exports;
  }
  ImmIdTInlineExport(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTInlineExport>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmInlineExport>>();
  }
  ImmIdTInlineExport(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmInlineExport>> const& ptr) : Napi::ObjectWrap<ImmIdTInlineExport>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmInlineExport>> _stored;
  org::imm::ImmIdT<org::imm::ImmInlineExport>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTInlineExport> {
  using type = org::imm::ImmIdT<org::imm::ImmInlineExport>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmInlineExport>> {
  using type = ImmIdTInlineExport;
};

struct ImmIdTTime : public Napi::ObjectWrap<ImmIdTTime> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmTime>::*)() const>(&org::imm::ImmIdT<org::imm::ImmTime>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmTime>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmTime>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmTime>::*)() const>(&org::imm::ImmIdT<org::imm::ImmTime>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmTime>::*)() const>(&org::imm::ImmIdT<org::imm::ImmTime>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTTime", {InstanceMethod("getKind", &ImmIdTTime::getKind),
                                                          InstanceMethod("is", &ImmIdTTime::is),
                                                          InstanceMethod("getNodeIndex", &ImmIdTTime::getNodeIndex),
                                                          InstanceMethod("getReadableId", &ImmIdTTime::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTTime", func);
    return exports;
  }
  ImmIdTTime(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTTime>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmTime>>();
  }
  ImmIdTTime(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmTime>> const& ptr) : Napi::ObjectWrap<ImmIdTTime>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmTime>> _stored;
  org::imm::ImmIdT<org::imm::ImmTime>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTTime> {
  using type = org::imm::ImmIdT<org::imm::ImmTime>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmTime>> {
  using type = ImmIdTTime;
};

struct ImmIdTTimeRange : public Napi::ObjectWrap<ImmIdTTimeRange> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmTimeRange>::*)() const>(&org::imm::ImmIdT<org::imm::ImmTimeRange>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmTimeRange>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmTimeRange>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmTimeRange>::*)() const>(&org::imm::ImmIdT<org::imm::ImmTimeRange>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmTimeRange>::*)() const>(&org::imm::ImmIdT<org::imm::ImmTimeRange>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTTimeRange", {InstanceMethod("getKind", &ImmIdTTimeRange::getKind),
                                                               InstanceMethod("is", &ImmIdTTimeRange::is),
                                                               InstanceMethod("getNodeIndex", &ImmIdTTimeRange::getNodeIndex),
                                                               InstanceMethod("getReadableId", &ImmIdTTimeRange::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTTimeRange", func);
    return exports;
  }
  ImmIdTTimeRange(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTTimeRange>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmTimeRange>>();
  }
  ImmIdTTimeRange(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmTimeRange>> const& ptr) : Napi::ObjectWrap<ImmIdTTimeRange>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmTimeRange>> _stored;
  org::imm::ImmIdT<org::imm::ImmTimeRange>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTTimeRange> {
  using type = org::imm::ImmIdT<org::imm::ImmTimeRange>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmTimeRange>> {
  using type = ImmIdTTimeRange;
};

struct ImmIdTMacro : public Napi::ObjectWrap<ImmIdTMacro> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmMacro>::*)() const>(&org::imm::ImmIdT<org::imm::ImmMacro>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmMacro>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmMacro>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmMacro>::*)() const>(&org::imm::ImmIdT<org::imm::ImmMacro>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmMacro>::*)() const>(&org::imm::ImmIdT<org::imm::ImmMacro>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTMacro", {InstanceMethod("getKind", &ImmIdTMacro::getKind),
                                                           InstanceMethod("is", &ImmIdTMacro::is),
                                                           InstanceMethod("getNodeIndex", &ImmIdTMacro::getNodeIndex),
                                                           InstanceMethod("getReadableId", &ImmIdTMacro::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTMacro", func);
    return exports;
  }
  ImmIdTMacro(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTMacro>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmMacro>>();
  }
  ImmIdTMacro(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmMacro>> const& ptr) : Napi::ObjectWrap<ImmIdTMacro>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmMacro>> _stored;
  org::imm::ImmIdT<org::imm::ImmMacro>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTMacro> {
  using type = org::imm::ImmIdT<org::imm::ImmMacro>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmMacro>> {
  using type = ImmIdTMacro;
};

struct ImmIdTSymbol : public Napi::ObjectWrap<ImmIdTSymbol> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmSymbol>::*)() const>(&org::imm::ImmIdT<org::imm::ImmSymbol>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmSymbol>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmSymbol>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmSymbol>::*)() const>(&org::imm::ImmIdT<org::imm::ImmSymbol>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmSymbol>::*)() const>(&org::imm::ImmIdT<org::imm::ImmSymbol>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTSymbol", {InstanceMethod("getKind", &ImmIdTSymbol::getKind),
                                                            InstanceMethod("is", &ImmIdTSymbol::is),
                                                            InstanceMethod("getNodeIndex", &ImmIdTSymbol::getNodeIndex),
                                                            InstanceMethod("getReadableId", &ImmIdTSymbol::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTSymbol", func);
    return exports;
  }
  ImmIdTSymbol(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTSymbol>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmSymbol>>();
  }
  ImmIdTSymbol(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmSymbol>> const& ptr) : Napi::ObjectWrap<ImmIdTSymbol>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmSymbol>> _stored;
  org::imm::ImmIdT<org::imm::ImmSymbol>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTSymbol> {
  using type = org::imm::ImmIdT<org::imm::ImmSymbol>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmSymbol>> {
  using type = ImmIdTSymbol;
};

struct ImmIdTEscaped : public Napi::ObjectWrap<ImmIdTEscaped> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmEscaped>::*)() const>(&org::imm::ImmIdT<org::imm::ImmEscaped>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmEscaped>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmEscaped>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmEscaped>::*)() const>(&org::imm::ImmIdT<org::imm::ImmEscaped>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmEscaped>::*)() const>(&org::imm::ImmIdT<org::imm::ImmEscaped>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTEscaped", {InstanceMethod("getKind", &ImmIdTEscaped::getKind),
                                                             InstanceMethod("is", &ImmIdTEscaped::is),
                                                             InstanceMethod("getNodeIndex", &ImmIdTEscaped::getNodeIndex),
                                                             InstanceMethod("getReadableId", &ImmIdTEscaped::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTEscaped", func);
    return exports;
  }
  ImmIdTEscaped(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTEscaped>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmEscaped>>();
  }
  ImmIdTEscaped(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmEscaped>> const& ptr) : Napi::ObjectWrap<ImmIdTEscaped>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmEscaped>> _stored;
  org::imm::ImmIdT<org::imm::ImmEscaped>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTEscaped> {
  using type = org::imm::ImmIdT<org::imm::ImmEscaped>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmEscaped>> {
  using type = ImmIdTEscaped;
};

struct ImmIdTNewline : public Napi::ObjectWrap<ImmIdTNewline> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmNewline>::*)() const>(&org::imm::ImmIdT<org::imm::ImmNewline>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmNewline>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmNewline>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmNewline>::*)() const>(&org::imm::ImmIdT<org::imm::ImmNewline>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmNewline>::*)() const>(&org::imm::ImmIdT<org::imm::ImmNewline>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTNewline", {InstanceMethod("getKind", &ImmIdTNewline::getKind),
                                                             InstanceMethod("is", &ImmIdTNewline::is),
                                                             InstanceMethod("getNodeIndex", &ImmIdTNewline::getNodeIndex),
                                                             InstanceMethod("getReadableId", &ImmIdTNewline::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTNewline", func);
    return exports;
  }
  ImmIdTNewline(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTNewline>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmNewline>>();
  }
  ImmIdTNewline(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmNewline>> const& ptr) : Napi::ObjectWrap<ImmIdTNewline>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmNewline>> _stored;
  org::imm::ImmIdT<org::imm::ImmNewline>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTNewline> {
  using type = org::imm::ImmIdT<org::imm::ImmNewline>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmNewline>> {
  using type = ImmIdTNewline;
};

struct ImmIdTSpace : public Napi::ObjectWrap<ImmIdTSpace> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmSpace>::*)() const>(&org::imm::ImmIdT<org::imm::ImmSpace>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmSpace>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmSpace>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmSpace>::*)() const>(&org::imm::ImmIdT<org::imm::ImmSpace>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmSpace>::*)() const>(&org::imm::ImmIdT<org::imm::ImmSpace>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTSpace", {InstanceMethod("getKind", &ImmIdTSpace::getKind),
                                                           InstanceMethod("is", &ImmIdTSpace::is),
                                                           InstanceMethod("getNodeIndex", &ImmIdTSpace::getNodeIndex),
                                                           InstanceMethod("getReadableId", &ImmIdTSpace::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTSpace", func);
    return exports;
  }
  ImmIdTSpace(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTSpace>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmSpace>>();
  }
  ImmIdTSpace(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmSpace>> const& ptr) : Napi::ObjectWrap<ImmIdTSpace>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmSpace>> _stored;
  org::imm::ImmIdT<org::imm::ImmSpace>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTSpace> {
  using type = org::imm::ImmIdT<org::imm::ImmSpace>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmSpace>> {
  using type = ImmIdTSpace;
};

struct ImmIdTWord : public Napi::ObjectWrap<ImmIdTWord> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmWord>::*)() const>(&org::imm::ImmIdT<org::imm::ImmWord>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmWord>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmWord>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmWord>::*)() const>(&org::imm::ImmIdT<org::imm::ImmWord>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmWord>::*)() const>(&org::imm::ImmIdT<org::imm::ImmWord>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTWord", {InstanceMethod("getKind", &ImmIdTWord::getKind),
                                                          InstanceMethod("is", &ImmIdTWord::is),
                                                          InstanceMethod("getNodeIndex", &ImmIdTWord::getNodeIndex),
                                                          InstanceMethod("getReadableId", &ImmIdTWord::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTWord", func);
    return exports;
  }
  ImmIdTWord(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTWord>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmWord>>();
  }
  ImmIdTWord(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmWord>> const& ptr) : Napi::ObjectWrap<ImmIdTWord>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmWord>> _stored;
  org::imm::ImmIdT<org::imm::ImmWord>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTWord> {
  using type = org::imm::ImmIdT<org::imm::ImmWord>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmWord>> {
  using type = ImmIdTWord;
};

struct ImmIdTAtMention : public Napi::ObjectWrap<ImmIdTAtMention> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmAtMention>::*)() const>(&org::imm::ImmIdT<org::imm::ImmAtMention>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmAtMention>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmAtMention>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmAtMention>::*)() const>(&org::imm::ImmIdT<org::imm::ImmAtMention>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmAtMention>::*)() const>(&org::imm::ImmIdT<org::imm::ImmAtMention>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTAtMention", {InstanceMethod("getKind", &ImmIdTAtMention::getKind),
                                                               InstanceMethod("is", &ImmIdTAtMention::is),
                                                               InstanceMethod("getNodeIndex", &ImmIdTAtMention::getNodeIndex),
                                                               InstanceMethod("getReadableId", &ImmIdTAtMention::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTAtMention", func);
    return exports;
  }
  ImmIdTAtMention(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTAtMention>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmAtMention>>();
  }
  ImmIdTAtMention(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmAtMention>> const& ptr) : Napi::ObjectWrap<ImmIdTAtMention>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmAtMention>> _stored;
  org::imm::ImmIdT<org::imm::ImmAtMention>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTAtMention> {
  using type = org::imm::ImmIdT<org::imm::ImmAtMention>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmAtMention>> {
  using type = ImmIdTAtMention;
};

struct ImmIdTRawText : public Napi::ObjectWrap<ImmIdTRawText> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmRawText>::*)() const>(&org::imm::ImmIdT<org::imm::ImmRawText>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmRawText>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmRawText>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmRawText>::*)() const>(&org::imm::ImmIdT<org::imm::ImmRawText>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmRawText>::*)() const>(&org::imm::ImmIdT<org::imm::ImmRawText>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTRawText", {InstanceMethod("getKind", &ImmIdTRawText::getKind),
                                                             InstanceMethod("is", &ImmIdTRawText::is),
                                                             InstanceMethod("getNodeIndex", &ImmIdTRawText::getNodeIndex),
                                                             InstanceMethod("getReadableId", &ImmIdTRawText::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTRawText", func);
    return exports;
  }
  ImmIdTRawText(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTRawText>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmRawText>>();
  }
  ImmIdTRawText(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmRawText>> const& ptr) : Napi::ObjectWrap<ImmIdTRawText>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmRawText>> _stored;
  org::imm::ImmIdT<org::imm::ImmRawText>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTRawText> {
  using type = org::imm::ImmIdT<org::imm::ImmRawText>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmRawText>> {
  using type = ImmIdTRawText;
};

struct ImmIdTPunctuation : public Napi::ObjectWrap<ImmIdTPunctuation> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmPunctuation>::*)() const>(&org::imm::ImmIdT<org::imm::ImmPunctuation>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmPunctuation>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmPunctuation>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmPunctuation>::*)() const>(&org::imm::ImmIdT<org::imm::ImmPunctuation>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmPunctuation>::*)() const>(&org::imm::ImmIdT<org::imm::ImmPunctuation>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTPunctuation", {InstanceMethod("getKind", &ImmIdTPunctuation::getKind),
                                                                 InstanceMethod("is", &ImmIdTPunctuation::is),
                                                                 InstanceMethod("getNodeIndex", &ImmIdTPunctuation::getNodeIndex),
                                                                 InstanceMethod("getReadableId", &ImmIdTPunctuation::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTPunctuation", func);
    return exports;
  }
  ImmIdTPunctuation(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTPunctuation>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmPunctuation>>();
  }
  ImmIdTPunctuation(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmPunctuation>> const& ptr) : Napi::ObjectWrap<ImmIdTPunctuation>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmPunctuation>> _stored;
  org::imm::ImmIdT<org::imm::ImmPunctuation>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTPunctuation> {
  using type = org::imm::ImmIdT<org::imm::ImmPunctuation>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmPunctuation>> {
  using type = ImmIdTPunctuation;
};

struct ImmIdTPlaceholder : public Napi::ObjectWrap<ImmIdTPlaceholder> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmPlaceholder>::*)() const>(&org::imm::ImmIdT<org::imm::ImmPlaceholder>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmPlaceholder>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmPlaceholder>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmPlaceholder>::*)() const>(&org::imm::ImmIdT<org::imm::ImmPlaceholder>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmPlaceholder>::*)() const>(&org::imm::ImmIdT<org::imm::ImmPlaceholder>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTPlaceholder", {InstanceMethod("getKind", &ImmIdTPlaceholder::getKind),
                                                                 InstanceMethod("is", &ImmIdTPlaceholder::is),
                                                                 InstanceMethod("getNodeIndex", &ImmIdTPlaceholder::getNodeIndex),
                                                                 InstanceMethod("getReadableId", &ImmIdTPlaceholder::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTPlaceholder", func);
    return exports;
  }
  ImmIdTPlaceholder(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTPlaceholder>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmPlaceholder>>();
  }
  ImmIdTPlaceholder(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmPlaceholder>> const& ptr) : Napi::ObjectWrap<ImmIdTPlaceholder>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmPlaceholder>> _stored;
  org::imm::ImmIdT<org::imm::ImmPlaceholder>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTPlaceholder> {
  using type = org::imm::ImmIdT<org::imm::ImmPlaceholder>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmPlaceholder>> {
  using type = ImmIdTPlaceholder;
};

struct ImmIdTBigIdent : public Napi::ObjectWrap<ImmIdTBigIdent> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmBigIdent>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBigIdent>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmBigIdent>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmBigIdent>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmBigIdent>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBigIdent>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmBigIdent>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBigIdent>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTBigIdent", {InstanceMethod("getKind", &ImmIdTBigIdent::getKind),
                                                              InstanceMethod("is", &ImmIdTBigIdent::is),
                                                              InstanceMethod("getNodeIndex", &ImmIdTBigIdent::getNodeIndex),
                                                              InstanceMethod("getReadableId", &ImmIdTBigIdent::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTBigIdent", func);
    return exports;
  }
  ImmIdTBigIdent(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTBigIdent>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmBigIdent>>();
  }
  ImmIdTBigIdent(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmBigIdent>> const& ptr) : Napi::ObjectWrap<ImmIdTBigIdent>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmBigIdent>> _stored;
  org::imm::ImmIdT<org::imm::ImmBigIdent>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTBigIdent> {
  using type = org::imm::ImmIdT<org::imm::ImmBigIdent>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmBigIdent>> {
  using type = ImmIdTBigIdent;
};

struct ImmIdTTextTarget : public Napi::ObjectWrap<ImmIdTTextTarget> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmTextTarget>::*)() const>(&org::imm::ImmIdT<org::imm::ImmTextTarget>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmTextTarget>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmTextTarget>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmTextTarget>::*)() const>(&org::imm::ImmIdT<org::imm::ImmTextTarget>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmTextTarget>::*)() const>(&org::imm::ImmIdT<org::imm::ImmTextTarget>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTTextTarget", {InstanceMethod("getKind", &ImmIdTTextTarget::getKind),
                                                                InstanceMethod("is", &ImmIdTTextTarget::is),
                                                                InstanceMethod("getNodeIndex", &ImmIdTTextTarget::getNodeIndex),
                                                                InstanceMethod("getReadableId", &ImmIdTTextTarget::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTTextTarget", func);
    return exports;
  }
  ImmIdTTextTarget(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTTextTarget>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmTextTarget>>();
  }
  ImmIdTTextTarget(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmTextTarget>> const& ptr) : Napi::ObjectWrap<ImmIdTTextTarget>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmTextTarget>> _stored;
  org::imm::ImmIdT<org::imm::ImmTextTarget>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTTextTarget> {
  using type = org::imm::ImmIdT<org::imm::ImmTextTarget>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmTextTarget>> {
  using type = ImmIdTTextTarget;
};

struct ImmIdTMarkup : public Napi::ObjectWrap<ImmIdTMarkup> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmMarkup>::*)() const>(&org::imm::ImmIdT<org::imm::ImmMarkup>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmMarkup>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmMarkup>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmMarkup>::*)() const>(&org::imm::ImmIdT<org::imm::ImmMarkup>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmMarkup>::*)() const>(&org::imm::ImmIdT<org::imm::ImmMarkup>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTMarkup", {InstanceMethod("getKind", &ImmIdTMarkup::getKind),
                                                            InstanceMethod("is", &ImmIdTMarkup::is),
                                                            InstanceMethod("getNodeIndex", &ImmIdTMarkup::getNodeIndex),
                                                            InstanceMethod("getReadableId", &ImmIdTMarkup::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTMarkup", func);
    return exports;
  }
  ImmIdTMarkup(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTMarkup>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmMarkup>>();
  }
  ImmIdTMarkup(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmMarkup>> const& ptr) : Napi::ObjectWrap<ImmIdTMarkup>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmMarkup>> _stored;
  org::imm::ImmIdT<org::imm::ImmMarkup>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTMarkup> {
  using type = org::imm::ImmIdT<org::imm::ImmMarkup>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmMarkup>> {
  using type = ImmIdTMarkup;
};

struct ImmIdTBold : public Napi::ObjectWrap<ImmIdTBold> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmBold>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBold>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmBold>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmBold>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmBold>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBold>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmBold>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBold>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTBold", {InstanceMethod("getKind", &ImmIdTBold::getKind),
                                                          InstanceMethod("is", &ImmIdTBold::is),
                                                          InstanceMethod("getNodeIndex", &ImmIdTBold::getNodeIndex),
                                                          InstanceMethod("getReadableId", &ImmIdTBold::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTBold", func);
    return exports;
  }
  ImmIdTBold(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTBold>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmBold>>();
  }
  ImmIdTBold(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmBold>> const& ptr) : Napi::ObjectWrap<ImmIdTBold>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmBold>> _stored;
  org::imm::ImmIdT<org::imm::ImmBold>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTBold> {
  using type = org::imm::ImmIdT<org::imm::ImmBold>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmBold>> {
  using type = ImmIdTBold;
};

struct ImmIdTUnderline : public Napi::ObjectWrap<ImmIdTUnderline> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmUnderline>::*)() const>(&org::imm::ImmIdT<org::imm::ImmUnderline>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmUnderline>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmUnderline>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmUnderline>::*)() const>(&org::imm::ImmIdT<org::imm::ImmUnderline>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmUnderline>::*)() const>(&org::imm::ImmIdT<org::imm::ImmUnderline>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTUnderline", {InstanceMethod("getKind", &ImmIdTUnderline::getKind),
                                                               InstanceMethod("is", &ImmIdTUnderline::is),
                                                               InstanceMethod("getNodeIndex", &ImmIdTUnderline::getNodeIndex),
                                                               InstanceMethod("getReadableId", &ImmIdTUnderline::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTUnderline", func);
    return exports;
  }
  ImmIdTUnderline(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTUnderline>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmUnderline>>();
  }
  ImmIdTUnderline(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmUnderline>> const& ptr) : Napi::ObjectWrap<ImmIdTUnderline>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmUnderline>> _stored;
  org::imm::ImmIdT<org::imm::ImmUnderline>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTUnderline> {
  using type = org::imm::ImmIdT<org::imm::ImmUnderline>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmUnderline>> {
  using type = ImmIdTUnderline;
};

struct ImmIdTMonospace : public Napi::ObjectWrap<ImmIdTMonospace> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmMonospace>::*)() const>(&org::imm::ImmIdT<org::imm::ImmMonospace>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmMonospace>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmMonospace>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmMonospace>::*)() const>(&org::imm::ImmIdT<org::imm::ImmMonospace>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmMonospace>::*)() const>(&org::imm::ImmIdT<org::imm::ImmMonospace>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTMonospace", {InstanceMethod("getKind", &ImmIdTMonospace::getKind),
                                                               InstanceMethod("is", &ImmIdTMonospace::is),
                                                               InstanceMethod("getNodeIndex", &ImmIdTMonospace::getNodeIndex),
                                                               InstanceMethod("getReadableId", &ImmIdTMonospace::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTMonospace", func);
    return exports;
  }
  ImmIdTMonospace(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTMonospace>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmMonospace>>();
  }
  ImmIdTMonospace(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmMonospace>> const& ptr) : Napi::ObjectWrap<ImmIdTMonospace>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmMonospace>> _stored;
  org::imm::ImmIdT<org::imm::ImmMonospace>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTMonospace> {
  using type = org::imm::ImmIdT<org::imm::ImmMonospace>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmMonospace>> {
  using type = ImmIdTMonospace;
};

struct ImmIdTMarkQuote : public Napi::ObjectWrap<ImmIdTMarkQuote> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmMarkQuote>::*)() const>(&org::imm::ImmIdT<org::imm::ImmMarkQuote>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmMarkQuote>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmMarkQuote>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmMarkQuote>::*)() const>(&org::imm::ImmIdT<org::imm::ImmMarkQuote>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmMarkQuote>::*)() const>(&org::imm::ImmIdT<org::imm::ImmMarkQuote>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTMarkQuote", {InstanceMethod("getKind", &ImmIdTMarkQuote::getKind),
                                                               InstanceMethod("is", &ImmIdTMarkQuote::is),
                                                               InstanceMethod("getNodeIndex", &ImmIdTMarkQuote::getNodeIndex),
                                                               InstanceMethod("getReadableId", &ImmIdTMarkQuote::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTMarkQuote", func);
    return exports;
  }
  ImmIdTMarkQuote(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTMarkQuote>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmMarkQuote>>();
  }
  ImmIdTMarkQuote(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmMarkQuote>> const& ptr) : Napi::ObjectWrap<ImmIdTMarkQuote>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmMarkQuote>> _stored;
  org::imm::ImmIdT<org::imm::ImmMarkQuote>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTMarkQuote> {
  using type = org::imm::ImmIdT<org::imm::ImmMarkQuote>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmMarkQuote>> {
  using type = ImmIdTMarkQuote;
};

struct ImmIdTVerbatim : public Napi::ObjectWrap<ImmIdTVerbatim> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmVerbatim>::*)() const>(&org::imm::ImmIdT<org::imm::ImmVerbatim>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmVerbatim>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmVerbatim>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmVerbatim>::*)() const>(&org::imm::ImmIdT<org::imm::ImmVerbatim>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmVerbatim>::*)() const>(&org::imm::ImmIdT<org::imm::ImmVerbatim>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTVerbatim", {InstanceMethod("getKind", &ImmIdTVerbatim::getKind),
                                                              InstanceMethod("is", &ImmIdTVerbatim::is),
                                                              InstanceMethod("getNodeIndex", &ImmIdTVerbatim::getNodeIndex),
                                                              InstanceMethod("getReadableId", &ImmIdTVerbatim::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTVerbatim", func);
    return exports;
  }
  ImmIdTVerbatim(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTVerbatim>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmVerbatim>>();
  }
  ImmIdTVerbatim(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmVerbatim>> const& ptr) : Napi::ObjectWrap<ImmIdTVerbatim>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmVerbatim>> _stored;
  org::imm::ImmIdT<org::imm::ImmVerbatim>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTVerbatim> {
  using type = org::imm::ImmIdT<org::imm::ImmVerbatim>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmVerbatim>> {
  using type = ImmIdTVerbatim;
};

struct ImmIdTItalic : public Napi::ObjectWrap<ImmIdTItalic> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmItalic>::*)() const>(&org::imm::ImmIdT<org::imm::ImmItalic>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmItalic>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmItalic>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmItalic>::*)() const>(&org::imm::ImmIdT<org::imm::ImmItalic>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmItalic>::*)() const>(&org::imm::ImmIdT<org::imm::ImmItalic>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTItalic", {InstanceMethod("getKind", &ImmIdTItalic::getKind),
                                                            InstanceMethod("is", &ImmIdTItalic::is),
                                                            InstanceMethod("getNodeIndex", &ImmIdTItalic::getNodeIndex),
                                                            InstanceMethod("getReadableId", &ImmIdTItalic::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTItalic", func);
    return exports;
  }
  ImmIdTItalic(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTItalic>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmItalic>>();
  }
  ImmIdTItalic(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmItalic>> const& ptr) : Napi::ObjectWrap<ImmIdTItalic>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmItalic>> _stored;
  org::imm::ImmIdT<org::imm::ImmItalic>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTItalic> {
  using type = org::imm::ImmIdT<org::imm::ImmItalic>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmItalic>> {
  using type = ImmIdTItalic;
};

struct ImmIdTStrike : public Napi::ObjectWrap<ImmIdTStrike> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmStrike>::*)() const>(&org::imm::ImmIdT<org::imm::ImmStrike>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmStrike>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmStrike>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmStrike>::*)() const>(&org::imm::ImmIdT<org::imm::ImmStrike>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmStrike>::*)() const>(&org::imm::ImmIdT<org::imm::ImmStrike>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTStrike", {InstanceMethod("getKind", &ImmIdTStrike::getKind),
                                                            InstanceMethod("is", &ImmIdTStrike::is),
                                                            InstanceMethod("getNodeIndex", &ImmIdTStrike::getNodeIndex),
                                                            InstanceMethod("getReadableId", &ImmIdTStrike::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTStrike", func);
    return exports;
  }
  ImmIdTStrike(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTStrike>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmStrike>>();
  }
  ImmIdTStrike(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmStrike>> const& ptr) : Napi::ObjectWrap<ImmIdTStrike>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmStrike>> _stored;
  org::imm::ImmIdT<org::imm::ImmStrike>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTStrike> {
  using type = org::imm::ImmIdT<org::imm::ImmStrike>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmStrike>> {
  using type = ImmIdTStrike;
};

struct ImmIdTPar : public Napi::ObjectWrap<ImmIdTPar> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmPar>::*)() const>(&org::imm::ImmIdT<org::imm::ImmPar>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmPar>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmPar>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmPar>::*)() const>(&org::imm::ImmIdT<org::imm::ImmPar>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmPar>::*)() const>(&org::imm::ImmIdT<org::imm::ImmPar>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTPar", {InstanceMethod("getKind", &ImmIdTPar::getKind),
                                                         InstanceMethod("is", &ImmIdTPar::is),
                                                         InstanceMethod("getNodeIndex", &ImmIdTPar::getNodeIndex),
                                                         InstanceMethod("getReadableId", &ImmIdTPar::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTPar", func);
    return exports;
  }
  ImmIdTPar(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTPar>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmPar>>();
  }
  ImmIdTPar(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmPar>> const& ptr) : Napi::ObjectWrap<ImmIdTPar>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmPar>> _stored;
  org::imm::ImmIdT<org::imm::ImmPar>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTPar> {
  using type = org::imm::ImmIdT<org::imm::ImmPar>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmPar>> {
  using type = ImmIdTPar;
};

struct ImmIdTRadioTarget : public Napi::ObjectWrap<ImmIdTRadioTarget> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmRadioTarget>::*)() const>(&org::imm::ImmIdT<org::imm::ImmRadioTarget>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmRadioTarget>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmRadioTarget>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmRadioTarget>::*)() const>(&org::imm::ImmIdT<org::imm::ImmRadioTarget>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmRadioTarget>::*)() const>(&org::imm::ImmIdT<org::imm::ImmRadioTarget>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTRadioTarget", {InstanceMethod("getKind", &ImmIdTRadioTarget::getKind),
                                                                 InstanceMethod("is", &ImmIdTRadioTarget::is),
                                                                 InstanceMethod("getNodeIndex", &ImmIdTRadioTarget::getNodeIndex),
                                                                 InstanceMethod("getReadableId", &ImmIdTRadioTarget::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTRadioTarget", func);
    return exports;
  }
  ImmIdTRadioTarget(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTRadioTarget>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmRadioTarget>>();
  }
  ImmIdTRadioTarget(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmRadioTarget>> const& ptr) : Napi::ObjectWrap<ImmIdTRadioTarget>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmRadioTarget>> _stored;
  org::imm::ImmIdT<org::imm::ImmRadioTarget>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTRadioTarget> {
  using type = org::imm::ImmIdT<org::imm::ImmRadioTarget>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmRadioTarget>> {
  using type = ImmIdTRadioTarget;
};

struct ImmIdTLatex : public Napi::ObjectWrap<ImmIdTLatex> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmLatex>::*)() const>(&org::imm::ImmIdT<org::imm::ImmLatex>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmLatex>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmLatex>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmLatex>::*)() const>(&org::imm::ImmIdT<org::imm::ImmLatex>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmLatex>::*)() const>(&org::imm::ImmIdT<org::imm::ImmLatex>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTLatex", {InstanceMethod("getKind", &ImmIdTLatex::getKind),
                                                           InstanceMethod("is", &ImmIdTLatex::is),
                                                           InstanceMethod("getNodeIndex", &ImmIdTLatex::getNodeIndex),
                                                           InstanceMethod("getReadableId", &ImmIdTLatex::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTLatex", func);
    return exports;
  }
  ImmIdTLatex(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTLatex>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmLatex>>();
  }
  ImmIdTLatex(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmLatex>> const& ptr) : Napi::ObjectWrap<ImmIdTLatex>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmLatex>> _stored;
  org::imm::ImmIdT<org::imm::ImmLatex>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTLatex> {
  using type = org::imm::ImmIdT<org::imm::ImmLatex>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmLatex>> {
  using type = ImmIdTLatex;
};

struct ImmIdTLink : public Napi::ObjectWrap<ImmIdTLink> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmLink>::*)() const>(&org::imm::ImmIdT<org::imm::ImmLink>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmLink>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmLink>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmLink>::*)() const>(&org::imm::ImmIdT<org::imm::ImmLink>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmLink>::*)() const>(&org::imm::ImmIdT<org::imm::ImmLink>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTLink", {InstanceMethod("getKind", &ImmIdTLink::getKind),
                                                          InstanceMethod("is", &ImmIdTLink::is),
                                                          InstanceMethod("getNodeIndex", &ImmIdTLink::getNodeIndex),
                                                          InstanceMethod("getReadableId", &ImmIdTLink::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTLink", func);
    return exports;
  }
  ImmIdTLink(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTLink>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmLink>>();
  }
  ImmIdTLink(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmLink>> const& ptr) : Napi::ObjectWrap<ImmIdTLink>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmLink>> _stored;
  org::imm::ImmIdT<org::imm::ImmLink>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTLink> {
  using type = org::imm::ImmIdT<org::imm::ImmLink>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmLink>> {
  using type = ImmIdTLink;
};

struct ImmIdTBlockCenter : public Napi::ObjectWrap<ImmIdTBlockCenter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmBlockCenter>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockCenter>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmBlockCenter>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmBlockCenter>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmBlockCenter>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockCenter>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmBlockCenter>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockCenter>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTBlockCenter", {InstanceMethod("getKind", &ImmIdTBlockCenter::getKind),
                                                                 InstanceMethod("is", &ImmIdTBlockCenter::is),
                                                                 InstanceMethod("getNodeIndex", &ImmIdTBlockCenter::getNodeIndex),
                                                                 InstanceMethod("getReadableId", &ImmIdTBlockCenter::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTBlockCenter", func);
    return exports;
  }
  ImmIdTBlockCenter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTBlockCenter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmBlockCenter>>();
  }
  ImmIdTBlockCenter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmBlockCenter>> const& ptr) : Napi::ObjectWrap<ImmIdTBlockCenter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmBlockCenter>> _stored;
  org::imm::ImmIdT<org::imm::ImmBlockCenter>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTBlockCenter> {
  using type = org::imm::ImmIdT<org::imm::ImmBlockCenter>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmBlockCenter>> {
  using type = ImmIdTBlockCenter;
};

struct ImmIdTBlockQuote : public Napi::ObjectWrap<ImmIdTBlockQuote> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmBlockQuote>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockQuote>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmBlockQuote>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmBlockQuote>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmBlockQuote>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockQuote>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmBlockQuote>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockQuote>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTBlockQuote", {InstanceMethod("getKind", &ImmIdTBlockQuote::getKind),
                                                                InstanceMethod("is", &ImmIdTBlockQuote::is),
                                                                InstanceMethod("getNodeIndex", &ImmIdTBlockQuote::getNodeIndex),
                                                                InstanceMethod("getReadableId", &ImmIdTBlockQuote::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTBlockQuote", func);
    return exports;
  }
  ImmIdTBlockQuote(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTBlockQuote>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmBlockQuote>>();
  }
  ImmIdTBlockQuote(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmBlockQuote>> const& ptr) : Napi::ObjectWrap<ImmIdTBlockQuote>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmBlockQuote>> _stored;
  org::imm::ImmIdT<org::imm::ImmBlockQuote>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTBlockQuote> {
  using type = org::imm::ImmIdT<org::imm::ImmBlockQuote>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmBlockQuote>> {
  using type = ImmIdTBlockQuote;
};

struct ImmIdTBlockComment : public Napi::ObjectWrap<ImmIdTBlockComment> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmBlockComment>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockComment>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmBlockComment>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmBlockComment>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmBlockComment>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockComment>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmBlockComment>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockComment>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTBlockComment", {InstanceMethod("getKind", &ImmIdTBlockComment::getKind),
                                                                  InstanceMethod("is", &ImmIdTBlockComment::is),
                                                                  InstanceMethod("getNodeIndex", &ImmIdTBlockComment::getNodeIndex),
                                                                  InstanceMethod("getReadableId", &ImmIdTBlockComment::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTBlockComment", func);
    return exports;
  }
  ImmIdTBlockComment(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTBlockComment>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmBlockComment>>();
  }
  ImmIdTBlockComment(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmBlockComment>> const& ptr) : Napi::ObjectWrap<ImmIdTBlockComment>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmBlockComment>> _stored;
  org::imm::ImmIdT<org::imm::ImmBlockComment>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTBlockComment> {
  using type = org::imm::ImmIdT<org::imm::ImmBlockComment>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmBlockComment>> {
  using type = ImmIdTBlockComment;
};

struct ImmIdTBlockVerse : public Napi::ObjectWrap<ImmIdTBlockVerse> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmBlockVerse>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockVerse>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmBlockVerse>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmBlockVerse>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmBlockVerse>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockVerse>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmBlockVerse>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockVerse>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTBlockVerse", {InstanceMethod("getKind", &ImmIdTBlockVerse::getKind),
                                                                InstanceMethod("is", &ImmIdTBlockVerse::is),
                                                                InstanceMethod("getNodeIndex", &ImmIdTBlockVerse::getNodeIndex),
                                                                InstanceMethod("getReadableId", &ImmIdTBlockVerse::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTBlockVerse", func);
    return exports;
  }
  ImmIdTBlockVerse(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTBlockVerse>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmBlockVerse>>();
  }
  ImmIdTBlockVerse(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmBlockVerse>> const& ptr) : Napi::ObjectWrap<ImmIdTBlockVerse>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmBlockVerse>> _stored;
  org::imm::ImmIdT<org::imm::ImmBlockVerse>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTBlockVerse> {
  using type = org::imm::ImmIdT<org::imm::ImmBlockVerse>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmBlockVerse>> {
  using type = ImmIdTBlockVerse;
};

struct ImmIdTBlockDynamicFallback : public Napi::ObjectWrap<ImmIdTBlockDynamicFallback> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmBlockDynamicFallback>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockDynamicFallback>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmBlockDynamicFallback>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmBlockDynamicFallback>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmBlockDynamicFallback>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockDynamicFallback>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmBlockDynamicFallback>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockDynamicFallback>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTBlockDynamicFallback", {InstanceMethod("getKind", &ImmIdTBlockDynamicFallback::getKind),
                                                                          InstanceMethod("is", &ImmIdTBlockDynamicFallback::is),
                                                                          InstanceMethod("getNodeIndex", &ImmIdTBlockDynamicFallback::getNodeIndex),
                                                                          InstanceMethod("getReadableId", &ImmIdTBlockDynamicFallback::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTBlockDynamicFallback", func);
    return exports;
  }
  ImmIdTBlockDynamicFallback(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTBlockDynamicFallback>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmBlockDynamicFallback>>();
  }
  ImmIdTBlockDynamicFallback(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmBlockDynamicFallback>> const& ptr) : Napi::ObjectWrap<ImmIdTBlockDynamicFallback>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmBlockDynamicFallback>> _stored;
  org::imm::ImmIdT<org::imm::ImmBlockDynamicFallback>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTBlockDynamicFallback> {
  using type = org::imm::ImmIdT<org::imm::ImmBlockDynamicFallback>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmBlockDynamicFallback>> {
  using type = ImmIdTBlockDynamicFallback;
};

struct ImmIdTBlockExample : public Napi::ObjectWrap<ImmIdTBlockExample> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmBlockExample>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockExample>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmBlockExample>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmBlockExample>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmBlockExample>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockExample>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmBlockExample>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockExample>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTBlockExample", {InstanceMethod("getKind", &ImmIdTBlockExample::getKind),
                                                                  InstanceMethod("is", &ImmIdTBlockExample::is),
                                                                  InstanceMethod("getNodeIndex", &ImmIdTBlockExample::getNodeIndex),
                                                                  InstanceMethod("getReadableId", &ImmIdTBlockExample::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTBlockExample", func);
    return exports;
  }
  ImmIdTBlockExample(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTBlockExample>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmBlockExample>>();
  }
  ImmIdTBlockExample(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmBlockExample>> const& ptr) : Napi::ObjectWrap<ImmIdTBlockExample>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmBlockExample>> _stored;
  org::imm::ImmIdT<org::imm::ImmBlockExample>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTBlockExample> {
  using type = org::imm::ImmIdT<org::imm::ImmBlockExample>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmBlockExample>> {
  using type = ImmIdTBlockExample;
};

struct ImmIdTBlockExport : public Napi::ObjectWrap<ImmIdTBlockExport> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmBlockExport>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockExport>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmBlockExport>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmBlockExport>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmBlockExport>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockExport>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmBlockExport>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockExport>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTBlockExport", {InstanceMethod("getKind", &ImmIdTBlockExport::getKind),
                                                                 InstanceMethod("is", &ImmIdTBlockExport::is),
                                                                 InstanceMethod("getNodeIndex", &ImmIdTBlockExport::getNodeIndex),
                                                                 InstanceMethod("getReadableId", &ImmIdTBlockExport::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTBlockExport", func);
    return exports;
  }
  ImmIdTBlockExport(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTBlockExport>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmBlockExport>>();
  }
  ImmIdTBlockExport(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmBlockExport>> const& ptr) : Napi::ObjectWrap<ImmIdTBlockExport>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmBlockExport>> _stored;
  org::imm::ImmIdT<org::imm::ImmBlockExport>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTBlockExport> {
  using type = org::imm::ImmIdT<org::imm::ImmBlockExport>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmBlockExport>> {
  using type = ImmIdTBlockExport;
};

struct ImmIdTBlockAdmonition : public Napi::ObjectWrap<ImmIdTBlockAdmonition> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmBlockAdmonition>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockAdmonition>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmBlockAdmonition>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmBlockAdmonition>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmBlockAdmonition>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockAdmonition>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmBlockAdmonition>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockAdmonition>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTBlockAdmonition", {InstanceMethod("getKind", &ImmIdTBlockAdmonition::getKind),
                                                                     InstanceMethod("is", &ImmIdTBlockAdmonition::is),
                                                                     InstanceMethod("getNodeIndex", &ImmIdTBlockAdmonition::getNodeIndex),
                                                                     InstanceMethod("getReadableId", &ImmIdTBlockAdmonition::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTBlockAdmonition", func);
    return exports;
  }
  ImmIdTBlockAdmonition(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTBlockAdmonition>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmBlockAdmonition>>();
  }
  ImmIdTBlockAdmonition(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmBlockAdmonition>> const& ptr) : Napi::ObjectWrap<ImmIdTBlockAdmonition>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmBlockAdmonition>> _stored;
  org::imm::ImmIdT<org::imm::ImmBlockAdmonition>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTBlockAdmonition> {
  using type = org::imm::ImmIdT<org::imm::ImmBlockAdmonition>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmBlockAdmonition>> {
  using type = ImmIdTBlockAdmonition;
};

struct ImmIdTBlockCodeEvalResult : public Napi::ObjectWrap<ImmIdTBlockCodeEvalResult> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTBlockCodeEvalResult", {InstanceMethod("getKind", &ImmIdTBlockCodeEvalResult::getKind),
                                                                         InstanceMethod("is", &ImmIdTBlockCodeEvalResult::is),
                                                                         InstanceMethod("getNodeIndex", &ImmIdTBlockCodeEvalResult::getNodeIndex),
                                                                         InstanceMethod("getReadableId", &ImmIdTBlockCodeEvalResult::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTBlockCodeEvalResult", func);
    return exports;
  }
  ImmIdTBlockCodeEvalResult(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTBlockCodeEvalResult>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>>();
  }
  ImmIdTBlockCodeEvalResult(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>> const& ptr) : Napi::ObjectWrap<ImmIdTBlockCodeEvalResult>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>> _stored;
  org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTBlockCodeEvalResult> {
  using type = org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>> {
  using type = ImmIdTBlockCodeEvalResult;
};

struct ImmIdTBlockCode : public Napi::ObjectWrap<ImmIdTBlockCode> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmBlockCode>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockCode>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmBlockCode>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmBlockCode>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmBlockCode>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockCode>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmBlockCode>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockCode>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTBlockCode", {InstanceMethod("getKind", &ImmIdTBlockCode::getKind),
                                                               InstanceMethod("is", &ImmIdTBlockCode::is),
                                                               InstanceMethod("getNodeIndex", &ImmIdTBlockCode::getNodeIndex),
                                                               InstanceMethod("getReadableId", &ImmIdTBlockCode::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTBlockCode", func);
    return exports;
  }
  ImmIdTBlockCode(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTBlockCode>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmBlockCode>>();
  }
  ImmIdTBlockCode(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmBlockCode>> const& ptr) : Napi::ObjectWrap<ImmIdTBlockCode>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmBlockCode>> _stored;
  org::imm::ImmIdT<org::imm::ImmBlockCode>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTBlockCode> {
  using type = org::imm::ImmIdT<org::imm::ImmBlockCode>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmBlockCode>> {
  using type = ImmIdTBlockCode;
};

struct ImmIdTSubtreeLog : public Napi::ObjectWrap<ImmIdTSubtreeLog> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmSubtreeLog>::*)() const>(&org::imm::ImmIdT<org::imm::ImmSubtreeLog>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmSubtreeLog>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmSubtreeLog>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmSubtreeLog>::*)() const>(&org::imm::ImmIdT<org::imm::ImmSubtreeLog>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmSubtreeLog>::*)() const>(&org::imm::ImmIdT<org::imm::ImmSubtreeLog>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTSubtreeLog", {InstanceMethod("getKind", &ImmIdTSubtreeLog::getKind),
                                                                InstanceMethod("is", &ImmIdTSubtreeLog::is),
                                                                InstanceMethod("getNodeIndex", &ImmIdTSubtreeLog::getNodeIndex),
                                                                InstanceMethod("getReadableId", &ImmIdTSubtreeLog::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTSubtreeLog", func);
    return exports;
  }
  ImmIdTSubtreeLog(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTSubtreeLog>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmSubtreeLog>>();
  }
  ImmIdTSubtreeLog(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmSubtreeLog>> const& ptr) : Napi::ObjectWrap<ImmIdTSubtreeLog>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmSubtreeLog>> _stored;
  org::imm::ImmIdT<org::imm::ImmSubtreeLog>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTSubtreeLog> {
  using type = org::imm::ImmIdT<org::imm::ImmSubtreeLog>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmSubtreeLog>> {
  using type = ImmIdTSubtreeLog;
};

struct ImmIdTSubtree : public Napi::ObjectWrap<ImmIdTSubtree> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmSubtree>::*)() const>(&org::imm::ImmIdT<org::imm::ImmSubtree>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmSubtree>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmSubtree>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmSubtree>::*)() const>(&org::imm::ImmIdT<org::imm::ImmSubtree>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmSubtree>::*)() const>(&org::imm::ImmIdT<org::imm::ImmSubtree>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTSubtree", {InstanceMethod("getKind", &ImmIdTSubtree::getKind),
                                                             InstanceMethod("is", &ImmIdTSubtree::is),
                                                             InstanceMethod("getNodeIndex", &ImmIdTSubtree::getNodeIndex),
                                                             InstanceMethod("getReadableId", &ImmIdTSubtree::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTSubtree", func);
    return exports;
  }
  ImmIdTSubtree(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTSubtree>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmSubtree>>();
  }
  ImmIdTSubtree(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmSubtree>> const& ptr) : Napi::ObjectWrap<ImmIdTSubtree>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmSubtree>> _stored;
  org::imm::ImmIdT<org::imm::ImmSubtree>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTSubtree> {
  using type = org::imm::ImmIdT<org::imm::ImmSubtree>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmSubtree>> {
  using type = ImmIdTSubtree;
};

struct ImmIdTCell : public Napi::ObjectWrap<ImmIdTCell> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmCell>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCell>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmCell>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmCell>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmCell>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCell>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmCell>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCell>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTCell", {InstanceMethod("getKind", &ImmIdTCell::getKind),
                                                          InstanceMethod("is", &ImmIdTCell::is),
                                                          InstanceMethod("getNodeIndex", &ImmIdTCell::getNodeIndex),
                                                          InstanceMethod("getReadableId", &ImmIdTCell::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTCell", func);
    return exports;
  }
  ImmIdTCell(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTCell>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmCell>>();
  }
  ImmIdTCell(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmCell>> const& ptr) : Napi::ObjectWrap<ImmIdTCell>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmCell>> _stored;
  org::imm::ImmIdT<org::imm::ImmCell>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTCell> {
  using type = org::imm::ImmIdT<org::imm::ImmCell>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmCell>> {
  using type = ImmIdTCell;
};

struct ImmIdTRow : public Napi::ObjectWrap<ImmIdTRow> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmRow>::*)() const>(&org::imm::ImmIdT<org::imm::ImmRow>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmRow>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmRow>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmRow>::*)() const>(&org::imm::ImmIdT<org::imm::ImmRow>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmRow>::*)() const>(&org::imm::ImmIdT<org::imm::ImmRow>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTRow", {InstanceMethod("getKind", &ImmIdTRow::getKind),
                                                         InstanceMethod("is", &ImmIdTRow::is),
                                                         InstanceMethod("getNodeIndex", &ImmIdTRow::getNodeIndex),
                                                         InstanceMethod("getReadableId", &ImmIdTRow::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTRow", func);
    return exports;
  }
  ImmIdTRow(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTRow>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmRow>>();
  }
  ImmIdTRow(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmRow>> const& ptr) : Napi::ObjectWrap<ImmIdTRow>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmRow>> _stored;
  org::imm::ImmIdT<org::imm::ImmRow>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTRow> {
  using type = org::imm::ImmIdT<org::imm::ImmRow>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmRow>> {
  using type = ImmIdTRow;
};

struct ImmIdTTable : public Napi::ObjectWrap<ImmIdTTable> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmTable>::*)() const>(&org::imm::ImmIdT<org::imm::ImmTable>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmTable>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmTable>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmTable>::*)() const>(&org::imm::ImmIdT<org::imm::ImmTable>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmTable>::*)() const>(&org::imm::ImmIdT<org::imm::ImmTable>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTTable", {InstanceMethod("getKind", &ImmIdTTable::getKind),
                                                           InstanceMethod("is", &ImmIdTTable::is),
                                                           InstanceMethod("getNodeIndex", &ImmIdTTable::getNodeIndex),
                                                           InstanceMethod("getReadableId", &ImmIdTTable::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTTable", func);
    return exports;
  }
  ImmIdTTable(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTTable>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmTable>>();
  }
  ImmIdTTable(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmTable>> const& ptr) : Napi::ObjectWrap<ImmIdTTable>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmTable>> _stored;
  org::imm::ImmIdT<org::imm::ImmTable>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTTable> {
  using type = org::imm::ImmIdT<org::imm::ImmTable>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmTable>> {
  using type = ImmIdTTable;
};

struct ImmIdTParagraph : public Napi::ObjectWrap<ImmIdTParagraph> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmParagraph>::*)() const>(&org::imm::ImmIdT<org::imm::ImmParagraph>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmParagraph>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmParagraph>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmParagraph>::*)() const>(&org::imm::ImmIdT<org::imm::ImmParagraph>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmParagraph>::*)() const>(&org::imm::ImmIdT<org::imm::ImmParagraph>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTParagraph", {InstanceMethod("getKind", &ImmIdTParagraph::getKind),
                                                               InstanceMethod("is", &ImmIdTParagraph::is),
                                                               InstanceMethod("getNodeIndex", &ImmIdTParagraph::getNodeIndex),
                                                               InstanceMethod("getReadableId", &ImmIdTParagraph::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTParagraph", func);
    return exports;
  }
  ImmIdTParagraph(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTParagraph>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmParagraph>>();
  }
  ImmIdTParagraph(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmParagraph>> const& ptr) : Napi::ObjectWrap<ImmIdTParagraph>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmParagraph>> _stored;
  org::imm::ImmIdT<org::imm::ImmParagraph>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTParagraph> {
  using type = org::imm::ImmIdT<org::imm::ImmParagraph>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmParagraph>> {
  using type = ImmIdTParagraph;
};

struct ImmIdTColonExample : public Napi::ObjectWrap<ImmIdTColonExample> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmColonExample>::*)() const>(&org::imm::ImmIdT<org::imm::ImmColonExample>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmColonExample>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmColonExample>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmColonExample>::*)() const>(&org::imm::ImmIdT<org::imm::ImmColonExample>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmColonExample>::*)() const>(&org::imm::ImmIdT<org::imm::ImmColonExample>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTColonExample", {InstanceMethod("getKind", &ImmIdTColonExample::getKind),
                                                                  InstanceMethod("is", &ImmIdTColonExample::is),
                                                                  InstanceMethod("getNodeIndex", &ImmIdTColonExample::getNodeIndex),
                                                                  InstanceMethod("getReadableId", &ImmIdTColonExample::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTColonExample", func);
    return exports;
  }
  ImmIdTColonExample(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTColonExample>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmColonExample>>();
  }
  ImmIdTColonExample(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmColonExample>> const& ptr) : Napi::ObjectWrap<ImmIdTColonExample>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmColonExample>> _stored;
  org::imm::ImmIdT<org::imm::ImmColonExample>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTColonExample> {
  using type = org::imm::ImmIdT<org::imm::ImmColonExample>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmColonExample>> {
  using type = ImmIdTColonExample;
};

struct ImmIdTCmdAttr : public Napi::ObjectWrap<ImmIdTCmdAttr> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmCmdAttr>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdAttr>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmCmdAttr>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmCmdAttr>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmCmdAttr>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdAttr>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmCmdAttr>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdAttr>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTCmdAttr", {InstanceMethod("getKind", &ImmIdTCmdAttr::getKind),
                                                             InstanceMethod("is", &ImmIdTCmdAttr::is),
                                                             InstanceMethod("getNodeIndex", &ImmIdTCmdAttr::getNodeIndex),
                                                             InstanceMethod("getReadableId", &ImmIdTCmdAttr::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTCmdAttr", func);
    return exports;
  }
  ImmIdTCmdAttr(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTCmdAttr>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmCmdAttr>>();
  }
  ImmIdTCmdAttr(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmCmdAttr>> const& ptr) : Napi::ObjectWrap<ImmIdTCmdAttr>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmCmdAttr>> _stored;
  org::imm::ImmIdT<org::imm::ImmCmdAttr>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTCmdAttr> {
  using type = org::imm::ImmIdT<org::imm::ImmCmdAttr>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmCmdAttr>> {
  using type = ImmIdTCmdAttr;
};

struct ImmIdTCmdExport : public Napi::ObjectWrap<ImmIdTCmdExport> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmCmdExport>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdExport>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmCmdExport>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmCmdExport>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmCmdExport>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdExport>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmCmdExport>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdExport>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTCmdExport", {InstanceMethod("getKind", &ImmIdTCmdExport::getKind),
                                                               InstanceMethod("is", &ImmIdTCmdExport::is),
                                                               InstanceMethod("getNodeIndex", &ImmIdTCmdExport::getNodeIndex),
                                                               InstanceMethod("getReadableId", &ImmIdTCmdExport::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTCmdExport", func);
    return exports;
  }
  ImmIdTCmdExport(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTCmdExport>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmCmdExport>>();
  }
  ImmIdTCmdExport(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmCmdExport>> const& ptr) : Napi::ObjectWrap<ImmIdTCmdExport>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmCmdExport>> _stored;
  org::imm::ImmIdT<org::imm::ImmCmdExport>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTCmdExport> {
  using type = org::imm::ImmIdT<org::imm::ImmCmdExport>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmCmdExport>> {
  using type = ImmIdTCmdExport;
};

struct ImmIdTCall : public Napi::ObjectWrap<ImmIdTCall> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmCall>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCall>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmCall>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmCall>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmCall>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCall>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmCall>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCall>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTCall", {InstanceMethod("getKind", &ImmIdTCall::getKind),
                                                          InstanceMethod("is", &ImmIdTCall::is),
                                                          InstanceMethod("getNodeIndex", &ImmIdTCall::getNodeIndex),
                                                          InstanceMethod("getReadableId", &ImmIdTCall::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTCall", func);
    return exports;
  }
  ImmIdTCall(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTCall>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmCall>>();
  }
  ImmIdTCall(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmCall>> const& ptr) : Napi::ObjectWrap<ImmIdTCall>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmCall>> _stored;
  org::imm::ImmIdT<org::imm::ImmCall>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTCall> {
  using type = org::imm::ImmIdT<org::imm::ImmCall>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmCall>> {
  using type = ImmIdTCall;
};

struct ImmIdTList : public Napi::ObjectWrap<ImmIdTList> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmList>::*)() const>(&org::imm::ImmIdT<org::imm::ImmList>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmList>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmList>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmList>::*)() const>(&org::imm::ImmIdT<org::imm::ImmList>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmList>::*)() const>(&org::imm::ImmIdT<org::imm::ImmList>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTList", {InstanceMethod("getKind", &ImmIdTList::getKind),
                                                          InstanceMethod("is", &ImmIdTList::is),
                                                          InstanceMethod("getNodeIndex", &ImmIdTList::getNodeIndex),
                                                          InstanceMethod("getReadableId", &ImmIdTList::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTList", func);
    return exports;
  }
  ImmIdTList(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTList>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmList>>();
  }
  ImmIdTList(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmList>> const& ptr) : Napi::ObjectWrap<ImmIdTList>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmList>> _stored;
  org::imm::ImmIdT<org::imm::ImmList>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTList> {
  using type = org::imm::ImmIdT<org::imm::ImmList>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmList>> {
  using type = ImmIdTList;
};

struct ImmIdTListItem : public Napi::ObjectWrap<ImmIdTListItem> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmListItem>::*)() const>(&org::imm::ImmIdT<org::imm::ImmListItem>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmListItem>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmListItem>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmListItem>::*)() const>(&org::imm::ImmIdT<org::imm::ImmListItem>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmListItem>::*)() const>(&org::imm::ImmIdT<org::imm::ImmListItem>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTListItem", {InstanceMethod("getKind", &ImmIdTListItem::getKind),
                                                              InstanceMethod("is", &ImmIdTListItem::is),
                                                              InstanceMethod("getNodeIndex", &ImmIdTListItem::getNodeIndex),
                                                              InstanceMethod("getReadableId", &ImmIdTListItem::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTListItem", func);
    return exports;
  }
  ImmIdTListItem(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTListItem>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmListItem>>();
  }
  ImmIdTListItem(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmListItem>> const& ptr) : Napi::ObjectWrap<ImmIdTListItem>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmListItem>> _stored;
  org::imm::ImmIdT<org::imm::ImmListItem>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTListItem> {
  using type = org::imm::ImmIdT<org::imm::ImmListItem>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmListItem>> {
  using type = ImmIdTListItem;
};

struct ImmIdTDocumentOptions : public Napi::ObjectWrap<ImmIdTDocumentOptions> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmDocumentOptions>::*)() const>(&org::imm::ImmIdT<org::imm::ImmDocumentOptions>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmDocumentOptions>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmDocumentOptions>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmDocumentOptions>::*)() const>(&org::imm::ImmIdT<org::imm::ImmDocumentOptions>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmDocumentOptions>::*)() const>(&org::imm::ImmIdT<org::imm::ImmDocumentOptions>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTDocumentOptions", {InstanceMethod("getKind", &ImmIdTDocumentOptions::getKind),
                                                                     InstanceMethod("is", &ImmIdTDocumentOptions::is),
                                                                     InstanceMethod("getNodeIndex", &ImmIdTDocumentOptions::getNodeIndex),
                                                                     InstanceMethod("getReadableId", &ImmIdTDocumentOptions::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTDocumentOptions", func);
    return exports;
  }
  ImmIdTDocumentOptions(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTDocumentOptions>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmDocumentOptions>>();
  }
  ImmIdTDocumentOptions(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmDocumentOptions>> const& ptr) : Napi::ObjectWrap<ImmIdTDocumentOptions>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmDocumentOptions>> _stored;
  org::imm::ImmIdT<org::imm::ImmDocumentOptions>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTDocumentOptions> {
  using type = org::imm::ImmIdT<org::imm::ImmDocumentOptions>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmDocumentOptions>> {
  using type = ImmIdTDocumentOptions;
};

struct ImmIdTDocumentFragment : public Napi::ObjectWrap<ImmIdTDocumentFragment> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmDocumentFragment>::*)() const>(&org::imm::ImmIdT<org::imm::ImmDocumentFragment>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmDocumentFragment>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmDocumentFragment>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmDocumentFragment>::*)() const>(&org::imm::ImmIdT<org::imm::ImmDocumentFragment>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmDocumentFragment>::*)() const>(&org::imm::ImmIdT<org::imm::ImmDocumentFragment>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTDocumentFragment", {InstanceMethod("getKind", &ImmIdTDocumentFragment::getKind),
                                                                      InstanceMethod("is", &ImmIdTDocumentFragment::is),
                                                                      InstanceMethod("getNodeIndex", &ImmIdTDocumentFragment::getNodeIndex),
                                                                      InstanceMethod("getReadableId", &ImmIdTDocumentFragment::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTDocumentFragment", func);
    return exports;
  }
  ImmIdTDocumentFragment(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTDocumentFragment>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmDocumentFragment>>();
  }
  ImmIdTDocumentFragment(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmDocumentFragment>> const& ptr) : Napi::ObjectWrap<ImmIdTDocumentFragment>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmDocumentFragment>> _stored;
  org::imm::ImmIdT<org::imm::ImmDocumentFragment>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTDocumentFragment> {
  using type = org::imm::ImmIdT<org::imm::ImmDocumentFragment>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmDocumentFragment>> {
  using type = ImmIdTDocumentFragment;
};

struct ImmIdTCriticMarkup : public Napi::ObjectWrap<ImmIdTCriticMarkup> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmCriticMarkup>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCriticMarkup>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmCriticMarkup>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmCriticMarkup>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmCriticMarkup>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCriticMarkup>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmCriticMarkup>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCriticMarkup>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTCriticMarkup", {InstanceMethod("getKind", &ImmIdTCriticMarkup::getKind),
                                                                  InstanceMethod("is", &ImmIdTCriticMarkup::is),
                                                                  InstanceMethod("getNodeIndex", &ImmIdTCriticMarkup::getNodeIndex),
                                                                  InstanceMethod("getReadableId", &ImmIdTCriticMarkup::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTCriticMarkup", func);
    return exports;
  }
  ImmIdTCriticMarkup(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTCriticMarkup>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmCriticMarkup>>();
  }
  ImmIdTCriticMarkup(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmCriticMarkup>> const& ptr) : Napi::ObjectWrap<ImmIdTCriticMarkup>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmCriticMarkup>> _stored;
  org::imm::ImmIdT<org::imm::ImmCriticMarkup>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTCriticMarkup> {
  using type = org::imm::ImmIdT<org::imm::ImmCriticMarkup>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmCriticMarkup>> {
  using type = ImmIdTCriticMarkup;
};

struct ImmIdTDocument : public Napi::ObjectWrap<ImmIdTDocument> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmDocument>::*)() const>(&org::imm::ImmIdT<org::imm::ImmDocument>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmDocument>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmDocument>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmDocument>::*)() const>(&org::imm::ImmIdT<org::imm::ImmDocument>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmDocument>::*)() const>(&org::imm::ImmIdT<org::imm::ImmDocument>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTDocument", {InstanceMethod("getKind", &ImmIdTDocument::getKind),
                                                              InstanceMethod("is", &ImmIdTDocument::is),
                                                              InstanceMethod("getNodeIndex", &ImmIdTDocument::getNodeIndex),
                                                              InstanceMethod("getReadableId", &ImmIdTDocument::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTDocument", func);
    return exports;
  }
  ImmIdTDocument(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTDocument>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmDocument>>();
  }
  ImmIdTDocument(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmDocument>> const& ptr) : Napi::ObjectWrap<ImmIdTDocument>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmDocument>> _stored;
  org::imm::ImmIdT<org::imm::ImmDocument>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTDocument> {
  using type = org::imm::ImmIdT<org::imm::ImmDocument>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmDocument>> {
  using type = ImmIdTDocument;
};

struct ImmIdTFileTarget : public Napi::ObjectWrap<ImmIdTFileTarget> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmFileTarget>::*)() const>(&org::imm::ImmIdT<org::imm::ImmFileTarget>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmFileTarget>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmFileTarget>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmFileTarget>::*)() const>(&org::imm::ImmIdT<org::imm::ImmFileTarget>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmFileTarget>::*)() const>(&org::imm::ImmIdT<org::imm::ImmFileTarget>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTFileTarget", {InstanceMethod("getKind", &ImmIdTFileTarget::getKind),
                                                                InstanceMethod("is", &ImmIdTFileTarget::is),
                                                                InstanceMethod("getNodeIndex", &ImmIdTFileTarget::getNodeIndex),
                                                                InstanceMethod("getReadableId", &ImmIdTFileTarget::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTFileTarget", func);
    return exports;
  }
  ImmIdTFileTarget(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTFileTarget>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmFileTarget>>();
  }
  ImmIdTFileTarget(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmFileTarget>> const& ptr) : Napi::ObjectWrap<ImmIdTFileTarget>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmFileTarget>> _stored;
  org::imm::ImmIdT<org::imm::ImmFileTarget>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTFileTarget> {
  using type = org::imm::ImmIdT<org::imm::ImmFileTarget>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmFileTarget>> {
  using type = ImmIdTFileTarget;
};

struct ImmIdTTextSeparator : public Napi::ObjectWrap<ImmIdTTextSeparator> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmTextSeparator>::*)() const>(&org::imm::ImmIdT<org::imm::ImmTextSeparator>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmTextSeparator>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmTextSeparator>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmTextSeparator>::*)() const>(&org::imm::ImmIdT<org::imm::ImmTextSeparator>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmTextSeparator>::*)() const>(&org::imm::ImmIdT<org::imm::ImmTextSeparator>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTTextSeparator", {InstanceMethod("getKind", &ImmIdTTextSeparator::getKind),
                                                                   InstanceMethod("is", &ImmIdTTextSeparator::is),
                                                                   InstanceMethod("getNodeIndex", &ImmIdTTextSeparator::getNodeIndex),
                                                                   InstanceMethod("getReadableId", &ImmIdTTextSeparator::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTTextSeparator", func);
    return exports;
  }
  ImmIdTTextSeparator(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTTextSeparator>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmTextSeparator>>();
  }
  ImmIdTTextSeparator(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmTextSeparator>> const& ptr) : Napi::ObjectWrap<ImmIdTTextSeparator>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmTextSeparator>> _stored;
  org::imm::ImmIdT<org::imm::ImmTextSeparator>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTTextSeparator> {
  using type = org::imm::ImmIdT<org::imm::ImmTextSeparator>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmTextSeparator>> {
  using type = ImmIdTTextSeparator;
};

struct ImmIdTDocumentGroup : public Napi::ObjectWrap<ImmIdTDocumentGroup> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmDocumentGroup>::*)() const>(&org::imm::ImmIdT<org::imm::ImmDocumentGroup>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmDocumentGroup>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmDocumentGroup>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmDocumentGroup>::*)() const>(&org::imm::ImmIdT<org::imm::ImmDocumentGroup>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmDocumentGroup>::*)() const>(&org::imm::ImmIdT<org::imm::ImmDocumentGroup>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTDocumentGroup", {InstanceMethod("getKind", &ImmIdTDocumentGroup::getKind),
                                                                   InstanceMethod("is", &ImmIdTDocumentGroup::is),
                                                                   InstanceMethod("getNodeIndex", &ImmIdTDocumentGroup::getNodeIndex),
                                                                   InstanceMethod("getReadableId", &ImmIdTDocumentGroup::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTDocumentGroup", func);
    return exports;
  }
  ImmIdTDocumentGroup(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTDocumentGroup>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmDocumentGroup>>();
  }
  ImmIdTDocumentGroup(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmDocumentGroup>> const& ptr) : Napi::ObjectWrap<ImmIdTDocumentGroup>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmDocumentGroup>> _stored;
  org::imm::ImmIdT<org::imm::ImmDocumentGroup>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTDocumentGroup> {
  using type = org::imm::ImmIdT<org::imm::ImmDocumentGroup>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmDocumentGroup>> {
  using type = ImmIdTDocumentGroup;
};

struct ImmIdTFile : public Napi::ObjectWrap<ImmIdTFile> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmFile>::*)() const>(&org::imm::ImmIdT<org::imm::ImmFile>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmFile>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmFile>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmFile>::*)() const>(&org::imm::ImmIdT<org::imm::ImmFile>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmFile>::*)() const>(&org::imm::ImmIdT<org::imm::ImmFile>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTFile", {InstanceMethod("getKind", &ImmIdTFile::getKind),
                                                          InstanceMethod("is", &ImmIdTFile::is),
                                                          InstanceMethod("getNodeIndex", &ImmIdTFile::getNodeIndex),
                                                          InstanceMethod("getReadableId", &ImmIdTFile::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTFile", func);
    return exports;
  }
  ImmIdTFile(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTFile>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmFile>>();
  }
  ImmIdTFile(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmFile>> const& ptr) : Napi::ObjectWrap<ImmIdTFile>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmFile>> _stored;
  org::imm::ImmIdT<org::imm::ImmFile>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTFile> {
  using type = org::imm::ImmIdT<org::imm::ImmFile>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmFile>> {
  using type = ImmIdTFile;
};

struct ImmIdTDirectory : public Napi::ObjectWrap<ImmIdTDirectory> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmDirectory>::*)() const>(&org::imm::ImmIdT<org::imm::ImmDirectory>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmDirectory>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmDirectory>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmDirectory>::*)() const>(&org::imm::ImmIdT<org::imm::ImmDirectory>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmDirectory>::*)() const>(&org::imm::ImmIdT<org::imm::ImmDirectory>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTDirectory", {InstanceMethod("getKind", &ImmIdTDirectory::getKind),
                                                               InstanceMethod("is", &ImmIdTDirectory::is),
                                                               InstanceMethod("getNodeIndex", &ImmIdTDirectory::getNodeIndex),
                                                               InstanceMethod("getReadableId", &ImmIdTDirectory::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTDirectory", func);
    return exports;
  }
  ImmIdTDirectory(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTDirectory>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmDirectory>>();
  }
  ImmIdTDirectory(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmDirectory>> const& ptr) : Napi::ObjectWrap<ImmIdTDirectory>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmDirectory>> _stored;
  org::imm::ImmIdT<org::imm::ImmDirectory>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTDirectory> {
  using type = org::imm::ImmIdT<org::imm::ImmDirectory>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmDirectory>> {
  using type = ImmIdTDirectory;
};

struct ImmIdTSymlink : public Napi::ObjectWrap<ImmIdTSymlink> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmSymlink>::*)() const>(&org::imm::ImmIdT<org::imm::ImmSymlink>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmSymlink>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmSymlink>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmSymlink>::*)() const>(&org::imm::ImmIdT<org::imm::ImmSymlink>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmSymlink>::*)() const>(&org::imm::ImmIdT<org::imm::ImmSymlink>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTSymlink", {InstanceMethod("getKind", &ImmIdTSymlink::getKind),
                                                             InstanceMethod("is", &ImmIdTSymlink::is),
                                                             InstanceMethod("getNodeIndex", &ImmIdTSymlink::getNodeIndex),
                                                             InstanceMethod("getReadableId", &ImmIdTSymlink::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTSymlink", func);
    return exports;
  }
  ImmIdTSymlink(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTSymlink>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmSymlink>>();
  }
  ImmIdTSymlink(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmSymlink>> const& ptr) : Napi::ObjectWrap<ImmIdTSymlink>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmSymlink>> _stored;
  org::imm::ImmIdT<org::imm::ImmSymlink>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTSymlink> {
  using type = org::imm::ImmIdT<org::imm::ImmSymlink>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmSymlink>> {
  using type = ImmIdTSymlink;
};

struct ImmIdTCmdInclude : public Napi::ObjectWrap<ImmIdTCmdInclude> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmCmdInclude>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdInclude>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmCmdInclude>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmCmdInclude>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmCmdInclude>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdInclude>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmCmdInclude>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdInclude>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmIdTCmdInclude", {InstanceMethod("getKind", &ImmIdTCmdInclude::getKind),
                                                                InstanceMethod("is", &ImmIdTCmdInclude::is),
                                                                InstanceMethod("getNodeIndex", &ImmIdTCmdInclude::getNodeIndex),
                                                                InstanceMethod("getReadableId", &ImmIdTCmdInclude::getReadableId)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmIdTCmdInclude", func);
    return exports;
  }
  ImmIdTCmdInclude(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmIdTCmdInclude>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::imm::ImmIdT<org::imm::ImmCmdInclude>>();
  }
  ImmIdTCmdInclude(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmIdT<org::imm::ImmCmdInclude>> const& ptr) : Napi::ObjectWrap<ImmIdTCmdInclude>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmIdT<org::imm::ImmCmdInclude>> _stored;
  org::imm::ImmIdT<org::imm::ImmCmdInclude>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmIdTCmdInclude> {
  using type = org::imm::ImmIdT<org::imm::ImmCmdInclude>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmCmdInclude>> {
  using type = ImmIdTCmdInclude;
};

struct ImmnonevalueJs : public Napi::ObjectWrap<ImmnonevalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmnonevalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmnonevalueJs", func);
    return exports;
  }
  ImmnonevalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmnonevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmnonevalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmNoneValue> const& ptr) : Napi::ObjectWrap<ImmnonevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmNoneValue> _stored;
  org::imm::ImmNoneValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmnonevalueJs> {
  using type = org::imm::ImmNoneValue;
};

template <>
struct org_to_js_type<org::imm::ImmNoneValue> {
  using type = ImmnonevalueJs;
};

struct ImmerroritemvalueJs : public Napi::ObjectWrap<ImmerroritemvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getMessage(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmErrorItemValue::*)() const>(&org::imm::ImmErrorItemValue::getMessage),
                                        std::make_tuple()));
  }
  Napi::Value getFunction(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmErrorItemValue::*)() const>(&org::imm::ImmErrorItemValue::getFunction),
                                        std::make_tuple()));
  }
  Napi::Value getLine(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<int>> const&(org::imm::ImmErrorItemValue::*)() const>(&org::imm::ImmErrorItemValue::getLine),
                                        std::make_tuple()));
  }
  Napi::Value setMessage(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmErrorItemValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmErrorItemValue::setMessage),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setFunction(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmErrorItemValue::*)(immer::box<std::optional<hstd::Str>> const&)>(&org::imm::ImmErrorItemValue::setFunction),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::Str>>>{"value"})));
  }
  Napi::Value setLine(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmErrorItemValue::*)(immer::box<std::optional<int>> const&)>(&org::imm::ImmErrorItemValue::setLine),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<int>>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmerroritemvalueJs", {InstanceMethod("getMessage", &ImmerroritemvalueJs::getMessage),
                                                                   InstanceMethod("getFunction", &ImmerroritemvalueJs::getFunction),
                                                                   InstanceMethod("getLine", &ImmerroritemvalueJs::getLine),
                                                                   InstanceMethod("setMessage", &ImmerroritemvalueJs::setMessage),
                                                                   InstanceMethod("setFunction", &ImmerroritemvalueJs::setFunction),
                                                                   InstanceMethod("setLine", &ImmerroritemvalueJs::setLine)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmerroritemvalueJs", func);
    return exports;
  }
  ImmerroritemvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmerroritemvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmerroritemvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmErrorItemValue> const& ptr) : Napi::ObjectWrap<ImmerroritemvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmErrorItemValue> _stored;
  org::imm::ImmErrorItemValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmerroritemvalueJs> {
  using type = org::imm::ImmErrorItemValue;
};

template <>
struct org_to_js_type<org::imm::ImmErrorItemValue> {
  using type = ImmerroritemvalueJs;
};

struct ImmerrorgroupvalueJs : public Napi::ObjectWrap<ImmerrorgroupvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getDiagnostics(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmErrorItem>> const&(org::imm::ImmErrorGroupValue::*)() const>(&org::imm::ImmErrorGroupValue::getDiagnostics),
                                        std::make_tuple()));
  }
  Napi::Value getFunction(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmErrorGroupValue::*)() const>(&org::imm::ImmErrorGroupValue::getFunction),
                                        std::make_tuple()));
  }
  Napi::Value getLine(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<int>> const&(org::imm::ImmErrorGroupValue::*)() const>(&org::imm::ImmErrorGroupValue::getLine),
                                        std::make_tuple()));
  }
  Napi::Value setDiagnostics(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmErrorGroupValue::*)(immer::flex_vector<org::imm::ImmIdT<org::imm::ImmErrorItem>> const&)>(&org::imm::ImmErrorGroupValue::setDiagnostics),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmErrorItem>>>{"value"})));
  }
  Napi::Value setFunction(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmErrorGroupValue::*)(immer::box<std::optional<hstd::Str>> const&)>(&org::imm::ImmErrorGroupValue::setFunction),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::Str>>>{"value"})));
  }
  Napi::Value setLine(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmErrorGroupValue::*)(immer::box<std::optional<int>> const&)>(&org::imm::ImmErrorGroupValue::setLine),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<int>>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmerrorgroupvalueJs", {InstanceMethod("getDiagnostics", &ImmerrorgroupvalueJs::getDiagnostics),
                                                                    InstanceMethod("getFunction", &ImmerrorgroupvalueJs::getFunction),
                                                                    InstanceMethod("getLine", &ImmerrorgroupvalueJs::getLine),
                                                                    InstanceMethod("setDiagnostics", &ImmerrorgroupvalueJs::setDiagnostics),
                                                                    InstanceMethod("setFunction", &ImmerrorgroupvalueJs::setFunction),
                                                                    InstanceMethod("setLine", &ImmerrorgroupvalueJs::setLine)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmerrorgroupvalueJs", func);
    return exports;
  }
  ImmerrorgroupvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmerrorgroupvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmerrorgroupvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmErrorGroupValue> const& ptr) : Napi::ObjectWrap<ImmerrorgroupvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmErrorGroupValue> _stored;
  org::imm::ImmErrorGroupValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmerrorgroupvalueJs> {
  using type = org::imm::ImmErrorGroupValue;
};

template <>
struct org_to_js_type<org::imm::ImmErrorGroupValue> {
  using type = ImmerrorgroupvalueJs;
};

struct ImmstmtlistvalueJs : public Napi::ObjectWrap<ImmstmtlistvalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmstmtlistvalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmstmtlistvalueJs", func);
    return exports;
  }
  ImmstmtlistvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmstmtlistvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmstmtlistvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmStmtListValue> const& ptr) : Napi::ObjectWrap<ImmstmtlistvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmStmtListValue> _stored;
  org::imm::ImmStmtListValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmstmtlistvalueJs> {
  using type = org::imm::ImmStmtListValue;
};

template <>
struct org_to_js_type<org::imm::ImmStmtListValue> {
  using type = ImmstmtlistvalueJs;
};

struct ImmemptyvalueJs : public Napi::ObjectWrap<ImmemptyvalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmemptyvalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmemptyvalueJs", func);
    return exports;
  }
  ImmemptyvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmemptyvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmemptyvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmEmptyValue> const& ptr) : Napi::ObjectWrap<ImmemptyvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmEmptyValue> _stored;
  org::imm::ImmEmptyValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmemptyvalueJs> {
  using type = org::imm::ImmEmptyValue;
};

template <>
struct org_to_js_type<org::imm::ImmEmptyValue> {
  using type = ImmemptyvalueJs;
};

struct ImmcmdcaptionvalueJs : public Napi::ObjectWrap<ImmcmdcaptionvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmIdT<org::imm::ImmParagraph> const&(org::imm::ImmCmdCaptionValue::*)() const>(&org::imm::ImmCmdCaptionValue::getText),
                                        std::make_tuple()));
  }
  Napi::Value setText(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdCaptionValue::*)(org::imm::ImmIdT<org::imm::ImmParagraph> const&)>(&org::imm::ImmCmdCaptionValue::setText),
                                   std::make_tuple(CxxArgSpec<org::imm::ImmIdT<org::imm::ImmParagraph>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmcmdcaptionvalueJs", {InstanceMethod("getText", &ImmcmdcaptionvalueJs::getText),
                                                                    InstanceMethod("setText", &ImmcmdcaptionvalueJs::setText)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmcmdcaptionvalueJs", func);
    return exports;
  }
  ImmcmdcaptionvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmcmdcaptionvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmcmdcaptionvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmCmdCaptionValue> const& ptr) : Napi::ObjectWrap<ImmcmdcaptionvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmCmdCaptionValue> _stored;
  org::imm::ImmCmdCaptionValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmcmdcaptionvalueJs> {
  using type = org::imm::ImmCmdCaptionValue;
};

template <>
struct org_to_js_type<org::imm::ImmCmdCaptionValue> {
  using type = ImmcmdcaptionvalueJs;
};

struct ImmcmdcolumnsvalueJs : public Napi::ObjectWrap<ImmcmdcolumnsvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getView(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::ColumnView const&(org::imm::ImmCmdColumnsValue::*)() const>(&org::imm::ImmCmdColumnsValue::getView),
                                        std::make_tuple()));
  }
  Napi::Value setView(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdColumnsValue::*)(org::sem::ColumnView const&)>(&org::imm::ImmCmdColumnsValue::setView),
                                   std::make_tuple(CxxArgSpec<org::sem::ColumnView>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmcmdcolumnsvalueJs", {InstanceMethod("getView", &ImmcmdcolumnsvalueJs::getView),
                                                                    InstanceMethod("setView", &ImmcmdcolumnsvalueJs::setView)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmcmdcolumnsvalueJs", func);
    return exports;
  }
  ImmcmdcolumnsvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmcmdcolumnsvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmcmdcolumnsvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmCmdColumnsValue> const& ptr) : Napi::ObjectWrap<ImmcmdcolumnsvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmCmdColumnsValue> _stored;
  org::imm::ImmCmdColumnsValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmcmdcolumnsvalueJs> {
  using type = org::imm::ImmCmdColumnsValue;
};

template <>
struct org_to_js_type<org::imm::ImmCmdColumnsValue> {
  using type = ImmcmdcolumnsvalueJs;
};

struct ImmcmdnamevalueJs : public Napi::ObjectWrap<ImmcmdnamevalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdNameValue::*)() const>(&org::imm::ImmCmdNameValue::getName),
                                        std::make_tuple()));
  }
  Napi::Value setName(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdNameValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmCmdNameValue::setName),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmcmdnamevalueJs", {InstanceMethod("getName", &ImmcmdnamevalueJs::getName),
                                                                 InstanceMethod("setName", &ImmcmdnamevalueJs::setName)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmcmdnamevalueJs", func);
    return exports;
  }
  ImmcmdnamevalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmcmdnamevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmcmdnamevalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmCmdNameValue> const& ptr) : Napi::ObjectWrap<ImmcmdnamevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmCmdNameValue> _stored;
  org::imm::ImmCmdNameValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmcmdnamevalueJs> {
  using type = org::imm::ImmCmdNameValue;
};

template <>
struct org_to_js_type<org::imm::ImmCmdNameValue> {
  using type = ImmcmdnamevalueJs;
};

struct ImmcmdcustomargsvalueJs : public Napi::ObjectWrap<ImmcmdcustomargsvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdCustomArgsValue::*)() const>(&org::imm::ImmCmdCustomArgsValue::getName),
                                        std::make_tuple()));
  }
  Napi::Value getIsattached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmCmdCustomArgsValue::*)() const>(&org::imm::ImmCmdCustomArgsValue::getIsattached),
                                        std::make_tuple()));
  }
  Napi::Value setName(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdCustomArgsValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmCmdCustomArgsValue::setName),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setIsattached(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdCustomArgsValue::*)(bool const&)>(&org::imm::ImmCmdCustomArgsValue::setIsattached),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmcmdcustomargsvalueJs", {InstanceMethod("getName", &ImmcmdcustomargsvalueJs::getName),
                                                                       InstanceMethod("getIsattached", &ImmcmdcustomargsvalueJs::getIsattached),
                                                                       InstanceMethod("setName", &ImmcmdcustomargsvalueJs::setName),
                                                                       InstanceMethod("setIsattached", &ImmcmdcustomargsvalueJs::setIsattached)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmcmdcustomargsvalueJs", func);
    return exports;
  }
  ImmcmdcustomargsvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmcmdcustomargsvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmcmdcustomargsvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmCmdCustomArgsValue> const& ptr) : Napi::ObjectWrap<ImmcmdcustomargsvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmCmdCustomArgsValue> _stored;
  org::imm::ImmCmdCustomArgsValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmcmdcustomargsvalueJs> {
  using type = org::imm::ImmCmdCustomArgsValue;
};

template <>
struct org_to_js_type<org::imm::ImmCmdCustomArgsValue> {
  using type = ImmcmdcustomargsvalueJs;
};

struct ImmcmdcustomrawvalueJs : public Napi::ObjectWrap<ImmcmdcustomrawvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdCustomRawValue::*)() const>(&org::imm::ImmCmdCustomRawValue::getName),
                                        std::make_tuple()));
  }
  Napi::Value getIsattached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmCmdCustomRawValue::*)() const>(&org::imm::ImmCmdCustomRawValue::getIsattached),
                                        std::make_tuple()));
  }
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdCustomRawValue::*)() const>(&org::imm::ImmCmdCustomRawValue::getText),
                                        std::make_tuple()));
  }
  Napi::Value setName(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdCustomRawValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmCmdCustomRawValue::setName),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setIsattached(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdCustomRawValue::*)(bool const&)>(&org::imm::ImmCmdCustomRawValue::setIsattached),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  Napi::Value setText(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdCustomRawValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmCmdCustomRawValue::setText),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmcmdcustomrawvalueJs", {InstanceMethod("getName", &ImmcmdcustomrawvalueJs::getName),
                                                                      InstanceMethod("getIsattached", &ImmcmdcustomrawvalueJs::getIsattached),
                                                                      InstanceMethod("getText", &ImmcmdcustomrawvalueJs::getText),
                                                                      InstanceMethod("setName", &ImmcmdcustomrawvalueJs::setName),
                                                                      InstanceMethod("setIsattached", &ImmcmdcustomrawvalueJs::setIsattached),
                                                                      InstanceMethod("setText", &ImmcmdcustomrawvalueJs::setText)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmcmdcustomrawvalueJs", func);
    return exports;
  }
  ImmcmdcustomrawvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmcmdcustomrawvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmcmdcustomrawvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmCmdCustomRawValue> const& ptr) : Napi::ObjectWrap<ImmcmdcustomrawvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmCmdCustomRawValue> _stored;
  org::imm::ImmCmdCustomRawValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmcmdcustomrawvalueJs> {
  using type = org::imm::ImmCmdCustomRawValue;
};

template <>
struct org_to_js_type<org::imm::ImmCmdCustomRawValue> {
  using type = ImmcmdcustomrawvalueJs;
};

struct ImmcmdcustomtextvalueJs : public Napi::ObjectWrap<ImmcmdcustomtextvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdCustomTextValue::*)() const>(&org::imm::ImmCmdCustomTextValue::getName),
                                        std::make_tuple()));
  }
  Napi::Value getIsattached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmCmdCustomTextValue::*)() const>(&org::imm::ImmCmdCustomTextValue::getIsattached),
                                        std::make_tuple()));
  }
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmIdT<org::imm::ImmParagraph> const&(org::imm::ImmCmdCustomTextValue::*)() const>(&org::imm::ImmCmdCustomTextValue::getText),
                                        std::make_tuple()));
  }
  Napi::Value setName(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdCustomTextValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmCmdCustomTextValue::setName),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setIsattached(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdCustomTextValue::*)(bool const&)>(&org::imm::ImmCmdCustomTextValue::setIsattached),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  Napi::Value setText(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdCustomTextValue::*)(org::imm::ImmIdT<org::imm::ImmParagraph> const&)>(&org::imm::ImmCmdCustomTextValue::setText),
                                   std::make_tuple(CxxArgSpec<org::imm::ImmIdT<org::imm::ImmParagraph>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmcmdcustomtextvalueJs", {InstanceMethod("getName", &ImmcmdcustomtextvalueJs::getName),
                                                                       InstanceMethod("getIsattached", &ImmcmdcustomtextvalueJs::getIsattached),
                                                                       InstanceMethod("getText", &ImmcmdcustomtextvalueJs::getText),
                                                                       InstanceMethod("setName", &ImmcmdcustomtextvalueJs::setName),
                                                                       InstanceMethod("setIsattached", &ImmcmdcustomtextvalueJs::setIsattached),
                                                                       InstanceMethod("setText", &ImmcmdcustomtextvalueJs::setText)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmcmdcustomtextvalueJs", func);
    return exports;
  }
  ImmcmdcustomtextvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmcmdcustomtextvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmcmdcustomtextvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmCmdCustomTextValue> const& ptr) : Napi::ObjectWrap<ImmcmdcustomtextvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmCmdCustomTextValue> _stored;
  org::imm::ImmCmdCustomTextValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmcmdcustomtextvalueJs> {
  using type = org::imm::ImmCmdCustomTextValue;
};

template <>
struct org_to_js_type<org::imm::ImmCmdCustomTextValue> {
  using type = ImmcmdcustomtextvalueJs;
};

struct ImmcmdcallvalueJs : public Napi::ObjectWrap<ImmcmdcallvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdCallValue::*)() const>(&org::imm::ImmCmdCallValue::getName),
                                        std::make_tuple()));
  }
  Napi::Value getFilename(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmCmdCallValue::*)() const>(&org::imm::ImmCmdCallValue::getFilename),
                                        std::make_tuple()));
  }
  Napi::Value getInsideheaderattrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrGroup const&(org::imm::ImmCmdCallValue::*)() const>(&org::imm::ImmCmdCallValue::getInsideheaderattrs),
                                        std::make_tuple()));
  }
  Napi::Value getCallattrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrGroup const&(org::imm::ImmCmdCallValue::*)() const>(&org::imm::ImmCmdCallValue::getCallattrs),
                                        std::make_tuple()));
  }
  Napi::Value getEndheaderattrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrGroup const&(org::imm::ImmCmdCallValue::*)() const>(&org::imm::ImmCmdCallValue::getEndheaderattrs),
                                        std::make_tuple()));
  }
  Napi::Value getResult(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>> const&(org::imm::ImmCmdCallValue::*)() const>(&org::imm::ImmCmdCallValue::getResult),
                                        std::make_tuple()));
  }
  Napi::Value setName(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdCallValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmCmdCallValue::setName),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setFilename(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdCallValue::*)(immer::box<std::optional<hstd::Str>> const&)>(&org::imm::ImmCmdCallValue::setFilename),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::Str>>>{"value"})));
  }
  Napi::Value setInsideheaderattrs(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdCallValue::*)(org::sem::AttrGroup const&)>(&org::imm::ImmCmdCallValue::setInsideheaderattrs),
                                   std::make_tuple(CxxArgSpec<org::sem::AttrGroup>{"value"})));
  }
  Napi::Value setCallattrs(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdCallValue::*)(org::sem::AttrGroup const&)>(&org::imm::ImmCmdCallValue::setCallattrs),
                                   std::make_tuple(CxxArgSpec<org::sem::AttrGroup>{"value"})));
  }
  Napi::Value setEndheaderattrs(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdCallValue::*)(org::sem::AttrGroup const&)>(&org::imm::ImmCmdCallValue::setEndheaderattrs),
                                   std::make_tuple(CxxArgSpec<org::sem::AttrGroup>{"value"})));
  }
  Napi::Value setResult(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdCallValue::*)(immer::flex_vector<org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>> const&)>(&org::imm::ImmCmdCallValue::setResult),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmcmdcallvalueJs", {InstanceMethod("getName", &ImmcmdcallvalueJs::getName),
                                                                 InstanceMethod("getFilename", &ImmcmdcallvalueJs::getFilename),
                                                                 InstanceMethod("getInsideheaderattrs", &ImmcmdcallvalueJs::getInsideheaderattrs),
                                                                 InstanceMethod("getCallattrs", &ImmcmdcallvalueJs::getCallattrs),
                                                                 InstanceMethod("getEndheaderattrs", &ImmcmdcallvalueJs::getEndheaderattrs),
                                                                 InstanceMethod("getResult", &ImmcmdcallvalueJs::getResult),
                                                                 InstanceMethod("setName", &ImmcmdcallvalueJs::setName),
                                                                 InstanceMethod("setFilename", &ImmcmdcallvalueJs::setFilename),
                                                                 InstanceMethod("setInsideheaderattrs", &ImmcmdcallvalueJs::setInsideheaderattrs),
                                                                 InstanceMethod("setCallattrs", &ImmcmdcallvalueJs::setCallattrs),
                                                                 InstanceMethod("setEndheaderattrs", &ImmcmdcallvalueJs::setEndheaderattrs),
                                                                 InstanceMethod("setResult", &ImmcmdcallvalueJs::setResult)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmcmdcallvalueJs", func);
    return exports;
  }
  ImmcmdcallvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmcmdcallvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmcmdcallvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmCmdCallValue> const& ptr) : Napi::ObjectWrap<ImmcmdcallvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmCmdCallValue> _stored;
  org::imm::ImmCmdCallValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmcmdcallvalueJs> {
  using type = org::imm::ImmCmdCallValue;
};

template <>
struct org_to_js_type<org::imm::ImmCmdCallValue> {
  using type = ImmcmdcallvalueJs;
};

struct ImmcmdtblfmvalueJs : public Napi::ObjectWrap<ImmcmdtblfmvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getExpr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::Tblfm const&(org::imm::ImmCmdTblfmValue::*)() const>(&org::imm::ImmCmdTblfmValue::getExpr),
                                        std::make_tuple()));
  }
  Napi::Value setExpr(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdTblfmValue::*)(org::sem::Tblfm const&)>(&org::imm::ImmCmdTblfmValue::setExpr),
                                   std::make_tuple(CxxArgSpec<org::sem::Tblfm>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmcmdtblfmvalueJs", {InstanceMethod("getExpr", &ImmcmdtblfmvalueJs::getExpr),
                                                                  InstanceMethod("setExpr", &ImmcmdtblfmvalueJs::setExpr)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmcmdtblfmvalueJs", func);
    return exports;
  }
  ImmcmdtblfmvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmcmdtblfmvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmcmdtblfmvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmCmdTblfmValue> const& ptr) : Napi::ObjectWrap<ImmcmdtblfmvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmCmdTblfmValue> _stored;
  org::imm::ImmCmdTblfmValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmcmdtblfmvalueJs> {
  using type = org::imm::ImmCmdTblfmValue;
};

template <>
struct org_to_js_type<org::imm::ImmCmdTblfmValue> {
  using type = ImmcmdtblfmvalueJs;
};

struct ImmhashtagvalueJs : public Napi::ObjectWrap<ImmhashtagvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::HashTagText const&(org::imm::ImmHashTagValue::*)() const>(&org::imm::ImmHashTagValue::getText),
                                        std::make_tuple()));
  }
  Napi::Value setText(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmHashTagValue::*)(org::sem::HashTagText const&)>(&org::imm::ImmHashTagValue::setText),
                                   std::make_tuple(CxxArgSpec<org::sem::HashTagText>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmhashtagvalueJs", {InstanceMethod("getText", &ImmhashtagvalueJs::getText),
                                                                 InstanceMethod("setText", &ImmhashtagvalueJs::setText)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmhashtagvalueJs", func);
    return exports;
  }
  ImmhashtagvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmhashtagvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmhashtagvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmHashTagValue> const& ptr) : Napi::ObjectWrap<ImmhashtagvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmHashTagValue> _stored;
  org::imm::ImmHashTagValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmhashtagvalueJs> {
  using type = org::imm::ImmHashTagValue;
};

template <>
struct org_to_js_type<org::imm::ImmHashTagValue> {
  using type = ImmhashtagvalueJs;
};

struct ImminlinefootnotevalueJs : public Napi::ObjectWrap<ImminlinefootnotevalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getTag(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmInlineFootnoteValue::*)() const>(&org::imm::ImmInlineFootnoteValue::getTag),
                                        std::make_tuple()));
  }
  Napi::Value getDefinition(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmOrg>>> const&(org::imm::ImmInlineFootnoteValue::*)() const>(&org::imm::ImmInlineFootnoteValue::getDefinition),
                                        std::make_tuple()));
  }
  Napi::Value setTag(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmInlineFootnoteValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmInlineFootnoteValue::setTag),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setDefinition(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmInlineFootnoteValue::*)(immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmOrg>>> const&)>(&org::imm::ImmInlineFootnoteValue::setDefinition),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmOrg>>>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImminlinefootnotevalueJs", {InstanceMethod("getTag", &ImminlinefootnotevalueJs::getTag),
                                                                        InstanceMethod("getDefinition", &ImminlinefootnotevalueJs::getDefinition),
                                                                        InstanceMethod("setTag", &ImminlinefootnotevalueJs::setTag),
                                                                        InstanceMethod("setDefinition", &ImminlinefootnotevalueJs::setDefinition)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImminlinefootnotevalueJs", func);
    return exports;
  }
  ImminlinefootnotevalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImminlinefootnotevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImminlinefootnotevalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmInlineFootnoteValue> const& ptr) : Napi::ObjectWrap<ImminlinefootnotevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmInlineFootnoteValue> _stored;
  org::imm::ImmInlineFootnoteValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImminlinefootnotevalueJs> {
  using type = org::imm::ImmInlineFootnoteValue;
};

template <>
struct org_to_js_type<org::imm::ImmInlineFootnoteValue> {
  using type = ImminlinefootnotevalueJs;
};

struct ImminlineexportvalueJs : public Napi::ObjectWrap<ImminlineexportvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getExporter(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmInlineExportValue::*)() const>(&org::imm::ImmInlineExportValue::getExporter),
                                        std::make_tuple()));
  }
  Napi::Value getContent(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmInlineExportValue::*)() const>(&org::imm::ImmInlineExportValue::getContent),
                                        std::make_tuple()));
  }
  Napi::Value setExporter(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmInlineExportValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmInlineExportValue::setExporter),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setContent(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmInlineExportValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmInlineExportValue::setContent),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImminlineexportvalueJs", {InstanceMethod("getExporter", &ImminlineexportvalueJs::getExporter),
                                                                      InstanceMethod("getContent", &ImminlineexportvalueJs::getContent),
                                                                      InstanceMethod("setExporter", &ImminlineexportvalueJs::setExporter),
                                                                      InstanceMethod("setContent", &ImminlineexportvalueJs::setContent)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImminlineexportvalueJs", func);
    return exports;
  }
  ImminlineexportvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImminlineexportvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImminlineexportvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmInlineExportValue> const& ptr) : Napi::ObjectWrap<ImminlineexportvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmInlineExportValue> _stored;
  org::imm::ImmInlineExportValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImminlineexportvalueJs> {
  using type = org::imm::ImmInlineExportValue;
};

template <>
struct org_to_js_type<org::imm::ImmInlineExportValue> {
  using type = ImminlineexportvalueJs;
};

struct ImmtimevalueJs : public Napi::ObjectWrap<ImmtimevalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getIsactive(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmTimeValue::*)() const>(&org::imm::ImmTimeValue::getIsactive),
                                        std::make_tuple()));
  }
  Napi::Value getTime(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmTime::TimeVariant const&(org::imm::ImmTimeValue::*)() const>(&org::imm::ImmTimeValue::getTime),
                                        std::make_tuple()));
  }
  Napi::Value setIsactive(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmTimeValue::*)(bool const&)>(&org::imm::ImmTimeValue::setIsactive),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  Napi::Value setTime(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmTimeValue::*)(org::imm::ImmTime::TimeVariant const&)>(&org::imm::ImmTimeValue::setTime),
                                   std::make_tuple(CxxArgSpec<org::imm::ImmTime::TimeVariant>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmtimevalueJs", {InstanceMethod("getIsactive", &ImmtimevalueJs::getIsactive),
                                                              InstanceMethod("getTime", &ImmtimevalueJs::getTime),
                                                              InstanceMethod("setIsactive", &ImmtimevalueJs::setIsactive),
                                                              InstanceMethod("setTime", &ImmtimevalueJs::setTime)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmtimevalueJs", func);
    return exports;
  }
  ImmtimevalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmtimevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmtimevalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmTimeValue> const& ptr) : Napi::ObjectWrap<ImmtimevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmTimeValue> _stored;
  org::imm::ImmTimeValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmtimevalueJs> {
  using type = org::imm::ImmTimeValue;
};

template <>
struct org_to_js_type<org::imm::ImmTimeValue> {
  using type = ImmtimevalueJs;
};

struct ImmtimerangevalueJs : public Napi::ObjectWrap<ImmtimerangevalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getFrom(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmIdT<org::imm::ImmTime> const&(org::imm::ImmTimeRangeValue::*)() const>(&org::imm::ImmTimeRangeValue::getFrom),
                                        std::make_tuple()));
  }
  Napi::Value getTo(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmIdT<org::imm::ImmTime> const&(org::imm::ImmTimeRangeValue::*)() const>(&org::imm::ImmTimeRangeValue::getTo),
                                        std::make_tuple()));
  }
  Napi::Value setFrom(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmTimeRangeValue::*)(org::imm::ImmIdT<org::imm::ImmTime> const&)>(&org::imm::ImmTimeRangeValue::setFrom),
                                   std::make_tuple(CxxArgSpec<org::imm::ImmIdT<org::imm::ImmTime>>{"value"})));
  }
  Napi::Value setTo(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmTimeRangeValue::*)(org::imm::ImmIdT<org::imm::ImmTime> const&)>(&org::imm::ImmTimeRangeValue::setTo),
                                   std::make_tuple(CxxArgSpec<org::imm::ImmIdT<org::imm::ImmTime>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmtimerangevalueJs", {InstanceMethod("getFrom", &ImmtimerangevalueJs::getFrom),
                                                                   InstanceMethod("getTo", &ImmtimerangevalueJs::getTo),
                                                                   InstanceMethod("setFrom", &ImmtimerangevalueJs::setFrom),
                                                                   InstanceMethod("setTo", &ImmtimerangevalueJs::setTo)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmtimerangevalueJs", func);
    return exports;
  }
  ImmtimerangevalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmtimerangevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmtimerangevalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmTimeRangeValue> const& ptr) : Napi::ObjectWrap<ImmtimerangevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmTimeRangeValue> _stored;
  org::imm::ImmTimeRangeValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmtimerangevalueJs> {
  using type = org::imm::ImmTimeRangeValue;
};

template <>
struct org_to_js_type<org::imm::ImmTimeRangeValue> {
  using type = ImmtimerangevalueJs;
};

struct ImmmacrovalueJs : public Napi::ObjectWrap<ImmmacrovalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmMacroValue::*)() const>(&org::imm::ImmMacroValue::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrGroup const&(org::imm::ImmMacroValue::*)() const>(&org::imm::ImmMacroValue::getAttrs),
                                        std::make_tuple()));
  }
  Napi::Value setName(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmMacroValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmMacroValue::setName),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setAttrs(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmMacroValue::*)(org::sem::AttrGroup const&)>(&org::imm::ImmMacroValue::setAttrs),
                                   std::make_tuple(CxxArgSpec<org::sem::AttrGroup>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmmacrovalueJs", {InstanceMethod("getName", &ImmmacrovalueJs::getName),
                                                               InstanceMethod("getAttrs", &ImmmacrovalueJs::getAttrs),
                                                               InstanceMethod("setName", &ImmmacrovalueJs::setName),
                                                               InstanceMethod("setAttrs", &ImmmacrovalueJs::setAttrs)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmmacrovalueJs", func);
    return exports;
  }
  ImmmacrovalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmmacrovalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmmacrovalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmMacroValue> const& ptr) : Napi::ObjectWrap<ImmmacrovalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmMacroValue> _stored;
  org::imm::ImmMacroValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmmacrovalueJs> {
  using type = org::imm::ImmMacroValue;
};

template <>
struct org_to_js_type<org::imm::ImmMacroValue> {
  using type = ImmmacrovalueJs;
};

struct ImmsymbolvalueJs : public Napi::ObjectWrap<ImmsymbolvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmSymbolValue::*)() const>(&org::imm::ImmSymbolValue::getName),
                                        std::make_tuple()));
  }
  Napi::Value getParameters(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmSymbol::Param> const&(org::imm::ImmSymbolValue::*)() const>(&org::imm::ImmSymbolValue::getParameters),
                                        std::make_tuple()));
  }
  Napi::Value getPositional(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmOrg>> const&(org::imm::ImmSymbolValue::*)() const>(&org::imm::ImmSymbolValue::getPositional),
                                        std::make_tuple()));
  }
  Napi::Value setName(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSymbolValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmSymbolValue::setName),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setParameters(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSymbolValue::*)(immer::flex_vector<org::imm::ImmSymbol::Param> const&)>(&org::imm::ImmSymbolValue::setParameters),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<org::imm::ImmSymbol::Param>>{"value"})));
  }
  Napi::Value setPositional(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSymbolValue::*)(immer::flex_vector<org::imm::ImmIdT<org::imm::ImmOrg>> const&)>(&org::imm::ImmSymbolValue::setPositional),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmOrg>>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmsymbolvalueJs", {InstanceMethod("getName", &ImmsymbolvalueJs::getName),
                                                                InstanceMethod("getParameters", &ImmsymbolvalueJs::getParameters),
                                                                InstanceMethod("getPositional", &ImmsymbolvalueJs::getPositional),
                                                                InstanceMethod("setName", &ImmsymbolvalueJs::setName),
                                                                InstanceMethod("setParameters", &ImmsymbolvalueJs::setParameters),
                                                                InstanceMethod("setPositional", &ImmsymbolvalueJs::setPositional)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmsymbolvalueJs", func);
    return exports;
  }
  ImmsymbolvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmsymbolvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmsymbolvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmSymbolValue> const& ptr) : Napi::ObjectWrap<ImmsymbolvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmSymbolValue> _stored;
  org::imm::ImmSymbolValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmsymbolvalueJs> {
  using type = org::imm::ImmSymbolValue;
};

template <>
struct org_to_js_type<org::imm::ImmSymbolValue> {
  using type = ImmsymbolvalueJs;
};

struct ImmescapedvalueJs : public Napi::ObjectWrap<ImmescapedvalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmescapedvalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmescapedvalueJs", func);
    return exports;
  }
  ImmescapedvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmescapedvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmescapedvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmEscapedValue> const& ptr) : Napi::ObjectWrap<ImmescapedvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmEscapedValue> _stored;
  org::imm::ImmEscapedValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmescapedvalueJs> {
  using type = org::imm::ImmEscapedValue;
};

template <>
struct org_to_js_type<org::imm::ImmEscapedValue> {
  using type = ImmescapedvalueJs;
};

struct ImmnewlinevalueJs : public Napi::ObjectWrap<ImmnewlinevalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmnewlinevalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmnewlinevalueJs", func);
    return exports;
  }
  ImmnewlinevalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmnewlinevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmnewlinevalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmNewlineValue> const& ptr) : Napi::ObjectWrap<ImmnewlinevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmNewlineValue> _stored;
  org::imm::ImmNewlineValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmnewlinevalueJs> {
  using type = org::imm::ImmNewlineValue;
};

template <>
struct org_to_js_type<org::imm::ImmNewlineValue> {
  using type = ImmnewlinevalueJs;
};

struct ImmspacevalueJs : public Napi::ObjectWrap<ImmspacevalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmspacevalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmspacevalueJs", func);
    return exports;
  }
  ImmspacevalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmspacevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmspacevalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmSpaceValue> const& ptr) : Napi::ObjectWrap<ImmspacevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmSpaceValue> _stored;
  org::imm::ImmSpaceValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmspacevalueJs> {
  using type = org::imm::ImmSpaceValue;
};

template <>
struct org_to_js_type<org::imm::ImmSpaceValue> {
  using type = ImmspacevalueJs;
};

struct ImmwordvalueJs : public Napi::ObjectWrap<ImmwordvalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmwordvalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmwordvalueJs", func);
    return exports;
  }
  ImmwordvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmwordvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmwordvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmWordValue> const& ptr) : Napi::ObjectWrap<ImmwordvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmWordValue> _stored;
  org::imm::ImmWordValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmwordvalueJs> {
  using type = org::imm::ImmWordValue;
};

template <>
struct org_to_js_type<org::imm::ImmWordValue> {
  using type = ImmwordvalueJs;
};

struct ImmatmentionvalueJs : public Napi::ObjectWrap<ImmatmentionvalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmatmentionvalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmatmentionvalueJs", func);
    return exports;
  }
  ImmatmentionvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmatmentionvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmatmentionvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAtMentionValue> const& ptr) : Napi::ObjectWrap<ImmatmentionvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAtMentionValue> _stored;
  org::imm::ImmAtMentionValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmatmentionvalueJs> {
  using type = org::imm::ImmAtMentionValue;
};

template <>
struct org_to_js_type<org::imm::ImmAtMentionValue> {
  using type = ImmatmentionvalueJs;
};

struct ImmrawtextvalueJs : public Napi::ObjectWrap<ImmrawtextvalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmrawtextvalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmrawtextvalueJs", func);
    return exports;
  }
  ImmrawtextvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmrawtextvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmrawtextvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmRawTextValue> const& ptr) : Napi::ObjectWrap<ImmrawtextvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmRawTextValue> _stored;
  org::imm::ImmRawTextValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmrawtextvalueJs> {
  using type = org::imm::ImmRawTextValue;
};

template <>
struct org_to_js_type<org::imm::ImmRawTextValue> {
  using type = ImmrawtextvalueJs;
};

struct ImmpunctuationvalueJs : public Napi::ObjectWrap<ImmpunctuationvalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmpunctuationvalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmpunctuationvalueJs", func);
    return exports;
  }
  ImmpunctuationvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmpunctuationvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmpunctuationvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmPunctuationValue> const& ptr) : Napi::ObjectWrap<ImmpunctuationvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmPunctuationValue> _stored;
  org::imm::ImmPunctuationValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmpunctuationvalueJs> {
  using type = org::imm::ImmPunctuationValue;
};

template <>
struct org_to_js_type<org::imm::ImmPunctuationValue> {
  using type = ImmpunctuationvalueJs;
};

struct ImmplaceholdervalueJs : public Napi::ObjectWrap<ImmplaceholdervalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmplaceholdervalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmplaceholdervalueJs", func);
    return exports;
  }
  ImmplaceholdervalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmplaceholdervalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmplaceholdervalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmPlaceholderValue> const& ptr) : Napi::ObjectWrap<ImmplaceholdervalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmPlaceholderValue> _stored;
  org::imm::ImmPlaceholderValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmplaceholdervalueJs> {
  using type = org::imm::ImmPlaceholderValue;
};

template <>
struct org_to_js_type<org::imm::ImmPlaceholderValue> {
  using type = ImmplaceholdervalueJs;
};

struct ImmbigidentvalueJs : public Napi::ObjectWrap<ImmbigidentvalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmbigidentvalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmbigidentvalueJs", func);
    return exports;
  }
  ImmbigidentvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmbigidentvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmbigidentvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmBigIdentValue> const& ptr) : Napi::ObjectWrap<ImmbigidentvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmBigIdentValue> _stored;
  org::imm::ImmBigIdentValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmbigidentvalueJs> {
  using type = org::imm::ImmBigIdentValue;
};

template <>
struct org_to_js_type<org::imm::ImmBigIdentValue> {
  using type = ImmbigidentvalueJs;
};

struct ImmtexttargetvalueJs : public Napi::ObjectWrap<ImmtexttargetvalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmtexttargetvalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmtexttargetvalueJs", func);
    return exports;
  }
  ImmtexttargetvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmtexttargetvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmtexttargetvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmTextTargetValue> const& ptr) : Napi::ObjectWrap<ImmtexttargetvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmTextTargetValue> _stored;
  org::imm::ImmTextTargetValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmtexttargetvalueJs> {
  using type = org::imm::ImmTextTargetValue;
};

template <>
struct org_to_js_type<org::imm::ImmTextTargetValue> {
  using type = ImmtexttargetvalueJs;
};

struct ImmboldvalueJs : public Napi::ObjectWrap<ImmboldvalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmboldvalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmboldvalueJs", func);
    return exports;
  }
  ImmboldvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmboldvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmboldvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmBoldValue> const& ptr) : Napi::ObjectWrap<ImmboldvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmBoldValue> _stored;
  org::imm::ImmBoldValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmboldvalueJs> {
  using type = org::imm::ImmBoldValue;
};

template <>
struct org_to_js_type<org::imm::ImmBoldValue> {
  using type = ImmboldvalueJs;
};

struct ImmunderlinevalueJs : public Napi::ObjectWrap<ImmunderlinevalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmunderlinevalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmunderlinevalueJs", func);
    return exports;
  }
  ImmunderlinevalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmunderlinevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmunderlinevalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmUnderlineValue> const& ptr) : Napi::ObjectWrap<ImmunderlinevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmUnderlineValue> _stored;
  org::imm::ImmUnderlineValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmunderlinevalueJs> {
  using type = org::imm::ImmUnderlineValue;
};

template <>
struct org_to_js_type<org::imm::ImmUnderlineValue> {
  using type = ImmunderlinevalueJs;
};

struct ImmmonospacevalueJs : public Napi::ObjectWrap<ImmmonospacevalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmmonospacevalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmmonospacevalueJs", func);
    return exports;
  }
  ImmmonospacevalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmmonospacevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmmonospacevalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmMonospaceValue> const& ptr) : Napi::ObjectWrap<ImmmonospacevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmMonospaceValue> _stored;
  org::imm::ImmMonospaceValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmmonospacevalueJs> {
  using type = org::imm::ImmMonospaceValue;
};

template <>
struct org_to_js_type<org::imm::ImmMonospaceValue> {
  using type = ImmmonospacevalueJs;
};

struct ImmmarkquotevalueJs : public Napi::ObjectWrap<ImmmarkquotevalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmmarkquotevalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmmarkquotevalueJs", func);
    return exports;
  }
  ImmmarkquotevalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmmarkquotevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmmarkquotevalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmMarkQuoteValue> const& ptr) : Napi::ObjectWrap<ImmmarkquotevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmMarkQuoteValue> _stored;
  org::imm::ImmMarkQuoteValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmmarkquotevalueJs> {
  using type = org::imm::ImmMarkQuoteValue;
};

template <>
struct org_to_js_type<org::imm::ImmMarkQuoteValue> {
  using type = ImmmarkquotevalueJs;
};

struct ImmverbatimvalueJs : public Napi::ObjectWrap<ImmverbatimvalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmverbatimvalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmverbatimvalueJs", func);
    return exports;
  }
  ImmverbatimvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmverbatimvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmverbatimvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmVerbatimValue> const& ptr) : Napi::ObjectWrap<ImmverbatimvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmVerbatimValue> _stored;
  org::imm::ImmVerbatimValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmverbatimvalueJs> {
  using type = org::imm::ImmVerbatimValue;
};

template <>
struct org_to_js_type<org::imm::ImmVerbatimValue> {
  using type = ImmverbatimvalueJs;
};

struct ImmitalicvalueJs : public Napi::ObjectWrap<ImmitalicvalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmitalicvalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmitalicvalueJs", func);
    return exports;
  }
  ImmitalicvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmitalicvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmitalicvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmItalicValue> const& ptr) : Napi::ObjectWrap<ImmitalicvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmItalicValue> _stored;
  org::imm::ImmItalicValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmitalicvalueJs> {
  using type = org::imm::ImmItalicValue;
};

template <>
struct org_to_js_type<org::imm::ImmItalicValue> {
  using type = ImmitalicvalueJs;
};

struct ImmstrikevalueJs : public Napi::ObjectWrap<ImmstrikevalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmstrikevalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmstrikevalueJs", func);
    return exports;
  }
  ImmstrikevalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmstrikevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmstrikevalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmStrikeValue> const& ptr) : Napi::ObjectWrap<ImmstrikevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmStrikeValue> _stored;
  org::imm::ImmStrikeValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmstrikevalueJs> {
  using type = org::imm::ImmStrikeValue;
};

template <>
struct org_to_js_type<org::imm::ImmStrikeValue> {
  using type = ImmstrikevalueJs;
};

struct ImmparvalueJs : public Napi::ObjectWrap<ImmparvalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmparvalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmparvalueJs", func);
    return exports;
  }
  ImmparvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmparvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmparvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmParValue> const& ptr) : Napi::ObjectWrap<ImmparvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmParValue> _stored;
  org::imm::ImmParValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmparvalueJs> {
  using type = org::imm::ImmParValue;
};

template <>
struct org_to_js_type<org::imm::ImmParValue> {
  using type = ImmparvalueJs;
};

struct ImmradiotargetvalueJs : public Napi::ObjectWrap<ImmradiotargetvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getWords(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<hstd::Str> const&(org::imm::ImmRadioTargetValue::*)() const>(&org::imm::ImmRadioTargetValue::getWords),
                                        std::make_tuple()));
  }
  Napi::Value setWords(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmRadioTargetValue::*)(immer::flex_vector<hstd::Str> const&)>(&org::imm::ImmRadioTargetValue::setWords),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<hstd::Str>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmradiotargetvalueJs", {InstanceMethod("getWords", &ImmradiotargetvalueJs::getWords),
                                                                     InstanceMethod("setWords", &ImmradiotargetvalueJs::setWords)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmradiotargetvalueJs", func);
    return exports;
  }
  ImmradiotargetvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmradiotargetvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmradiotargetvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmRadioTargetValue> const& ptr) : Napi::ObjectWrap<ImmradiotargetvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmRadioTargetValue> _stored;
  org::imm::ImmRadioTargetValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmradiotargetvalueJs> {
  using type = org::imm::ImmRadioTargetValue;
};

template <>
struct org_to_js_type<org::imm::ImmRadioTargetValue> {
  using type = ImmradiotargetvalueJs;
};

struct ImmlatexvalueJs : public Napi::ObjectWrap<ImmlatexvalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmlatexvalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmlatexvalueJs", func);
    return exports;
  }
  ImmlatexvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmlatexvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmlatexvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmLatexValue> const& ptr) : Napi::ObjectWrap<ImmlatexvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmLatexValue> _stored;
  org::imm::ImmLatexValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmlatexvalueJs> {
  using type = org::imm::ImmLatexValue;
};

template <>
struct org_to_js_type<org::imm::ImmLatexValue> {
  using type = ImmlatexvalueJs;
};

struct ImmlinkvalueJs : public Napi::ObjectWrap<ImmlinkvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getDescription(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&(org::imm::ImmLinkValue::*)() const>(&org::imm::ImmLinkValue::getDescription),
                                        std::make_tuple()));
  }
  Napi::Value getTarget(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::LinkTarget const&(org::imm::ImmLinkValue::*)() const>(&org::imm::ImmLinkValue::getTarget),
                                        std::make_tuple()));
  }
  Napi::Value setDescription(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmLinkValue::*)(immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&)>(&org::imm::ImmLinkValue::setDescription),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>>>{"value"})));
  }
  Napi::Value setTarget(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmLinkValue::*)(org::sem::LinkTarget const&)>(&org::imm::ImmLinkValue::setTarget),
                                   std::make_tuple(CxxArgSpec<org::sem::LinkTarget>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmlinkvalueJs", {InstanceMethod("getDescription", &ImmlinkvalueJs::getDescription),
                                                              InstanceMethod("getTarget", &ImmlinkvalueJs::getTarget),
                                                              InstanceMethod("setDescription", &ImmlinkvalueJs::setDescription),
                                                              InstanceMethod("setTarget", &ImmlinkvalueJs::setTarget)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmlinkvalueJs", func);
    return exports;
  }
  ImmlinkvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmlinkvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmlinkvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmLinkValue> const& ptr) : Napi::ObjectWrap<ImmlinkvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmLinkValue> _stored;
  org::imm::ImmLinkValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmlinkvalueJs> {
  using type = org::imm::ImmLinkValue;
};

template <>
struct org_to_js_type<org::imm::ImmLinkValue> {
  using type = ImmlinkvalueJs;
};

struct ImmblockcentervalueJs : public Napi::ObjectWrap<ImmblockcentervalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmblockcentervalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmblockcentervalueJs", func);
    return exports;
  }
  ImmblockcentervalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmblockcentervalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmblockcentervalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmBlockCenterValue> const& ptr) : Napi::ObjectWrap<ImmblockcentervalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmBlockCenterValue> _stored;
  org::imm::ImmBlockCenterValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmblockcentervalueJs> {
  using type = org::imm::ImmBlockCenterValue;
};

template <>
struct org_to_js_type<org::imm::ImmBlockCenterValue> {
  using type = ImmblockcentervalueJs;
};

struct ImmblockquotevalueJs : public Napi::ObjectWrap<ImmblockquotevalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmblockquotevalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmblockquotevalueJs", func);
    return exports;
  }
  ImmblockquotevalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmblockquotevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmblockquotevalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmBlockQuoteValue> const& ptr) : Napi::ObjectWrap<ImmblockquotevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmBlockQuoteValue> _stored;
  org::imm::ImmBlockQuoteValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmblockquotevalueJs> {
  using type = org::imm::ImmBlockQuoteValue;
};

template <>
struct org_to_js_type<org::imm::ImmBlockQuoteValue> {
  using type = ImmblockquotevalueJs;
};

struct ImmblockcommentvalueJs : public Napi::ObjectWrap<ImmblockcommentvalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmblockcommentvalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmblockcommentvalueJs", func);
    return exports;
  }
  ImmblockcommentvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmblockcommentvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmblockcommentvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmBlockCommentValue> const& ptr) : Napi::ObjectWrap<ImmblockcommentvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmBlockCommentValue> _stored;
  org::imm::ImmBlockCommentValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmblockcommentvalueJs> {
  using type = org::imm::ImmBlockCommentValue;
};

template <>
struct org_to_js_type<org::imm::ImmBlockCommentValue> {
  using type = ImmblockcommentvalueJs;
};

struct ImmblockversevalueJs : public Napi::ObjectWrap<ImmblockversevalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmblockversevalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmblockversevalueJs", func);
    return exports;
  }
  ImmblockversevalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmblockversevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmblockversevalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmBlockVerseValue> const& ptr) : Napi::ObjectWrap<ImmblockversevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmBlockVerseValue> _stored;
  org::imm::ImmBlockVerseValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmblockversevalueJs> {
  using type = org::imm::ImmBlockVerseValue;
};

template <>
struct org_to_js_type<org::imm::ImmBlockVerseValue> {
  using type = ImmblockversevalueJs;
};

struct ImmblockdynamicfallbackvalueJs : public Napi::ObjectWrap<ImmblockdynamicfallbackvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmBlockDynamicFallbackValue::*)() const>(&org::imm::ImmBlockDynamicFallbackValue::getName),
                                        std::make_tuple()));
  }
  Napi::Value setName(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmBlockDynamicFallbackValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmBlockDynamicFallbackValue::setName),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmblockdynamicfallbackvalueJs", {InstanceMethod("getName", &ImmblockdynamicfallbackvalueJs::getName),
                                                                              InstanceMethod("setName", &ImmblockdynamicfallbackvalueJs::setName)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmblockdynamicfallbackvalueJs", func);
    return exports;
  }
  ImmblockdynamicfallbackvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmblockdynamicfallbackvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmblockdynamicfallbackvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmBlockDynamicFallbackValue> const& ptr) : Napi::ObjectWrap<ImmblockdynamicfallbackvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmBlockDynamicFallbackValue> _stored;
  org::imm::ImmBlockDynamicFallbackValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmblockdynamicfallbackvalueJs> {
  using type = org::imm::ImmBlockDynamicFallbackValue;
};

template <>
struct org_to_js_type<org::imm::ImmBlockDynamicFallbackValue> {
  using type = ImmblockdynamicfallbackvalueJs;
};

struct ImmblockexamplevalueJs : public Napi::ObjectWrap<ImmblockexamplevalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmblockexamplevalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmblockexamplevalueJs", func);
    return exports;
  }
  ImmblockexamplevalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmblockexamplevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmblockexamplevalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmBlockExampleValue> const& ptr) : Napi::ObjectWrap<ImmblockexamplevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmBlockExampleValue> _stored;
  org::imm::ImmBlockExampleValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmblockexamplevalueJs> {
  using type = org::imm::ImmBlockExampleValue;
};

template <>
struct org_to_js_type<org::imm::ImmBlockExampleValue> {
  using type = ImmblockexamplevalueJs;
};

struct ImmblockexportvalueJs : public Napi::ObjectWrap<ImmblockexportvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getExporter(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmBlockExportValue::*)() const>(&org::imm::ImmBlockExportValue::getExporter),
                                        std::make_tuple()));
  }
  Napi::Value getContent(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmBlockExportValue::*)() const>(&org::imm::ImmBlockExportValue::getContent),
                                        std::make_tuple()));
  }
  Napi::Value setExporter(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmBlockExportValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmBlockExportValue::setExporter),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setContent(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmBlockExportValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmBlockExportValue::setContent),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmblockexportvalueJs", {InstanceMethod("getExporter", &ImmblockexportvalueJs::getExporter),
                                                                     InstanceMethod("getContent", &ImmblockexportvalueJs::getContent),
                                                                     InstanceMethod("setExporter", &ImmblockexportvalueJs::setExporter),
                                                                     InstanceMethod("setContent", &ImmblockexportvalueJs::setContent)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmblockexportvalueJs", func);
    return exports;
  }
  ImmblockexportvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmblockexportvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmblockexportvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmBlockExportValue> const& ptr) : Napi::ObjectWrap<ImmblockexportvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmBlockExportValue> _stored;
  org::imm::ImmBlockExportValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmblockexportvalueJs> {
  using type = org::imm::ImmBlockExportValue;
};

template <>
struct org_to_js_type<org::imm::ImmBlockExportValue> {
  using type = ImmblockexportvalueJs;
};

struct ImmblockadmonitionvalueJs : public Napi::ObjectWrap<ImmblockadmonitionvalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmblockadmonitionvalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmblockadmonitionvalueJs", func);
    return exports;
  }
  ImmblockadmonitionvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmblockadmonitionvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmblockadmonitionvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmBlockAdmonitionValue> const& ptr) : Napi::ObjectWrap<ImmblockadmonitionvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmBlockAdmonitionValue> _stored;
  org::imm::ImmBlockAdmonitionValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmblockadmonitionvalueJs> {
  using type = org::imm::ImmBlockAdmonitionValue;
};

template <>
struct org_to_js_type<org::imm::ImmBlockAdmonitionValue> {
  using type = ImmblockadmonitionvalueJs;
};

struct ImmblockcodeevalresultvalueJs : public Napi::ObjectWrap<ImmblockcodeevalresultvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getRaw(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::sem::OrgCodeEvalOutput> const&(org::imm::ImmBlockCodeEvalResultValue::*)() const>(&org::imm::ImmBlockCodeEvalResultValue::getRaw),
                                        std::make_tuple()));
  }
  Napi::Value getNode(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmIdT<org::imm::ImmOrg> const&(org::imm::ImmBlockCodeEvalResultValue::*)() const>(&org::imm::ImmBlockCodeEvalResultValue::getNode),
                                        std::make_tuple()));
  }
  Napi::Value setRaw(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmBlockCodeEvalResultValue::*)(immer::flex_vector<org::sem::OrgCodeEvalOutput> const&)>(&org::imm::ImmBlockCodeEvalResultValue::setRaw),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<org::sem::OrgCodeEvalOutput>>{"value"})));
  }
  Napi::Value setNode(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmBlockCodeEvalResultValue::*)(org::imm::ImmIdT<org::imm::ImmOrg> const&)>(&org::imm::ImmBlockCodeEvalResultValue::setNode),
                                   std::make_tuple(CxxArgSpec<org::imm::ImmIdT<org::imm::ImmOrg>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmblockcodeevalresultvalueJs", {InstanceMethod("getRaw", &ImmblockcodeevalresultvalueJs::getRaw),
                                                                             InstanceMethod("getNode", &ImmblockcodeevalresultvalueJs::getNode),
                                                                             InstanceMethod("setRaw", &ImmblockcodeevalresultvalueJs::setRaw),
                                                                             InstanceMethod("setNode", &ImmblockcodeevalresultvalueJs::setNode)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmblockcodeevalresultvalueJs", func);
    return exports;
  }
  ImmblockcodeevalresultvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmblockcodeevalresultvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmblockcodeevalresultvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmBlockCodeEvalResultValue> const& ptr) : Napi::ObjectWrap<ImmblockcodeevalresultvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmBlockCodeEvalResultValue> _stored;
  org::imm::ImmBlockCodeEvalResultValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmblockcodeevalresultvalueJs> {
  using type = org::imm::ImmBlockCodeEvalResultValue;
};

template <>
struct org_to_js_type<org::imm::ImmBlockCodeEvalResultValue> {
  using type = ImmblockcodeevalresultvalueJs;
};

struct ImmblockcodevalueJs : public Napi::ObjectWrap<ImmblockcodevalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getLang(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmBlockCodeValue::*)() const>(&org::imm::ImmBlockCodeValue::getLang),
                                        std::make_tuple()));
  }
  Napi::Value getExports(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<BlockCodeExports const&(org::imm::ImmBlockCodeValue::*)() const>(&org::imm::ImmBlockCodeValue::getExports),
                                        std::make_tuple()));
  }
  Napi::Value getResult(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>> const&(org::imm::ImmBlockCodeValue::*)() const>(&org::imm::ImmBlockCodeValue::getResult),
                                        std::make_tuple()));
  }
  Napi::Value getLines(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::sem::BlockCodeLine> const&(org::imm::ImmBlockCodeValue::*)() const>(&org::imm::ImmBlockCodeValue::getLines),
                                        std::make_tuple()));
  }
  Napi::Value getCache(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmBlockCodeValue::*)() const>(&org::imm::ImmBlockCodeValue::getCache),
                                        std::make_tuple()));
  }
  Napi::Value getEval(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmBlockCodeValue::*)() const>(&org::imm::ImmBlockCodeValue::getEval),
                                        std::make_tuple()));
  }
  Napi::Value getNoweb(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmBlockCodeValue::*)() const>(&org::imm::ImmBlockCodeValue::getNoweb),
                                        std::make_tuple()));
  }
  Napi::Value getHlines(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmBlockCodeValue::*)() const>(&org::imm::ImmBlockCodeValue::getHlines),
                                        std::make_tuple()));
  }
  Napi::Value getTangle(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmBlockCodeValue::*)() const>(&org::imm::ImmBlockCodeValue::getTangle),
                                        std::make_tuple()));
  }
  Napi::Value getSwitches(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrGroup const&(org::imm::ImmBlockCodeValue::*)() const>(&org::imm::ImmBlockCodeValue::getSwitches),
                                        std::make_tuple()));
  }
  Napi::Value setLang(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmBlockCodeValue::*)(immer::box<std::optional<hstd::Str>> const&)>(&org::imm::ImmBlockCodeValue::setLang),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::Str>>>{"value"})));
  }
  Napi::Value setExports(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmBlockCodeValue::*)(BlockCodeExports const&)>(&org::imm::ImmBlockCodeValue::setExports),
                                   std::make_tuple(CxxArgSpec<BlockCodeExports>{"value"})));
  }
  Napi::Value setResult(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmBlockCodeValue::*)(immer::flex_vector<org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>> const&)>(&org::imm::ImmBlockCodeValue::setResult),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>>>{"value"})));
  }
  Napi::Value setLines(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmBlockCodeValue::*)(immer::flex_vector<org::sem::BlockCodeLine> const&)>(&org::imm::ImmBlockCodeValue::setLines),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<org::sem::BlockCodeLine>>{"value"})));
  }
  Napi::Value setCache(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmBlockCodeValue::*)(bool const&)>(&org::imm::ImmBlockCodeValue::setCache),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  Napi::Value setEval(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmBlockCodeValue::*)(bool const&)>(&org::imm::ImmBlockCodeValue::setEval),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  Napi::Value setNoweb(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmBlockCodeValue::*)(bool const&)>(&org::imm::ImmBlockCodeValue::setNoweb),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  Napi::Value setHlines(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmBlockCodeValue::*)(bool const&)>(&org::imm::ImmBlockCodeValue::setHlines),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  Napi::Value setTangle(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmBlockCodeValue::*)(bool const&)>(&org::imm::ImmBlockCodeValue::setTangle),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  Napi::Value setSwitches(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmBlockCodeValue::*)(org::sem::AttrGroup const&)>(&org::imm::ImmBlockCodeValue::setSwitches),
                                   std::make_tuple(CxxArgSpec<org::sem::AttrGroup>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmblockcodevalueJs", {InstanceMethod("getLang", &ImmblockcodevalueJs::getLang),
                                                                   InstanceMethod("getExports", &ImmblockcodevalueJs::getExports),
                                                                   InstanceMethod("getResult", &ImmblockcodevalueJs::getResult),
                                                                   InstanceMethod("getLines", &ImmblockcodevalueJs::getLines),
                                                                   InstanceMethod("getCache", &ImmblockcodevalueJs::getCache),
                                                                   InstanceMethod("getEval", &ImmblockcodevalueJs::getEval),
                                                                   InstanceMethod("getNoweb", &ImmblockcodevalueJs::getNoweb),
                                                                   InstanceMethod("getHlines", &ImmblockcodevalueJs::getHlines),
                                                                   InstanceMethod("getTangle", &ImmblockcodevalueJs::getTangle),
                                                                   InstanceMethod("getSwitches", &ImmblockcodevalueJs::getSwitches),
                                                                   InstanceMethod("setLang", &ImmblockcodevalueJs::setLang),
                                                                   InstanceMethod("setExports", &ImmblockcodevalueJs::setExports),
                                                                   InstanceMethod("setResult", &ImmblockcodevalueJs::setResult),
                                                                   InstanceMethod("setLines", &ImmblockcodevalueJs::setLines),
                                                                   InstanceMethod("setCache", &ImmblockcodevalueJs::setCache),
                                                                   InstanceMethod("setEval", &ImmblockcodevalueJs::setEval),
                                                                   InstanceMethod("setNoweb", &ImmblockcodevalueJs::setNoweb),
                                                                   InstanceMethod("setHlines", &ImmblockcodevalueJs::setHlines),
                                                                   InstanceMethod("setTangle", &ImmblockcodevalueJs::setTangle),
                                                                   InstanceMethod("setSwitches", &ImmblockcodevalueJs::setSwitches)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmblockcodevalueJs", func);
    return exports;
  }
  ImmblockcodevalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmblockcodevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmblockcodevalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmBlockCodeValue> const& ptr) : Napi::ObjectWrap<ImmblockcodevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmBlockCodeValue> _stored;
  org::imm::ImmBlockCodeValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmblockcodevalueJs> {
  using type = org::imm::ImmBlockCodeValue;
};

template <>
struct org_to_js_type<org::imm::ImmBlockCodeValue> {
  using type = ImmblockcodevalueJs;
};

struct ImmsubtreelogvalueJs : public Napi::ObjectWrap<ImmsubtreelogvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getHead(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SubtreeLogHead const&(org::imm::ImmSubtreeLogValue::*)() const>(&org::imm::ImmSubtreeLogValue::getHead),
                                        std::make_tuple()));
  }
  Napi::Value getDesc(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmStmtList>>> const&(org::imm::ImmSubtreeLogValue::*)() const>(&org::imm::ImmSubtreeLogValue::getDesc),
                                        std::make_tuple()));
  }
  Napi::Value setHead(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeLogValue::*)(org::sem::SubtreeLogHead const&)>(&org::imm::ImmSubtreeLogValue::setHead),
                                   std::make_tuple(CxxArgSpec<org::sem::SubtreeLogHead>{"value"})));
  }
  Napi::Value setDesc(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeLogValue::*)(immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmStmtList>>> const&)>(&org::imm::ImmSubtreeLogValue::setDesc),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmStmtList>>>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmsubtreelogvalueJs", {InstanceMethod("getHead", &ImmsubtreelogvalueJs::getHead),
                                                                    InstanceMethod("getDesc", &ImmsubtreelogvalueJs::getDesc),
                                                                    InstanceMethod("setHead", &ImmsubtreelogvalueJs::setHead),
                                                                    InstanceMethod("setDesc", &ImmsubtreelogvalueJs::setDesc)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmsubtreelogvalueJs", func);
    return exports;
  }
  ImmsubtreelogvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmsubtreelogvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmsubtreelogvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmSubtreeLogValue> const& ptr) : Napi::ObjectWrap<ImmsubtreelogvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmSubtreeLogValue> _stored;
  org::imm::ImmSubtreeLogValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmsubtreelogvalueJs> {
  using type = org::imm::ImmSubtreeLogValue;
};

template <>
struct org_to_js_type<org::imm::ImmSubtreeLogValue> {
  using type = ImmsubtreelogvalueJs;
};

struct ImmsubtreevalueJs : public Napi::ObjectWrap<ImmsubtreevalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getLevel(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int const&(org::imm::ImmSubtreeValue::*)() const>(&org::imm::ImmSubtreeValue::getLevel),
                                        std::make_tuple()));
  }
  Napi::Value getTreeid(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmSubtreeValue::*)() const>(&org::imm::ImmSubtreeValue::getTreeid),
                                        std::make_tuple()));
  }
  Napi::Value getTodo(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmSubtreeValue::*)() const>(&org::imm::ImmSubtreeValue::getTodo),
                                        std::make_tuple()));
  }
  Napi::Value getCompletion(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::sem::SubtreeCompletion>> const&(org::imm::ImmSubtreeValue::*)() const>(&org::imm::ImmSubtreeValue::getCompletion),
                                        std::make_tuple()));
  }
  Napi::Value getDescription(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&(org::imm::ImmSubtreeValue::*)() const>(&org::imm::ImmSubtreeValue::getDescription),
                                        std::make_tuple()));
  }
  Napi::Value getTags(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmHashTag>> const&(org::imm::ImmSubtreeValue::*)() const>(&org::imm::ImmSubtreeValue::getTags),
                                        std::make_tuple()));
  }
  Napi::Value getTitle(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmIdT<org::imm::ImmParagraph> const&(org::imm::ImmSubtreeValue::*)() const>(&org::imm::ImmSubtreeValue::getTitle),
                                        std::make_tuple()));
  }
  Napi::Value getLogbook(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmSubtreeLog>> const&(org::imm::ImmSubtreeValue::*)() const>(&org::imm::ImmSubtreeValue::getLogbook),
                                        std::make_tuple()));
  }
  Napi::Value getProperties(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::sem::NamedProperty> const&(org::imm::ImmSubtreeValue::*)() const>(&org::imm::ImmSubtreeValue::getProperties),
                                        std::make_tuple()));
  }
  Napi::Value getClosed(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::UserTime>> const&(org::imm::ImmSubtreeValue::*)() const>(&org::imm::ImmSubtreeValue::getClosed),
                                        std::make_tuple()));
  }
  Napi::Value getDeadline(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::UserTime>> const&(org::imm::ImmSubtreeValue::*)() const>(&org::imm::ImmSubtreeValue::getDeadline),
                                        std::make_tuple()));
  }
  Napi::Value getScheduled(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::UserTime>> const&(org::imm::ImmSubtreeValue::*)() const>(&org::imm::ImmSubtreeValue::getScheduled),
                                        std::make_tuple()));
  }
  Napi::Value getIscomment(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmSubtreeValue::*)() const>(&org::imm::ImmSubtreeValue::getIscomment),
                                        std::make_tuple()));
  }
  Napi::Value getIsarchived(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmSubtreeValue::*)() const>(&org::imm::ImmSubtreeValue::getIsarchived),
                                        std::make_tuple()));
  }
  Napi::Value getPriority(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmSubtreeValue::*)() const>(&org::imm::ImmSubtreeValue::getPriority),
                                        std::make_tuple()));
  }
  Napi::Value setLevel(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeValue::*)(int const&)>(&org::imm::ImmSubtreeValue::setLevel),
                                   std::make_tuple(CxxArgSpec<int>{"value"})));
  }
  Napi::Value setTreeid(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeValue::*)(immer::box<std::optional<hstd::Str>> const&)>(&org::imm::ImmSubtreeValue::setTreeid),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::Str>>>{"value"})));
  }
  Napi::Value setTodo(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeValue::*)(immer::box<std::optional<hstd::Str>> const&)>(&org::imm::ImmSubtreeValue::setTodo),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::Str>>>{"value"})));
  }
  Napi::Value setCompletion(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeValue::*)(immer::box<std::optional<org::sem::SubtreeCompletion>> const&)>(&org::imm::ImmSubtreeValue::setCompletion),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<org::sem::SubtreeCompletion>>>{"value"})));
  }
  Napi::Value setDescription(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeValue::*)(immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&)>(&org::imm::ImmSubtreeValue::setDescription),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>>>{"value"})));
  }
  Napi::Value setTags(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeValue::*)(immer::flex_vector<org::imm::ImmIdT<org::imm::ImmHashTag>> const&)>(&org::imm::ImmSubtreeValue::setTags),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmHashTag>>>{"value"})));
  }
  Napi::Value setTitle(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeValue::*)(org::imm::ImmIdT<org::imm::ImmParagraph> const&)>(&org::imm::ImmSubtreeValue::setTitle),
                                   std::make_tuple(CxxArgSpec<org::imm::ImmIdT<org::imm::ImmParagraph>>{"value"})));
  }
  Napi::Value setLogbook(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeValue::*)(immer::flex_vector<org::imm::ImmIdT<org::imm::ImmSubtreeLog>> const&)>(&org::imm::ImmSubtreeValue::setLogbook),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmSubtreeLog>>>{"value"})));
  }
  Napi::Value setProperties(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeValue::*)(immer::flex_vector<org::sem::NamedProperty> const&)>(&org::imm::ImmSubtreeValue::setProperties),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<org::sem::NamedProperty>>{"value"})));
  }
  Napi::Value setClosed(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeValue::*)(immer::box<std::optional<hstd::UserTime>> const&)>(&org::imm::ImmSubtreeValue::setClosed),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::UserTime>>>{"value"})));
  }
  Napi::Value setDeadline(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeValue::*)(immer::box<std::optional<hstd::UserTime>> const&)>(&org::imm::ImmSubtreeValue::setDeadline),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::UserTime>>>{"value"})));
  }
  Napi::Value setScheduled(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeValue::*)(immer::box<std::optional<hstd::UserTime>> const&)>(&org::imm::ImmSubtreeValue::setScheduled),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::UserTime>>>{"value"})));
  }
  Napi::Value setIscomment(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeValue::*)(bool const&)>(&org::imm::ImmSubtreeValue::setIscomment),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  Napi::Value setIsarchived(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeValue::*)(bool const&)>(&org::imm::ImmSubtreeValue::setIsarchived),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  Napi::Value setPriority(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeValue::*)(immer::box<std::optional<hstd::Str>> const&)>(&org::imm::ImmSubtreeValue::setPriority),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::Str>>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmsubtreevalueJs", {InstanceMethod("getLevel", &ImmsubtreevalueJs::getLevel),
                                                                 InstanceMethod("getTreeid", &ImmsubtreevalueJs::getTreeid),
                                                                 InstanceMethod("getTodo", &ImmsubtreevalueJs::getTodo),
                                                                 InstanceMethod("getCompletion", &ImmsubtreevalueJs::getCompletion),
                                                                 InstanceMethod("getDescription", &ImmsubtreevalueJs::getDescription),
                                                                 InstanceMethod("getTags", &ImmsubtreevalueJs::getTags),
                                                                 InstanceMethod("getTitle", &ImmsubtreevalueJs::getTitle),
                                                                 InstanceMethod("getLogbook", &ImmsubtreevalueJs::getLogbook),
                                                                 InstanceMethod("getProperties", &ImmsubtreevalueJs::getProperties),
                                                                 InstanceMethod("getClosed", &ImmsubtreevalueJs::getClosed),
                                                                 InstanceMethod("getDeadline", &ImmsubtreevalueJs::getDeadline),
                                                                 InstanceMethod("getScheduled", &ImmsubtreevalueJs::getScheduled),
                                                                 InstanceMethod("getIscomment", &ImmsubtreevalueJs::getIscomment),
                                                                 InstanceMethod("getIsarchived", &ImmsubtreevalueJs::getIsarchived),
                                                                 InstanceMethod("getPriority", &ImmsubtreevalueJs::getPriority),
                                                                 InstanceMethod("setLevel", &ImmsubtreevalueJs::setLevel),
                                                                 InstanceMethod("setTreeid", &ImmsubtreevalueJs::setTreeid),
                                                                 InstanceMethod("setTodo", &ImmsubtreevalueJs::setTodo),
                                                                 InstanceMethod("setCompletion", &ImmsubtreevalueJs::setCompletion),
                                                                 InstanceMethod("setDescription", &ImmsubtreevalueJs::setDescription),
                                                                 InstanceMethod("setTags", &ImmsubtreevalueJs::setTags),
                                                                 InstanceMethod("setTitle", &ImmsubtreevalueJs::setTitle),
                                                                 InstanceMethod("setLogbook", &ImmsubtreevalueJs::setLogbook),
                                                                 InstanceMethod("setProperties", &ImmsubtreevalueJs::setProperties),
                                                                 InstanceMethod("setClosed", &ImmsubtreevalueJs::setClosed),
                                                                 InstanceMethod("setDeadline", &ImmsubtreevalueJs::setDeadline),
                                                                 InstanceMethod("setScheduled", &ImmsubtreevalueJs::setScheduled),
                                                                 InstanceMethod("setIscomment", &ImmsubtreevalueJs::setIscomment),
                                                                 InstanceMethod("setIsarchived", &ImmsubtreevalueJs::setIsarchived),
                                                                 InstanceMethod("setPriority", &ImmsubtreevalueJs::setPriority)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmsubtreevalueJs", func);
    return exports;
  }
  ImmsubtreevalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmsubtreevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmsubtreevalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmSubtreeValue> const& ptr) : Napi::ObjectWrap<ImmsubtreevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmSubtreeValue> _stored;
  org::imm::ImmSubtreeValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmsubtreevalueJs> {
  using type = org::imm::ImmSubtreeValue;
};

template <>
struct org_to_js_type<org::imm::ImmSubtreeValue> {
  using type = ImmsubtreevalueJs;
};

struct ImmcellvalueJs : public Napi::ObjectWrap<ImmcellvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getIsblock(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmCellValue::*)() const>(&org::imm::ImmCellValue::getIsblock),
                                        std::make_tuple()));
  }
  Napi::Value setIsblock(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCellValue::*)(bool const&)>(&org::imm::ImmCellValue::setIsblock),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmcellvalueJs", {InstanceMethod("getIsblock", &ImmcellvalueJs::getIsblock),
                                                              InstanceMethod("setIsblock", &ImmcellvalueJs::setIsblock)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmcellvalueJs", func);
    return exports;
  }
  ImmcellvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmcellvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmcellvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmCellValue> const& ptr) : Napi::ObjectWrap<ImmcellvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmCellValue> _stored;
  org::imm::ImmCellValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmcellvalueJs> {
  using type = org::imm::ImmCellValue;
};

template <>
struct org_to_js_type<org::imm::ImmCellValue> {
  using type = ImmcellvalueJs;
};

struct ImmrowvalueJs : public Napi::ObjectWrap<ImmrowvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getCells(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmCell>> const&(org::imm::ImmRowValue::*)() const>(&org::imm::ImmRowValue::getCells),
                                        std::make_tuple()));
  }
  Napi::Value getIsblock(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmRowValue::*)() const>(&org::imm::ImmRowValue::getIsblock),
                                        std::make_tuple()));
  }
  Napi::Value setCells(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmRowValue::*)(immer::flex_vector<org::imm::ImmIdT<org::imm::ImmCell>> const&)>(&org::imm::ImmRowValue::setCells),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmCell>>>{"value"})));
  }
  Napi::Value setIsblock(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmRowValue::*)(bool const&)>(&org::imm::ImmRowValue::setIsblock),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmrowvalueJs", {InstanceMethod("getCells", &ImmrowvalueJs::getCells),
                                                             InstanceMethod("getIsblock", &ImmrowvalueJs::getIsblock),
                                                             InstanceMethod("setCells", &ImmrowvalueJs::setCells),
                                                             InstanceMethod("setIsblock", &ImmrowvalueJs::setIsblock)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmrowvalueJs", func);
    return exports;
  }
  ImmrowvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmrowvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmrowvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmRowValue> const& ptr) : Napi::ObjectWrap<ImmrowvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmRowValue> _stored;
  org::imm::ImmRowValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmrowvalueJs> {
  using type = org::imm::ImmRowValue;
};

template <>
struct org_to_js_type<org::imm::ImmRowValue> {
  using type = ImmrowvalueJs;
};

struct ImmtablevalueJs : public Napi::ObjectWrap<ImmtablevalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getRows(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmRow>> const&(org::imm::ImmTableValue::*)() const>(&org::imm::ImmTableValue::getRows),
                                        std::make_tuple()));
  }
  Napi::Value getIsblock(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmTableValue::*)() const>(&org::imm::ImmTableValue::getIsblock),
                                        std::make_tuple()));
  }
  Napi::Value setRows(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmTableValue::*)(immer::flex_vector<org::imm::ImmIdT<org::imm::ImmRow>> const&)>(&org::imm::ImmTableValue::setRows),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmRow>>>{"value"})));
  }
  Napi::Value setIsblock(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmTableValue::*)(bool const&)>(&org::imm::ImmTableValue::setIsblock),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmtablevalueJs", {InstanceMethod("getRows", &ImmtablevalueJs::getRows),
                                                               InstanceMethod("getIsblock", &ImmtablevalueJs::getIsblock),
                                                               InstanceMethod("setRows", &ImmtablevalueJs::setRows),
                                                               InstanceMethod("setIsblock", &ImmtablevalueJs::setIsblock)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmtablevalueJs", func);
    return exports;
  }
  ImmtablevalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmtablevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmtablevalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmTableValue> const& ptr) : Napi::ObjectWrap<ImmtablevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmTableValue> _stored;
  org::imm::ImmTableValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmtablevalueJs> {
  using type = org::imm::ImmTableValue;
};

template <>
struct org_to_js_type<org::imm::ImmTableValue> {
  using type = ImmtablevalueJs;
};

struct ImmparagraphvalueJs : public Napi::ObjectWrap<ImmparagraphvalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmparagraphvalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmparagraphvalueJs", func);
    return exports;
  }
  ImmparagraphvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmparagraphvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmparagraphvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmParagraphValue> const& ptr) : Napi::ObjectWrap<ImmparagraphvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmParagraphValue> _stored;
  org::imm::ImmParagraphValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmparagraphvalueJs> {
  using type = org::imm::ImmParagraphValue;
};

template <>
struct org_to_js_type<org::imm::ImmParagraphValue> {
  using type = ImmparagraphvalueJs;
};

struct ImmcolonexamplevalueJs : public Napi::ObjectWrap<ImmcolonexamplevalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmcolonexamplevalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmcolonexamplevalueJs", func);
    return exports;
  }
  ImmcolonexamplevalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmcolonexamplevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmcolonexamplevalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmColonExampleValue> const& ptr) : Napi::ObjectWrap<ImmcolonexamplevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmColonExampleValue> _stored;
  org::imm::ImmColonExampleValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmcolonexamplevalueJs> {
  using type = org::imm::ImmColonExampleValue;
};

template <>
struct org_to_js_type<org::imm::ImmColonExampleValue> {
  using type = ImmcolonexamplevalueJs;
};

struct ImmcmdattrvalueJs : public Napi::ObjectWrap<ImmcmdattrvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getTarget(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdAttrValue::*)() const>(&org::imm::ImmCmdAttrValue::getTarget),
                                        std::make_tuple()));
  }
  Napi::Value setTarget(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdAttrValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmCmdAttrValue::setTarget),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmcmdattrvalueJs", {InstanceMethod("getTarget", &ImmcmdattrvalueJs::getTarget),
                                                                 InstanceMethod("setTarget", &ImmcmdattrvalueJs::setTarget)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmcmdattrvalueJs", func);
    return exports;
  }
  ImmcmdattrvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmcmdattrvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmcmdattrvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmCmdAttrValue> const& ptr) : Napi::ObjectWrap<ImmcmdattrvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmCmdAttrValue> _stored;
  org::imm::ImmCmdAttrValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmcmdattrvalueJs> {
  using type = org::imm::ImmCmdAttrValue;
};

template <>
struct org_to_js_type<org::imm::ImmCmdAttrValue> {
  using type = ImmcmdattrvalueJs;
};

struct ImmcmdexportvalueJs : public Napi::ObjectWrap<ImmcmdexportvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getExporter(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdExportValue::*)() const>(&org::imm::ImmCmdExportValue::getExporter),
                                        std::make_tuple()));
  }
  Napi::Value getContent(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdExportValue::*)() const>(&org::imm::ImmCmdExportValue::getContent),
                                        std::make_tuple()));
  }
  Napi::Value setExporter(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdExportValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmCmdExportValue::setExporter),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setContent(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdExportValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmCmdExportValue::setContent),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmcmdexportvalueJs", {InstanceMethod("getExporter", &ImmcmdexportvalueJs::getExporter),
                                                                   InstanceMethod("getContent", &ImmcmdexportvalueJs::getContent),
                                                                   InstanceMethod("setExporter", &ImmcmdexportvalueJs::setExporter),
                                                                   InstanceMethod("setContent", &ImmcmdexportvalueJs::setContent)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmcmdexportvalueJs", func);
    return exports;
  }
  ImmcmdexportvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmcmdexportvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmcmdexportvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmCmdExportValue> const& ptr) : Napi::ObjectWrap<ImmcmdexportvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmCmdExportValue> _stored;
  org::imm::ImmCmdExportValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmcmdexportvalueJs> {
  using type = org::imm::ImmCmdExportValue;
};

template <>
struct org_to_js_type<org::imm::ImmCmdExportValue> {
  using type = ImmcmdexportvalueJs;
};

struct ImmcallvalueJs : public Napi::ObjectWrap<ImmcallvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCallValue::*)() const>(&org::imm::ImmCallValue::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrGroup const&(org::imm::ImmCallValue::*)() const>(&org::imm::ImmCallValue::getAttrs),
                                        std::make_tuple()));
  }
  Napi::Value getIscommand(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmCallValue::*)() const>(&org::imm::ImmCallValue::getIscommand),
                                        std::make_tuple()));
  }
  Napi::Value setName(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCallValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmCallValue::setName),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setAttrs(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCallValue::*)(org::sem::AttrGroup const&)>(&org::imm::ImmCallValue::setAttrs),
                                   std::make_tuple(CxxArgSpec<org::sem::AttrGroup>{"value"})));
  }
  Napi::Value setIscommand(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCallValue::*)(bool const&)>(&org::imm::ImmCallValue::setIscommand),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmcallvalueJs", {InstanceMethod("getName", &ImmcallvalueJs::getName),
                                                              InstanceMethod("getAttrs", &ImmcallvalueJs::getAttrs),
                                                              InstanceMethod("getIscommand", &ImmcallvalueJs::getIscommand),
                                                              InstanceMethod("setName", &ImmcallvalueJs::setName),
                                                              InstanceMethod("setAttrs", &ImmcallvalueJs::setAttrs),
                                                              InstanceMethod("setIscommand", &ImmcallvalueJs::setIscommand)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmcallvalueJs", func);
    return exports;
  }
  ImmcallvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmcallvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmcallvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmCallValue> const& ptr) : Napi::ObjectWrap<ImmcallvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmCallValue> _stored;
  org::imm::ImmCallValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmcallvalueJs> {
  using type = org::imm::ImmCallValue;
};

template <>
struct org_to_js_type<org::imm::ImmCallValue> {
  using type = ImmcallvalueJs;
};

struct ImmlistvalueJs : public Napi::ObjectWrap<ImmlistvalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmlistvalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmlistvalueJs", func);
    return exports;
  }
  ImmlistvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmlistvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmlistvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmListValue> const& ptr) : Napi::ObjectWrap<ImmlistvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmListValue> _stored;
  org::imm::ImmListValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmlistvalueJs> {
  using type = org::imm::ImmListValue;
};

template <>
struct org_to_js_type<org::imm::ImmListValue> {
  using type = ImmlistvalueJs;
};

struct ImmlistitemvalueJs : public Napi::ObjectWrap<ImmlistitemvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getCheckbox(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmListItem::Checkbox const&(org::imm::ImmListItemValue::*)() const>(&org::imm::ImmListItemValue::getCheckbox),
                                        std::make_tuple()));
  }
  Napi::Value getHeader(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&(org::imm::ImmListItemValue::*)() const>(&org::imm::ImmListItemValue::getHeader),
                                        std::make_tuple()));
  }
  Napi::Value getBullet(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmListItemValue::*)() const>(&org::imm::ImmListItemValue::getBullet),
                                        std::make_tuple()));
  }
  Napi::Value setCheckbox(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmListItemValue::*)(org::imm::ImmListItem::Checkbox const&)>(&org::imm::ImmListItemValue::setCheckbox),
                                   std::make_tuple(CxxArgSpec<org::imm::ImmListItem::Checkbox>{"value"})));
  }
  Napi::Value setHeader(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmListItemValue::*)(immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&)>(&org::imm::ImmListItemValue::setHeader),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>>>{"value"})));
  }
  Napi::Value setBullet(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmListItemValue::*)(immer::box<std::optional<hstd::Str>> const&)>(&org::imm::ImmListItemValue::setBullet),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::Str>>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmlistitemvalueJs", {InstanceMethod("getCheckbox", &ImmlistitemvalueJs::getCheckbox),
                                                                  InstanceMethod("getHeader", &ImmlistitemvalueJs::getHeader),
                                                                  InstanceMethod("getBullet", &ImmlistitemvalueJs::getBullet),
                                                                  InstanceMethod("setCheckbox", &ImmlistitemvalueJs::setCheckbox),
                                                                  InstanceMethod("setHeader", &ImmlistitemvalueJs::setHeader),
                                                                  InstanceMethod("setBullet", &ImmlistitemvalueJs::setBullet)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmlistitemvalueJs", func);
    return exports;
  }
  ImmlistitemvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmlistitemvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmlistitemvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmListItemValue> const& ptr) : Napi::ObjectWrap<ImmlistitemvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmListItemValue> _stored;
  org::imm::ImmListItemValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmlistitemvalueJs> {
  using type = org::imm::ImmListItemValue;
};

template <>
struct org_to_js_type<org::imm::ImmListItemValue> {
  using type = ImmlistitemvalueJs;
};

struct ImmdocumentoptionsvalueJs : public Napi::ObjectWrap<ImmdocumentoptionsvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getInitialvisibility(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<InitialSubtreeVisibility const&(org::imm::ImmDocumentOptionsValue::*)() const>(&org::imm::ImmDocumentOptionsValue::getInitialvisibility),
                                        std::make_tuple()));
  }
  Napi::Value getProperties(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::sem::NamedProperty> const&(org::imm::ImmDocumentOptionsValue::*)() const>(&org::imm::ImmDocumentOptionsValue::getProperties),
                                        std::make_tuple()));
  }
  Napi::Value getExportconfig(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::DocumentExportConfig const&(org::imm::ImmDocumentOptionsValue::*)() const>(&org::imm::ImmDocumentOptionsValue::getExportconfig),
                                        std::make_tuple()));
  }
  Napi::Value getFixedwidthsections(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<bool>> const&(org::imm::ImmDocumentOptionsValue::*)() const>(&org::imm::ImmDocumentOptionsValue::getFixedwidthsections),
                                        std::make_tuple()));
  }
  Napi::Value getStartupindented(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<bool>> const&(org::imm::ImmDocumentOptionsValue::*)() const>(&org::imm::ImmDocumentOptionsValue::getStartupindented),
                                        std::make_tuple()));
  }
  Napi::Value getCategory(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmDocumentOptionsValue::*)() const>(&org::imm::ImmDocumentOptionsValue::getCategory),
                                        std::make_tuple()));
  }
  Napi::Value getSetupfile(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmDocumentOptionsValue::*)() const>(&org::imm::ImmDocumentOptionsValue::getSetupfile),
                                        std::make_tuple()));
  }
  Napi::Value getMaxsubtreelevelexport(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<int>> const&(org::imm::ImmDocumentOptionsValue::*)() const>(&org::imm::ImmDocumentOptionsValue::getMaxsubtreelevelexport),
                                        std::make_tuple()));
  }
  Napi::Value getColumns(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::sem::ColumnView>> const&(org::imm::ImmDocumentOptionsValue::*)() const>(&org::imm::ImmDocumentOptionsValue::getColumns),
                                        std::make_tuple()));
  }
  Napi::Value setInitialvisibility(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentOptionsValue::*)(InitialSubtreeVisibility const&)>(&org::imm::ImmDocumentOptionsValue::setInitialvisibility),
                                   std::make_tuple(CxxArgSpec<InitialSubtreeVisibility>{"value"})));
  }
  Napi::Value setProperties(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentOptionsValue::*)(immer::flex_vector<org::sem::NamedProperty> const&)>(&org::imm::ImmDocumentOptionsValue::setProperties),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<org::sem::NamedProperty>>{"value"})));
  }
  Napi::Value setExportconfig(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentOptionsValue::*)(org::sem::DocumentExportConfig const&)>(&org::imm::ImmDocumentOptionsValue::setExportconfig),
                                   std::make_tuple(CxxArgSpec<org::sem::DocumentExportConfig>{"value"})));
  }
  Napi::Value setFixedwidthsections(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentOptionsValue::*)(immer::box<std::optional<bool>> const&)>(&org::imm::ImmDocumentOptionsValue::setFixedwidthsections),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<bool>>>{"value"})));
  }
  Napi::Value setStartupindented(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentOptionsValue::*)(immer::box<std::optional<bool>> const&)>(&org::imm::ImmDocumentOptionsValue::setStartupindented),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<bool>>>{"value"})));
  }
  Napi::Value setCategory(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentOptionsValue::*)(immer::box<std::optional<hstd::Str>> const&)>(&org::imm::ImmDocumentOptionsValue::setCategory),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::Str>>>{"value"})));
  }
  Napi::Value setSetupfile(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentOptionsValue::*)(immer::box<std::optional<hstd::Str>> const&)>(&org::imm::ImmDocumentOptionsValue::setSetupfile),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::Str>>>{"value"})));
  }
  Napi::Value setMaxsubtreelevelexport(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentOptionsValue::*)(immer::box<std::optional<int>> const&)>(&org::imm::ImmDocumentOptionsValue::setMaxsubtreelevelexport),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<int>>>{"value"})));
  }
  Napi::Value setColumns(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentOptionsValue::*)(immer::box<std::optional<org::sem::ColumnView>> const&)>(&org::imm::ImmDocumentOptionsValue::setColumns),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<org::sem::ColumnView>>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmdocumentoptionsvalueJs", {InstanceMethod("getInitialvisibility", &ImmdocumentoptionsvalueJs::getInitialvisibility),
                                                                         InstanceMethod("getProperties", &ImmdocumentoptionsvalueJs::getProperties),
                                                                         InstanceMethod("getExportconfig", &ImmdocumentoptionsvalueJs::getExportconfig),
                                                                         InstanceMethod("getFixedwidthsections", &ImmdocumentoptionsvalueJs::getFixedwidthsections),
                                                                         InstanceMethod("getStartupindented", &ImmdocumentoptionsvalueJs::getStartupindented),
                                                                         InstanceMethod("getCategory", &ImmdocumentoptionsvalueJs::getCategory),
                                                                         InstanceMethod("getSetupfile", &ImmdocumentoptionsvalueJs::getSetupfile),
                                                                         InstanceMethod("getMaxsubtreelevelexport", &ImmdocumentoptionsvalueJs::getMaxsubtreelevelexport),
                                                                         InstanceMethod("getColumns", &ImmdocumentoptionsvalueJs::getColumns),
                                                                         InstanceMethod("setInitialvisibility", &ImmdocumentoptionsvalueJs::setInitialvisibility),
                                                                         InstanceMethod("setProperties", &ImmdocumentoptionsvalueJs::setProperties),
                                                                         InstanceMethod("setExportconfig", &ImmdocumentoptionsvalueJs::setExportconfig),
                                                                         InstanceMethod("setFixedwidthsections", &ImmdocumentoptionsvalueJs::setFixedwidthsections),
                                                                         InstanceMethod("setStartupindented", &ImmdocumentoptionsvalueJs::setStartupindented),
                                                                         InstanceMethod("setCategory", &ImmdocumentoptionsvalueJs::setCategory),
                                                                         InstanceMethod("setSetupfile", &ImmdocumentoptionsvalueJs::setSetupfile),
                                                                         InstanceMethod("setMaxsubtreelevelexport", &ImmdocumentoptionsvalueJs::setMaxsubtreelevelexport),
                                                                         InstanceMethod("setColumns", &ImmdocumentoptionsvalueJs::setColumns)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmdocumentoptionsvalueJs", func);
    return exports;
  }
  ImmdocumentoptionsvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmdocumentoptionsvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmdocumentoptionsvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmDocumentOptionsValue> const& ptr) : Napi::ObjectWrap<ImmdocumentoptionsvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmDocumentOptionsValue> _stored;
  org::imm::ImmDocumentOptionsValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmdocumentoptionsvalueJs> {
  using type = org::imm::ImmDocumentOptionsValue;
};

template <>
struct org_to_js_type<org::imm::ImmDocumentOptionsValue> {
  using type = ImmdocumentoptionsvalueJs;
};

struct ImmdocumentfragmentvalueJs : public Napi::ObjectWrap<ImmdocumentfragmentvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getBaseline(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int const&(org::imm::ImmDocumentFragmentValue::*)() const>(&org::imm::ImmDocumentFragmentValue::getBaseline),
                                        std::make_tuple()));
  }
  Napi::Value getBasecol(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int const&(org::imm::ImmDocumentFragmentValue::*)() const>(&org::imm::ImmDocumentFragmentValue::getBasecol),
                                        std::make_tuple()));
  }
  Napi::Value setBaseline(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentFragmentValue::*)(int const&)>(&org::imm::ImmDocumentFragmentValue::setBaseline),
                                   std::make_tuple(CxxArgSpec<int>{"value"})));
  }
  Napi::Value setBasecol(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentFragmentValue::*)(int const&)>(&org::imm::ImmDocumentFragmentValue::setBasecol),
                                   std::make_tuple(CxxArgSpec<int>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmdocumentfragmentvalueJs", {InstanceMethod("getBaseline", &ImmdocumentfragmentvalueJs::getBaseline),
                                                                          InstanceMethod("getBasecol", &ImmdocumentfragmentvalueJs::getBasecol),
                                                                          InstanceMethod("setBaseline", &ImmdocumentfragmentvalueJs::setBaseline),
                                                                          InstanceMethod("setBasecol", &ImmdocumentfragmentvalueJs::setBasecol)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmdocumentfragmentvalueJs", func);
    return exports;
  }
  ImmdocumentfragmentvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmdocumentfragmentvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmdocumentfragmentvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmDocumentFragmentValue> const& ptr) : Napi::ObjectWrap<ImmdocumentfragmentvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmDocumentFragmentValue> _stored;
  org::imm::ImmDocumentFragmentValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmdocumentfragmentvalueJs> {
  using type = org::imm::ImmDocumentFragmentValue;
};

template <>
struct org_to_js_type<org::imm::ImmDocumentFragmentValue> {
  using type = ImmdocumentfragmentvalueJs;
};

struct ImmcriticmarkupvalueJs : public Napi::ObjectWrap<ImmcriticmarkupvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCriticMarkup::Kind const&(org::imm::ImmCriticMarkupValue::*)() const>(&org::imm::ImmCriticMarkupValue::getKind),
                                        std::make_tuple()));
  }
  Napi::Value setKind(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCriticMarkupValue::*)(org::imm::ImmCriticMarkup::Kind const&)>(&org::imm::ImmCriticMarkupValue::setKind),
                                   std::make_tuple(CxxArgSpec<org::imm::ImmCriticMarkup::Kind>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmcriticmarkupvalueJs", {InstanceMethod("getKind", &ImmcriticmarkupvalueJs::getKind),
                                                                      InstanceMethod("setKind", &ImmcriticmarkupvalueJs::setKind)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmcriticmarkupvalueJs", func);
    return exports;
  }
  ImmcriticmarkupvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmcriticmarkupvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmcriticmarkupvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmCriticMarkupValue> const& ptr) : Napi::ObjectWrap<ImmcriticmarkupvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmCriticMarkupValue> _stored;
  org::imm::ImmCriticMarkupValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmcriticmarkupvalueJs> {
  using type = org::imm::ImmCriticMarkupValue;
};

template <>
struct org_to_js_type<org::imm::ImmCriticMarkupValue> {
  using type = ImmcriticmarkupvalueJs;
};

struct ImmdocumentvalueJs : public Napi::ObjectWrap<ImmdocumentvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getTitle(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&(org::imm::ImmDocumentValue::*)() const>(&org::imm::ImmDocumentValue::getTitle),
                                        std::make_tuple()));
  }
  Napi::Value getAuthor(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&(org::imm::ImmDocumentValue::*)() const>(&org::imm::ImmDocumentValue::getAuthor),
                                        std::make_tuple()));
  }
  Napi::Value getCreator(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&(org::imm::ImmDocumentValue::*)() const>(&org::imm::ImmDocumentValue::getCreator),
                                        std::make_tuple()));
  }
  Napi::Value getFiletags(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmHashTag>> const&(org::imm::ImmDocumentValue::*)() const>(&org::imm::ImmDocumentValue::getFiletags),
                                        std::make_tuple()));
  }
  Napi::Value getEmail(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmRawText>>> const&(org::imm::ImmDocumentValue::*)() const>(&org::imm::ImmDocumentValue::getEmail),
                                        std::make_tuple()));
  }
  Napi::Value getLanguage(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<hstd::Str> const&(org::imm::ImmDocumentValue::*)() const>(&org::imm::ImmDocumentValue::getLanguage),
                                        std::make_tuple()));
  }
  Napi::Value getOptions(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmIdT<org::imm::ImmDocumentOptions> const&(org::imm::ImmDocumentValue::*)() const>(&org::imm::ImmDocumentValue::getOptions),
                                        std::make_tuple()));
  }
  Napi::Value getExportfilename(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmDocumentValue::*)() const>(&org::imm::ImmDocumentValue::getExportfilename),
                                        std::make_tuple()));
  }
  Napi::Value setTitle(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentValue::*)(immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&)>(&org::imm::ImmDocumentValue::setTitle),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>>>{"value"})));
  }
  Napi::Value setAuthor(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentValue::*)(immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&)>(&org::imm::ImmDocumentValue::setAuthor),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>>>{"value"})));
  }
  Napi::Value setCreator(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentValue::*)(immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&)>(&org::imm::ImmDocumentValue::setCreator),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>>>{"value"})));
  }
  Napi::Value setFiletags(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentValue::*)(immer::flex_vector<org::imm::ImmIdT<org::imm::ImmHashTag>> const&)>(&org::imm::ImmDocumentValue::setFiletags),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmHashTag>>>{"value"})));
  }
  Napi::Value setEmail(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentValue::*)(immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmRawText>>> const&)>(&org::imm::ImmDocumentValue::setEmail),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmRawText>>>>{"value"})));
  }
  Napi::Value setLanguage(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentValue::*)(immer::flex_vector<hstd::Str> const&)>(&org::imm::ImmDocumentValue::setLanguage),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<hstd::Str>>{"value"})));
  }
  Napi::Value setOptions(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentValue::*)(org::imm::ImmIdT<org::imm::ImmDocumentOptions> const&)>(&org::imm::ImmDocumentValue::setOptions),
                                   std::make_tuple(CxxArgSpec<org::imm::ImmIdT<org::imm::ImmDocumentOptions>>{"value"})));
  }
  Napi::Value setExportfilename(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentValue::*)(immer::box<std::optional<hstd::Str>> const&)>(&org::imm::ImmDocumentValue::setExportfilename),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::Str>>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmdocumentvalueJs", {InstanceMethod("getTitle", &ImmdocumentvalueJs::getTitle),
                                                                  InstanceMethod("getAuthor", &ImmdocumentvalueJs::getAuthor),
                                                                  InstanceMethod("getCreator", &ImmdocumentvalueJs::getCreator),
                                                                  InstanceMethod("getFiletags", &ImmdocumentvalueJs::getFiletags),
                                                                  InstanceMethod("getEmail", &ImmdocumentvalueJs::getEmail),
                                                                  InstanceMethod("getLanguage", &ImmdocumentvalueJs::getLanguage),
                                                                  InstanceMethod("getOptions", &ImmdocumentvalueJs::getOptions),
                                                                  InstanceMethod("getExportfilename", &ImmdocumentvalueJs::getExportfilename),
                                                                  InstanceMethod("setTitle", &ImmdocumentvalueJs::setTitle),
                                                                  InstanceMethod("setAuthor", &ImmdocumentvalueJs::setAuthor),
                                                                  InstanceMethod("setCreator", &ImmdocumentvalueJs::setCreator),
                                                                  InstanceMethod("setFiletags", &ImmdocumentvalueJs::setFiletags),
                                                                  InstanceMethod("setEmail", &ImmdocumentvalueJs::setEmail),
                                                                  InstanceMethod("setLanguage", &ImmdocumentvalueJs::setLanguage),
                                                                  InstanceMethod("setOptions", &ImmdocumentvalueJs::setOptions),
                                                                  InstanceMethod("setExportfilename", &ImmdocumentvalueJs::setExportfilename)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmdocumentvalueJs", func);
    return exports;
  }
  ImmdocumentvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmdocumentvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmdocumentvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmDocumentValue> const& ptr) : Napi::ObjectWrap<ImmdocumentvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmDocumentValue> _stored;
  org::imm::ImmDocumentValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmdocumentvalueJs> {
  using type = org::imm::ImmDocumentValue;
};

template <>
struct org_to_js_type<org::imm::ImmDocumentValue> {
  using type = ImmdocumentvalueJs;
};

struct ImmfiletargetvalueJs : public Napi::ObjectWrap<ImmfiletargetvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getPath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmFileTargetValue::*)() const>(&org::imm::ImmFileTargetValue::getPath),
                                        std::make_tuple()));
  }
  Napi::Value getLine(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<int>> const&(org::imm::ImmFileTargetValue::*)() const>(&org::imm::ImmFileTargetValue::getLine),
                                        std::make_tuple()));
  }
  Napi::Value getSearchtarget(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmFileTargetValue::*)() const>(&org::imm::ImmFileTargetValue::getSearchtarget),
                                        std::make_tuple()));
  }
  Napi::Value getRestricttoheadlines(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmFileTargetValue::*)() const>(&org::imm::ImmFileTargetValue::getRestricttoheadlines),
                                        std::make_tuple()));
  }
  Napi::Value getTargetid(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmFileTargetValue::*)() const>(&org::imm::ImmFileTargetValue::getTargetid),
                                        std::make_tuple()));
  }
  Napi::Value getRegexp(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmFileTargetValue::*)() const>(&org::imm::ImmFileTargetValue::getRegexp),
                                        std::make_tuple()));
  }
  Napi::Value setPath(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmFileTargetValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmFileTargetValue::setPath),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setLine(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmFileTargetValue::*)(immer::box<std::optional<int>> const&)>(&org::imm::ImmFileTargetValue::setLine),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<int>>>{"value"})));
  }
  Napi::Value setSearchtarget(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmFileTargetValue::*)(immer::box<std::optional<hstd::Str>> const&)>(&org::imm::ImmFileTargetValue::setSearchtarget),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::Str>>>{"value"})));
  }
  Napi::Value setRestricttoheadlines(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmFileTargetValue::*)(bool const&)>(&org::imm::ImmFileTargetValue::setRestricttoheadlines),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  Napi::Value setTargetid(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmFileTargetValue::*)(immer::box<std::optional<hstd::Str>> const&)>(&org::imm::ImmFileTargetValue::setTargetid),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::Str>>>{"value"})));
  }
  Napi::Value setRegexp(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmFileTargetValue::*)(immer::box<std::optional<hstd::Str>> const&)>(&org::imm::ImmFileTargetValue::setRegexp),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::Str>>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmfiletargetvalueJs", {InstanceMethod("getPath", &ImmfiletargetvalueJs::getPath),
                                                                    InstanceMethod("getLine", &ImmfiletargetvalueJs::getLine),
                                                                    InstanceMethod("getSearchtarget", &ImmfiletargetvalueJs::getSearchtarget),
                                                                    InstanceMethod("getRestricttoheadlines", &ImmfiletargetvalueJs::getRestricttoheadlines),
                                                                    InstanceMethod("getTargetid", &ImmfiletargetvalueJs::getTargetid),
                                                                    InstanceMethod("getRegexp", &ImmfiletargetvalueJs::getRegexp),
                                                                    InstanceMethod("setPath", &ImmfiletargetvalueJs::setPath),
                                                                    InstanceMethod("setLine", &ImmfiletargetvalueJs::setLine),
                                                                    InstanceMethod("setSearchtarget", &ImmfiletargetvalueJs::setSearchtarget),
                                                                    InstanceMethod("setRestricttoheadlines", &ImmfiletargetvalueJs::setRestricttoheadlines),
                                                                    InstanceMethod("setTargetid", &ImmfiletargetvalueJs::setTargetid),
                                                                    InstanceMethod("setRegexp", &ImmfiletargetvalueJs::setRegexp)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmfiletargetvalueJs", func);
    return exports;
  }
  ImmfiletargetvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmfiletargetvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmfiletargetvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmFileTargetValue> const& ptr) : Napi::ObjectWrap<ImmfiletargetvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmFileTargetValue> _stored;
  org::imm::ImmFileTargetValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmfiletargetvalueJs> {
  using type = org::imm::ImmFileTargetValue;
};

template <>
struct org_to_js_type<org::imm::ImmFileTargetValue> {
  using type = ImmfiletargetvalueJs;
};

struct ImmtextseparatorvalueJs : public Napi::ObjectWrap<ImmtextseparatorvalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmtextseparatorvalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmtextseparatorvalueJs", func);
    return exports;
  }
  ImmtextseparatorvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmtextseparatorvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmtextseparatorvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmTextSeparatorValue> const& ptr) : Napi::ObjectWrap<ImmtextseparatorvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmTextSeparatorValue> _stored;
  org::imm::ImmTextSeparatorValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmtextseparatorvalueJs> {
  using type = org::imm::ImmTextSeparatorValue;
};

template <>
struct org_to_js_type<org::imm::ImmTextSeparatorValue> {
  using type = ImmtextseparatorvalueJs;
};

struct ImmdocumentgroupvalueJs : public Napi::ObjectWrap<ImmdocumentgroupvalueJs> {
  static inline Napi::FunctionReference* constructor;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmdocumentgroupvalueJs", {});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmdocumentgroupvalueJs", func);
    return exports;
  }
  ImmdocumentgroupvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmdocumentgroupvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmdocumentgroupvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmDocumentGroupValue> const& ptr) : Napi::ObjectWrap<ImmdocumentgroupvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmDocumentGroupValue> _stored;
  org::imm::ImmDocumentGroupValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmdocumentgroupvalueJs> {
  using type = org::imm::ImmDocumentGroupValue;
};

template <>
struct org_to_js_type<org::imm::ImmDocumentGroupValue> {
  using type = ImmdocumentgroupvalueJs;
};

struct ImmfilevalueJs : public Napi::ObjectWrap<ImmfilevalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getRelpath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmFileValue::*)() const>(&org::imm::ImmFileValue::getRelpath),
                                        std::make_tuple()));
  }
  Napi::Value getAbspath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmFileValue::*)() const>(&org::imm::ImmFileValue::getAbspath),
                                        std::make_tuple()));
  }
  Napi::Value getData(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmFile::Data const&(org::imm::ImmFileValue::*)() const>(&org::imm::ImmFileValue::getData),
                                        std::make_tuple()));
  }
  Napi::Value setRelpath(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmFileValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmFileValue::setRelpath),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setAbspath(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmFileValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmFileValue::setAbspath),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setData(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmFileValue::*)(org::imm::ImmFile::Data const&)>(&org::imm::ImmFileValue::setData),
                                   std::make_tuple(CxxArgSpec<org::imm::ImmFile::Data>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmfilevalueJs", {InstanceMethod("getRelpath", &ImmfilevalueJs::getRelpath),
                                                              InstanceMethod("getAbspath", &ImmfilevalueJs::getAbspath),
                                                              InstanceMethod("getData", &ImmfilevalueJs::getData),
                                                              InstanceMethod("setRelpath", &ImmfilevalueJs::setRelpath),
                                                              InstanceMethod("setAbspath", &ImmfilevalueJs::setAbspath),
                                                              InstanceMethod("setData", &ImmfilevalueJs::setData)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmfilevalueJs", func);
    return exports;
  }
  ImmfilevalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmfilevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmfilevalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmFileValue> const& ptr) : Napi::ObjectWrap<ImmfilevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmFileValue> _stored;
  org::imm::ImmFileValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmfilevalueJs> {
  using type = org::imm::ImmFileValue;
};

template <>
struct org_to_js_type<org::imm::ImmFileValue> {
  using type = ImmfilevalueJs;
};

struct ImmdirectoryvalueJs : public Napi::ObjectWrap<ImmdirectoryvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getRelpath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmDirectoryValue::*)() const>(&org::imm::ImmDirectoryValue::getRelpath),
                                        std::make_tuple()));
  }
  Napi::Value getAbspath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmDirectoryValue::*)() const>(&org::imm::ImmDirectoryValue::getAbspath),
                                        std::make_tuple()));
  }
  Napi::Value setRelpath(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDirectoryValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmDirectoryValue::setRelpath),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setAbspath(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDirectoryValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmDirectoryValue::setAbspath),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmdirectoryvalueJs", {InstanceMethod("getRelpath", &ImmdirectoryvalueJs::getRelpath),
                                                                   InstanceMethod("getAbspath", &ImmdirectoryvalueJs::getAbspath),
                                                                   InstanceMethod("setRelpath", &ImmdirectoryvalueJs::setRelpath),
                                                                   InstanceMethod("setAbspath", &ImmdirectoryvalueJs::setAbspath)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmdirectoryvalueJs", func);
    return exports;
  }
  ImmdirectoryvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmdirectoryvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmdirectoryvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmDirectoryValue> const& ptr) : Napi::ObjectWrap<ImmdirectoryvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmDirectoryValue> _stored;
  org::imm::ImmDirectoryValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmdirectoryvalueJs> {
  using type = org::imm::ImmDirectoryValue;
};

template <>
struct org_to_js_type<org::imm::ImmDirectoryValue> {
  using type = ImmdirectoryvalueJs;
};

struct ImmsymlinkvalueJs : public Napi::ObjectWrap<ImmsymlinkvalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getIsdirectory(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmSymlinkValue::*)() const>(&org::imm::ImmSymlinkValue::getIsdirectory),
                                        std::make_tuple()));
  }
  Napi::Value getAbspath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmSymlinkValue::*)() const>(&org::imm::ImmSymlinkValue::getAbspath),
                                        std::make_tuple()));
  }
  Napi::Value setIsdirectory(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSymlinkValue::*)(bool const&)>(&org::imm::ImmSymlinkValue::setIsdirectory),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  Napi::Value setAbspath(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSymlinkValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmSymlinkValue::setAbspath),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmsymlinkvalueJs", {InstanceMethod("getIsdirectory", &ImmsymlinkvalueJs::getIsdirectory),
                                                                 InstanceMethod("getAbspath", &ImmsymlinkvalueJs::getAbspath),
                                                                 InstanceMethod("setIsdirectory", &ImmsymlinkvalueJs::setIsdirectory),
                                                                 InstanceMethod("setAbspath", &ImmsymlinkvalueJs::setAbspath)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmsymlinkvalueJs", func);
    return exports;
  }
  ImmsymlinkvalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmsymlinkvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmsymlinkvalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmSymlinkValue> const& ptr) : Napi::ObjectWrap<ImmsymlinkvalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmSymlinkValue> _stored;
  org::imm::ImmSymlinkValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmsymlinkvalueJs> {
  using type = org::imm::ImmSymlinkValue;
};

template <>
struct org_to_js_type<org::imm::ImmSymlinkValue> {
  using type = ImmsymlinkvalueJs;
};

struct ImmcmdincludevalueJs : public Napi::ObjectWrap<ImmcmdincludevalueJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getPath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdIncludeValue::*)() const>(&org::imm::ImmCmdIncludeValue::getPath),
                                        std::make_tuple()));
  }
  Napi::Value getFirstline(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<int>> const&(org::imm::ImmCmdIncludeValue::*)() const>(&org::imm::ImmCmdIncludeValue::getFirstline),
                                        std::make_tuple()));
  }
  Napi::Value getLastline(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<int>> const&(org::imm::ImmCmdIncludeValue::*)() const>(&org::imm::ImmCmdIncludeValue::getLastline),
                                        std::make_tuple()));
  }
  Napi::Value getData(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCmdInclude::Data const&(org::imm::ImmCmdIncludeValue::*)() const>(&org::imm::ImmCmdIncludeValue::getData),
                                        std::make_tuple()));
  }
  Napi::Value setPath(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdIncludeValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmCmdIncludeValue::setPath),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setFirstline(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdIncludeValue::*)(immer::box<std::optional<int>> const&)>(&org::imm::ImmCmdIncludeValue::setFirstline),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<int>>>{"value"})));
  }
  Napi::Value setLastline(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdIncludeValue::*)(immer::box<std::optional<int>> const&)>(&org::imm::ImmCmdIncludeValue::setLastline),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<int>>>{"value"})));
  }
  Napi::Value setData(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdIncludeValue::*)(org::imm::ImmCmdInclude::Data const&)>(&org::imm::ImmCmdIncludeValue::setData),
                                   std::make_tuple(CxxArgSpec<org::imm::ImmCmdInclude::Data>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmcmdincludevalueJs", {InstanceMethod("getPath", &ImmcmdincludevalueJs::getPath),
                                                                    InstanceMethod("getFirstline", &ImmcmdincludevalueJs::getFirstline),
                                                                    InstanceMethod("getLastline", &ImmcmdincludevalueJs::getLastline),
                                                                    InstanceMethod("getData", &ImmcmdincludevalueJs::getData),
                                                                    InstanceMethod("setPath", &ImmcmdincludevalueJs::setPath),
                                                                    InstanceMethod("setFirstline", &ImmcmdincludevalueJs::setFirstline),
                                                                    InstanceMethod("setLastline", &ImmcmdincludevalueJs::setLastline),
                                                                    InstanceMethod("setData", &ImmcmdincludevalueJs::setData)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmcmdincludevalueJs", func);
    return exports;
  }
  ImmcmdincludevalueJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmcmdincludevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmcmdincludevalueJs(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmCmdIncludeValue> const& ptr) : Napi::ObjectWrap<ImmcmdincludevalueJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmCmdIncludeValue> _stored;
  org::imm::ImmCmdIncludeValue* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmcmdincludevalueJs> {
  using type = org::imm::ImmCmdIncludeValue;
};

template <>
struct org_to_js_type<org::imm::ImmCmdIncludeValue> {
  using type = ImmcmdincludevalueJs;
};

struct CmdcustomrawJs : public Napi::ObjectWrap<CmdcustomrawJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::CmdCustomRaw::*)() const>(&org::sem::CmdCustomRaw::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdCustomRaw::*)() const>(&org::sem::CmdCustomRaw::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdCustomRaw::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::CmdCustomRaw::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdCustomRaw::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::CmdCustomRaw::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::CmdCustomRaw::*)(int) const>(&org::sem::CmdCustomRaw::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdCustomRaw::*)(OrgSemKind) const>(&org::sem::CmdCustomRaw::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdCustomRaw::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdCustomRaw::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdCustomRaw::*)() const>(&org::sem::CmdCustomRaw::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::CmdCustomRaw::*)() const>(&org::sem::CmdCustomRaw::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::CmdCustomRaw::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdCustomRaw::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::CmdCustomRaw::*)(hstd::Str const&) const>(&org::sem::CmdCustomRaw::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "CmdcustomrawJs", {InstanceMethod("getKind", &CmdcustomrawJs::getKind),
                                                              InstanceMethod("isGenerated", &CmdcustomrawJs::isGenerated),
                                                              InstanceMethod("push_back", &CmdcustomrawJs::push_back),
                                                              InstanceMethod("insert", &CmdcustomrawJs::insert),
                                                              InstanceMethod("at", &CmdcustomrawJs::at),
                                                              InstanceMethod("is", &CmdcustomrawJs::is),
                                                              InstanceMethod("getAttached", &CmdcustomrawJs::getAttached),
                                                              InstanceMethod("getCaption", &CmdcustomrawJs::getCaption),
                                                              InstanceMethod("getName", &CmdcustomrawJs::getName),
                                                              InstanceMethod("getAttrs", &CmdcustomrawJs::getAttrs),
                                                              InstanceMethod("getFirstAttr", &CmdcustomrawJs::getFirstAttr)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("CmdcustomrawJs", func);
    return exports;
  }
  CmdcustomrawJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<CmdcustomrawJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::CmdCustomRaw>();
  }
  CmdcustomrawJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::CmdCustomRaw> const& ptr) : Napi::ObjectWrap<CmdcustomrawJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::CmdCustomRaw> _stored;
  org::sem::CmdCustomRaw* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<CmdcustomrawJs> {
  using type = org::sem::CmdCustomRaw;
};

template <>
struct org_to_js_type<org::sem::CmdCustomRaw> {
  using type = CmdcustomrawJs;
};

struct CmdcustomtextJs : public Napi::ObjectWrap<CmdcustomtextJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::CmdCustomText::*)() const>(&org::sem::CmdCustomText::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdCustomText::*)() const>(&org::sem::CmdCustomText::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdCustomText::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::CmdCustomText::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdCustomText::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::CmdCustomText::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::CmdCustomText::*)(int) const>(&org::sem::CmdCustomText::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdCustomText::*)(OrgSemKind) const>(&org::sem::CmdCustomText::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdCustomText::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdCustomText::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdCustomText::*)() const>(&org::sem::CmdCustomText::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::CmdCustomText::*)() const>(&org::sem::CmdCustomText::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::CmdCustomText::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdCustomText::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::CmdCustomText::*)(hstd::Str const&) const>(&org::sem::CmdCustomText::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "CmdcustomtextJs", {InstanceMethod("getKind", &CmdcustomtextJs::getKind),
                                                               InstanceMethod("isGenerated", &CmdcustomtextJs::isGenerated),
                                                               InstanceMethod("push_back", &CmdcustomtextJs::push_back),
                                                               InstanceMethod("insert", &CmdcustomtextJs::insert),
                                                               InstanceMethod("at", &CmdcustomtextJs::at),
                                                               InstanceMethod("is", &CmdcustomtextJs::is),
                                                               InstanceMethod("getAttached", &CmdcustomtextJs::getAttached),
                                                               InstanceMethod("getCaption", &CmdcustomtextJs::getCaption),
                                                               InstanceMethod("getName", &CmdcustomtextJs::getName),
                                                               InstanceMethod("getAttrs", &CmdcustomtextJs::getAttrs),
                                                               InstanceMethod("getFirstAttr", &CmdcustomtextJs::getFirstAttr)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("CmdcustomtextJs", func);
    return exports;
  }
  CmdcustomtextJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<CmdcustomtextJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::CmdCustomText>();
  }
  CmdcustomtextJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::CmdCustomText> const& ptr) : Napi::ObjectWrap<CmdcustomtextJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::CmdCustomText> _stored;
  org::sem::CmdCustomText* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<CmdcustomtextJs> {
  using type = org::sem::CmdCustomText;
};

template <>
struct org_to_js_type<org::sem::CmdCustomText> {
  using type = CmdcustomtextJs;
};

struct LinkJs : public Napi::ObjectWrap<LinkJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Link::*)() const>(&org::sem::Link::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Link::*)() const>(&org::sem::Link::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Link::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Link::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Link::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Link::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Link::*)(int) const>(&org::sem::Link::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Link::*)(OrgSemKind) const>(&org::sem::Link::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::Link::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::Link::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::Link::*)() const>(&org::sem::Link::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::Link::*)() const>(&org::sem::Link::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::Link::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::Link::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::Link::*)(hstd::Str const&) const>(&org::sem::Link::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "LinkJs", {InstanceMethod("getKind", &LinkJs::getKind),
                                                      InstanceMethod("isGenerated", &LinkJs::isGenerated),
                                                      InstanceMethod("push_back", &LinkJs::push_back),
                                                      InstanceMethod("insert", &LinkJs::insert),
                                                      InstanceMethod("at", &LinkJs::at),
                                                      InstanceMethod("is", &LinkJs::is),
                                                      InstanceMethod("getAttached", &LinkJs::getAttached),
                                                      InstanceMethod("getCaption", &LinkJs::getCaption),
                                                      InstanceMethod("getName", &LinkJs::getName),
                                                      InstanceMethod("getAttrs", &LinkJs::getAttrs),
                                                      InstanceMethod("getFirstAttr", &LinkJs::getFirstAttr)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("LinkJs", func);
    return exports;
  }
  LinkJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<LinkJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Link>();
  }
  LinkJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Link> const& ptr) : Napi::ObjectWrap<LinkJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Link> _stored;
  org::sem::Link* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<LinkJs> {
  using type = org::sem::Link;
};

template <>
struct org_to_js_type<org::sem::Link> {
  using type = LinkJs;
};

struct BlockcommentJs : public Napi::ObjectWrap<BlockcommentJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::BlockComment::*)() const>(&org::sem::BlockComment::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockComment::*)() const>(&org::sem::BlockComment::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockComment::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::BlockComment::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockComment::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::BlockComment::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::BlockComment::*)(int) const>(&org::sem::BlockComment::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockComment::*)(OrgSemKind) const>(&org::sem::BlockComment::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockComment::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockComment::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockComment::*)() const>(&org::sem::BlockComment::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::BlockComment::*)() const>(&org::sem::BlockComment::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::BlockComment::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockComment::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::BlockComment::*)(hstd::Str const&) const>(&org::sem::BlockComment::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "BlockcommentJs", {InstanceMethod("getKind", &BlockcommentJs::getKind),
                                                              InstanceMethod("isGenerated", &BlockcommentJs::isGenerated),
                                                              InstanceMethod("push_back", &BlockcommentJs::push_back),
                                                              InstanceMethod("insert", &BlockcommentJs::insert),
                                                              InstanceMethod("at", &BlockcommentJs::at),
                                                              InstanceMethod("is", &BlockcommentJs::is),
                                                              InstanceMethod("getAttached", &BlockcommentJs::getAttached),
                                                              InstanceMethod("getCaption", &BlockcommentJs::getCaption),
                                                              InstanceMethod("getName", &BlockcommentJs::getName),
                                                              InstanceMethod("getAttrs", &BlockcommentJs::getAttrs),
                                                              InstanceMethod("getFirstAttr", &BlockcommentJs::getFirstAttr)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("BlockcommentJs", func);
    return exports;
  }
  BlockcommentJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<BlockcommentJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::BlockComment>();
  }
  BlockcommentJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::BlockComment> const& ptr) : Napi::ObjectWrap<BlockcommentJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::BlockComment> _stored;
  org::sem::BlockComment* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<BlockcommentJs> {
  using type = org::sem::BlockComment;
};

template <>
struct org_to_js_type<org::sem::BlockComment> {
  using type = BlockcommentJs;
};

struct ParagraphJs : public Napi::ObjectWrap<ParagraphJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Paragraph::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Paragraph::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Paragraph::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Paragraph::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Paragraph::*)(int) const>(&org::sem::Paragraph::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Paragraph::*)(OrgSemKind) const>(&org::sem::Paragraph::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::Paragraph::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::Paragraph::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::Paragraph::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::Paragraph::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::Paragraph::*)(hstd::Str const&) const>(&org::sem::Paragraph::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  Napi::Value isFootnoteDefinition(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::isFootnoteDefinition),
                                        std::make_tuple()));
  }
  Napi::Value getFootnoteName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<hstd::Str>(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::getFootnoteName),
                                        std::make_tuple()));
  }
  Napi::Value hasAdmonition(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::hasAdmonition),
                                        std::make_tuple()));
  }
  Napi::Value getAdmonitions(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::getAdmonitions),
                                        std::make_tuple()));
  }
  Napi::Value getAdmonitionNodes(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::BigIdent>>(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::getAdmonitionNodes),
                                        std::make_tuple()));
  }
  Napi::Value hasTimestamp(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::hasTimestamp),
                                        std::make_tuple()));
  }
  Napi::Value getTimestamps(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::UserTime>(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::getTimestamps),
                                        std::make_tuple()));
  }
  Napi::Value getTimestampNodes(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Time>>(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::getTimestampNodes),
                                        std::make_tuple()));
  }
  Napi::Value hasLeadHashtags(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::hasLeadHashtags),
                                        std::make_tuple()));
  }
  Napi::Value getLeadHashtags(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::HashTag>>(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::getLeadHashtags),
                                        std::make_tuple()));
  }
  Napi::Value getBody(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::getBody),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ParagraphJs", {InstanceMethod("getKind", &ParagraphJs::getKind),
                                                           InstanceMethod("isGenerated", &ParagraphJs::isGenerated),
                                                           InstanceMethod("push_back", &ParagraphJs::push_back),
                                                           InstanceMethod("insert", &ParagraphJs::insert),
                                                           InstanceMethod("at", &ParagraphJs::at),
                                                           InstanceMethod("is", &ParagraphJs::is),
                                                           InstanceMethod("getAttached", &ParagraphJs::getAttached),
                                                           InstanceMethod("getCaption", &ParagraphJs::getCaption),
                                                           InstanceMethod("getName", &ParagraphJs::getName),
                                                           InstanceMethod("getAttrs", &ParagraphJs::getAttrs),
                                                           InstanceMethod("getFirstAttr", &ParagraphJs::getFirstAttr),
                                                           InstanceMethod("isFootnoteDefinition", &ParagraphJs::isFootnoteDefinition),
                                                           InstanceMethod("getFootnoteName", &ParagraphJs::getFootnoteName),
                                                           InstanceMethod("hasAdmonition", &ParagraphJs::hasAdmonition),
                                                           InstanceMethod("getAdmonitions", &ParagraphJs::getAdmonitions),
                                                           InstanceMethod("getAdmonitionNodes", &ParagraphJs::getAdmonitionNodes),
                                                           InstanceMethod("hasTimestamp", &ParagraphJs::hasTimestamp),
                                                           InstanceMethod("getTimestamps", &ParagraphJs::getTimestamps),
                                                           InstanceMethod("getTimestampNodes", &ParagraphJs::getTimestampNodes),
                                                           InstanceMethod("hasLeadHashtags", &ParagraphJs::hasLeadHashtags),
                                                           InstanceMethod("getLeadHashtags", &ParagraphJs::getLeadHashtags),
                                                           InstanceMethod("getBody", &ParagraphJs::getBody)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ParagraphJs", func);
    return exports;
  }
  ParagraphJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ParagraphJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Paragraph>();
  }
  ParagraphJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Paragraph> const& ptr) : Napi::ObjectWrap<ParagraphJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Paragraph> _stored;
  org::sem::Paragraph* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ParagraphJs> {
  using type = org::sem::Paragraph;
};

template <>
struct org_to_js_type<org::sem::Paragraph> {
  using type = ParagraphJs;
};

struct ListJs : public Napi::ObjectWrap<ListJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::List::*)() const>(&org::sem::List::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::List::*)() const>(&org::sem::List::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::List::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::List::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::List::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::List::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::List::*)(int) const>(&org::sem::List::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::List::*)(OrgSemKind) const>(&org::sem::List::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::List::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::List::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::List::*)() const>(&org::sem::List::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::List::*)() const>(&org::sem::List::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::List::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::List::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::List::*)(hstd::Str const&) const>(&org::sem::List::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  Napi::Value getListAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::List::*)(hstd::Str const&) const>(&org::sem::List::getListAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"key"})));
  }
  Napi::Value getListFormattingMode(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<ListFormattingMode(org::sem::List::*)() const>(&org::sem::List::getListFormattingMode),
                                        std::make_tuple()));
  }
  Napi::Value isDescriptionList(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::List::*)() const>(&org::sem::List::isDescriptionList),
                                        std::make_tuple()));
  }
  Napi::Value isNumberedList(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::List::*)() const>(&org::sem::List::isNumberedList),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ListJs", {InstanceMethod("getKind", &ListJs::getKind),
                                                      InstanceMethod("isGenerated", &ListJs::isGenerated),
                                                      InstanceMethod("push_back", &ListJs::push_back),
                                                      InstanceMethod("insert", &ListJs::insert),
                                                      InstanceMethod("at", &ListJs::at),
                                                      InstanceMethod("is", &ListJs::is),
                                                      InstanceMethod("getAttached", &ListJs::getAttached),
                                                      InstanceMethod("getCaption", &ListJs::getCaption),
                                                      InstanceMethod("getName", &ListJs::getName),
                                                      InstanceMethod("getAttrs", &ListJs::getAttrs),
                                                      InstanceMethod("getFirstAttr", &ListJs::getFirstAttr),
                                                      InstanceMethod("getListAttrs", &ListJs::getListAttrs),
                                                      InstanceMethod("getListFormattingMode", &ListJs::getListFormattingMode),
                                                      InstanceMethod("isDescriptionList", &ListJs::isDescriptionList),
                                                      InstanceMethod("isNumberedList", &ListJs::isNumberedList)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ListJs", func);
    return exports;
  }
  ListJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ListJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::List>();
  }
  ListJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::List> const& ptr) : Napi::ObjectWrap<ListJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::List> _stored;
  org::sem::List* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ListJs> {
  using type = org::sem::List;
};

template <>
struct org_to_js_type<org::sem::List> {
  using type = ListJs;
};

struct HashtagJs : public Napi::ObjectWrap<HashtagJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::HashTag::*)() const>(&org::sem::HashTag::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::HashTag::*)() const>(&org::sem::HashTag::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::HashTag::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::HashTag::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::HashTag::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::HashTag::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::HashTag::*)(int) const>(&org::sem::HashTag::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::HashTag::*)(OrgSemKind) const>(&org::sem::HashTag::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "HashtagJs", {InstanceMethod("getKind", &HashtagJs::getKind),
                                                         InstanceMethod("isGenerated", &HashtagJs::isGenerated),
                                                         InstanceMethod("push_back", &HashtagJs::push_back),
                                                         InstanceMethod("insert", &HashtagJs::insert),
                                                         InstanceMethod("at", &HashtagJs::at),
                                                         InstanceMethod("is", &HashtagJs::is)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("HashtagJs", func);
    return exports;
  }
  HashtagJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<HashtagJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::HashTag>();
  }
  HashtagJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::HashTag> const& ptr) : Napi::ObjectWrap<HashtagJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::HashTag> _stored;
  org::sem::HashTag* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<HashtagJs> {
  using type = org::sem::HashTag;
};

template <>
struct org_to_js_type<org::sem::HashTag> {
  using type = HashtagJs;
};

struct InlinefootnoteJs : public Napi::ObjectWrap<InlinefootnoteJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::InlineFootnote::*)() const>(&org::sem::InlineFootnote::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::InlineFootnote::*)() const>(&org::sem::InlineFootnote::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::InlineFootnote::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::InlineFootnote::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::InlineFootnote::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::InlineFootnote::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::InlineFootnote::*)(int) const>(&org::sem::InlineFootnote::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::InlineFootnote::*)(OrgSemKind) const>(&org::sem::InlineFootnote::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "InlinefootnoteJs", {InstanceMethod("getKind", &InlinefootnoteJs::getKind),
                                                                InstanceMethod("isGenerated", &InlinefootnoteJs::isGenerated),
                                                                InstanceMethod("push_back", &InlinefootnoteJs::push_back),
                                                                InstanceMethod("insert", &InlinefootnoteJs::insert),
                                                                InstanceMethod("at", &InlinefootnoteJs::at),
                                                                InstanceMethod("is", &InlinefootnoteJs::is)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("InlinefootnoteJs", func);
    return exports;
  }
  InlinefootnoteJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<InlinefootnoteJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::InlineFootnote>();
  }
  InlinefootnoteJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::InlineFootnote> const& ptr) : Napi::ObjectWrap<InlinefootnoteJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::InlineFootnote> _stored;
  org::sem::InlineFootnote* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<InlinefootnoteJs> {
  using type = org::sem::InlineFootnote;
};

template <>
struct org_to_js_type<org::sem::InlineFootnote> {
  using type = InlinefootnoteJs;
};

struct InlineexportJs : public Napi::ObjectWrap<InlineexportJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::InlineExport::*)() const>(&org::sem::InlineExport::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::InlineExport::*)() const>(&org::sem::InlineExport::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::InlineExport::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::InlineExport::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::InlineExport::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::InlineExport::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::InlineExport::*)(int) const>(&org::sem::InlineExport::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::InlineExport::*)(OrgSemKind) const>(&org::sem::InlineExport::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "InlineexportJs", {InstanceMethod("getKind", &InlineexportJs::getKind),
                                                              InstanceMethod("isGenerated", &InlineexportJs::isGenerated),
                                                              InstanceMethod("push_back", &InlineexportJs::push_back),
                                                              InstanceMethod("insert", &InlineexportJs::insert),
                                                              InstanceMethod("at", &InlineexportJs::at),
                                                              InstanceMethod("is", &InlineexportJs::is)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("InlineexportJs", func);
    return exports;
  }
  InlineexportJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<InlineexportJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::InlineExport>();
  }
  InlineexportJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::InlineExport> const& ptr) : Napi::ObjectWrap<InlineexportJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::InlineExport> _stored;
  org::sem::InlineExport* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<InlineexportJs> {
  using type = org::sem::InlineExport;
};

template <>
struct org_to_js_type<org::sem::InlineExport> {
  using type = InlineexportJs;
};

struct EscapedJs : public Napi::ObjectWrap<EscapedJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Escaped::*)() const>(&org::sem::Escaped::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Escaped::*)() const>(&org::sem::Escaped::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Escaped::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Escaped::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Escaped::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Escaped::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Escaped::*)(int) const>(&org::sem::Escaped::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Escaped::*)(OrgSemKind) const>(&org::sem::Escaped::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Str(org::sem::Escaped::*)() const>(&org::sem::Escaped::getText),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "EscapedJs", {InstanceMethod("getKind", &EscapedJs::getKind),
                                                         InstanceMethod("isGenerated", &EscapedJs::isGenerated),
                                                         InstanceMethod("push_back", &EscapedJs::push_back),
                                                         InstanceMethod("insert", &EscapedJs::insert),
                                                         InstanceMethod("at", &EscapedJs::at),
                                                         InstanceMethod("is", &EscapedJs::is),
                                                         InstanceMethod("getText", &EscapedJs::getText)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("EscapedJs", func);
    return exports;
  }
  EscapedJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<EscapedJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Escaped>();
  }
  EscapedJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Escaped> const& ptr) : Napi::ObjectWrap<EscapedJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Escaped> _stored;
  org::sem::Escaped* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<EscapedJs> {
  using type = org::sem::Escaped;
};

template <>
struct org_to_js_type<org::sem::Escaped> {
  using type = EscapedJs;
};

struct NewlineJs : public Napi::ObjectWrap<NewlineJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Newline::*)() const>(&org::sem::Newline::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Newline::*)() const>(&org::sem::Newline::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Newline::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Newline::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Newline::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Newline::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Newline::*)(int) const>(&org::sem::Newline::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Newline::*)(OrgSemKind) const>(&org::sem::Newline::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Str(org::sem::Newline::*)() const>(&org::sem::Newline::getText),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "NewlineJs", {InstanceMethod("getKind", &NewlineJs::getKind),
                                                         InstanceMethod("isGenerated", &NewlineJs::isGenerated),
                                                         InstanceMethod("push_back", &NewlineJs::push_back),
                                                         InstanceMethod("insert", &NewlineJs::insert),
                                                         InstanceMethod("at", &NewlineJs::at),
                                                         InstanceMethod("is", &NewlineJs::is),
                                                         InstanceMethod("getText", &NewlineJs::getText)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("NewlineJs", func);
    return exports;
  }
  NewlineJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<NewlineJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Newline>();
  }
  NewlineJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Newline> const& ptr) : Napi::ObjectWrap<NewlineJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Newline> _stored;
  org::sem::Newline* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<NewlineJs> {
  using type = org::sem::Newline;
};

template <>
struct org_to_js_type<org::sem::Newline> {
  using type = NewlineJs;
};

struct SpaceJs : public Napi::ObjectWrap<SpaceJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Space::*)() const>(&org::sem::Space::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Space::*)() const>(&org::sem::Space::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Space::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Space::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Space::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Space::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Space::*)(int) const>(&org::sem::Space::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Space::*)(OrgSemKind) const>(&org::sem::Space::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Str(org::sem::Space::*)() const>(&org::sem::Space::getText),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "SpaceJs", {InstanceMethod("getKind", &SpaceJs::getKind),
                                                       InstanceMethod("isGenerated", &SpaceJs::isGenerated),
                                                       InstanceMethod("push_back", &SpaceJs::push_back),
                                                       InstanceMethod("insert", &SpaceJs::insert),
                                                       InstanceMethod("at", &SpaceJs::at),
                                                       InstanceMethod("is", &SpaceJs::is),
                                                       InstanceMethod("getText", &SpaceJs::getText)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("SpaceJs", func);
    return exports;
  }
  SpaceJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<SpaceJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Space>();
  }
  SpaceJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Space> const& ptr) : Napi::ObjectWrap<SpaceJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Space> _stored;
  org::sem::Space* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<SpaceJs> {
  using type = org::sem::Space;
};

template <>
struct org_to_js_type<org::sem::Space> {
  using type = SpaceJs;
};

struct WordJs : public Napi::ObjectWrap<WordJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Word::*)() const>(&org::sem::Word::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Word::*)() const>(&org::sem::Word::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Word::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Word::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Word::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Word::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Word::*)(int) const>(&org::sem::Word::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Word::*)(OrgSemKind) const>(&org::sem::Word::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Str(org::sem::Word::*)() const>(&org::sem::Word::getText),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "WordJs", {InstanceMethod("getKind", &WordJs::getKind),
                                                      InstanceMethod("isGenerated", &WordJs::isGenerated),
                                                      InstanceMethod("push_back", &WordJs::push_back),
                                                      InstanceMethod("insert", &WordJs::insert),
                                                      InstanceMethod("at", &WordJs::at),
                                                      InstanceMethod("is", &WordJs::is),
                                                      InstanceMethod("getText", &WordJs::getText)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("WordJs", func);
    return exports;
  }
  WordJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<WordJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Word>();
  }
  WordJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Word> const& ptr) : Napi::ObjectWrap<WordJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Word> _stored;
  org::sem::Word* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<WordJs> {
  using type = org::sem::Word;
};

template <>
struct org_to_js_type<org::sem::Word> {
  using type = WordJs;
};

struct AtmentionJs : public Napi::ObjectWrap<AtmentionJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::AtMention::*)() const>(&org::sem::AtMention::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::AtMention::*)() const>(&org::sem::AtMention::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::AtMention::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::AtMention::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::AtMention::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::AtMention::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::AtMention::*)(int) const>(&org::sem::AtMention::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::AtMention::*)(OrgSemKind) const>(&org::sem::AtMention::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Str(org::sem::AtMention::*)() const>(&org::sem::AtMention::getText),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "AtmentionJs", {InstanceMethod("getKind", &AtmentionJs::getKind),
                                                           InstanceMethod("isGenerated", &AtmentionJs::isGenerated),
                                                           InstanceMethod("push_back", &AtmentionJs::push_back),
                                                           InstanceMethod("insert", &AtmentionJs::insert),
                                                           InstanceMethod("at", &AtmentionJs::at),
                                                           InstanceMethod("is", &AtmentionJs::is),
                                                           InstanceMethod("getText", &AtmentionJs::getText)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("AtmentionJs", func);
    return exports;
  }
  AtmentionJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<AtmentionJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::AtMention>();
  }
  AtmentionJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::AtMention> const& ptr) : Napi::ObjectWrap<AtmentionJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::AtMention> _stored;
  org::sem::AtMention* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<AtmentionJs> {
  using type = org::sem::AtMention;
};

template <>
struct org_to_js_type<org::sem::AtMention> {
  using type = AtmentionJs;
};

struct RawtextJs : public Napi::ObjectWrap<RawtextJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::RawText::*)() const>(&org::sem::RawText::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::RawText::*)() const>(&org::sem::RawText::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::RawText::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::RawText::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::RawText::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::RawText::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::RawText::*)(int) const>(&org::sem::RawText::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::RawText::*)(OrgSemKind) const>(&org::sem::RawText::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Str(org::sem::RawText::*)() const>(&org::sem::RawText::getText),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "RawtextJs", {InstanceMethod("getKind", &RawtextJs::getKind),
                                                         InstanceMethod("isGenerated", &RawtextJs::isGenerated),
                                                         InstanceMethod("push_back", &RawtextJs::push_back),
                                                         InstanceMethod("insert", &RawtextJs::insert),
                                                         InstanceMethod("at", &RawtextJs::at),
                                                         InstanceMethod("is", &RawtextJs::is),
                                                         InstanceMethod("getText", &RawtextJs::getText)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("RawtextJs", func);
    return exports;
  }
  RawtextJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<RawtextJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::RawText>();
  }
  RawtextJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::RawText> const& ptr) : Napi::ObjectWrap<RawtextJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::RawText> _stored;
  org::sem::RawText* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<RawtextJs> {
  using type = org::sem::RawText;
};

template <>
struct org_to_js_type<org::sem::RawText> {
  using type = RawtextJs;
};

struct PunctuationJs : public Napi::ObjectWrap<PunctuationJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Punctuation::*)() const>(&org::sem::Punctuation::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Punctuation::*)() const>(&org::sem::Punctuation::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Punctuation::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Punctuation::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Punctuation::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Punctuation::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Punctuation::*)(int) const>(&org::sem::Punctuation::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Punctuation::*)(OrgSemKind) const>(&org::sem::Punctuation::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Str(org::sem::Punctuation::*)() const>(&org::sem::Punctuation::getText),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "PunctuationJs", {InstanceMethod("getKind", &PunctuationJs::getKind),
                                                             InstanceMethod("isGenerated", &PunctuationJs::isGenerated),
                                                             InstanceMethod("push_back", &PunctuationJs::push_back),
                                                             InstanceMethod("insert", &PunctuationJs::insert),
                                                             InstanceMethod("at", &PunctuationJs::at),
                                                             InstanceMethod("is", &PunctuationJs::is),
                                                             InstanceMethod("getText", &PunctuationJs::getText)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("PunctuationJs", func);
    return exports;
  }
  PunctuationJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<PunctuationJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Punctuation>();
  }
  PunctuationJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Punctuation> const& ptr) : Napi::ObjectWrap<PunctuationJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Punctuation> _stored;
  org::sem::Punctuation* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<PunctuationJs> {
  using type = org::sem::Punctuation;
};

template <>
struct org_to_js_type<org::sem::Punctuation> {
  using type = PunctuationJs;
};

struct PlaceholderJs : public Napi::ObjectWrap<PlaceholderJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Placeholder::*)() const>(&org::sem::Placeholder::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Placeholder::*)() const>(&org::sem::Placeholder::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Placeholder::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Placeholder::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Placeholder::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Placeholder::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Placeholder::*)(int) const>(&org::sem::Placeholder::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Placeholder::*)(OrgSemKind) const>(&org::sem::Placeholder::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Str(org::sem::Placeholder::*)() const>(&org::sem::Placeholder::getText),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "PlaceholderJs", {InstanceMethod("getKind", &PlaceholderJs::getKind),
                                                             InstanceMethod("isGenerated", &PlaceholderJs::isGenerated),
                                                             InstanceMethod("push_back", &PlaceholderJs::push_back),
                                                             InstanceMethod("insert", &PlaceholderJs::insert),
                                                             InstanceMethod("at", &PlaceholderJs::at),
                                                             InstanceMethod("is", &PlaceholderJs::is),
                                                             InstanceMethod("getText", &PlaceholderJs::getText)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("PlaceholderJs", func);
    return exports;
  }
  PlaceholderJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<PlaceholderJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Placeholder>();
  }
  PlaceholderJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Placeholder> const& ptr) : Napi::ObjectWrap<PlaceholderJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Placeholder> _stored;
  org::sem::Placeholder* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<PlaceholderJs> {
  using type = org::sem::Placeholder;
};

template <>
struct org_to_js_type<org::sem::Placeholder> {
  using type = PlaceholderJs;
};

struct BigidentJs : public Napi::ObjectWrap<BigidentJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::BigIdent::*)() const>(&org::sem::BigIdent::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BigIdent::*)() const>(&org::sem::BigIdent::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BigIdent::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::BigIdent::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BigIdent::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::BigIdent::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::BigIdent::*)(int) const>(&org::sem::BigIdent::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BigIdent::*)(OrgSemKind) const>(&org::sem::BigIdent::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Str(org::sem::BigIdent::*)() const>(&org::sem::BigIdent::getText),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "BigidentJs", {InstanceMethod("getKind", &BigidentJs::getKind),
                                                          InstanceMethod("isGenerated", &BigidentJs::isGenerated),
                                                          InstanceMethod("push_back", &BigidentJs::push_back),
                                                          InstanceMethod("insert", &BigidentJs::insert),
                                                          InstanceMethod("at", &BigidentJs::at),
                                                          InstanceMethod("is", &BigidentJs::is),
                                                          InstanceMethod("getText", &BigidentJs::getText)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("BigidentJs", func);
    return exports;
  }
  BigidentJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<BigidentJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::BigIdent>();
  }
  BigidentJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::BigIdent> const& ptr) : Napi::ObjectWrap<BigidentJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::BigIdent> _stored;
  org::sem::BigIdent* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<BigidentJs> {
  using type = org::sem::BigIdent;
};

template <>
struct org_to_js_type<org::sem::BigIdent> {
  using type = BigidentJs;
};

struct TexttargetJs : public Napi::ObjectWrap<TexttargetJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::TextTarget::*)() const>(&org::sem::TextTarget::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::TextTarget::*)() const>(&org::sem::TextTarget::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::TextTarget::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::TextTarget::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::TextTarget::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::TextTarget::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::TextTarget::*)(int) const>(&org::sem::TextTarget::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::TextTarget::*)(OrgSemKind) const>(&org::sem::TextTarget::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Str(org::sem::TextTarget::*)() const>(&org::sem::TextTarget::getText),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "TexttargetJs", {InstanceMethod("getKind", &TexttargetJs::getKind),
                                                            InstanceMethod("isGenerated", &TexttargetJs::isGenerated),
                                                            InstanceMethod("push_back", &TexttargetJs::push_back),
                                                            InstanceMethod("insert", &TexttargetJs::insert),
                                                            InstanceMethod("at", &TexttargetJs::at),
                                                            InstanceMethod("is", &TexttargetJs::is),
                                                            InstanceMethod("getText", &TexttargetJs::getText)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("TexttargetJs", func);
    return exports;
  }
  TexttargetJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<TexttargetJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::TextTarget>();
  }
  TexttargetJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::TextTarget> const& ptr) : Napi::ObjectWrap<TexttargetJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::TextTarget> _stored;
  org::sem::TextTarget* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<TexttargetJs> {
  using type = org::sem::TextTarget;
};

template <>
struct org_to_js_type<org::sem::TextTarget> {
  using type = TexttargetJs;
};

struct BoldJs : public Napi::ObjectWrap<BoldJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Bold::*)() const>(&org::sem::Bold::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Bold::*)() const>(&org::sem::Bold::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Bold::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Bold::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Bold::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Bold::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Bold::*)(int) const>(&org::sem::Bold::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Bold::*)(OrgSemKind) const>(&org::sem::Bold::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "BoldJs", {InstanceMethod("getKind", &BoldJs::getKind),
                                                      InstanceMethod("isGenerated", &BoldJs::isGenerated),
                                                      InstanceMethod("push_back", &BoldJs::push_back),
                                                      InstanceMethod("insert", &BoldJs::insert),
                                                      InstanceMethod("at", &BoldJs::at),
                                                      InstanceMethod("is", &BoldJs::is)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("BoldJs", func);
    return exports;
  }
  BoldJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<BoldJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Bold>();
  }
  BoldJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Bold> const& ptr) : Napi::ObjectWrap<BoldJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Bold> _stored;
  org::sem::Bold* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<BoldJs> {
  using type = org::sem::Bold;
};

template <>
struct org_to_js_type<org::sem::Bold> {
  using type = BoldJs;
};

struct UnderlineJs : public Napi::ObjectWrap<UnderlineJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Underline::*)() const>(&org::sem::Underline::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Underline::*)() const>(&org::sem::Underline::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Underline::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Underline::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Underline::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Underline::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Underline::*)(int) const>(&org::sem::Underline::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Underline::*)(OrgSemKind) const>(&org::sem::Underline::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "UnderlineJs", {InstanceMethod("getKind", &UnderlineJs::getKind),
                                                           InstanceMethod("isGenerated", &UnderlineJs::isGenerated),
                                                           InstanceMethod("push_back", &UnderlineJs::push_back),
                                                           InstanceMethod("insert", &UnderlineJs::insert),
                                                           InstanceMethod("at", &UnderlineJs::at),
                                                           InstanceMethod("is", &UnderlineJs::is)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("UnderlineJs", func);
    return exports;
  }
  UnderlineJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<UnderlineJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Underline>();
  }
  UnderlineJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Underline> const& ptr) : Napi::ObjectWrap<UnderlineJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Underline> _stored;
  org::sem::Underline* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<UnderlineJs> {
  using type = org::sem::Underline;
};

template <>
struct org_to_js_type<org::sem::Underline> {
  using type = UnderlineJs;
};

struct MonospaceJs : public Napi::ObjectWrap<MonospaceJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Monospace::*)() const>(&org::sem::Monospace::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Monospace::*)() const>(&org::sem::Monospace::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Monospace::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Monospace::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Monospace::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Monospace::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Monospace::*)(int) const>(&org::sem::Monospace::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Monospace::*)(OrgSemKind) const>(&org::sem::Monospace::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "MonospaceJs", {InstanceMethod("getKind", &MonospaceJs::getKind),
                                                           InstanceMethod("isGenerated", &MonospaceJs::isGenerated),
                                                           InstanceMethod("push_back", &MonospaceJs::push_back),
                                                           InstanceMethod("insert", &MonospaceJs::insert),
                                                           InstanceMethod("at", &MonospaceJs::at),
                                                           InstanceMethod("is", &MonospaceJs::is)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("MonospaceJs", func);
    return exports;
  }
  MonospaceJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<MonospaceJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Monospace>();
  }
  MonospaceJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Monospace> const& ptr) : Napi::ObjectWrap<MonospaceJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Monospace> _stored;
  org::sem::Monospace* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<MonospaceJs> {
  using type = org::sem::Monospace;
};

template <>
struct org_to_js_type<org::sem::Monospace> {
  using type = MonospaceJs;
};

struct MarkquoteJs : public Napi::ObjectWrap<MarkquoteJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::MarkQuote::*)() const>(&org::sem::MarkQuote::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::MarkQuote::*)() const>(&org::sem::MarkQuote::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::MarkQuote::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::MarkQuote::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::MarkQuote::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::MarkQuote::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::MarkQuote::*)(int) const>(&org::sem::MarkQuote::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::MarkQuote::*)(OrgSemKind) const>(&org::sem::MarkQuote::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "MarkquoteJs", {InstanceMethod("getKind", &MarkquoteJs::getKind),
                                                           InstanceMethod("isGenerated", &MarkquoteJs::isGenerated),
                                                           InstanceMethod("push_back", &MarkquoteJs::push_back),
                                                           InstanceMethod("insert", &MarkquoteJs::insert),
                                                           InstanceMethod("at", &MarkquoteJs::at),
                                                           InstanceMethod("is", &MarkquoteJs::is)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("MarkquoteJs", func);
    return exports;
  }
  MarkquoteJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<MarkquoteJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::MarkQuote>();
  }
  MarkquoteJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::MarkQuote> const& ptr) : Napi::ObjectWrap<MarkquoteJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::MarkQuote> _stored;
  org::sem::MarkQuote* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<MarkquoteJs> {
  using type = org::sem::MarkQuote;
};

template <>
struct org_to_js_type<org::sem::MarkQuote> {
  using type = MarkquoteJs;
};

struct VerbatimJs : public Napi::ObjectWrap<VerbatimJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Verbatim::*)() const>(&org::sem::Verbatim::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Verbatim::*)() const>(&org::sem::Verbatim::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Verbatim::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Verbatim::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Verbatim::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Verbatim::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Verbatim::*)(int) const>(&org::sem::Verbatim::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Verbatim::*)(OrgSemKind) const>(&org::sem::Verbatim::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "VerbatimJs", {InstanceMethod("getKind", &VerbatimJs::getKind),
                                                          InstanceMethod("isGenerated", &VerbatimJs::isGenerated),
                                                          InstanceMethod("push_back", &VerbatimJs::push_back),
                                                          InstanceMethod("insert", &VerbatimJs::insert),
                                                          InstanceMethod("at", &VerbatimJs::at),
                                                          InstanceMethod("is", &VerbatimJs::is)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("VerbatimJs", func);
    return exports;
  }
  VerbatimJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<VerbatimJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Verbatim>();
  }
  VerbatimJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Verbatim> const& ptr) : Napi::ObjectWrap<VerbatimJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Verbatim> _stored;
  org::sem::Verbatim* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<VerbatimJs> {
  using type = org::sem::Verbatim;
};

template <>
struct org_to_js_type<org::sem::Verbatim> {
  using type = VerbatimJs;
};

struct ItalicJs : public Napi::ObjectWrap<ItalicJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Italic::*)() const>(&org::sem::Italic::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Italic::*)() const>(&org::sem::Italic::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Italic::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Italic::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Italic::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Italic::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Italic::*)(int) const>(&org::sem::Italic::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Italic::*)(OrgSemKind) const>(&org::sem::Italic::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ItalicJs", {InstanceMethod("getKind", &ItalicJs::getKind),
                                                        InstanceMethod("isGenerated", &ItalicJs::isGenerated),
                                                        InstanceMethod("push_back", &ItalicJs::push_back),
                                                        InstanceMethod("insert", &ItalicJs::insert),
                                                        InstanceMethod("at", &ItalicJs::at),
                                                        InstanceMethod("is", &ItalicJs::is)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ItalicJs", func);
    return exports;
  }
  ItalicJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ItalicJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Italic>();
  }
  ItalicJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Italic> const& ptr) : Napi::ObjectWrap<ItalicJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Italic> _stored;
  org::sem::Italic* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ItalicJs> {
  using type = org::sem::Italic;
};

template <>
struct org_to_js_type<org::sem::Italic> {
  using type = ItalicJs;
};

struct StrikeJs : public Napi::ObjectWrap<StrikeJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Strike::*)() const>(&org::sem::Strike::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Strike::*)() const>(&org::sem::Strike::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Strike::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Strike::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Strike::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Strike::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Strike::*)(int) const>(&org::sem::Strike::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Strike::*)(OrgSemKind) const>(&org::sem::Strike::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "StrikeJs", {InstanceMethod("getKind", &StrikeJs::getKind),
                                                        InstanceMethod("isGenerated", &StrikeJs::isGenerated),
                                                        InstanceMethod("push_back", &StrikeJs::push_back),
                                                        InstanceMethod("insert", &StrikeJs::insert),
                                                        InstanceMethod("at", &StrikeJs::at),
                                                        InstanceMethod("is", &StrikeJs::is)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("StrikeJs", func);
    return exports;
  }
  StrikeJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<StrikeJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Strike>();
  }
  StrikeJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Strike> const& ptr) : Napi::ObjectWrap<StrikeJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Strike> _stored;
  org::sem::Strike* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<StrikeJs> {
  using type = org::sem::Strike;
};

template <>
struct org_to_js_type<org::sem::Strike> {
  using type = StrikeJs;
};

struct ParJs : public Napi::ObjectWrap<ParJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Par::*)() const>(&org::sem::Par::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Par::*)() const>(&org::sem::Par::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Par::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Par::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Par::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Par::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Par::*)(int) const>(&org::sem::Par::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Par::*)(OrgSemKind) const>(&org::sem::Par::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ParJs", {InstanceMethod("getKind", &ParJs::getKind),
                                                     InstanceMethod("isGenerated", &ParJs::isGenerated),
                                                     InstanceMethod("push_back", &ParJs::push_back),
                                                     InstanceMethod("insert", &ParJs::insert),
                                                     InstanceMethod("at", &ParJs::at),
                                                     InstanceMethod("is", &ParJs::is)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ParJs", func);
    return exports;
  }
  ParJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ParJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Par>();
  }
  ParJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Par> const& ptr) : Napi::ObjectWrap<ParJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Par> _stored;
  org::sem::Par* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ParJs> {
  using type = org::sem::Par;
};

template <>
struct org_to_js_type<org::sem::Par> {
  using type = ParJs;
};

struct CmdcustomargsJs : public Napi::ObjectWrap<CmdcustomargsJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::CmdCustomArgs::*)() const>(&org::sem::CmdCustomArgs::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdCustomArgs::*)() const>(&org::sem::CmdCustomArgs::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdCustomArgs::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::CmdCustomArgs::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdCustomArgs::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::CmdCustomArgs::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::CmdCustomArgs::*)(int) const>(&org::sem::CmdCustomArgs::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdCustomArgs::*)(OrgSemKind) const>(&org::sem::CmdCustomArgs::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdCustomArgs::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdCustomArgs::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdCustomArgs::*)() const>(&org::sem::CmdCustomArgs::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::CmdCustomArgs::*)() const>(&org::sem::CmdCustomArgs::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::CmdCustomArgs::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdCustomArgs::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::CmdCustomArgs::*)(hstd::Str const&) const>(&org::sem::CmdCustomArgs::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "CmdcustomargsJs", {InstanceMethod("getKind", &CmdcustomargsJs::getKind),
                                                               InstanceMethod("isGenerated", &CmdcustomargsJs::isGenerated),
                                                               InstanceMethod("push_back", &CmdcustomargsJs::push_back),
                                                               InstanceMethod("insert", &CmdcustomargsJs::insert),
                                                               InstanceMethod("at", &CmdcustomargsJs::at),
                                                               InstanceMethod("is", &CmdcustomargsJs::is),
                                                               InstanceMethod("getAttached", &CmdcustomargsJs::getAttached),
                                                               InstanceMethod("getCaption", &CmdcustomargsJs::getCaption),
                                                               InstanceMethod("getName", &CmdcustomargsJs::getName),
                                                               InstanceMethod("getAttrs", &CmdcustomargsJs::getAttrs),
                                                               InstanceMethod("getFirstAttr", &CmdcustomargsJs::getFirstAttr)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("CmdcustomargsJs", func);
    return exports;
  }
  CmdcustomargsJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<CmdcustomargsJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::CmdCustomArgs>();
  }
  CmdcustomargsJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::CmdCustomArgs> const& ptr) : Napi::ObjectWrap<CmdcustomargsJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::CmdCustomArgs> _stored;
  org::sem::CmdCustomArgs* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<CmdcustomargsJs> {
  using type = org::sem::CmdCustomArgs;
};

template <>
struct org_to_js_type<org::sem::CmdCustomArgs> {
  using type = CmdcustomargsJs;
};

struct CmdtblfmJs : public Napi::ObjectWrap<CmdtblfmJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::CmdTblfm::*)() const>(&org::sem::CmdTblfm::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdTblfm::*)() const>(&org::sem::CmdTblfm::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdTblfm::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::CmdTblfm::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdTblfm::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::CmdTblfm::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::CmdTblfm::*)(int) const>(&org::sem::CmdTblfm::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdTblfm::*)(OrgSemKind) const>(&org::sem::CmdTblfm::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdTblfm::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdTblfm::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdTblfm::*)() const>(&org::sem::CmdTblfm::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::CmdTblfm::*)() const>(&org::sem::CmdTblfm::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::CmdTblfm::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdTblfm::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::CmdTblfm::*)(hstd::Str const&) const>(&org::sem::CmdTblfm::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "CmdtblfmJs", {InstanceMethod("getKind", &CmdtblfmJs::getKind),
                                                          InstanceMethod("isGenerated", &CmdtblfmJs::isGenerated),
                                                          InstanceMethod("push_back", &CmdtblfmJs::push_back),
                                                          InstanceMethod("insert", &CmdtblfmJs::insert),
                                                          InstanceMethod("at", &CmdtblfmJs::at),
                                                          InstanceMethod("is", &CmdtblfmJs::is),
                                                          InstanceMethod("getAttached", &CmdtblfmJs::getAttached),
                                                          InstanceMethod("getCaption", &CmdtblfmJs::getCaption),
                                                          InstanceMethod("getName", &CmdtblfmJs::getName),
                                                          InstanceMethod("getAttrs", &CmdtblfmJs::getAttrs),
                                                          InstanceMethod("getFirstAttr", &CmdtblfmJs::getFirstAttr)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("CmdtblfmJs", func);
    return exports;
  }
  CmdtblfmJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<CmdtblfmJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::CmdTblfm>();
  }
  CmdtblfmJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::CmdTblfm> const& ptr) : Napi::ObjectWrap<CmdtblfmJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::CmdTblfm> _stored;
  org::sem::CmdTblfm* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<CmdtblfmJs> {
  using type = org::sem::CmdTblfm;
};

template <>
struct org_to_js_type<org::sem::CmdTblfm> {
  using type = CmdtblfmJs;
};

struct CellJs : public Napi::ObjectWrap<CellJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Cell::*)() const>(&org::sem::Cell::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Cell::*)() const>(&org::sem::Cell::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Cell::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Cell::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Cell::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Cell::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Cell::*)(int) const>(&org::sem::Cell::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Cell::*)(OrgSemKind) const>(&org::sem::Cell::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::Cell::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::Cell::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::Cell::*)() const>(&org::sem::Cell::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::Cell::*)() const>(&org::sem::Cell::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::Cell::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::Cell::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::Cell::*)(hstd::Str const&) const>(&org::sem::Cell::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "CellJs", {InstanceMethod("getKind", &CellJs::getKind),
                                                      InstanceMethod("isGenerated", &CellJs::isGenerated),
                                                      InstanceMethod("push_back", &CellJs::push_back),
                                                      InstanceMethod("insert", &CellJs::insert),
                                                      InstanceMethod("at", &CellJs::at),
                                                      InstanceMethod("is", &CellJs::is),
                                                      InstanceMethod("getAttached", &CellJs::getAttached),
                                                      InstanceMethod("getCaption", &CellJs::getCaption),
                                                      InstanceMethod("getName", &CellJs::getName),
                                                      InstanceMethod("getAttrs", &CellJs::getAttrs),
                                                      InstanceMethod("getFirstAttr", &CellJs::getFirstAttr)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("CellJs", func);
    return exports;
  }
  CellJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<CellJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Cell>();
  }
  CellJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Cell> const& ptr) : Napi::ObjectWrap<CellJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Cell> _stored;
  org::sem::Cell* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<CellJs> {
  using type = org::sem::Cell;
};

template <>
struct org_to_js_type<org::sem::Cell> {
  using type = CellJs;
};

struct RowJs : public Napi::ObjectWrap<RowJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Row::*)() const>(&org::sem::Row::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Row::*)() const>(&org::sem::Row::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Row::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Row::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Row::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Row::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Row::*)(int) const>(&org::sem::Row::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Row::*)(OrgSemKind) const>(&org::sem::Row::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::Row::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::Row::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::Row::*)() const>(&org::sem::Row::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::Row::*)() const>(&org::sem::Row::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::Row::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::Row::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::Row::*)(hstd::Str const&) const>(&org::sem::Row::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "RowJs", {InstanceMethod("getKind", &RowJs::getKind),
                                                     InstanceMethod("isGenerated", &RowJs::isGenerated),
                                                     InstanceMethod("push_back", &RowJs::push_back),
                                                     InstanceMethod("insert", &RowJs::insert),
                                                     InstanceMethod("at", &RowJs::at),
                                                     InstanceMethod("is", &RowJs::is),
                                                     InstanceMethod("getAttached", &RowJs::getAttached),
                                                     InstanceMethod("getCaption", &RowJs::getCaption),
                                                     InstanceMethod("getName", &RowJs::getName),
                                                     InstanceMethod("getAttrs", &RowJs::getAttrs),
                                                     InstanceMethod("getFirstAttr", &RowJs::getFirstAttr)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("RowJs", func);
    return exports;
  }
  RowJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<RowJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Row>();
  }
  RowJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Row> const& ptr) : Napi::ObjectWrap<RowJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Row> _stored;
  org::sem::Row* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<RowJs> {
  using type = org::sem::Row;
};

template <>
struct org_to_js_type<org::sem::Row> {
  using type = RowJs;
};

struct ImmSubtreeAdapter : public Napi::ObjectWrap<ImmSubtreeAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmSubtreeValueRead(org::imm::ImmAdapterT<org::imm::ImmSubtree>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmSubtree>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmSubtreeAdapter", {InstanceMethod("getValue", &ImmSubtreeAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmSubtreeAdapter", func);
    return exports;
  }
  ImmSubtreeAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmSubtreeAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmSubtreeAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmSubtree>> const& ptr) : Napi::ObjectWrap<ImmSubtreeAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmSubtree>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmSubtree>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmSubtreeAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmSubtree>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmSubtree>> {
  using type = ImmSubtreeAdapter;
};

struct ImmNoneAdapter : public Napi::ObjectWrap<ImmNoneAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmNoneValueRead(org::imm::ImmAdapterT<org::imm::ImmNone>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmNone>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmNoneAdapter", {InstanceMethod("getValue", &ImmNoneAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmNoneAdapter", func);
    return exports;
  }
  ImmNoneAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmNoneAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmNoneAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmNone>> const& ptr) : Napi::ObjectWrap<ImmNoneAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmNone>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmNone>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmNoneAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmNone>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmNone>> {
  using type = ImmNoneAdapter;
};

struct ImmErrorItemAdapter : public Napi::ObjectWrap<ImmErrorItemAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmErrorItemValueRead(org::imm::ImmAdapterT<org::imm::ImmErrorItem>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmErrorItem>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmErrorItemAdapter", {InstanceMethod("getValue", &ImmErrorItemAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmErrorItemAdapter", func);
    return exports;
  }
  ImmErrorItemAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmErrorItemAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmErrorItemAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmErrorItem>> const& ptr) : Napi::ObjectWrap<ImmErrorItemAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmErrorItem>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmErrorItem>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmErrorItemAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmErrorItem>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmErrorItem>> {
  using type = ImmErrorItemAdapter;
};

struct ImmErrorGroupAdapter : public Napi::ObjectWrap<ImmErrorGroupAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmErrorGroupValueRead(org::imm::ImmAdapterT<org::imm::ImmErrorGroup>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmErrorGroup>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmErrorGroupAdapter", {InstanceMethod("getValue", &ImmErrorGroupAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmErrorGroupAdapter", func);
    return exports;
  }
  ImmErrorGroupAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmErrorGroupAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmErrorGroupAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmErrorGroup>> const& ptr) : Napi::ObjectWrap<ImmErrorGroupAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmErrorGroup>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmErrorGroup>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmErrorGroupAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmErrorGroup>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmErrorGroup>> {
  using type = ImmErrorGroupAdapter;
};

struct ImmStmtListAdapter : public Napi::ObjectWrap<ImmStmtListAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmStmtListValueRead(org::imm::ImmAdapterT<org::imm::ImmStmtList>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmStmtList>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmStmtListAdapter", {InstanceMethod("getValue", &ImmStmtListAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmStmtListAdapter", func);
    return exports;
  }
  ImmStmtListAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmStmtListAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmStmtListAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmStmtList>> const& ptr) : Napi::ObjectWrap<ImmStmtListAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmStmtList>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmStmtList>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmStmtListAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmStmtList>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmStmtList>> {
  using type = ImmStmtListAdapter;
};

struct ImmEmptyAdapter : public Napi::ObjectWrap<ImmEmptyAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmEmptyValueRead(org::imm::ImmAdapterT<org::imm::ImmEmpty>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmEmpty>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmEmptyAdapter", {InstanceMethod("getValue", &ImmEmptyAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmEmptyAdapter", func);
    return exports;
  }
  ImmEmptyAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmEmptyAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmEmptyAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmEmpty>> const& ptr) : Napi::ObjectWrap<ImmEmptyAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmEmpty>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmEmpty>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmEmptyAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmEmpty>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmEmpty>> {
  using type = ImmEmptyAdapter;
};

struct ImmTimeAdapter : public Napi::ObjectWrap<ImmTimeAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmTimeValueRead(org::imm::ImmAdapterT<org::imm::ImmTime>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmTime>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmTimeAdapter", {InstanceMethod("getValue", &ImmTimeAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmTimeAdapter", func);
    return exports;
  }
  ImmTimeAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmTimeAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmTimeAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmTime>> const& ptr) : Napi::ObjectWrap<ImmTimeAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmTime>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmTime>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmTimeAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmTime>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmTime>> {
  using type = ImmTimeAdapter;
};

struct ImmTimeRangeAdapter : public Napi::ObjectWrap<ImmTimeRangeAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmTimeRangeValueRead(org::imm::ImmAdapterT<org::imm::ImmTimeRange>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmTimeRange>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmTimeRangeAdapter", {InstanceMethod("getValue", &ImmTimeRangeAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmTimeRangeAdapter", func);
    return exports;
  }
  ImmTimeRangeAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmTimeRangeAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmTimeRangeAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmTimeRange>> const& ptr) : Napi::ObjectWrap<ImmTimeRangeAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmTimeRange>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmTimeRange>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmTimeRangeAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmTimeRange>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmTimeRange>> {
  using type = ImmTimeRangeAdapter;
};

struct ImmMacroAdapter : public Napi::ObjectWrap<ImmMacroAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmMacroValueRead(org::imm::ImmAdapterT<org::imm::ImmMacro>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmMacro>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmMacroAdapter", {InstanceMethod("getValue", &ImmMacroAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmMacroAdapter", func);
    return exports;
  }
  ImmMacroAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmMacroAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmMacroAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmMacro>> const& ptr) : Napi::ObjectWrap<ImmMacroAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmMacro>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmMacro>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmMacroAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmMacro>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmMacro>> {
  using type = ImmMacroAdapter;
};

struct ImmSymbolAdapter : public Napi::ObjectWrap<ImmSymbolAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmSymbolValueRead(org::imm::ImmAdapterT<org::imm::ImmSymbol>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmSymbol>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmSymbolAdapter", {InstanceMethod("getValue", &ImmSymbolAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmSymbolAdapter", func);
    return exports;
  }
  ImmSymbolAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmSymbolAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmSymbolAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmSymbol>> const& ptr) : Napi::ObjectWrap<ImmSymbolAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmSymbol>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmSymbol>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmSymbolAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmSymbol>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmSymbol>> {
  using type = ImmSymbolAdapter;
};

struct ImmLatexAdapter : public Napi::ObjectWrap<ImmLatexAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmLatexValueRead(org::imm::ImmAdapterT<org::imm::ImmLatex>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmLatex>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmLatexAdapter", {InstanceMethod("getValue", &ImmLatexAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmLatexAdapter", func);
    return exports;
  }
  ImmLatexAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmLatexAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmLatexAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmLatex>> const& ptr) : Napi::ObjectWrap<ImmLatexAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmLatex>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmLatex>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmLatexAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmLatex>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmLatex>> {
  using type = ImmLatexAdapter;
};

struct ImmSubtreeLogAdapter : public Napi::ObjectWrap<ImmSubtreeLogAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmSubtreeLogValueRead(org::imm::ImmAdapterT<org::imm::ImmSubtreeLog>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmSubtreeLog>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmSubtreeLogAdapter", {InstanceMethod("getValue", &ImmSubtreeLogAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmSubtreeLogAdapter", func);
    return exports;
  }
  ImmSubtreeLogAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmSubtreeLogAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmSubtreeLogAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmSubtreeLog>> const& ptr) : Napi::ObjectWrap<ImmSubtreeLogAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmSubtreeLog>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmSubtreeLog>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmSubtreeLogAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmSubtreeLog>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmSubtreeLog>> {
  using type = ImmSubtreeLogAdapter;
};

struct ImmColonExampleAdapter : public Napi::ObjectWrap<ImmColonExampleAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmColonExampleValueRead(org::imm::ImmAdapterT<org::imm::ImmColonExample>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmColonExample>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmColonExampleAdapter", {InstanceMethod("getValue", &ImmColonExampleAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmColonExampleAdapter", func);
    return exports;
  }
  ImmColonExampleAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmColonExampleAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmColonExampleAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmColonExample>> const& ptr) : Napi::ObjectWrap<ImmColonExampleAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmColonExample>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmColonExample>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmColonExampleAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmColonExample>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmColonExample>> {
  using type = ImmColonExampleAdapter;
};

struct ImmCallAdapter : public Napi::ObjectWrap<ImmCallAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCallValueRead(org::imm::ImmAdapterT<org::imm::ImmCall>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmCall>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmCallAdapter", {InstanceMethod("getValue", &ImmCallAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmCallAdapter", func);
    return exports;
  }
  ImmCallAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmCallAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmCallAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmCall>> const& ptr) : Napi::ObjectWrap<ImmCallAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmCall>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmCall>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmCallAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmCall>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmCall>> {
  using type = ImmCallAdapter;
};

struct ImmFileAdapter : public Napi::ObjectWrap<ImmFileAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmFileValueRead(org::imm::ImmAdapterT<org::imm::ImmFile>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmFile>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmFileAdapter", {InstanceMethod("getValue", &ImmFileAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmFileAdapter", func);
    return exports;
  }
  ImmFileAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmFileAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmFileAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmFile>> const& ptr) : Napi::ObjectWrap<ImmFileAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmFile>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmFile>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmFileAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmFile>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmFile>> {
  using type = ImmFileAdapter;
};

struct ImmDirectoryAdapter : public Napi::ObjectWrap<ImmDirectoryAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getFsSubnode(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::optional<org::imm::ImmAdapter>(org::imm::ImmAdapterT<org::imm::ImmDirectory>::*)(hstd::Str const&, bool) const>(&org::imm::ImmAdapterT<org::imm::ImmDirectory>::getFsSubnode),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"name"},
                                                        CxxArgSpec<bool>{"withPath", 1})));
  }
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmDirectoryValueRead(org::imm::ImmAdapterT<org::imm::ImmDirectory>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmDirectory>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmDirectoryAdapter", {InstanceMethod("getFsSubnode", &ImmDirectoryAdapter::getFsSubnode),
                                                                   InstanceMethod("getValue", &ImmDirectoryAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmDirectoryAdapter", func);
    return exports;
  }
  ImmDirectoryAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmDirectoryAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmDirectoryAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmDirectory>> const& ptr) : Napi::ObjectWrap<ImmDirectoryAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmDirectory>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmDirectory>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmDirectoryAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmDirectory>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmDirectory>> {
  using type = ImmDirectoryAdapter;
};

struct ImmSymlinkAdapter : public Napi::ObjectWrap<ImmSymlinkAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmSymlinkValueRead(org::imm::ImmAdapterT<org::imm::ImmSymlink>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmSymlink>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmSymlinkAdapter", {InstanceMethod("getValue", &ImmSymlinkAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmSymlinkAdapter", func);
    return exports;
  }
  ImmSymlinkAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmSymlinkAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmSymlinkAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmSymlink>> const& ptr) : Napi::ObjectWrap<ImmSymlinkAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmSymlink>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmSymlink>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmSymlinkAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmSymlink>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmSymlink>> {
  using type = ImmSymlinkAdapter;
};

struct ImmDocumentFragmentAdapter : public Napi::ObjectWrap<ImmDocumentFragmentAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmDocumentFragmentValueRead(org::imm::ImmAdapterT<org::imm::ImmDocumentFragment>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmDocumentFragment>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmDocumentFragmentAdapter", {InstanceMethod("getValue", &ImmDocumentFragmentAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmDocumentFragmentAdapter", func);
    return exports;
  }
  ImmDocumentFragmentAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmDocumentFragmentAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmDocumentFragmentAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmDocumentFragment>> const& ptr) : Napi::ObjectWrap<ImmDocumentFragmentAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmDocumentFragment>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmDocumentFragment>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmDocumentFragmentAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmDocumentFragment>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmDocumentFragment>> {
  using type = ImmDocumentFragmentAdapter;
};

struct ImmCriticMarkupAdapter : public Napi::ObjectWrap<ImmCriticMarkupAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCriticMarkupValueRead(org::imm::ImmAdapterT<org::imm::ImmCriticMarkup>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmCriticMarkup>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmCriticMarkupAdapter", {InstanceMethod("getValue", &ImmCriticMarkupAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmCriticMarkupAdapter", func);
    return exports;
  }
  ImmCriticMarkupAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmCriticMarkupAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmCriticMarkupAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmCriticMarkup>> const& ptr) : Napi::ObjectWrap<ImmCriticMarkupAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmCriticMarkup>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmCriticMarkup>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmCriticMarkupAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmCriticMarkup>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmCriticMarkup>> {
  using type = ImmCriticMarkupAdapter;
};

struct ImmListItemAdapter : public Napi::ObjectWrap<ImmListItemAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmListItemValueRead(org::imm::ImmAdapterT<org::imm::ImmListItem>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmListItem>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmListItemAdapter", {InstanceMethod("getValue", &ImmListItemAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmListItemAdapter", func);
    return exports;
  }
  ImmListItemAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmListItemAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmListItemAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmListItem>> const& ptr) : Napi::ObjectWrap<ImmListItemAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmListItem>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmListItem>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmListItemAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmListItem>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmListItem>> {
  using type = ImmListItemAdapter;
};

struct ImmDocumentOptionsAdapter : public Napi::ObjectWrap<ImmDocumentOptionsAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmDocumentOptionsValueRead(org::imm::ImmAdapterT<org::imm::ImmDocumentOptions>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmDocumentOptions>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmDocumentOptionsAdapter", {InstanceMethod("getValue", &ImmDocumentOptionsAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmDocumentOptionsAdapter", func);
    return exports;
  }
  ImmDocumentOptionsAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmDocumentOptionsAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmDocumentOptionsAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmDocumentOptions>> const& ptr) : Napi::ObjectWrap<ImmDocumentOptionsAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmDocumentOptions>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmDocumentOptions>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmDocumentOptionsAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmDocumentOptions>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmDocumentOptions>> {
  using type = ImmDocumentOptionsAdapter;
};

struct ImmDocumentAdapter : public Napi::ObjectWrap<ImmDocumentAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmDocumentValueRead(org::imm::ImmAdapterT<org::imm::ImmDocument>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmDocument>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmDocumentAdapter", {InstanceMethod("getValue", &ImmDocumentAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmDocumentAdapter", func);
    return exports;
  }
  ImmDocumentAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmDocumentAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmDocumentAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmDocument>> const& ptr) : Napi::ObjectWrap<ImmDocumentAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmDocument>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmDocument>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmDocumentAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmDocument>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmDocument>> {
  using type = ImmDocumentAdapter;
};

struct ImmFileTargetAdapter : public Napi::ObjectWrap<ImmFileTargetAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmFileTargetValueRead(org::imm::ImmAdapterT<org::imm::ImmFileTarget>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmFileTarget>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmFileTargetAdapter", {InstanceMethod("getValue", &ImmFileTargetAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmFileTargetAdapter", func);
    return exports;
  }
  ImmFileTargetAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmFileTargetAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmFileTargetAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmFileTarget>> const& ptr) : Napi::ObjectWrap<ImmFileTargetAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmFileTarget>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmFileTarget>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmFileTargetAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmFileTarget>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmFileTarget>> {
  using type = ImmFileTargetAdapter;
};

struct ImmTextSeparatorAdapter : public Napi::ObjectWrap<ImmTextSeparatorAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmTextSeparatorValueRead(org::imm::ImmAdapterT<org::imm::ImmTextSeparator>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmTextSeparator>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmTextSeparatorAdapter", {InstanceMethod("getValue", &ImmTextSeparatorAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmTextSeparatorAdapter", func);
    return exports;
  }
  ImmTextSeparatorAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmTextSeparatorAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmTextSeparatorAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmTextSeparator>> const& ptr) : Napi::ObjectWrap<ImmTextSeparatorAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmTextSeparator>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmTextSeparator>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmTextSeparatorAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmTextSeparator>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmTextSeparator>> {
  using type = ImmTextSeparatorAdapter;
};

struct ImmCmdIncludeAdapter : public Napi::ObjectWrap<ImmCmdIncludeAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCmdIncludeValueRead(org::imm::ImmAdapterT<org::imm::ImmCmdInclude>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmCmdInclude>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmCmdIncludeAdapter", {InstanceMethod("getValue", &ImmCmdIncludeAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmCmdIncludeAdapter", func);
    return exports;
  }
  ImmCmdIncludeAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmCmdIncludeAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmCmdIncludeAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmCmdInclude>> const& ptr) : Napi::ObjectWrap<ImmCmdIncludeAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmCmdInclude>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmCmdInclude>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmCmdIncludeAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmCmdInclude>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmCmdInclude>> {
  using type = ImmCmdIncludeAdapter;
};

struct ImmDocumentGroupAdapter : public Napi::ObjectWrap<ImmDocumentGroupAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmDocumentGroupValueRead(org::imm::ImmAdapterT<org::imm::ImmDocumentGroup>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmDocumentGroup>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmDocumentGroupAdapter", {InstanceMethod("getValue", &ImmDocumentGroupAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmDocumentGroupAdapter", func);
    return exports;
  }
  ImmDocumentGroupAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmDocumentGroupAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmDocumentGroupAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmDocumentGroup>> const& ptr) : Napi::ObjectWrap<ImmDocumentGroupAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmDocumentGroup>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmDocumentGroup>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmDocumentGroupAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmDocumentGroup>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmDocumentGroup>> {
  using type = ImmDocumentGroupAdapter;
};

struct BlockcenterJs : public Napi::ObjectWrap<BlockcenterJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::BlockCenter::*)() const>(&org::sem::BlockCenter::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockCenter::*)() const>(&org::sem::BlockCenter::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockCenter::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::BlockCenter::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockCenter::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::BlockCenter::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::BlockCenter::*)(int) const>(&org::sem::BlockCenter::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockCenter::*)(OrgSemKind) const>(&org::sem::BlockCenter::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockCenter::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockCenter::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockCenter::*)() const>(&org::sem::BlockCenter::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::BlockCenter::*)() const>(&org::sem::BlockCenter::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::BlockCenter::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockCenter::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::BlockCenter::*)(hstd::Str const&) const>(&org::sem::BlockCenter::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "BlockcenterJs", {InstanceMethod("getKind", &BlockcenterJs::getKind),
                                                             InstanceMethod("isGenerated", &BlockcenterJs::isGenerated),
                                                             InstanceMethod("push_back", &BlockcenterJs::push_back),
                                                             InstanceMethod("insert", &BlockcenterJs::insert),
                                                             InstanceMethod("at", &BlockcenterJs::at),
                                                             InstanceMethod("is", &BlockcenterJs::is),
                                                             InstanceMethod("getAttached", &BlockcenterJs::getAttached),
                                                             InstanceMethod("getCaption", &BlockcenterJs::getCaption),
                                                             InstanceMethod("getName", &BlockcenterJs::getName),
                                                             InstanceMethod("getAttrs", &BlockcenterJs::getAttrs),
                                                             InstanceMethod("getFirstAttr", &BlockcenterJs::getFirstAttr)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("BlockcenterJs", func);
    return exports;
  }
  BlockcenterJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<BlockcenterJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::BlockCenter>();
  }
  BlockcenterJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::BlockCenter> const& ptr) : Napi::ObjectWrap<BlockcenterJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::BlockCenter> _stored;
  org::sem::BlockCenter* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<BlockcenterJs> {
  using type = org::sem::BlockCenter;
};

template <>
struct org_to_js_type<org::sem::BlockCenter> {
  using type = BlockcenterJs;
};

struct BlockquoteJs : public Napi::ObjectWrap<BlockquoteJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::BlockQuote::*)() const>(&org::sem::BlockQuote::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockQuote::*)() const>(&org::sem::BlockQuote::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockQuote::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::BlockQuote::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockQuote::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::BlockQuote::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::BlockQuote::*)(int) const>(&org::sem::BlockQuote::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockQuote::*)(OrgSemKind) const>(&org::sem::BlockQuote::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockQuote::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockQuote::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockQuote::*)() const>(&org::sem::BlockQuote::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::BlockQuote::*)() const>(&org::sem::BlockQuote::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::BlockQuote::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockQuote::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::BlockQuote::*)(hstd::Str const&) const>(&org::sem::BlockQuote::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "BlockquoteJs", {InstanceMethod("getKind", &BlockquoteJs::getKind),
                                                            InstanceMethod("isGenerated", &BlockquoteJs::isGenerated),
                                                            InstanceMethod("push_back", &BlockquoteJs::push_back),
                                                            InstanceMethod("insert", &BlockquoteJs::insert),
                                                            InstanceMethod("at", &BlockquoteJs::at),
                                                            InstanceMethod("is", &BlockquoteJs::is),
                                                            InstanceMethod("getAttached", &BlockquoteJs::getAttached),
                                                            InstanceMethod("getCaption", &BlockquoteJs::getCaption),
                                                            InstanceMethod("getName", &BlockquoteJs::getName),
                                                            InstanceMethod("getAttrs", &BlockquoteJs::getAttrs),
                                                            InstanceMethod("getFirstAttr", &BlockquoteJs::getFirstAttr)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("BlockquoteJs", func);
    return exports;
  }
  BlockquoteJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<BlockquoteJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::BlockQuote>();
  }
  BlockquoteJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::BlockQuote> const& ptr) : Napi::ObjectWrap<BlockquoteJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::BlockQuote> _stored;
  org::sem::BlockQuote* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<BlockquoteJs> {
  using type = org::sem::BlockQuote;
};

template <>
struct org_to_js_type<org::sem::BlockQuote> {
  using type = BlockquoteJs;
};

struct BlockverseJs : public Napi::ObjectWrap<BlockverseJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::BlockVerse::*)() const>(&org::sem::BlockVerse::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockVerse::*)() const>(&org::sem::BlockVerse::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockVerse::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::BlockVerse::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockVerse::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::BlockVerse::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::BlockVerse::*)(int) const>(&org::sem::BlockVerse::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockVerse::*)(OrgSemKind) const>(&org::sem::BlockVerse::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockVerse::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockVerse::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockVerse::*)() const>(&org::sem::BlockVerse::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::BlockVerse::*)() const>(&org::sem::BlockVerse::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::BlockVerse::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockVerse::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::BlockVerse::*)(hstd::Str const&) const>(&org::sem::BlockVerse::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "BlockverseJs", {InstanceMethod("getKind", &BlockverseJs::getKind),
                                                            InstanceMethod("isGenerated", &BlockverseJs::isGenerated),
                                                            InstanceMethod("push_back", &BlockverseJs::push_back),
                                                            InstanceMethod("insert", &BlockverseJs::insert),
                                                            InstanceMethod("at", &BlockverseJs::at),
                                                            InstanceMethod("is", &BlockverseJs::is),
                                                            InstanceMethod("getAttached", &BlockverseJs::getAttached),
                                                            InstanceMethod("getCaption", &BlockverseJs::getCaption),
                                                            InstanceMethod("getName", &BlockverseJs::getName),
                                                            InstanceMethod("getAttrs", &BlockverseJs::getAttrs),
                                                            InstanceMethod("getFirstAttr", &BlockverseJs::getFirstAttr)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("BlockverseJs", func);
    return exports;
  }
  BlockverseJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<BlockverseJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::BlockVerse>();
  }
  BlockverseJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::BlockVerse> const& ptr) : Napi::ObjectWrap<BlockverseJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::BlockVerse> _stored;
  org::sem::BlockVerse* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<BlockverseJs> {
  using type = org::sem::BlockVerse;
};

template <>
struct org_to_js_type<org::sem::BlockVerse> {
  using type = BlockverseJs;
};

struct BlockdynamicfallbackJs : public Napi::ObjectWrap<BlockdynamicfallbackJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::BlockDynamicFallback::*)() const>(&org::sem::BlockDynamicFallback::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockDynamicFallback::*)() const>(&org::sem::BlockDynamicFallback::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockDynamicFallback::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::BlockDynamicFallback::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockDynamicFallback::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::BlockDynamicFallback::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::BlockDynamicFallback::*)(int) const>(&org::sem::BlockDynamicFallback::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockDynamicFallback::*)(OrgSemKind) const>(&org::sem::BlockDynamicFallback::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockDynamicFallback::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockDynamicFallback::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockDynamicFallback::*)() const>(&org::sem::BlockDynamicFallback::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::BlockDynamicFallback::*)() const>(&org::sem::BlockDynamicFallback::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::BlockDynamicFallback::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockDynamicFallback::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::BlockDynamicFallback::*)(hstd::Str const&) const>(&org::sem::BlockDynamicFallback::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "BlockdynamicfallbackJs", {InstanceMethod("getKind", &BlockdynamicfallbackJs::getKind),
                                                                      InstanceMethod("isGenerated", &BlockdynamicfallbackJs::isGenerated),
                                                                      InstanceMethod("push_back", &BlockdynamicfallbackJs::push_back),
                                                                      InstanceMethod("insert", &BlockdynamicfallbackJs::insert),
                                                                      InstanceMethod("at", &BlockdynamicfallbackJs::at),
                                                                      InstanceMethod("is", &BlockdynamicfallbackJs::is),
                                                                      InstanceMethod("getAttached", &BlockdynamicfallbackJs::getAttached),
                                                                      InstanceMethod("getCaption", &BlockdynamicfallbackJs::getCaption),
                                                                      InstanceMethod("getName", &BlockdynamicfallbackJs::getName),
                                                                      InstanceMethod("getAttrs", &BlockdynamicfallbackJs::getAttrs),
                                                                      InstanceMethod("getFirstAttr", &BlockdynamicfallbackJs::getFirstAttr)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("BlockdynamicfallbackJs", func);
    return exports;
  }
  BlockdynamicfallbackJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<BlockdynamicfallbackJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::BlockDynamicFallback>();
  }
  BlockdynamicfallbackJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::BlockDynamicFallback> const& ptr) : Napi::ObjectWrap<BlockdynamicfallbackJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::BlockDynamicFallback> _stored;
  org::sem::BlockDynamicFallback* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<BlockdynamicfallbackJs> {
  using type = org::sem::BlockDynamicFallback;
};

template <>
struct org_to_js_type<org::sem::BlockDynamicFallback> {
  using type = BlockdynamicfallbackJs;
};

struct BlockexampleJs : public Napi::ObjectWrap<BlockexampleJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::BlockExample::*)() const>(&org::sem::BlockExample::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockExample::*)() const>(&org::sem::BlockExample::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockExample::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::BlockExample::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockExample::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::BlockExample::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::BlockExample::*)(int) const>(&org::sem::BlockExample::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockExample::*)(OrgSemKind) const>(&org::sem::BlockExample::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockExample::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockExample::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockExample::*)() const>(&org::sem::BlockExample::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::BlockExample::*)() const>(&org::sem::BlockExample::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::BlockExample::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockExample::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::BlockExample::*)(hstd::Str const&) const>(&org::sem::BlockExample::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "BlockexampleJs", {InstanceMethod("getKind", &BlockexampleJs::getKind),
                                                              InstanceMethod("isGenerated", &BlockexampleJs::isGenerated),
                                                              InstanceMethod("push_back", &BlockexampleJs::push_back),
                                                              InstanceMethod("insert", &BlockexampleJs::insert),
                                                              InstanceMethod("at", &BlockexampleJs::at),
                                                              InstanceMethod("is", &BlockexampleJs::is),
                                                              InstanceMethod("getAttached", &BlockexampleJs::getAttached),
                                                              InstanceMethod("getCaption", &BlockexampleJs::getCaption),
                                                              InstanceMethod("getName", &BlockexampleJs::getName),
                                                              InstanceMethod("getAttrs", &BlockexampleJs::getAttrs),
                                                              InstanceMethod("getFirstAttr", &BlockexampleJs::getFirstAttr)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("BlockexampleJs", func);
    return exports;
  }
  BlockexampleJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<BlockexampleJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::BlockExample>();
  }
  BlockexampleJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::BlockExample> const& ptr) : Napi::ObjectWrap<BlockexampleJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::BlockExample> _stored;
  org::sem::BlockExample* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<BlockexampleJs> {
  using type = org::sem::BlockExample;
};

template <>
struct org_to_js_type<org::sem::BlockExample> {
  using type = BlockexampleJs;
};

struct BlockexportJs : public Napi::ObjectWrap<BlockexportJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::BlockExport::*)() const>(&org::sem::BlockExport::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockExport::*)() const>(&org::sem::BlockExport::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockExport::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::BlockExport::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockExport::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::BlockExport::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::BlockExport::*)(int) const>(&org::sem::BlockExport::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockExport::*)(OrgSemKind) const>(&org::sem::BlockExport::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockExport::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockExport::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockExport::*)() const>(&org::sem::BlockExport::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::BlockExport::*)() const>(&org::sem::BlockExport::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::BlockExport::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockExport::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::BlockExport::*)(hstd::Str const&) const>(&org::sem::BlockExport::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  Napi::Value getPlacement(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<hstd::Str>(org::sem::BlockExport::*)() const>(&org::sem::BlockExport::getPlacement),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "BlockexportJs", {InstanceMethod("getKind", &BlockexportJs::getKind),
                                                             InstanceMethod("isGenerated", &BlockexportJs::isGenerated),
                                                             InstanceMethod("push_back", &BlockexportJs::push_back),
                                                             InstanceMethod("insert", &BlockexportJs::insert),
                                                             InstanceMethod("at", &BlockexportJs::at),
                                                             InstanceMethod("is", &BlockexportJs::is),
                                                             InstanceMethod("getAttached", &BlockexportJs::getAttached),
                                                             InstanceMethod("getCaption", &BlockexportJs::getCaption),
                                                             InstanceMethod("getName", &BlockexportJs::getName),
                                                             InstanceMethod("getAttrs", &BlockexportJs::getAttrs),
                                                             InstanceMethod("getFirstAttr", &BlockexportJs::getFirstAttr),
                                                             InstanceMethod("getPlacement", &BlockexportJs::getPlacement)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("BlockexportJs", func);
    return exports;
  }
  BlockexportJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<BlockexportJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::BlockExport>();
  }
  BlockexportJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::BlockExport> const& ptr) : Napi::ObjectWrap<BlockexportJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::BlockExport> _stored;
  org::sem::BlockExport* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<BlockexportJs> {
  using type = org::sem::BlockExport;
};

template <>
struct org_to_js_type<org::sem::BlockExport> {
  using type = BlockexportJs;
};

struct BlockadmonitionJs : public Napi::ObjectWrap<BlockadmonitionJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::BlockAdmonition::*)() const>(&org::sem::BlockAdmonition::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockAdmonition::*)() const>(&org::sem::BlockAdmonition::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockAdmonition::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::BlockAdmonition::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockAdmonition::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::BlockAdmonition::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::BlockAdmonition::*)(int) const>(&org::sem::BlockAdmonition::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockAdmonition::*)(OrgSemKind) const>(&org::sem::BlockAdmonition::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockAdmonition::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockAdmonition::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockAdmonition::*)() const>(&org::sem::BlockAdmonition::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::BlockAdmonition::*)() const>(&org::sem::BlockAdmonition::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::BlockAdmonition::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockAdmonition::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::BlockAdmonition::*)(hstd::Str const&) const>(&org::sem::BlockAdmonition::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "BlockadmonitionJs", {InstanceMethod("getKind", &BlockadmonitionJs::getKind),
                                                                 InstanceMethod("isGenerated", &BlockadmonitionJs::isGenerated),
                                                                 InstanceMethod("push_back", &BlockadmonitionJs::push_back),
                                                                 InstanceMethod("insert", &BlockadmonitionJs::insert),
                                                                 InstanceMethod("at", &BlockadmonitionJs::at),
                                                                 InstanceMethod("is", &BlockadmonitionJs::is),
                                                                 InstanceMethod("getAttached", &BlockadmonitionJs::getAttached),
                                                                 InstanceMethod("getCaption", &BlockadmonitionJs::getCaption),
                                                                 InstanceMethod("getName", &BlockadmonitionJs::getName),
                                                                 InstanceMethod("getAttrs", &BlockadmonitionJs::getAttrs),
                                                                 InstanceMethod("getFirstAttr", &BlockadmonitionJs::getFirstAttr)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("BlockadmonitionJs", func);
    return exports;
  }
  BlockadmonitionJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<BlockadmonitionJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::BlockAdmonition>();
  }
  BlockadmonitionJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::BlockAdmonition> const& ptr) : Napi::ObjectWrap<BlockadmonitionJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::BlockAdmonition> _stored;
  org::sem::BlockAdmonition* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<BlockadmonitionJs> {
  using type = org::sem::BlockAdmonition;
};

template <>
struct org_to_js_type<org::sem::BlockAdmonition> {
  using type = BlockadmonitionJs;
};

struct BlockcodeevalresultJs : public Napi::ObjectWrap<BlockcodeevalresultJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::BlockCodeEvalResult::*)() const>(&org::sem::BlockCodeEvalResult::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockCodeEvalResult::*)() const>(&org::sem::BlockCodeEvalResult::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockCodeEvalResult::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::BlockCodeEvalResult::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockCodeEvalResult::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::BlockCodeEvalResult::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::BlockCodeEvalResult::*)(int) const>(&org::sem::BlockCodeEvalResult::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockCodeEvalResult::*)(OrgSemKind) const>(&org::sem::BlockCodeEvalResult::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockCodeEvalResult::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockCodeEvalResult::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockCodeEvalResult::*)() const>(&org::sem::BlockCodeEvalResult::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::BlockCodeEvalResult::*)() const>(&org::sem::BlockCodeEvalResult::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::BlockCodeEvalResult::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockCodeEvalResult::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::BlockCodeEvalResult::*)(hstd::Str const&) const>(&org::sem::BlockCodeEvalResult::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "BlockcodeevalresultJs", {InstanceMethod("getKind", &BlockcodeevalresultJs::getKind),
                                                                     InstanceMethod("isGenerated", &BlockcodeevalresultJs::isGenerated),
                                                                     InstanceMethod("push_back", &BlockcodeevalresultJs::push_back),
                                                                     InstanceMethod("insert", &BlockcodeevalresultJs::insert),
                                                                     InstanceMethod("at", &BlockcodeevalresultJs::at),
                                                                     InstanceMethod("is", &BlockcodeevalresultJs::is),
                                                                     InstanceMethod("getAttached", &BlockcodeevalresultJs::getAttached),
                                                                     InstanceMethod("getCaption", &BlockcodeevalresultJs::getCaption),
                                                                     InstanceMethod("getName", &BlockcodeevalresultJs::getName),
                                                                     InstanceMethod("getAttrs", &BlockcodeevalresultJs::getAttrs),
                                                                     InstanceMethod("getFirstAttr", &BlockcodeevalresultJs::getFirstAttr)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("BlockcodeevalresultJs", func);
    return exports;
  }
  BlockcodeevalresultJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<BlockcodeevalresultJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::BlockCodeEvalResult>();
  }
  BlockcodeevalresultJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::BlockCodeEvalResult> const& ptr) : Napi::ObjectWrap<BlockcodeevalresultJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::BlockCodeEvalResult> _stored;
  org::sem::BlockCodeEvalResult* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<BlockcodeevalresultJs> {
  using type = org::sem::BlockCodeEvalResult;
};

template <>
struct org_to_js_type<org::sem::BlockCodeEvalResult> {
  using type = BlockcodeevalresultJs;
};

struct BlockcodeJs : public Napi::ObjectWrap<BlockcodeJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::BlockCode::*)() const>(&org::sem::BlockCode::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockCode::*)() const>(&org::sem::BlockCode::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockCode::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::BlockCode::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockCode::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::BlockCode::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::BlockCode::*)(int) const>(&org::sem::BlockCode::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockCode::*)(OrgSemKind) const>(&org::sem::BlockCode::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockCode::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockCode::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockCode::*)() const>(&org::sem::BlockCode::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::BlockCode::*)() const>(&org::sem::BlockCode::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::BlockCode::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockCode::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::BlockCode::*)(hstd::Str const&) const>(&org::sem::BlockCode::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  Napi::Value getVariable(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::BlockCode::*)(hstd::Str const&) const>(&org::sem::BlockCode::getVariable),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"varname"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "BlockcodeJs", {InstanceMethod("getKind", &BlockcodeJs::getKind),
                                                           InstanceMethod("isGenerated", &BlockcodeJs::isGenerated),
                                                           InstanceMethod("push_back", &BlockcodeJs::push_back),
                                                           InstanceMethod("insert", &BlockcodeJs::insert),
                                                           InstanceMethod("at", &BlockcodeJs::at),
                                                           InstanceMethod("is", &BlockcodeJs::is),
                                                           InstanceMethod("getAttached", &BlockcodeJs::getAttached),
                                                           InstanceMethod("getCaption", &BlockcodeJs::getCaption),
                                                           InstanceMethod("getName", &BlockcodeJs::getName),
                                                           InstanceMethod("getAttrs", &BlockcodeJs::getAttrs),
                                                           InstanceMethod("getFirstAttr", &BlockcodeJs::getFirstAttr),
                                                           InstanceMethod("getVariable", &BlockcodeJs::getVariable)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("BlockcodeJs", func);
    return exports;
  }
  BlockcodeJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<BlockcodeJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::BlockCode>();
  }
  BlockcodeJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::BlockCode> const& ptr) : Napi::ObjectWrap<BlockcodeJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::BlockCode> _stored;
  org::sem::BlockCode* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<BlockcodeJs> {
  using type = org::sem::BlockCode;
};

template <>
struct org_to_js_type<org::sem::BlockCode> {
  using type = BlockcodeJs;
};

struct TableJs : public Napi::ObjectWrap<TableJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Table::*)() const>(&org::sem::Table::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Table::*)() const>(&org::sem::Table::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Table::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Table::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Table::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Table::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Table::*)(int) const>(&org::sem::Table::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Table::*)(OrgSemKind) const>(&org::sem::Table::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::Table::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::Table::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::Table::*)() const>(&org::sem::Table::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::Table::*)() const>(&org::sem::Table::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::Table::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::Table::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::Table::*)(hstd::Str const&) const>(&org::sem::Table::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "TableJs", {InstanceMethod("getKind", &TableJs::getKind),
                                                       InstanceMethod("isGenerated", &TableJs::isGenerated),
                                                       InstanceMethod("push_back", &TableJs::push_back),
                                                       InstanceMethod("insert", &TableJs::insert),
                                                       InstanceMethod("at", &TableJs::at),
                                                       InstanceMethod("is", &TableJs::is),
                                                       InstanceMethod("getAttached", &TableJs::getAttached),
                                                       InstanceMethod("getCaption", &TableJs::getCaption),
                                                       InstanceMethod("getName", &TableJs::getName),
                                                       InstanceMethod("getAttrs", &TableJs::getAttrs),
                                                       InstanceMethod("getFirstAttr", &TableJs::getFirstAttr)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("TableJs", func);
    return exports;
  }
  TableJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<TableJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::Table>();
  }
  TableJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::Table> const& ptr) : Napi::ObjectWrap<TableJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::Table> _stored;
  org::sem::Table* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<TableJs> {
  using type = org::sem::Table;
};

template <>
struct org_to_js_type<org::sem::Table> {
  using type = TableJs;
};

struct ImmCmdCustomRawAdapter : public Napi::ObjectWrap<ImmCmdCustomRawAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCmdCustomRawValueRead(org::imm::ImmAdapterT<org::imm::ImmCmdCustomRaw>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmCmdCustomRaw>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmCmdCustomRawAdapter", {InstanceMethod("getValue", &ImmCmdCustomRawAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmCmdCustomRawAdapter", func);
    return exports;
  }
  ImmCmdCustomRawAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmCmdCustomRawAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmCmdCustomRawAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmCmdCustomRaw>> const& ptr) : Napi::ObjectWrap<ImmCmdCustomRawAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmCmdCustomRaw>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmCmdCustomRaw>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmCmdCustomRawAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmCmdCustomRaw>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmCmdCustomRaw>> {
  using type = ImmCmdCustomRawAdapter;
};

struct ImmCmdCustomTextAdapter : public Napi::ObjectWrap<ImmCmdCustomTextAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCmdCustomTextValueRead(org::imm::ImmAdapterT<org::imm::ImmCmdCustomText>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmCmdCustomText>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmCmdCustomTextAdapter", {InstanceMethod("getValue", &ImmCmdCustomTextAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmCmdCustomTextAdapter", func);
    return exports;
  }
  ImmCmdCustomTextAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmCmdCustomTextAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmCmdCustomTextAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmCmdCustomText>> const& ptr) : Napi::ObjectWrap<ImmCmdCustomTextAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmCmdCustomText>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmCmdCustomText>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmCmdCustomTextAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmCmdCustomText>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmCmdCustomText>> {
  using type = ImmCmdCustomTextAdapter;
};

struct ImmLinkAdapter : public Napi::ObjectWrap<ImmLinkAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmLinkValueRead(org::imm::ImmAdapterT<org::imm::ImmLink>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmLink>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmLinkAdapter", {InstanceMethod("getValue", &ImmLinkAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmLinkAdapter", func);
    return exports;
  }
  ImmLinkAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmLinkAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmLinkAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmLink>> const& ptr) : Napi::ObjectWrap<ImmLinkAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmLink>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmLink>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmLinkAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmLink>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmLink>> {
  using type = ImmLinkAdapter;
};

struct ImmBlockCommentAdapter : public Napi::ObjectWrap<ImmBlockCommentAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmBlockCommentValueRead(org::imm::ImmAdapterT<org::imm::ImmBlockComment>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmBlockComment>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmBlockCommentAdapter", {InstanceMethod("getValue", &ImmBlockCommentAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmBlockCommentAdapter", func);
    return exports;
  }
  ImmBlockCommentAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmBlockCommentAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmBlockCommentAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmBlockComment>> const& ptr) : Napi::ObjectWrap<ImmBlockCommentAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmBlockComment>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmBlockComment>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmBlockCommentAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmBlockComment>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmBlockComment>> {
  using type = ImmBlockCommentAdapter;
};

struct ImmParagraphAdapter : public Napi::ObjectWrap<ImmParagraphAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmParagraphValueRead(org::imm::ImmAdapterT<org::imm::ImmParagraph>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmParagraph>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmParagraphAdapter", {InstanceMethod("getValue", &ImmParagraphAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmParagraphAdapter", func);
    return exports;
  }
  ImmParagraphAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmParagraphAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmParagraphAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmParagraph>> const& ptr) : Napi::ObjectWrap<ImmParagraphAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmParagraph>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmParagraph>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmParagraphAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmParagraph>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmParagraph>> {
  using type = ImmParagraphAdapter;
};

struct ImmListAdapter : public Napi::ObjectWrap<ImmListAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmListValueRead(org::imm::ImmAdapterT<org::imm::ImmList>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmList>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmListAdapter", {InstanceMethod("getValue", &ImmListAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmListAdapter", func);
    return exports;
  }
  ImmListAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmListAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmListAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmList>> const& ptr) : Napi::ObjectWrap<ImmListAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmList>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmList>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmListAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmList>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmList>> {
  using type = ImmListAdapter;
};

struct ImmHashTagAdapter : public Napi::ObjectWrap<ImmHashTagAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmHashTagValueRead(org::imm::ImmAdapterT<org::imm::ImmHashTag>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmHashTag>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmHashTagAdapter", {InstanceMethod("getValue", &ImmHashTagAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmHashTagAdapter", func);
    return exports;
  }
  ImmHashTagAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmHashTagAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmHashTagAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmHashTag>> const& ptr) : Napi::ObjectWrap<ImmHashTagAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmHashTag>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmHashTag>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmHashTagAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmHashTag>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmHashTag>> {
  using type = ImmHashTagAdapter;
};

struct ImmInlineFootnoteAdapter : public Napi::ObjectWrap<ImmInlineFootnoteAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmInlineFootnoteValueRead(org::imm::ImmAdapterT<org::imm::ImmInlineFootnote>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmInlineFootnote>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmInlineFootnoteAdapter", {InstanceMethod("getValue", &ImmInlineFootnoteAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmInlineFootnoteAdapter", func);
    return exports;
  }
  ImmInlineFootnoteAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmInlineFootnoteAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmInlineFootnoteAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmInlineFootnote>> const& ptr) : Napi::ObjectWrap<ImmInlineFootnoteAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmInlineFootnote>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmInlineFootnote>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmInlineFootnoteAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmInlineFootnote>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmInlineFootnote>> {
  using type = ImmInlineFootnoteAdapter;
};

struct ImmEscapedAdapter : public Napi::ObjectWrap<ImmEscapedAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmEscapedValueRead(org::imm::ImmAdapterT<org::imm::ImmEscaped>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmEscaped>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmEscapedAdapter", {InstanceMethod("getValue", &ImmEscapedAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmEscapedAdapter", func);
    return exports;
  }
  ImmEscapedAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmEscapedAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmEscapedAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmEscaped>> const& ptr) : Napi::ObjectWrap<ImmEscapedAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmEscaped>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmEscaped>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmEscapedAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmEscaped>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmEscaped>> {
  using type = ImmEscapedAdapter;
};

struct ImmNewlineAdapter : public Napi::ObjectWrap<ImmNewlineAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmNewlineValueRead(org::imm::ImmAdapterT<org::imm::ImmNewline>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmNewline>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmNewlineAdapter", {InstanceMethod("getValue", &ImmNewlineAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmNewlineAdapter", func);
    return exports;
  }
  ImmNewlineAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmNewlineAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmNewlineAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmNewline>> const& ptr) : Napi::ObjectWrap<ImmNewlineAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmNewline>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmNewline>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmNewlineAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmNewline>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmNewline>> {
  using type = ImmNewlineAdapter;
};

struct ImmSpaceAdapter : public Napi::ObjectWrap<ImmSpaceAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmSpaceValueRead(org::imm::ImmAdapterT<org::imm::ImmSpace>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmSpace>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmSpaceAdapter", {InstanceMethod("getValue", &ImmSpaceAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmSpaceAdapter", func);
    return exports;
  }
  ImmSpaceAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmSpaceAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmSpaceAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmSpace>> const& ptr) : Napi::ObjectWrap<ImmSpaceAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmSpace>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmSpace>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmSpaceAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmSpace>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmSpace>> {
  using type = ImmSpaceAdapter;
};

struct ImmWordAdapter : public Napi::ObjectWrap<ImmWordAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmWordValueRead(org::imm::ImmAdapterT<org::imm::ImmWord>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmWord>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmWordAdapter", {InstanceMethod("getValue", &ImmWordAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmWordAdapter", func);
    return exports;
  }
  ImmWordAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmWordAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmWordAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmWord>> const& ptr) : Napi::ObjectWrap<ImmWordAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmWord>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmWord>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmWordAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmWord>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmWord>> {
  using type = ImmWordAdapter;
};

struct ImmAtMentionAdapter : public Napi::ObjectWrap<ImmAtMentionAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmAtMentionValueRead(org::imm::ImmAdapterT<org::imm::ImmAtMention>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmAtMention>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmAtMentionAdapter", {InstanceMethod("getValue", &ImmAtMentionAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmAtMentionAdapter", func);
    return exports;
  }
  ImmAtMentionAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmAtMentionAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmAtMentionAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmAtMention>> const& ptr) : Napi::ObjectWrap<ImmAtMentionAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmAtMention>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmAtMention>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmAtMentionAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmAtMention>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmAtMention>> {
  using type = ImmAtMentionAdapter;
};

struct ImmRawTextAdapter : public Napi::ObjectWrap<ImmRawTextAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmRawTextValueRead(org::imm::ImmAdapterT<org::imm::ImmRawText>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmRawText>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmRawTextAdapter", {InstanceMethod("getValue", &ImmRawTextAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmRawTextAdapter", func);
    return exports;
  }
  ImmRawTextAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmRawTextAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmRawTextAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmRawText>> const& ptr) : Napi::ObjectWrap<ImmRawTextAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmRawText>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmRawText>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmRawTextAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmRawText>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmRawText>> {
  using type = ImmRawTextAdapter;
};

struct ImmPunctuationAdapter : public Napi::ObjectWrap<ImmPunctuationAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmPunctuationValueRead(org::imm::ImmAdapterT<org::imm::ImmPunctuation>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmPunctuation>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmPunctuationAdapter", {InstanceMethod("getValue", &ImmPunctuationAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmPunctuationAdapter", func);
    return exports;
  }
  ImmPunctuationAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmPunctuationAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmPunctuationAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmPunctuation>> const& ptr) : Napi::ObjectWrap<ImmPunctuationAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmPunctuation>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmPunctuation>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmPunctuationAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmPunctuation>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmPunctuation>> {
  using type = ImmPunctuationAdapter;
};

struct ImmPlaceholderAdapter : public Napi::ObjectWrap<ImmPlaceholderAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmPlaceholderValueRead(org::imm::ImmAdapterT<org::imm::ImmPlaceholder>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmPlaceholder>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmPlaceholderAdapter", {InstanceMethod("getValue", &ImmPlaceholderAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmPlaceholderAdapter", func);
    return exports;
  }
  ImmPlaceholderAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmPlaceholderAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmPlaceholderAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmPlaceholder>> const& ptr) : Napi::ObjectWrap<ImmPlaceholderAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmPlaceholder>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmPlaceholder>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmPlaceholderAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmPlaceholder>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmPlaceholder>> {
  using type = ImmPlaceholderAdapter;
};

struct ImmBigIdentAdapter : public Napi::ObjectWrap<ImmBigIdentAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmBigIdentValueRead(org::imm::ImmAdapterT<org::imm::ImmBigIdent>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmBigIdent>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmBigIdentAdapter", {InstanceMethod("getValue", &ImmBigIdentAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmBigIdentAdapter", func);
    return exports;
  }
  ImmBigIdentAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmBigIdentAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmBigIdentAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmBigIdent>> const& ptr) : Napi::ObjectWrap<ImmBigIdentAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmBigIdent>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmBigIdent>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmBigIdentAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmBigIdent>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmBigIdent>> {
  using type = ImmBigIdentAdapter;
};

struct ImmTextTargetAdapter : public Napi::ObjectWrap<ImmTextTargetAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmTextTargetValueRead(org::imm::ImmAdapterT<org::imm::ImmTextTarget>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmTextTarget>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmTextTargetAdapter", {InstanceMethod("getValue", &ImmTextTargetAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmTextTargetAdapter", func);
    return exports;
  }
  ImmTextTargetAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmTextTargetAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmTextTargetAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmTextTarget>> const& ptr) : Napi::ObjectWrap<ImmTextTargetAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmTextTarget>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmTextTarget>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmTextTargetAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmTextTarget>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmTextTarget>> {
  using type = ImmTextTargetAdapter;
};

struct ImmBoldAdapter : public Napi::ObjectWrap<ImmBoldAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmBoldValueRead(org::imm::ImmAdapterT<org::imm::ImmBold>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmBold>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmBoldAdapter", {InstanceMethod("getValue", &ImmBoldAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmBoldAdapter", func);
    return exports;
  }
  ImmBoldAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmBoldAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmBoldAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmBold>> const& ptr) : Napi::ObjectWrap<ImmBoldAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmBold>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmBold>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmBoldAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmBold>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmBold>> {
  using type = ImmBoldAdapter;
};

struct ImmUnderlineAdapter : public Napi::ObjectWrap<ImmUnderlineAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmUnderlineValueRead(org::imm::ImmAdapterT<org::imm::ImmUnderline>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmUnderline>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmUnderlineAdapter", {InstanceMethod("getValue", &ImmUnderlineAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmUnderlineAdapter", func);
    return exports;
  }
  ImmUnderlineAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmUnderlineAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmUnderlineAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmUnderline>> const& ptr) : Napi::ObjectWrap<ImmUnderlineAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmUnderline>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmUnderline>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmUnderlineAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmUnderline>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmUnderline>> {
  using type = ImmUnderlineAdapter;
};

struct ImmMonospaceAdapter : public Napi::ObjectWrap<ImmMonospaceAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmMonospaceValueRead(org::imm::ImmAdapterT<org::imm::ImmMonospace>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmMonospace>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmMonospaceAdapter", {InstanceMethod("getValue", &ImmMonospaceAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmMonospaceAdapter", func);
    return exports;
  }
  ImmMonospaceAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmMonospaceAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmMonospaceAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmMonospace>> const& ptr) : Napi::ObjectWrap<ImmMonospaceAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmMonospace>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmMonospace>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmMonospaceAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmMonospace>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmMonospace>> {
  using type = ImmMonospaceAdapter;
};

struct ImmMarkQuoteAdapter : public Napi::ObjectWrap<ImmMarkQuoteAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmMarkQuoteValueRead(org::imm::ImmAdapterT<org::imm::ImmMarkQuote>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmMarkQuote>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmMarkQuoteAdapter", {InstanceMethod("getValue", &ImmMarkQuoteAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmMarkQuoteAdapter", func);
    return exports;
  }
  ImmMarkQuoteAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmMarkQuoteAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmMarkQuoteAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmMarkQuote>> const& ptr) : Napi::ObjectWrap<ImmMarkQuoteAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmMarkQuote>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmMarkQuote>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmMarkQuoteAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmMarkQuote>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmMarkQuote>> {
  using type = ImmMarkQuoteAdapter;
};

struct ImmRadioTargetAdapter : public Napi::ObjectWrap<ImmRadioTargetAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmRadioTargetValueRead(org::imm::ImmAdapterT<org::imm::ImmRadioTarget>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmRadioTarget>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmRadioTargetAdapter", {InstanceMethod("getValue", &ImmRadioTargetAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmRadioTargetAdapter", func);
    return exports;
  }
  ImmRadioTargetAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmRadioTargetAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmRadioTargetAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmRadioTarget>> const& ptr) : Napi::ObjectWrap<ImmRadioTargetAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmRadioTarget>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmRadioTarget>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmRadioTargetAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmRadioTarget>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmRadioTarget>> {
  using type = ImmRadioTargetAdapter;
};

struct ImmVerbatimAdapter : public Napi::ObjectWrap<ImmVerbatimAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmVerbatimValueRead(org::imm::ImmAdapterT<org::imm::ImmVerbatim>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmVerbatim>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmVerbatimAdapter", {InstanceMethod("getValue", &ImmVerbatimAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmVerbatimAdapter", func);
    return exports;
  }
  ImmVerbatimAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmVerbatimAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmVerbatimAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmVerbatim>> const& ptr) : Napi::ObjectWrap<ImmVerbatimAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmVerbatim>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmVerbatim>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmVerbatimAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmVerbatim>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmVerbatim>> {
  using type = ImmVerbatimAdapter;
};

struct ImmItalicAdapter : public Napi::ObjectWrap<ImmItalicAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmItalicValueRead(org::imm::ImmAdapterT<org::imm::ImmItalic>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmItalic>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmItalicAdapter", {InstanceMethod("getValue", &ImmItalicAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmItalicAdapter", func);
    return exports;
  }
  ImmItalicAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmItalicAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmItalicAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmItalic>> const& ptr) : Napi::ObjectWrap<ImmItalicAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmItalic>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmItalic>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmItalicAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmItalic>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmItalic>> {
  using type = ImmItalicAdapter;
};

struct ImmStrikeAdapter : public Napi::ObjectWrap<ImmStrikeAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmStrikeValueRead(org::imm::ImmAdapterT<org::imm::ImmStrike>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmStrike>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmStrikeAdapter", {InstanceMethod("getValue", &ImmStrikeAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmStrikeAdapter", func);
    return exports;
  }
  ImmStrikeAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmStrikeAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmStrikeAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmStrike>> const& ptr) : Napi::ObjectWrap<ImmStrikeAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmStrike>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmStrike>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmStrikeAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmStrike>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmStrike>> {
  using type = ImmStrikeAdapter;
};

struct ImmParAdapter : public Napi::ObjectWrap<ImmParAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmParValueRead(org::imm::ImmAdapterT<org::imm::ImmPar>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmPar>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmParAdapter", {InstanceMethod("getValue", &ImmParAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmParAdapter", func);
    return exports;
  }
  ImmParAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmParAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmParAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmPar>> const& ptr) : Napi::ObjectWrap<ImmParAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmPar>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmPar>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmParAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmPar>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmPar>> {
  using type = ImmParAdapter;
};

struct CmdcaptionJs : public Napi::ObjectWrap<CmdcaptionJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::CmdCaption::*)() const>(&org::sem::CmdCaption::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdCaption::*)() const>(&org::sem::CmdCaption::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdCaption::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::CmdCaption::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdCaption::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::CmdCaption::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::CmdCaption::*)(int) const>(&org::sem::CmdCaption::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdCaption::*)(OrgSemKind) const>(&org::sem::CmdCaption::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdCaption::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdCaption::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdCaption::*)() const>(&org::sem::CmdCaption::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::CmdCaption::*)() const>(&org::sem::CmdCaption::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::CmdCaption::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdCaption::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::CmdCaption::*)(hstd::Str const&) const>(&org::sem::CmdCaption::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "CmdcaptionJs", {InstanceMethod("getKind", &CmdcaptionJs::getKind),
                                                            InstanceMethod("isGenerated", &CmdcaptionJs::isGenerated),
                                                            InstanceMethod("push_back", &CmdcaptionJs::push_back),
                                                            InstanceMethod("insert", &CmdcaptionJs::insert),
                                                            InstanceMethod("at", &CmdcaptionJs::at),
                                                            InstanceMethod("is", &CmdcaptionJs::is),
                                                            InstanceMethod("getAttached", &CmdcaptionJs::getAttached),
                                                            InstanceMethod("getCaption", &CmdcaptionJs::getCaption),
                                                            InstanceMethod("getName", &CmdcaptionJs::getName),
                                                            InstanceMethod("getAttrs", &CmdcaptionJs::getAttrs),
                                                            InstanceMethod("getFirstAttr", &CmdcaptionJs::getFirstAttr)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("CmdcaptionJs", func);
    return exports;
  }
  CmdcaptionJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<CmdcaptionJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::CmdCaption>();
  }
  CmdcaptionJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::CmdCaption> const& ptr) : Napi::ObjectWrap<CmdcaptionJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::CmdCaption> _stored;
  org::sem::CmdCaption* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<CmdcaptionJs> {
  using type = org::sem::CmdCaption;
};

template <>
struct org_to_js_type<org::sem::CmdCaption> {
  using type = CmdcaptionJs;
};

struct CmdcolumnsJs : public Napi::ObjectWrap<CmdcolumnsJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::CmdColumns::*)() const>(&org::sem::CmdColumns::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdColumns::*)() const>(&org::sem::CmdColumns::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdColumns::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::CmdColumns::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdColumns::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::CmdColumns::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::CmdColumns::*)(int) const>(&org::sem::CmdColumns::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdColumns::*)(OrgSemKind) const>(&org::sem::CmdColumns::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdColumns::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdColumns::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdColumns::*)() const>(&org::sem::CmdColumns::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::CmdColumns::*)() const>(&org::sem::CmdColumns::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::CmdColumns::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdColumns::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::CmdColumns::*)(hstd::Str const&) const>(&org::sem::CmdColumns::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "CmdcolumnsJs", {InstanceMethod("getKind", &CmdcolumnsJs::getKind),
                                                            InstanceMethod("isGenerated", &CmdcolumnsJs::isGenerated),
                                                            InstanceMethod("push_back", &CmdcolumnsJs::push_back),
                                                            InstanceMethod("insert", &CmdcolumnsJs::insert),
                                                            InstanceMethod("at", &CmdcolumnsJs::at),
                                                            InstanceMethod("is", &CmdcolumnsJs::is),
                                                            InstanceMethod("getAttached", &CmdcolumnsJs::getAttached),
                                                            InstanceMethod("getCaption", &CmdcolumnsJs::getCaption),
                                                            InstanceMethod("getName", &CmdcolumnsJs::getName),
                                                            InstanceMethod("getAttrs", &CmdcolumnsJs::getAttrs),
                                                            InstanceMethod("getFirstAttr", &CmdcolumnsJs::getFirstAttr)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("CmdcolumnsJs", func);
    return exports;
  }
  CmdcolumnsJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<CmdcolumnsJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::CmdColumns>();
  }
  CmdcolumnsJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::CmdColumns> const& ptr) : Napi::ObjectWrap<CmdcolumnsJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::CmdColumns> _stored;
  org::sem::CmdColumns* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<CmdcolumnsJs> {
  using type = org::sem::CmdColumns;
};

template <>
struct org_to_js_type<org::sem::CmdColumns> {
  using type = CmdcolumnsJs;
};

struct CmdnameJs : public Napi::ObjectWrap<CmdnameJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::CmdName::*)() const>(&org::sem::CmdName::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdName::*)() const>(&org::sem::CmdName::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdName::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::CmdName::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdName::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::CmdName::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::CmdName::*)(int) const>(&org::sem::CmdName::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdName::*)(OrgSemKind) const>(&org::sem::CmdName::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdName::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdName::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdName::*)() const>(&org::sem::CmdName::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::CmdName::*)() const>(&org::sem::CmdName::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::CmdName::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdName::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::CmdName::*)(hstd::Str const&) const>(&org::sem::CmdName::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "CmdnameJs", {InstanceMethod("getKind", &CmdnameJs::getKind),
                                                         InstanceMethod("isGenerated", &CmdnameJs::isGenerated),
                                                         InstanceMethod("push_back", &CmdnameJs::push_back),
                                                         InstanceMethod("insert", &CmdnameJs::insert),
                                                         InstanceMethod("at", &CmdnameJs::at),
                                                         InstanceMethod("is", &CmdnameJs::is),
                                                         InstanceMethod("getAttached", &CmdnameJs::getAttached),
                                                         InstanceMethod("getCaption", &CmdnameJs::getCaption),
                                                         InstanceMethod("getName", &CmdnameJs::getName),
                                                         InstanceMethod("getAttrs", &CmdnameJs::getAttrs),
                                                         InstanceMethod("getFirstAttr", &CmdnameJs::getFirstAttr)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("CmdnameJs", func);
    return exports;
  }
  CmdnameJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<CmdnameJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::CmdName>();
  }
  CmdnameJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::CmdName> const& ptr) : Napi::ObjectWrap<CmdnameJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::CmdName> _stored;
  org::sem::CmdName* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<CmdnameJs> {
  using type = org::sem::CmdName;
};

template <>
struct org_to_js_type<org::sem::CmdName> {
  using type = CmdnameJs;
};

struct CmdcallJs : public Napi::ObjectWrap<CmdcallJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::CmdCall::*)() const>(&org::sem::CmdCall::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdCall::*)() const>(&org::sem::CmdCall::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdCall::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::CmdCall::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdCall::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::CmdCall::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::CmdCall::*)(int) const>(&org::sem::CmdCall::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdCall::*)(OrgSemKind) const>(&org::sem::CmdCall::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdCall::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdCall::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdCall::*)() const>(&org::sem::CmdCall::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::CmdCall::*)() const>(&org::sem::CmdCall::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::CmdCall::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdCall::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::CmdCall::*)(hstd::Str const&) const>(&org::sem::CmdCall::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "CmdcallJs", {InstanceMethod("getKind", &CmdcallJs::getKind),
                                                         InstanceMethod("isGenerated", &CmdcallJs::isGenerated),
                                                         InstanceMethod("push_back", &CmdcallJs::push_back),
                                                         InstanceMethod("insert", &CmdcallJs::insert),
                                                         InstanceMethod("at", &CmdcallJs::at),
                                                         InstanceMethod("is", &CmdcallJs::is),
                                                         InstanceMethod("getAttached", &CmdcallJs::getAttached),
                                                         InstanceMethod("getCaption", &CmdcallJs::getCaption),
                                                         InstanceMethod("getName", &CmdcallJs::getName),
                                                         InstanceMethod("getAttrs", &CmdcallJs::getAttrs),
                                                         InstanceMethod("getFirstAttr", &CmdcallJs::getFirstAttr)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("CmdcallJs", func);
    return exports;
  }
  CmdcallJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<CmdcallJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::CmdCall>();
  }
  CmdcallJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::CmdCall> const& ptr) : Napi::ObjectWrap<CmdcallJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::CmdCall> _stored;
  org::sem::CmdCall* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<CmdcallJs> {
  using type = org::sem::CmdCall;
};

template <>
struct org_to_js_type<org::sem::CmdCall> {
  using type = CmdcallJs;
};

struct CmdattrJs : public Napi::ObjectWrap<CmdattrJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::CmdAttr::*)() const>(&org::sem::CmdAttr::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdAttr::*)() const>(&org::sem::CmdAttr::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdAttr::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::CmdAttr::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdAttr::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::CmdAttr::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::CmdAttr::*)(int) const>(&org::sem::CmdAttr::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdAttr::*)(OrgSemKind) const>(&org::sem::CmdAttr::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdAttr::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdAttr::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdAttr::*)() const>(&org::sem::CmdAttr::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::CmdAttr::*)() const>(&org::sem::CmdAttr::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::CmdAttr::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdAttr::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::CmdAttr::*)(hstd::Str const&) const>(&org::sem::CmdAttr::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "CmdattrJs", {InstanceMethod("getKind", &CmdattrJs::getKind),
                                                         InstanceMethod("isGenerated", &CmdattrJs::isGenerated),
                                                         InstanceMethod("push_back", &CmdattrJs::push_back),
                                                         InstanceMethod("insert", &CmdattrJs::insert),
                                                         InstanceMethod("at", &CmdattrJs::at),
                                                         InstanceMethod("is", &CmdattrJs::is),
                                                         InstanceMethod("getAttached", &CmdattrJs::getAttached),
                                                         InstanceMethod("getCaption", &CmdattrJs::getCaption),
                                                         InstanceMethod("getName", &CmdattrJs::getName),
                                                         InstanceMethod("getAttrs", &CmdattrJs::getAttrs),
                                                         InstanceMethod("getFirstAttr", &CmdattrJs::getFirstAttr)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("CmdattrJs", func);
    return exports;
  }
  CmdattrJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<CmdattrJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::CmdAttr>();
  }
  CmdattrJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::CmdAttr> const& ptr) : Napi::ObjectWrap<CmdattrJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::CmdAttr> _stored;
  org::sem::CmdAttr* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<CmdattrJs> {
  using type = org::sem::CmdAttr;
};

template <>
struct org_to_js_type<org::sem::CmdAttr> {
  using type = CmdattrJs;
};

struct CmdexportJs : public Napi::ObjectWrap<CmdexportJs> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::CmdExport::*)() const>(&org::sem::CmdExport::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdExport::*)() const>(&org::sem::CmdExport::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdExport::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::CmdExport::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdExport::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::CmdExport::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::CmdExport::*)(int) const>(&org::sem::CmdExport::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdExport::*)(OrgSemKind) const>(&org::sem::CmdExport::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdExport::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdExport::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdExport::*)() const>(&org::sem::CmdExport::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::CmdExport::*)() const>(&org::sem::CmdExport::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::CmdExport::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdExport::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::CmdExport::*)(hstd::Str const&) const>(&org::sem::CmdExport::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "CmdexportJs", {InstanceMethod("getKind", &CmdexportJs::getKind),
                                                           InstanceMethod("isGenerated", &CmdexportJs::isGenerated),
                                                           InstanceMethod("push_back", &CmdexportJs::push_back),
                                                           InstanceMethod("insert", &CmdexportJs::insert),
                                                           InstanceMethod("at", &CmdexportJs::at),
                                                           InstanceMethod("is", &CmdexportJs::is),
                                                           InstanceMethod("getAttached", &CmdexportJs::getAttached),
                                                           InstanceMethod("getCaption", &CmdexportJs::getCaption),
                                                           InstanceMethod("getName", &CmdexportJs::getName),
                                                           InstanceMethod("getAttrs", &CmdexportJs::getAttrs),
                                                           InstanceMethod("getFirstAttr", &CmdexportJs::getFirstAttr)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("CmdexportJs", func);
    return exports;
  }
  CmdexportJs(Napi::CallbackInfo const& info) : Napi::ObjectWrap<CmdexportJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = std::make_shared<org::sem::CmdExport>();
  }
  CmdexportJs(Napi::CallbackInfo const& info, std::shared_ptr<org::sem::CmdExport> const& ptr) : Napi::ObjectWrap<CmdexportJs>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::sem::CmdExport> _stored;
  org::sem::CmdExport* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<CmdexportJs> {
  using type = org::sem::CmdExport;
};

template <>
struct org_to_js_type<org::sem::CmdExport> {
  using type = CmdexportJs;
};

struct ImmCmdCustomArgsAdapter : public Napi::ObjectWrap<ImmCmdCustomArgsAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCmdCustomArgsValueRead(org::imm::ImmAdapterT<org::imm::ImmCmdCustomArgs>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmCmdCustomArgs>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmCmdCustomArgsAdapter", {InstanceMethod("getValue", &ImmCmdCustomArgsAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmCmdCustomArgsAdapter", func);
    return exports;
  }
  ImmCmdCustomArgsAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmCmdCustomArgsAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmCmdCustomArgsAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmCmdCustomArgs>> const& ptr) : Napi::ObjectWrap<ImmCmdCustomArgsAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmCmdCustomArgs>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmCmdCustomArgs>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmCmdCustomArgsAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmCmdCustomArgs>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmCmdCustomArgs>> {
  using type = ImmCmdCustomArgsAdapter;
};

struct ImmCmdTblfmAdapter : public Napi::ObjectWrap<ImmCmdTblfmAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCmdTblfmValueRead(org::imm::ImmAdapterT<org::imm::ImmCmdTblfm>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmCmdTblfm>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmCmdTblfmAdapter", {InstanceMethod("getValue", &ImmCmdTblfmAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmCmdTblfmAdapter", func);
    return exports;
  }
  ImmCmdTblfmAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmCmdTblfmAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmCmdTblfmAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmCmdTblfm>> const& ptr) : Napi::ObjectWrap<ImmCmdTblfmAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmCmdTblfm>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmCmdTblfm>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmCmdTblfmAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmCmdTblfm>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmCmdTblfm>> {
  using type = ImmCmdTblfmAdapter;
};

struct ImmCellAdapter : public Napi::ObjectWrap<ImmCellAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCellValueRead(org::imm::ImmAdapterT<org::imm::ImmCell>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmCell>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmCellAdapter", {InstanceMethod("getValue", &ImmCellAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmCellAdapter", func);
    return exports;
  }
  ImmCellAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmCellAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmCellAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmCell>> const& ptr) : Napi::ObjectWrap<ImmCellAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmCell>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmCell>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmCellAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmCell>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmCell>> {
  using type = ImmCellAdapter;
};

struct ImmRowAdapter : public Napi::ObjectWrap<ImmRowAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmRowValueRead(org::imm::ImmAdapterT<org::imm::ImmRow>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmRow>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmRowAdapter", {InstanceMethod("getValue", &ImmRowAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmRowAdapter", func);
    return exports;
  }
  ImmRowAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmRowAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmRowAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmRow>> const& ptr) : Napi::ObjectWrap<ImmRowAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmRow>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmRow>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmRowAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmRow>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmRow>> {
  using type = ImmRowAdapter;
};

struct ImmBlockCenterAdapter : public Napi::ObjectWrap<ImmBlockCenterAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmBlockCenterValueRead(org::imm::ImmAdapterT<org::imm::ImmBlockCenter>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmBlockCenter>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmBlockCenterAdapter", {InstanceMethod("getValue", &ImmBlockCenterAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmBlockCenterAdapter", func);
    return exports;
  }
  ImmBlockCenterAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmBlockCenterAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmBlockCenterAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmBlockCenter>> const& ptr) : Napi::ObjectWrap<ImmBlockCenterAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmBlockCenter>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmBlockCenter>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmBlockCenterAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmBlockCenter>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmBlockCenter>> {
  using type = ImmBlockCenterAdapter;
};

struct ImmBlockQuoteAdapter : public Napi::ObjectWrap<ImmBlockQuoteAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmBlockQuoteValueRead(org::imm::ImmAdapterT<org::imm::ImmBlockQuote>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmBlockQuote>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmBlockQuoteAdapter", {InstanceMethod("getValue", &ImmBlockQuoteAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmBlockQuoteAdapter", func);
    return exports;
  }
  ImmBlockQuoteAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmBlockQuoteAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmBlockQuoteAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmBlockQuote>> const& ptr) : Napi::ObjectWrap<ImmBlockQuoteAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmBlockQuote>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmBlockQuote>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmBlockQuoteAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmBlockQuote>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmBlockQuote>> {
  using type = ImmBlockQuoteAdapter;
};

struct ImmBlockVerseAdapter : public Napi::ObjectWrap<ImmBlockVerseAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmBlockVerseValueRead(org::imm::ImmAdapterT<org::imm::ImmBlockVerse>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmBlockVerse>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmBlockVerseAdapter", {InstanceMethod("getValue", &ImmBlockVerseAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmBlockVerseAdapter", func);
    return exports;
  }
  ImmBlockVerseAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmBlockVerseAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmBlockVerseAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmBlockVerse>> const& ptr) : Napi::ObjectWrap<ImmBlockVerseAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmBlockVerse>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmBlockVerse>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmBlockVerseAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmBlockVerse>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmBlockVerse>> {
  using type = ImmBlockVerseAdapter;
};

struct ImmBlockExampleAdapter : public Napi::ObjectWrap<ImmBlockExampleAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmBlockExampleValueRead(org::imm::ImmAdapterT<org::imm::ImmBlockExample>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmBlockExample>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmBlockExampleAdapter", {InstanceMethod("getValue", &ImmBlockExampleAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmBlockExampleAdapter", func);
    return exports;
  }
  ImmBlockExampleAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmBlockExampleAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmBlockExampleAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmBlockExample>> const& ptr) : Napi::ObjectWrap<ImmBlockExampleAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmBlockExample>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmBlockExample>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmBlockExampleAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmBlockExample>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmBlockExample>> {
  using type = ImmBlockExampleAdapter;
};

struct ImmInlineExportAdapter : public Napi::ObjectWrap<ImmInlineExportAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmInlineExportValueRead(org::imm::ImmAdapterT<org::imm::ImmInlineExport>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmInlineExport>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmInlineExportAdapter", {InstanceMethod("getValue", &ImmInlineExportAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmInlineExportAdapter", func);
    return exports;
  }
  ImmInlineExportAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmInlineExportAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmInlineExportAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmInlineExport>> const& ptr) : Napi::ObjectWrap<ImmInlineExportAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmInlineExport>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmInlineExport>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmInlineExportAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmInlineExport>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmInlineExport>> {
  using type = ImmInlineExportAdapter;
};

struct ImmCmdExportAdapter : public Napi::ObjectWrap<ImmCmdExportAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCmdExportValueRead(org::imm::ImmAdapterT<org::imm::ImmCmdExport>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmCmdExport>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmCmdExportAdapter", {InstanceMethod("getValue", &ImmCmdExportAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmCmdExportAdapter", func);
    return exports;
  }
  ImmCmdExportAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmCmdExportAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmCmdExportAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmCmdExport>> const& ptr) : Napi::ObjectWrap<ImmCmdExportAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmCmdExport>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmCmdExport>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmCmdExportAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmCmdExport>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmCmdExport>> {
  using type = ImmCmdExportAdapter;
};

struct ImmBlockExportAdapter : public Napi::ObjectWrap<ImmBlockExportAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmBlockExportValueRead(org::imm::ImmAdapterT<org::imm::ImmBlockExport>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmBlockExport>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmBlockExportAdapter", {InstanceMethod("getValue", &ImmBlockExportAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmBlockExportAdapter", func);
    return exports;
  }
  ImmBlockExportAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmBlockExportAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmBlockExportAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmBlockExport>> const& ptr) : Napi::ObjectWrap<ImmBlockExportAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmBlockExport>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmBlockExport>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmBlockExportAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmBlockExport>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmBlockExport>> {
  using type = ImmBlockExportAdapter;
};

struct ImmBlockDynamicFallbackAdapter : public Napi::ObjectWrap<ImmBlockDynamicFallbackAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmBlockDynamicFallbackValueRead(org::imm::ImmAdapterT<org::imm::ImmBlockDynamicFallback>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmBlockDynamicFallback>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmBlockDynamicFallbackAdapter", {InstanceMethod("getValue", &ImmBlockDynamicFallbackAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmBlockDynamicFallbackAdapter", func);
    return exports;
  }
  ImmBlockDynamicFallbackAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmBlockDynamicFallbackAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmBlockDynamicFallbackAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmBlockDynamicFallback>> const& ptr) : Napi::ObjectWrap<ImmBlockDynamicFallbackAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmBlockDynamicFallback>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmBlockDynamicFallback>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmBlockDynamicFallbackAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmBlockDynamicFallback>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmBlockDynamicFallback>> {
  using type = ImmBlockDynamicFallbackAdapter;
};

struct ImmBlockAdmonitionAdapter : public Napi::ObjectWrap<ImmBlockAdmonitionAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmBlockAdmonitionValueRead(org::imm::ImmAdapterT<org::imm::ImmBlockAdmonition>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmBlockAdmonition>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmBlockAdmonitionAdapter", {InstanceMethod("getValue", &ImmBlockAdmonitionAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmBlockAdmonitionAdapter", func);
    return exports;
  }
  ImmBlockAdmonitionAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmBlockAdmonitionAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmBlockAdmonitionAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmBlockAdmonition>> const& ptr) : Napi::ObjectWrap<ImmBlockAdmonitionAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmBlockAdmonition>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmBlockAdmonition>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmBlockAdmonitionAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmBlockAdmonition>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmBlockAdmonition>> {
  using type = ImmBlockAdmonitionAdapter;
};

struct ImmBlockCodeEvalResultAdapter : public Napi::ObjectWrap<ImmBlockCodeEvalResultAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmBlockCodeEvalResultValueRead(org::imm::ImmAdapterT<org::imm::ImmBlockCodeEvalResult>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmBlockCodeEvalResult>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmBlockCodeEvalResultAdapter", {InstanceMethod("getValue", &ImmBlockCodeEvalResultAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmBlockCodeEvalResultAdapter", func);
    return exports;
  }
  ImmBlockCodeEvalResultAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmBlockCodeEvalResultAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmBlockCodeEvalResultAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmBlockCodeEvalResult>> const& ptr) : Napi::ObjectWrap<ImmBlockCodeEvalResultAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmBlockCodeEvalResult>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmBlockCodeEvalResult>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmBlockCodeEvalResultAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmBlockCodeEvalResult>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmBlockCodeEvalResult>> {
  using type = ImmBlockCodeEvalResultAdapter;
};

struct ImmBlockCodeAdapter : public Napi::ObjectWrap<ImmBlockCodeAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmBlockCodeValueRead(org::imm::ImmAdapterT<org::imm::ImmBlockCode>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmBlockCode>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmBlockCodeAdapter", {InstanceMethod("getValue", &ImmBlockCodeAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmBlockCodeAdapter", func);
    return exports;
  }
  ImmBlockCodeAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmBlockCodeAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmBlockCodeAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmBlockCode>> const& ptr) : Napi::ObjectWrap<ImmBlockCodeAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmBlockCode>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmBlockCode>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmBlockCodeAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmBlockCode>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmBlockCode>> {
  using type = ImmBlockCodeAdapter;
};

struct ImmTableAdapter : public Napi::ObjectWrap<ImmTableAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmTableValueRead(org::imm::ImmAdapterT<org::imm::ImmTable>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmTable>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmTableAdapter", {InstanceMethod("getValue", &ImmTableAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmTableAdapter", func);
    return exports;
  }
  ImmTableAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmTableAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmTableAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmTable>> const& ptr) : Napi::ObjectWrap<ImmTableAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmTable>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmTable>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmTableAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmTable>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmTable>> {
  using type = ImmTableAdapter;
};

struct ImmCmdCaptionAdapter : public Napi::ObjectWrap<ImmCmdCaptionAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCmdCaptionValueRead(org::imm::ImmAdapterT<org::imm::ImmCmdCaption>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmCmdCaption>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmCmdCaptionAdapter", {InstanceMethod("getValue", &ImmCmdCaptionAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmCmdCaptionAdapter", func);
    return exports;
  }
  ImmCmdCaptionAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmCmdCaptionAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmCmdCaptionAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmCmdCaption>> const& ptr) : Napi::ObjectWrap<ImmCmdCaptionAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmCmdCaption>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmCmdCaption>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmCmdCaptionAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmCmdCaption>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmCmdCaption>> {
  using type = ImmCmdCaptionAdapter;
};

struct ImmCmdColumnsAdapter : public Napi::ObjectWrap<ImmCmdColumnsAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCmdColumnsValueRead(org::imm::ImmAdapterT<org::imm::ImmCmdColumns>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmCmdColumns>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmCmdColumnsAdapter", {InstanceMethod("getValue", &ImmCmdColumnsAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmCmdColumnsAdapter", func);
    return exports;
  }
  ImmCmdColumnsAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmCmdColumnsAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmCmdColumnsAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmCmdColumns>> const& ptr) : Napi::ObjectWrap<ImmCmdColumnsAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmCmdColumns>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmCmdColumns>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmCmdColumnsAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmCmdColumns>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmCmdColumns>> {
  using type = ImmCmdColumnsAdapter;
};

struct ImmCmdNameAdapter : public Napi::ObjectWrap<ImmCmdNameAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCmdNameValueRead(org::imm::ImmAdapterT<org::imm::ImmCmdName>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmCmdName>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmCmdNameAdapter", {InstanceMethod("getValue", &ImmCmdNameAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmCmdNameAdapter", func);
    return exports;
  }
  ImmCmdNameAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmCmdNameAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmCmdNameAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmCmdName>> const& ptr) : Napi::ObjectWrap<ImmCmdNameAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmCmdName>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmCmdName>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmCmdNameAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmCmdName>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmCmdName>> {
  using type = ImmCmdNameAdapter;
};

struct ImmCmdCallAdapter : public Napi::ObjectWrap<ImmCmdCallAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCmdCallValueRead(org::imm::ImmAdapterT<org::imm::ImmCmdCall>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmCmdCall>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmCmdCallAdapter", {InstanceMethod("getValue", &ImmCmdCallAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmCmdCallAdapter", func);
    return exports;
  }
  ImmCmdCallAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmCmdCallAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmCmdCallAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmCmdCall>> const& ptr) : Napi::ObjectWrap<ImmCmdCallAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmCmdCall>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmCmdCall>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmCmdCallAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmCmdCall>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmCmdCall>> {
  using type = ImmCmdCallAdapter;
};

struct ImmCmdAttrAdapter : public Napi::ObjectWrap<ImmCmdAttrAdapter> {
  static inline Napi::FunctionReference* constructor;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCmdAttrValueRead(org::imm::ImmAdapterT<org::imm::ImmCmdAttr>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmCmdAttr>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "ImmCmdAttrAdapter", {InstanceMethod("getValue", &ImmCmdAttrAdapter::getValue)});
    constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("ImmCmdAttrAdapter", func);
    return exports;
  }
  ImmCmdAttrAdapter(Napi::CallbackInfo const& info) : Napi::ObjectWrap<ImmCmdAttrAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
  }
  ImmCmdAttrAdapter(Napi::CallbackInfo const& info, std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmCmdAttr>> const& ptr) : Napi::ObjectWrap<ImmCmdAttrAdapter>{info} {
    Napi::Env env = info.Env();
    Napi::HandleScope scope(env);
    _stored = ptr;
  }
  std::shared_ptr<org::imm::ImmAdapterT<org::imm::ImmCmdAttr>> _stored;
  org::imm::ImmAdapterT<org::imm::ImmCmdAttr>* getPtr() { return _stored.get(); }
};

template <>
struct js_to_org_type<ImmCmdAttrAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmCmdAttr>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmCmdAttr>> {
  using type = ImmCmdAttrAdapter;
};

Napi::Object InitModule(Napi::Env env, Napi::Object exports) {
  hstdVec_bind<org::sem::OrgJson>::Init(env, exports, "VecOfOrgJson");
  hstdVec_bind<org::sem::SemId<org::sem::Org>>::Init(env, exports, "VecOfSemIdOfOrg");
  immerbox_bind<hstd::Str>::Init(env, exports, "ImmBox");
  immerbox_bind<std::optional<hstd::Str>>::Init(env, exports, "ImmBox");
  immerbox_bind<std::optional<int>>::Init(env, exports, "ImmBox");
  immerflex_vector_bind<org::imm::ImmIdT<org::imm::ImmErrorItem>>::Init(env, exports, "ImmFlexVector");
  immerflex_vector_bind<org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>>::Init(env, exports, "ImmFlexVector");
  immerbox_bind<std::optional<org::imm::ImmIdT<org::imm::ImmOrg>>>::Init(env, exports, "ImmBox");
  immerflex_vector_bind<org::imm::ImmSymbol::Param>::Init(env, exports, "ImmFlexVector");
  immerflex_vector_bind<org::imm::ImmIdT<org::imm::ImmOrg>>::Init(env, exports, "ImmFlexVector");
  immerflex_vector_bind<hstd::Str>::Init(env, exports, "ImmFlexVector");
  immerbox_bind<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>>::Init(env, exports, "ImmBox");
  immerflex_vector_bind<org::sem::OrgCodeEvalOutput>::Init(env, exports, "ImmFlexVector");
  immerflex_vector_bind<org::sem::BlockCodeLine>::Init(env, exports, "ImmFlexVector");
  immerbox_bind<std::optional<org::imm::ImmIdT<org::imm::ImmStmtList>>>::Init(env, exports, "ImmBox");
  immerbox_bind<std::optional<org::sem::SubtreeCompletion>>::Init(env, exports, "ImmBox");
  immerflex_vector_bind<org::imm::ImmIdT<org::imm::ImmHashTag>>::Init(env, exports, "ImmFlexVector");
  immerflex_vector_bind<org::imm::ImmIdT<org::imm::ImmSubtreeLog>>::Init(env, exports, "ImmFlexVector");
  immerflex_vector_bind<org::sem::NamedProperty>::Init(env, exports, "ImmFlexVector");
  immerbox_bind<std::optional<hstd::UserTime>>::Init(env, exports, "ImmBox");
  immerflex_vector_bind<org::imm::ImmIdT<org::imm::ImmCell>>::Init(env, exports, "ImmFlexVector");
  immerflex_vector_bind<org::imm::ImmIdT<org::imm::ImmRow>>::Init(env, exports, "ImmFlexVector");
  immerbox_bind<std::optional<bool>>::Init(env, exports, "ImmBox");
  immerbox_bind<std::optional<org::sem::ColumnView>>::Init(env, exports, "ImmBox");
  immerbox_bind<std::optional<org::imm::ImmIdT<org::imm::ImmRawText>>>::Init(env, exports, "ImmBox");
  hstdVec_bind<int>::Init(env, exports, "VecOfint");
  hstdVec_bind<org::imm::ImmAdapter>::Init(env, exports, "VecOfImmAdapter");
  hstdUnorderedMap_bind<org::sem::HashTagFlat, org::AstTrackingPath>::Init(env, exports, "UnorderedMapOfHashTagFlatAstTrackingPath");
  hstdUnorderedMap_bind<hstd::Str, org::AstTrackingAlternatives>::Init(env, exports, "UnorderedMapOfStrAstTrackingAlternatives");
  hstdUnorderedMap_bind<org::sem::HashTagFlat, org::AstTrackingAlternatives>::Init(env, exports, "UnorderedMapOfHashTagFlatAstTrackingAlternatives");
  hstdVec_bind<hstd::SequenceSegment>::Init(env, exports, "VecOfSequenceSegment");
  hstdVec_bind<hstd::SequenceAnnotationTag>::Init(env, exports, "VecOfSequenceAnnotationTag");
  hstdVec_bind<org::graph::MapLink>::Init(env, exports, "VecOfgraphMapLink");
  hstdUnorderedMap_bind<org::graph::MapNode, org::graph::MapNodeProp>::Init(env, exports, "UnorderedMapOfgraphMapNodegraphMapNodeProp");
  hstdUnorderedMap_bind<org::graph::MapEdge, org::graph::MapEdgeProp>::Init(env, exports, "UnorderedMapOfgraphMapEdgegraphMapEdgeProp");
  hstdUnorderedMap_bind<org::graph::MapNode, org::graph::AdjNodesList>::Init(env, exports, "UnorderedMapOfgraphMapNodegraphAdjNodesList");
  hstdVec_bind<org::graph::MapNode>::Init(env, exports, "VecOfgraphMapNode");
  hstdVec_bind<org::graph::MapEdge>::Init(env, exports, "VecOfgraphMapEdge");
  hstdVec_bind<org::sem::LispCode>::Init(env, exports, "VecOfLispCode");
  hstdVec_bind<org::sem::Tblfm::Assign>::Init(env, exports, "VecOfTblfmAssign");
  hstdVec_bind<org::sem::Tblfm::Expr>::Init(env, exports, "VecOfTblfmExpr");
  hstdVec_bind<org::sem::Tblfm::Assign::Flag>::Init(env, exports, "VecOfTblfmAssignFlag");
  hstdVec_bind<org::sem::AttrValue::DimensionSpan>::Init(env, exports, "VecOfAttrValueDimensionSpan");
  hstdVec_bind<hstd::Str>::Init(env, exports, "VecOfStr");
  hstdVec_bind<org::sem::HashTagText>::Init(env, exports, "VecOfHashTagText");
  hstdVec_bind<org::sem::HashTagFlat>::Init(env, exports, "VecOfHashTagFlat");
  hstdVec_bind<org::sem::AttrValue>::Init(env, exports, "VecOfAttrValue");
  hstdUnorderedMap_bind<hstd::Str, org::sem::AttrList>::Init(env, exports, "UnorderedMapOfStrAttrList");
  hstdVec_bind<org::sem::OrgCodeEvalInput::Var>::Init(env, exports, "VecOfOrgCodeEvalInputVar");
  hstdVec_bind<org::sem::ColumnView::Column>::Init(env, exports, "VecOfColumnViewColumn");
  hstdVec_bind<org::sem::BlockCodeLine::Part>::Init(env, exports, "VecOfBlockCodeLinePart");
  hstdUnorderedMap_bind<hstd::Str, hstd::Str>::Init(env, exports, "UnorderedMapOfStrStr");
  hstdVec_bind<org::sem::SemId<org::sem::ErrorItem>>::Init(env, exports, "VecOfSemIdOfErrorItem");
  hstdVec_bind<org::sem::Symbol::Param>::Init(env, exports, "VecOfSymbolParam");
  hstdVec_bind<org::sem::SemId<org::sem::HashTag>>::Init(env, exports, "VecOfSemIdOfHashTag");
  hstdVec_bind<org::sem::SemId<org::sem::SubtreeLog>>::Init(env, exports, "VecOfSemIdOfSubtreeLog");
  hstdVec_bind<org::sem::NamedProperty>::Init(env, exports, "VecOfNamedProperty");
  hstdVec_bind<org::sem::SubtreePeriod>::Init(env, exports, "VecOfSubtreePeriod");
  hstdIntSet_bind<org::sem::SubtreePeriod::Kind>::Init(env, exports, "IntSetOfSubtreePeriodKind");
  hstdVec_bind<org::sem::SemId<org::sem::BigIdent>>::Init(env, exports, "VecOfSemIdOfBigIdent");
  hstdVec_bind<hstd::UserTime>::Init(env, exports, "VecOfUserTime");
  hstdVec_bind<org::sem::SemId<org::sem::Time>>::Init(env, exports, "VecOfSemIdOfTime");
  hstdVec_bind<org::sem::SemId<org::sem::Cell>>::Init(env, exports, "VecOfSemIdOfCell");
  hstdVec_bind<org::sem::OrgCodeEvalOutput>::Init(env, exports, "VecOfOrgCodeEvalOutput");
  hstdVec_bind<org::sem::SemId<org::sem::BlockCodeEvalResult>>::Init(env, exports, "VecOfSemIdOfBlockCodeEvalResult");
  hstdVec_bind<org::sem::BlockCodeLine>::Init(env, exports, "VecOfBlockCodeLine");
  hstdVec_bind<org::sem::SemId<org::sem::Row>>::Init(env, exports, "VecOfSemIdOfRow");
  hstdVec_bind<org::AstTrackingGroup>::Init(env, exports, "VecOfAstTrackingGroup");
  hstdVec_bind<hstd::SequenceAnnotation>::Init(env, exports, "VecOfSequenceAnnotation");
  hstdVec_bind<hstd::SequenceSegmentGroup>::Init(env, exports, "VecOfSequenceSegmentGroup");
  UsertimebreakdownJs::Init(env, exports);
  UsertimeJs::Init(env, exports);
  ParseLinecolJs::Init(env, exports);
  OrgjsonJs::Init(env, exports);
  OperationstracerJs::Init(env, exports);
  ImmidJs::Init(env, exports);
  ImmpathstepJs::Init(env, exports);
  ImmpathJs::Init(env, exports);
  ImmuniqidJs::Init(env, exports);
  ImmnonevaluereadJs::Init(env, exports);
  ImmerroritemvaluereadJs::Init(env, exports);
  ImmerrorgroupvaluereadJs::Init(env, exports);
  ImmstmtlistvaluereadJs::Init(env, exports);
  ImmemptyvaluereadJs::Init(env, exports);
  ImmcmdcaptionvaluereadJs::Init(env, exports);
  ImmcmdcolumnsvaluereadJs::Init(env, exports);
  ImmcmdnamevaluereadJs::Init(env, exports);
  ImmcmdcustomargsvaluereadJs::Init(env, exports);
  ImmcmdcustomrawvaluereadJs::Init(env, exports);
  ImmcmdcustomtextvaluereadJs::Init(env, exports);
  ImmcmdcallvaluereadJs::Init(env, exports);
  ImmcmdtblfmvaluereadJs::Init(env, exports);
  ImmhashtagvaluereadJs::Init(env, exports);
  ImminlinefootnotevaluereadJs::Init(env, exports);
  ImminlineexportvaluereadJs::Init(env, exports);
  ImmtimevaluereadJs::Init(env, exports);
  ImmtimerangevaluereadJs::Init(env, exports);
  ImmmacrovaluereadJs::Init(env, exports);
  ImmsymbolvaluereadJs::Init(env, exports);
  ImmescapedvaluereadJs::Init(env, exports);
  ImmnewlinevaluereadJs::Init(env, exports);
  ImmspacevaluereadJs::Init(env, exports);
  ImmwordvaluereadJs::Init(env, exports);
  ImmatmentionvaluereadJs::Init(env, exports);
  ImmrawtextvaluereadJs::Init(env, exports);
  ImmpunctuationvaluereadJs::Init(env, exports);
  ImmplaceholdervaluereadJs::Init(env, exports);
  ImmbigidentvaluereadJs::Init(env, exports);
  ImmtexttargetvaluereadJs::Init(env, exports);
  ImmboldvaluereadJs::Init(env, exports);
  ImmunderlinevaluereadJs::Init(env, exports);
  ImmmonospacevaluereadJs::Init(env, exports);
  ImmmarkquotevaluereadJs::Init(env, exports);
  ImmverbatimvaluereadJs::Init(env, exports);
  ImmitalicvaluereadJs::Init(env, exports);
  ImmstrikevaluereadJs::Init(env, exports);
  ImmparvaluereadJs::Init(env, exports);
  ImmradiotargetvaluereadJs::Init(env, exports);
  ImmlatexvaluereadJs::Init(env, exports);
  ImmlinkvaluereadJs::Init(env, exports);
  ImmblockcentervaluereadJs::Init(env, exports);
  ImmblockquotevaluereadJs::Init(env, exports);
  ImmblockcommentvaluereadJs::Init(env, exports);
  ImmblockversevaluereadJs::Init(env, exports);
  ImmblockdynamicfallbackvaluereadJs::Init(env, exports);
  ImmblockexamplevaluereadJs::Init(env, exports);
  ImmblockexportvaluereadJs::Init(env, exports);
  ImmblockadmonitionvaluereadJs::Init(env, exports);
  ImmblockcodeevalresultvaluereadJs::Init(env, exports);
  ImmblockcodevaluereadJs::Init(env, exports);
  ImmsubtreelogvaluereadJs::Init(env, exports);
  ImmsubtreevaluereadJs::Init(env, exports);
  ImmcellvaluereadJs::Init(env, exports);
  ImmrowvaluereadJs::Init(env, exports);
  ImmtablevaluereadJs::Init(env, exports);
  ImmparagraphvaluereadJs::Init(env, exports);
  ImmcolonexamplevaluereadJs::Init(env, exports);
  ImmcmdattrvaluereadJs::Init(env, exports);
  ImmcmdexportvaluereadJs::Init(env, exports);
  ImmcallvaluereadJs::Init(env, exports);
  ImmlistvaluereadJs::Init(env, exports);
  ImmlistitemvaluereadJs::Init(env, exports);
  ImmdocumentoptionsvaluereadJs::Init(env, exports);
  ImmdocumentfragmentvaluereadJs::Init(env, exports);
  ImmcriticmarkupvaluereadJs::Init(env, exports);
  ImmdocumentvaluereadJs::Init(env, exports);
  ImmfiletargetvaluereadJs::Init(env, exports);
  ImmtextseparatorvaluereadJs::Init(env, exports);
  ImmdocumentgroupvaluereadJs::Init(env, exports);
  ImmfilevaluereadJs::Init(env, exports);
  ImmdirectoryvaluereadJs::Init(env, exports);
  ImmsymlinkvaluereadJs::Init(env, exports);
  ImmcmdincludevaluereadJs::Init(env, exports);
  ImmastcontextJs::Init(env, exports);
  ImmastversionJs::Init(env, exports);
  ImmadapterJs::Init(env, exports);
  ImmadapterTreereprconfJs::Init(env, exports);
  OrgparsefragmentJs::Init(env, exports);
  OrgparseparametersJs::Init(env, exports);
  OrgdirectoryparseparametersJs::Init(env, exports);
  OrgyamlexportoptsJs::Init(env, exports);
  OrgtreeexportoptsJs::Init(env, exports);
  AsttrackingpathJs::Init(env, exports);
  AsttrackingalternativesJs::Init(env, exports);
  AsttrackinggroupJs::Init(env, exports);
  AsttrackinggroupRadiotargetJs::Init(env, exports);
  AsttrackinggroupSingleJs::Init(env, exports);
  AsttrackinggroupTrackedhashtagJs::Init(env, exports);
  AsttrackingmapJs::Init(env, exports);
  SequencesegmentJs::Init(env, exports);
  SequencesegmentgroupJs::Init(env, exports);
  SequenceannotationtagJs::Init(env, exports);
  SequenceannotationJs::Init(env, exports);
  GraphMaplinkJs::Init(env, exports);
  GraphMaplinkLinkJs::Init(env, exports);
  GraphMaplinkRadioJs::Init(env, exports);
  GraphMapnodepropJs::Init(env, exports);
  GraphMapedgepropJs::Init(env, exports);
  GraphMapnodeJs::Init(env, exports);
  GraphMapedgeJs::Init(env, exports);
  GraphMapgraphJs::Init(env, exports);
  GraphMapgraphstateJs::Init(env, exports);
  LispcodeJs::Init(env, exports);
  LispcodeCallJs::Init(env, exports);
  LispcodeListJs::Init(env, exports);
  LispcodeKeyvalueJs::Init(env, exports);
  LispcodeNumberJs::Init(env, exports);
  LispcodeTextJs::Init(env, exports);
  LispcodeIdentJs::Init(env, exports);
  LispcodeBooleanJs::Init(env, exports);
  LispcodeRealJs::Init(env, exports);
  TblfmJs::Init(env, exports);
  TblfmExprJs::Init(env, exports);
  TblfmExprAxisrefJs::Init(env, exports);
  TblfmExprAxisrefPositionJs::Init(env, exports);
  TblfmExprAxisrefPositionIndexJs::Init(env, exports);
  TblfmExprAxisrefPositionNameJs::Init(env, exports);
  TblfmExprAxisnameJs::Init(env, exports);
  TblfmExprIntliteralJs::Init(env, exports);
  TblfmExprFloatliteralJs::Init(env, exports);
  TblfmExprRangerefJs::Init(env, exports);
  TblfmExprCallJs::Init(env, exports);
  TblfmExprElispJs::Init(env, exports);
  TblfmAssignJs::Init(env, exports);
  AttrvalueJs::Init(env, exports);
  AttrvalueDimensionspanJs::Init(env, exports);
  AttrvalueTextvalueJs::Init(env, exports);
  AttrvalueFilereferenceJs::Init(env, exports);
  AttrvalueLispvalueJs::Init(env, exports);
  HashtagflatJs::Init(env, exports);
  HashtagtextJs::Init(env, exports);
  SubtreepathJs::Init(env, exports);
  LinktargetJs::Init(env, exports);
  LinktargetRawJs::Init(env, exports);
  LinktargetIdJs::Init(env, exports);
  LinktargetCustomidJs::Init(env, exports);
  LinktargetSubtreetitleJs::Init(env, exports);
  LinktargetPersonJs::Init(env, exports);
  LinktargetUserprotocolJs::Init(env, exports);
  LinktargetInternalJs::Init(env, exports);
  LinktargetFootnoteJs::Init(env, exports);
  LinktargetFileJs::Init(env, exports);
  LinktargetAttachmentJs::Init(env, exports);
  SubtreelogheadJs::Init(env, exports);
  SubtreelogheadPriorityJs::Init(env, exports);
  SubtreelogheadNoteJs::Init(env, exports);
  SubtreelogheadRefileJs::Init(env, exports);
  SubtreelogheadClockJs::Init(env, exports);
  SubtreelogheadStateJs::Init(env, exports);
  SubtreelogheadDeadlineJs::Init(env, exports);
  SubtreelogheadScheduleJs::Init(env, exports);
  SubtreelogheadTagJs::Init(env, exports);
  SubtreelogheadUnknownJs::Init(env, exports);
  SubtreecompletionJs::Init(env, exports);
  AttrlistJs::Init(env, exports);
  AttrgroupJs::Init(env, exports);
  OrgcodeevalinputJs::Init(env, exports);
  OrgcodeevalinputVarJs::Init(env, exports);
  OrgcodeevaloutputJs::Init(env, exports);
  ColumnviewJs::Init(env, exports);
  ColumnviewSummaryJs::Init(env, exports);
  ColumnviewSummaryCheckboxaggregateJs::Init(env, exports);
  ColumnviewSummaryMathaggregateJs::Init(env, exports);
  ColumnviewColumnJs::Init(env, exports);
  BlockcodelineJs::Init(env, exports);
  BlockcodelinePartJs::Init(env, exports);
  BlockcodelinePartRawJs::Init(env, exports);
  BlockcodelinePartCalloutJs::Init(env, exports);
  BlockcodelinePartTangleJs::Init(env, exports);
  DocumentexportconfigJs::Init(env, exports);
  DocumentexportconfigTaskexportJs::Init(env, exports);
  DocumentexportconfigDoexportJs::Init(env, exports);
  DocumentexportconfigExportfixedJs::Init(env, exports);
  SubtreeperiodJs::Init(env, exports);
  NamedpropertyJs::Init(env, exports);
  NamedpropertyNonblockingJs::Init(env, exports);
  NamedpropertyArchivetimeJs::Init(env, exports);
  NamedpropertyArchivefileJs::Init(env, exports);
  NamedpropertyArchiveolpathJs::Init(env, exports);
  NamedpropertyArchivetargetJs::Init(env, exports);
  NamedpropertyArchivecategoryJs::Init(env, exports);
  NamedpropertyArchivetodoJs::Init(env, exports);
  NamedpropertyTriggerJs::Init(env, exports);
  NamedpropertyExportlatexclassJs::Init(env, exports);
  NamedpropertyCookiedataJs::Init(env, exports);
  NamedpropertyExportlatexclassoptionsJs::Init(env, exports);
  NamedpropertyExportlatexheaderJs::Init(env, exports);
  NamedpropertyExportlatexcompilerJs::Init(env, exports);
  NamedpropertyOrderedJs::Init(env, exports);
  NamedpropertyEffortJs::Init(env, exports);
  NamedpropertyVisibilityJs::Init(env, exports);
  NamedpropertyExportoptionsJs::Init(env, exports);
  NamedpropertyBlockerJs::Init(env, exports);
  NamedpropertyUnnumberedJs::Init(env, exports);
  NamedpropertyCreatedJs::Init(env, exports);
  NamedpropertyRadioidJs::Init(env, exports);
  NamedpropertyHashtagdefJs::Init(env, exports);
  NamedpropertyCustomargsJs::Init(env, exports);
  NamedpropertyCustomrawJs::Init(env, exports);
  NamedpropertyCustomsubtreejsonJs::Init(env, exports);
  NamedpropertyCustomsubtreeflagsJs::Init(env, exports);
  NoneJs::Init(env, exports);
  ErroritemJs::Init(env, exports);
  ErrorgroupJs::Init(env, exports);
  StmtlistJs::Init(env, exports);
  EmptyJs::Init(env, exports);
  TimeJs::Init(env, exports);
  TimeRepeatJs::Init(env, exports);
  TimeStaticJs::Init(env, exports);
  TimeDynamicJs::Init(env, exports);
  TimerangeJs::Init(env, exports);
  MacroJs::Init(env, exports);
  SymbolJs::Init(env, exports);
  SymbolParamJs::Init(env, exports);
  RadiotargetJs::Init(env, exports);
  LatexJs::Init(env, exports);
  SubtreelogJs::Init(env, exports);
  SubtreeJs::Init(env, exports);
  ColonexampleJs::Init(env, exports);
  CallJs::Init(env, exports);
  ListitemJs::Init(env, exports);
  DocumentoptionsJs::Init(env, exports);
  DocumentfragmentJs::Init(env, exports);
  CriticmarkupJs::Init(env, exports);
  DocumentJs::Init(env, exports);
  FiletargetJs::Init(env, exports);
  TextseparatorJs::Init(env, exports);
  DocumentgroupJs::Init(env, exports);
  FileJs::Init(env, exports);
  FileDocumentJs::Init(env, exports);
  FileAttachmentJs::Init(env, exports);
  FileSourceJs::Init(env, exports);
  DirectoryJs::Init(env, exports);
  SymlinkJs::Init(env, exports);
  CmdincludeJs::Init(env, exports);
  CmdincludeIncludebaseJs::Init(env, exports);
  CmdincludeExampleJs::Init(env, exports);
  CmdincludeExportJs::Init(env, exports);
  CmdincludeCustomJs::Init(env, exports);
  CmdincludeSrcJs::Init(env, exports);
  CmdincludeOrgdocumentJs::Init(env, exports);
  GraphMapconfigJs::Init(env, exports);
  ImmIdTNone::Init(env, exports);
  ImmIdTErrorItem::Init(env, exports);
  ImmIdTErrorGroup::Init(env, exports);
  ImmIdTStmt::Init(env, exports);
  ImmIdTInline::Init(env, exports);
  ImmIdTStmtList::Init(env, exports);
  ImmIdTEmpty::Init(env, exports);
  ImmIdTCmd::Init(env, exports);
  ImmIdTBlock::Init(env, exports);
  ImmIdTLineCommand::Init(env, exports);
  ImmIdTAttached::Init(env, exports);
  ImmIdTLeaf::Init(env, exports);
  ImmIdTCmdCaption::Init(env, exports);
  ImmIdTCmdColumns::Init(env, exports);
  ImmIdTCmdName::Init(env, exports);
  ImmIdTCmdCustomArgs::Init(env, exports);
  ImmIdTCmdCustomRaw::Init(env, exports);
  ImmIdTCmdCustomText::Init(env, exports);
  ImmIdTCmdCall::Init(env, exports);
  ImmIdTCmdTblfm::Init(env, exports);
  ImmIdTHashTag::Init(env, exports);
  ImmIdTInlineFootnote::Init(env, exports);
  ImmIdTInlineExport::Init(env, exports);
  ImmIdTTime::Init(env, exports);
  ImmIdTTimeRange::Init(env, exports);
  ImmIdTMacro::Init(env, exports);
  ImmIdTSymbol::Init(env, exports);
  ImmIdTEscaped::Init(env, exports);
  ImmIdTNewline::Init(env, exports);
  ImmIdTSpace::Init(env, exports);
  ImmIdTWord::Init(env, exports);
  ImmIdTAtMention::Init(env, exports);
  ImmIdTRawText::Init(env, exports);
  ImmIdTPunctuation::Init(env, exports);
  ImmIdTPlaceholder::Init(env, exports);
  ImmIdTBigIdent::Init(env, exports);
  ImmIdTTextTarget::Init(env, exports);
  ImmIdTMarkup::Init(env, exports);
  ImmIdTBold::Init(env, exports);
  ImmIdTUnderline::Init(env, exports);
  ImmIdTMonospace::Init(env, exports);
  ImmIdTMarkQuote::Init(env, exports);
  ImmIdTVerbatim::Init(env, exports);
  ImmIdTItalic::Init(env, exports);
  ImmIdTStrike::Init(env, exports);
  ImmIdTPar::Init(env, exports);
  ImmIdTRadioTarget::Init(env, exports);
  ImmIdTLatex::Init(env, exports);
  ImmIdTLink::Init(env, exports);
  ImmIdTBlockCenter::Init(env, exports);
  ImmIdTBlockQuote::Init(env, exports);
  ImmIdTBlockComment::Init(env, exports);
  ImmIdTBlockVerse::Init(env, exports);
  ImmIdTBlockDynamicFallback::Init(env, exports);
  ImmIdTBlockExample::Init(env, exports);
  ImmIdTBlockExport::Init(env, exports);
  ImmIdTBlockAdmonition::Init(env, exports);
  ImmIdTBlockCodeEvalResult::Init(env, exports);
  ImmIdTBlockCode::Init(env, exports);
  ImmIdTSubtreeLog::Init(env, exports);
  ImmIdTSubtree::Init(env, exports);
  ImmIdTCell::Init(env, exports);
  ImmIdTRow::Init(env, exports);
  ImmIdTTable::Init(env, exports);
  ImmIdTParagraph::Init(env, exports);
  ImmIdTColonExample::Init(env, exports);
  ImmIdTCmdAttr::Init(env, exports);
  ImmIdTCmdExport::Init(env, exports);
  ImmIdTCall::Init(env, exports);
  ImmIdTList::Init(env, exports);
  ImmIdTListItem::Init(env, exports);
  ImmIdTDocumentOptions::Init(env, exports);
  ImmIdTDocumentFragment::Init(env, exports);
  ImmIdTCriticMarkup::Init(env, exports);
  ImmIdTDocument::Init(env, exports);
  ImmIdTFileTarget::Init(env, exports);
  ImmIdTTextSeparator::Init(env, exports);
  ImmIdTDocumentGroup::Init(env, exports);
  ImmIdTFile::Init(env, exports);
  ImmIdTDirectory::Init(env, exports);
  ImmIdTSymlink::Init(env, exports);
  ImmIdTCmdInclude::Init(env, exports);
  ImmnonevalueJs::Init(env, exports);
  ImmerroritemvalueJs::Init(env, exports);
  ImmerrorgroupvalueJs::Init(env, exports);
  ImmstmtlistvalueJs::Init(env, exports);
  ImmemptyvalueJs::Init(env, exports);
  ImmcmdcaptionvalueJs::Init(env, exports);
  ImmcmdcolumnsvalueJs::Init(env, exports);
  ImmcmdnamevalueJs::Init(env, exports);
  ImmcmdcustomargsvalueJs::Init(env, exports);
  ImmcmdcustomrawvalueJs::Init(env, exports);
  ImmcmdcustomtextvalueJs::Init(env, exports);
  ImmcmdcallvalueJs::Init(env, exports);
  ImmcmdtblfmvalueJs::Init(env, exports);
  ImmhashtagvalueJs::Init(env, exports);
  ImminlinefootnotevalueJs::Init(env, exports);
  ImminlineexportvalueJs::Init(env, exports);
  ImmtimevalueJs::Init(env, exports);
  ImmtimerangevalueJs::Init(env, exports);
  ImmmacrovalueJs::Init(env, exports);
  ImmsymbolvalueJs::Init(env, exports);
  ImmescapedvalueJs::Init(env, exports);
  ImmnewlinevalueJs::Init(env, exports);
  ImmspacevalueJs::Init(env, exports);
  ImmwordvalueJs::Init(env, exports);
  ImmatmentionvalueJs::Init(env, exports);
  ImmrawtextvalueJs::Init(env, exports);
  ImmpunctuationvalueJs::Init(env, exports);
  ImmplaceholdervalueJs::Init(env, exports);
  ImmbigidentvalueJs::Init(env, exports);
  ImmtexttargetvalueJs::Init(env, exports);
  ImmboldvalueJs::Init(env, exports);
  ImmunderlinevalueJs::Init(env, exports);
  ImmmonospacevalueJs::Init(env, exports);
  ImmmarkquotevalueJs::Init(env, exports);
  ImmverbatimvalueJs::Init(env, exports);
  ImmitalicvalueJs::Init(env, exports);
  ImmstrikevalueJs::Init(env, exports);
  ImmparvalueJs::Init(env, exports);
  ImmradiotargetvalueJs::Init(env, exports);
  ImmlatexvalueJs::Init(env, exports);
  ImmlinkvalueJs::Init(env, exports);
  ImmblockcentervalueJs::Init(env, exports);
  ImmblockquotevalueJs::Init(env, exports);
  ImmblockcommentvalueJs::Init(env, exports);
  ImmblockversevalueJs::Init(env, exports);
  ImmblockdynamicfallbackvalueJs::Init(env, exports);
  ImmblockexamplevalueJs::Init(env, exports);
  ImmblockexportvalueJs::Init(env, exports);
  ImmblockadmonitionvalueJs::Init(env, exports);
  ImmblockcodeevalresultvalueJs::Init(env, exports);
  ImmblockcodevalueJs::Init(env, exports);
  ImmsubtreelogvalueJs::Init(env, exports);
  ImmsubtreevalueJs::Init(env, exports);
  ImmcellvalueJs::Init(env, exports);
  ImmrowvalueJs::Init(env, exports);
  ImmtablevalueJs::Init(env, exports);
  ImmparagraphvalueJs::Init(env, exports);
  ImmcolonexamplevalueJs::Init(env, exports);
  ImmcmdattrvalueJs::Init(env, exports);
  ImmcmdexportvalueJs::Init(env, exports);
  ImmcallvalueJs::Init(env, exports);
  ImmlistvalueJs::Init(env, exports);
  ImmlistitemvalueJs::Init(env, exports);
  ImmdocumentoptionsvalueJs::Init(env, exports);
  ImmdocumentfragmentvalueJs::Init(env, exports);
  ImmcriticmarkupvalueJs::Init(env, exports);
  ImmdocumentvalueJs::Init(env, exports);
  ImmfiletargetvalueJs::Init(env, exports);
  ImmtextseparatorvalueJs::Init(env, exports);
  ImmdocumentgroupvalueJs::Init(env, exports);
  ImmfilevalueJs::Init(env, exports);
  ImmdirectoryvalueJs::Init(env, exports);
  ImmsymlinkvalueJs::Init(env, exports);
  ImmcmdincludevalueJs::Init(env, exports);
  CmdcustomrawJs::Init(env, exports);
  CmdcustomtextJs::Init(env, exports);
  LinkJs::Init(env, exports);
  BlockcommentJs::Init(env, exports);
  ParagraphJs::Init(env, exports);
  ListJs::Init(env, exports);
  HashtagJs::Init(env, exports);
  InlinefootnoteJs::Init(env, exports);
  InlineexportJs::Init(env, exports);
  EscapedJs::Init(env, exports);
  NewlineJs::Init(env, exports);
  SpaceJs::Init(env, exports);
  WordJs::Init(env, exports);
  AtmentionJs::Init(env, exports);
  RawtextJs::Init(env, exports);
  PunctuationJs::Init(env, exports);
  PlaceholderJs::Init(env, exports);
  BigidentJs::Init(env, exports);
  TexttargetJs::Init(env, exports);
  BoldJs::Init(env, exports);
  UnderlineJs::Init(env, exports);
  MonospaceJs::Init(env, exports);
  MarkquoteJs::Init(env, exports);
  VerbatimJs::Init(env, exports);
  ItalicJs::Init(env, exports);
  StrikeJs::Init(env, exports);
  ParJs::Init(env, exports);
  CmdcustomargsJs::Init(env, exports);
  CmdtblfmJs::Init(env, exports);
  CellJs::Init(env, exports);
  RowJs::Init(env, exports);
  ImmSubtreeAdapter::Init(env, exports);
  ImmNoneAdapter::Init(env, exports);
  ImmErrorItemAdapter::Init(env, exports);
  ImmErrorGroupAdapter::Init(env, exports);
  ImmStmtListAdapter::Init(env, exports);
  ImmEmptyAdapter::Init(env, exports);
  ImmTimeAdapter::Init(env, exports);
  ImmTimeRangeAdapter::Init(env, exports);
  ImmMacroAdapter::Init(env, exports);
  ImmSymbolAdapter::Init(env, exports);
  ImmLatexAdapter::Init(env, exports);
  ImmSubtreeLogAdapter::Init(env, exports);
  ImmColonExampleAdapter::Init(env, exports);
  ImmCallAdapter::Init(env, exports);
  ImmFileAdapter::Init(env, exports);
  ImmDirectoryAdapter::Init(env, exports);
  ImmSymlinkAdapter::Init(env, exports);
  ImmDocumentFragmentAdapter::Init(env, exports);
  ImmCriticMarkupAdapter::Init(env, exports);
  ImmListItemAdapter::Init(env, exports);
  ImmDocumentOptionsAdapter::Init(env, exports);
  ImmDocumentAdapter::Init(env, exports);
  ImmFileTargetAdapter::Init(env, exports);
  ImmTextSeparatorAdapter::Init(env, exports);
  ImmCmdIncludeAdapter::Init(env, exports);
  ImmDocumentGroupAdapter::Init(env, exports);
  BlockcenterJs::Init(env, exports);
  BlockquoteJs::Init(env, exports);
  BlockverseJs::Init(env, exports);
  BlockdynamicfallbackJs::Init(env, exports);
  BlockexampleJs::Init(env, exports);
  BlockexportJs::Init(env, exports);
  BlockadmonitionJs::Init(env, exports);
  BlockcodeevalresultJs::Init(env, exports);
  BlockcodeJs::Init(env, exports);
  TableJs::Init(env, exports);
  ImmCmdCustomRawAdapter::Init(env, exports);
  ImmCmdCustomTextAdapter::Init(env, exports);
  ImmLinkAdapter::Init(env, exports);
  ImmBlockCommentAdapter::Init(env, exports);
  ImmParagraphAdapter::Init(env, exports);
  ImmListAdapter::Init(env, exports);
  ImmHashTagAdapter::Init(env, exports);
  ImmInlineFootnoteAdapter::Init(env, exports);
  ImmEscapedAdapter::Init(env, exports);
  ImmNewlineAdapter::Init(env, exports);
  ImmSpaceAdapter::Init(env, exports);
  ImmWordAdapter::Init(env, exports);
  ImmAtMentionAdapter::Init(env, exports);
  ImmRawTextAdapter::Init(env, exports);
  ImmPunctuationAdapter::Init(env, exports);
  ImmPlaceholderAdapter::Init(env, exports);
  ImmBigIdentAdapter::Init(env, exports);
  ImmTextTargetAdapter::Init(env, exports);
  ImmBoldAdapter::Init(env, exports);
  ImmUnderlineAdapter::Init(env, exports);
  ImmMonospaceAdapter::Init(env, exports);
  ImmMarkQuoteAdapter::Init(env, exports);
  ImmRadioTargetAdapter::Init(env, exports);
  ImmVerbatimAdapter::Init(env, exports);
  ImmItalicAdapter::Init(env, exports);
  ImmStrikeAdapter::Init(env, exports);
  ImmParAdapter::Init(env, exports);
  CmdcaptionJs::Init(env, exports);
  CmdcolumnsJs::Init(env, exports);
  CmdnameJs::Init(env, exports);
  CmdcallJs::Init(env, exports);
  CmdattrJs::Init(env, exports);
  CmdexportJs::Init(env, exports);
  ImmCmdCustomArgsAdapter::Init(env, exports);
  ImmCmdTblfmAdapter::Init(env, exports);
  ImmCellAdapter::Init(env, exports);
  ImmRowAdapter::Init(env, exports);
  ImmBlockCenterAdapter::Init(env, exports);
  ImmBlockQuoteAdapter::Init(env, exports);
  ImmBlockVerseAdapter::Init(env, exports);
  ImmBlockExampleAdapter::Init(env, exports);
  ImmInlineExportAdapter::Init(env, exports);
  ImmCmdExportAdapter::Init(env, exports);
  ImmBlockExportAdapter::Init(env, exports);
  ImmBlockDynamicFallbackAdapter::Init(env, exports);
  ImmBlockAdmonitionAdapter::Init(env, exports);
  ImmBlockCodeEvalResultAdapter::Init(env, exports);
  ImmBlockCodeAdapter::Init(env, exports);
  ImmTableAdapter::Init(env, exports);
  ImmCmdCaptionAdapter::Init(env, exports);
  ImmCmdColumnsAdapter::Init(env, exports);
  ImmCmdNameAdapter::Init(env, exports);
  ImmCmdCallAdapter::Init(env, exports);
  ImmCmdAttrAdapter::Init(env, exports);
  {
    auto callable = makeCallable(&org::newSemTimeStatic, std::make_tuple(CxxArgSpec<hstd::UserTimeBreakdown>{"breakdown"},
                                                                         CxxArgSpec<bool>{"isActive", 0}));
    exports.Set("newSemTimeStatic", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::parseFile, std::make_tuple(CxxArgSpec<std::string>{"file"},
                                                                  CxxArgSpec<org::OrgParseParameters>{"opts"}));
    exports.Set("parseFile", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::parseString, std::make_tuple(CxxArgSpec<std::string>{"text"}));
    exports.Set("parseString", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::parseStringOpts, std::make_tuple(CxxArgSpec<std::string>{"text"},
                                                                        CxxArgSpec<org::OrgParseParameters>{"opts"}));
    exports.Set("parseStringOpts", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::parseDirectoryOpts, std::make_tuple(CxxArgSpec<std::string>{"path"},
                                                                           CxxArgSpec<org::OrgDirectoryParseParameters>{"opts"}));
    exports.Set("parseDirectoryOpts", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::parseFileWithIncludes, std::make_tuple(CxxArgSpec<std::string>{"file"},
                                                                              CxxArgSpec<org::OrgDirectoryParseParameters>{"opts"}));
    exports.Set("parseFileWithIncludes", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::initImmutableAstContext, std::make_tuple());
    exports.Set("initImmutableAstContext", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::asOneNode, std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"arg"}));
    exports.Set("asOneNode", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::formatToString, std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"arg"}));
    exports.Set("formatToString", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::exportToYamlString, std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"},
                                                                           CxxArgSpec<org::OrgYamlExportOpts>{"opts"}));
    exports.Set("exportToYamlString", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::exportToYamlFile, std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"},
                                                                         CxxArgSpec<std::string>{"path"},
                                                                         CxxArgSpec<org::OrgYamlExportOpts>{"opts"}));
    exports.Set("exportToYamlFile", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::exportToJsonString, std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"}));
    exports.Set("exportToJsonString", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::exportToJsonFile, std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"},
                                                                         CxxArgSpec<std::string>{"path"}));
    exports.Set("exportToJsonFile", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::readProtobufFile, std::make_tuple(CxxArgSpec<std::string>{"file"}));
    exports.Set("readProtobufFile", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::exportToProtobufFile, std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Document>>{"doc"},
                                                                             CxxArgSpec<std::string>{"file"}));
    exports.Set("exportToProtobufFile", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::exportToTreeString, std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"},
                                                                           CxxArgSpec<org::OrgTreeExportOpts>{"opts"}));
    exports.Set("exportToTreeString", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::exportToTreeFile, std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"},
                                                                         CxxArgSpec<std::string>{"path"},
                                                                         CxxArgSpec<org::OrgTreeExportOpts>{"opts"}));
    exports.Set("exportToTreeFile", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::getAstTrackingMap, std::make_tuple(CxxArgSpec<hstd::Vec<org::sem::SemId<org::sem::Org>>>{"nodes"}));
    exports.Set("getAstTrackingMap", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::getSubnodeGroups, std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"},
                                                                         CxxArgSpec<org::AstTrackingMap>{"map"}));
    exports.Set("getSubnodeGroups", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&hstd::annotateSequence, std::make_tuple(CxxArgSpec<hstd::Vec<hstd::SequenceSegmentGroup>>{"groups"},
                                                                          CxxArgSpec<int>{"first"},
                                                                          CxxArgSpec<int>{"last"}));
    exports.Set("annotateSequence", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  return exports;
}

NODE_API_MODULE(pyhaxorg, InitModule);
/* clang-format on */