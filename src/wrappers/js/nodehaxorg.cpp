/* clang-format off */
#include "node_utils.hpp"
#include "node_org_include.hpp"
using namespace org::bind::js;
struct UserTimeBreakdownJs : public SharedPtrWrapBase<UserTimeBreakdownJs, hstd::UserTimeBreakdown> {
  using SharedPtrWrapBase<UserTimeBreakdownJs, hstd::UserTimeBreakdown>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "UserTimeBreakdownJs", {}); }
};

template <>
struct js_to_org_type<UserTimeBreakdownJs> {
  using type = hstd::UserTimeBreakdown;
};

template <>
struct org_to_js_type<hstd::UserTimeBreakdown> {
  using type = UserTimeBreakdownJs;
};

struct UserTimeJs : public SharedPtrWrapBase<UserTimeJs, hstd::UserTime> {
  using SharedPtrWrapBase<UserTimeJs, hstd::UserTime>::SharedPtrWrapBase;
  Napi::Value getBreakdown(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::UserTimeBreakdown(hstd::UserTime::*)() const>(&hstd::UserTime::getBreakdown),
                                        std::make_tuple()));
  }
  Napi::Value format(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(hstd::UserTime::*)() const>(&hstd::UserTime::format),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "UserTimeJs", {InstanceMethod("getBreakdown", &UserTimeJs::getBreakdown),
                                                                                                                     InstanceMethod("format", &UserTimeJs::format)}); }
};

template <>
struct js_to_org_type<UserTimeJs> {
  using type = hstd::UserTime;
};

template <>
struct org_to_js_type<hstd::UserTime> {
  using type = UserTimeJs;
};

struct LineColParseJs : public SharedPtrWrapBase<LineColParseJs, org::parse::LineCol> {
  using SharedPtrWrapBase<LineColParseJs, org::parse::LineCol>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "LineColParseJs", {}); }
};

template <>
struct js_to_org_type<LineColParseJs> {
  using type = org::parse::LineCol;
};

template <>
struct org_to_js_type<org::parse::LineCol> {
  using type = LineColParseJs;
};

struct OrgJsonJs : public SharedPtrWrapBase<OrgJsonJs, org::sem::OrgJson> {
  using SharedPtrWrapBase<OrgJsonJs, org::sem::OrgJson>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgJsonKind(org::sem::OrgJson::*)() const>(&org::sem::OrgJson::getKind),
                                        std::make_tuple()));
  }
  Napi::Value getJsonString(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::sem::OrgJson::*)() const>(&org::sem::OrgJson::getJsonString),
                                        std::make_tuple()));
  }
  Napi::Value atField(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::OrgJson(org::sem::OrgJson::*)(std::string const&) const>(&org::sem::OrgJson::at),
                                        std::make_tuple(CxxArgSpec<std::string>{"name"})));
  }
  Napi::Value getString(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::sem::OrgJson::*)() const>(&org::sem::OrgJson::getString),
                                        std::make_tuple()));
  }
  Napi::Value getField(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::OrgJson(org::sem::OrgJson::*)(std::string const&) const>(&org::sem::OrgJson::getField),
                                        std::make_tuple(CxxArgSpec<std::string>{"name"})));
  }
  Napi::Value getItem(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::OrgJson(org::sem::OrgJson::*)(int) const>(&org::sem::OrgJson::getItem),
                                        std::make_tuple(CxxArgSpec<int>{"index"})));
  }
  Napi::Value getInt(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::OrgJson::*)() const>(&org::sem::OrgJson::getInt),
                                        std::make_tuple()));
  }
  Napi::Value getBool(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::OrgJson::*)() const>(&org::sem::OrgJson::getBool),
                                        std::make_tuple()));
  }
  Napi::Value getArray(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::OrgJson>(org::sem::OrgJson::*)() const>(&org::sem::OrgJson::getArray),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "OrgJsonJs", {InstanceMethod("getKind", &OrgJsonJs::getKind),
                                                                                                                    InstanceMethod("getJsonString", &OrgJsonJs::getJsonString),
                                                                                                                    InstanceMethod("atField", &OrgJsonJs::atField),
                                                                                                                    InstanceMethod("getString", &OrgJsonJs::getString),
                                                                                                                    InstanceMethod("getField", &OrgJsonJs::getField),
                                                                                                                    InstanceMethod("getItem", &OrgJsonJs::getItem),
                                                                                                                    InstanceMethod("getInt", &OrgJsonJs::getInt),
                                                                                                                    InstanceMethod("getBool", &OrgJsonJs::getBool),
                                                                                                                    InstanceMethod("getArray", &OrgJsonJs::getArray)}); }
};

template <>
struct js_to_org_type<OrgJsonJs> {
  using type = org::sem::OrgJson;
};

template <>
struct org_to_js_type<org::sem::OrgJson> {
  using type = OrgJsonJs;
};

struct OperationsTracerJs : public SharedPtrWrapBase<OperationsTracerJs, hstd::OperationsTracer> {
  using SharedPtrWrapBase<OperationsTracerJs, hstd::OperationsTracer>::SharedPtrWrapBase;
  Napi::Value setTraceFileStr(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(hstd::OperationsTracer::*)(std::string const&, bool)>(&hstd::OperationsTracer::setTraceFileStr),
                                   std::make_tuple(CxxArgSpec<std::string>{"outfile"},
                                                   CxxArgSpec<bool>{"overwrite"})));
  }
  Napi::Value sendMessage(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(hstd::OperationsTracer::*)(std::string const&, std::string const&, int, std::string const&)>(&hstd::OperationsTracer::sendMessage),
                                   std::make_tuple(CxxArgSpec<std::string>{"value"},
                                                   CxxArgSpec<std::string>{"function"},
                                                   CxxArgSpec<int>{"line"},
                                                   CxxArgSpec<std::string>{"file"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "OperationsTracerJs", {InstanceMethod("setTraceFileStr", &OperationsTracerJs::setTraceFileStr),
                                                                                                                             InstanceMethod("sendMessage", &OperationsTracerJs::sendMessage)}); }
};

template <>
struct js_to_org_type<OperationsTracerJs> {
  using type = hstd::OperationsTracer;
};

template <>
struct org_to_js_type<hstd::OperationsTracer> {
  using type = OperationsTracerJs;
};

struct ImmIdJs : public SharedPtrWrapBase<ImmIdJs, org::imm::ImmId> {
  using SharedPtrWrapBase<ImmIdJs, org::imm::ImmId>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmId::*)() const>(&org::imm::ImmId::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmId::*)(OrgSemKind) const>(&org::imm::ImmId::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmId::*)() const>(&org::imm::ImmId::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmId::*)() const>(&org::imm::ImmId::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdJs", {InstanceMethod("getKind", &ImmIdJs::getKind),
                                                                                                                  InstanceMethod("is", &ImmIdJs::is),
                                                                                                                  InstanceMethod("getNodeIndex", &ImmIdJs::getNodeIndex),
                                                                                                                  InstanceMethod("getReadableId", &ImmIdJs::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdJs> {
  using type = org::imm::ImmId;
};

template <>
struct org_to_js_type<org::imm::ImmId> {
  using type = ImmIdJs;
};

struct ImmPathStepJs : public SharedPtrWrapBase<ImmPathStepJs, org::imm::ImmPathStep> {
  using SharedPtrWrapBase<ImmPathStepJs, org::imm::ImmPathStep>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmPathStepJs", {}); }
};

template <>
struct js_to_org_type<ImmPathStepJs> {
  using type = org::imm::ImmPathStep;
};

template <>
struct org_to_js_type<org::imm::ImmPathStep> {
  using type = ImmPathStepJs;
};

struct ImmPathJs : public SharedPtrWrapBase<ImmPathJs, org::imm::ImmPath> {
  using SharedPtrWrapBase<ImmPathJs, org::imm::ImmPath>::SharedPtrWrapBase;
  Napi::Value empty(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmPath::*)() const>(&org::imm::ImmPath::empty),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmPathJs", {InstanceMethod("empty", &ImmPathJs::empty)}); }
};

template <>
struct js_to_org_type<ImmPathJs> {
  using type = org::imm::ImmPath;
};

template <>
struct org_to_js_type<org::imm::ImmPath> {
  using type = ImmPathJs;
};

struct ImmUniqIdJs : public SharedPtrWrapBase<ImmUniqIdJs, org::imm::ImmUniqId> {
  using SharedPtrWrapBase<ImmUniqIdJs, org::imm::ImmUniqId>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmUniqIdJs", {}); }
};

template <>
struct js_to_org_type<ImmUniqIdJs> {
  using type = org::imm::ImmUniqId;
};

template <>
struct org_to_js_type<org::imm::ImmUniqId> {
  using type = ImmUniqIdJs;
};

struct ImmNoneValueReadJs : public SharedPtrWrapBase<ImmNoneValueReadJs, org::imm::ImmNoneValueRead> {
  using SharedPtrWrapBase<ImmNoneValueReadJs, org::imm::ImmNoneValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmNoneValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmNoneValueReadJs> {
  using type = org::imm::ImmNoneValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmNoneValueRead> {
  using type = ImmNoneValueReadJs;
};

struct ImmErrorItemValueReadJs : public SharedPtrWrapBase<ImmErrorItemValueReadJs, org::imm::ImmErrorItemValueRead> {
  using SharedPtrWrapBase<ImmErrorItemValueReadJs, org::imm::ImmErrorItemValueRead>::SharedPtrWrapBase;
  Napi::Value getMessage(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmErrorItemValueRead::*)() const>(&org::imm::ImmErrorItemValueRead::getMessage),
                                        std::make_tuple()));
  }
  Napi::Value getFunction(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmErrorItemValueRead::*)() const>(&org::imm::ImmErrorItemValueRead::getFunction),
                                        std::make_tuple()));
  }
  Napi::Value getLine(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<int>> const&(org::imm::ImmErrorItemValueRead::*)() const>(&org::imm::ImmErrorItemValueRead::getLine),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmErrorItemValueReadJs", {InstanceMethod("getMessage", &ImmErrorItemValueReadJs::getMessage),
                                                                                                                                  InstanceMethod("getFunction", &ImmErrorItemValueReadJs::getFunction),
                                                                                                                                  InstanceMethod("getLine", &ImmErrorItemValueReadJs::getLine)}); }
};

template <>
struct js_to_org_type<ImmErrorItemValueReadJs> {
  using type = org::imm::ImmErrorItemValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmErrorItemValueRead> {
  using type = ImmErrorItemValueReadJs;
};

struct ImmErrorGroupValueReadJs : public SharedPtrWrapBase<ImmErrorGroupValueReadJs, org::imm::ImmErrorGroupValueRead> {
  using SharedPtrWrapBase<ImmErrorGroupValueReadJs, org::imm::ImmErrorGroupValueRead>::SharedPtrWrapBase;
  Napi::Value getDiagnostics(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmErrorItem>> const&(org::imm::ImmErrorGroupValueRead::*)() const>(&org::imm::ImmErrorGroupValueRead::getDiagnostics),
                                        std::make_tuple()));
  }
  Napi::Value getFunction(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmErrorGroupValueRead::*)() const>(&org::imm::ImmErrorGroupValueRead::getFunction),
                                        std::make_tuple()));
  }
  Napi::Value getLine(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<int>> const&(org::imm::ImmErrorGroupValueRead::*)() const>(&org::imm::ImmErrorGroupValueRead::getLine),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmErrorGroupValueReadJs", {InstanceMethod("getDiagnostics", &ImmErrorGroupValueReadJs::getDiagnostics),
                                                                                                                                   InstanceMethod("getFunction", &ImmErrorGroupValueReadJs::getFunction),
                                                                                                                                   InstanceMethod("getLine", &ImmErrorGroupValueReadJs::getLine)}); }
};

template <>
struct js_to_org_type<ImmErrorGroupValueReadJs> {
  using type = org::imm::ImmErrorGroupValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmErrorGroupValueRead> {
  using type = ImmErrorGroupValueReadJs;
};

struct ImmStmtListValueReadJs : public SharedPtrWrapBase<ImmStmtListValueReadJs, org::imm::ImmStmtListValueRead> {
  using SharedPtrWrapBase<ImmStmtListValueReadJs, org::imm::ImmStmtListValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmStmtListValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmStmtListValueReadJs> {
  using type = org::imm::ImmStmtListValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmStmtListValueRead> {
  using type = ImmStmtListValueReadJs;
};

struct ImmEmptyValueReadJs : public SharedPtrWrapBase<ImmEmptyValueReadJs, org::imm::ImmEmptyValueRead> {
  using SharedPtrWrapBase<ImmEmptyValueReadJs, org::imm::ImmEmptyValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmEmptyValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmEmptyValueReadJs> {
  using type = org::imm::ImmEmptyValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmEmptyValueRead> {
  using type = ImmEmptyValueReadJs;
};

struct ImmCmdCaptionValueReadJs : public SharedPtrWrapBase<ImmCmdCaptionValueReadJs, org::imm::ImmCmdCaptionValueRead> {
  using SharedPtrWrapBase<ImmCmdCaptionValueReadJs, org::imm::ImmCmdCaptionValueRead>::SharedPtrWrapBase;
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmIdT<org::imm::ImmParagraph> const&(org::imm::ImmCmdCaptionValueRead::*)() const>(&org::imm::ImmCmdCaptionValueRead::getText),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdCaptionValueReadJs", {InstanceMethod("getText", &ImmCmdCaptionValueReadJs::getText)}); }
};

template <>
struct js_to_org_type<ImmCmdCaptionValueReadJs> {
  using type = org::imm::ImmCmdCaptionValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmCmdCaptionValueRead> {
  using type = ImmCmdCaptionValueReadJs;
};

struct ImmCmdColumnsValueReadJs : public SharedPtrWrapBase<ImmCmdColumnsValueReadJs, org::imm::ImmCmdColumnsValueRead> {
  using SharedPtrWrapBase<ImmCmdColumnsValueReadJs, org::imm::ImmCmdColumnsValueRead>::SharedPtrWrapBase;
  Napi::Value getView(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::ColumnView const&(org::imm::ImmCmdColumnsValueRead::*)() const>(&org::imm::ImmCmdColumnsValueRead::getView),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdColumnsValueReadJs", {InstanceMethod("getView", &ImmCmdColumnsValueReadJs::getView)}); }
};

template <>
struct js_to_org_type<ImmCmdColumnsValueReadJs> {
  using type = org::imm::ImmCmdColumnsValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmCmdColumnsValueRead> {
  using type = ImmCmdColumnsValueReadJs;
};

struct ImmCmdNameValueReadJs : public SharedPtrWrapBase<ImmCmdNameValueReadJs, org::imm::ImmCmdNameValueRead> {
  using SharedPtrWrapBase<ImmCmdNameValueReadJs, org::imm::ImmCmdNameValueRead>::SharedPtrWrapBase;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdNameValueRead::*)() const>(&org::imm::ImmCmdNameValueRead::getName),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdNameValueReadJs", {InstanceMethod("getName", &ImmCmdNameValueReadJs::getName)}); }
};

template <>
struct js_to_org_type<ImmCmdNameValueReadJs> {
  using type = org::imm::ImmCmdNameValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmCmdNameValueRead> {
  using type = ImmCmdNameValueReadJs;
};

struct ImmCmdCustomArgsValueReadJs : public SharedPtrWrapBase<ImmCmdCustomArgsValueReadJs, org::imm::ImmCmdCustomArgsValueRead> {
  using SharedPtrWrapBase<ImmCmdCustomArgsValueReadJs, org::imm::ImmCmdCustomArgsValueRead>::SharedPtrWrapBase;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdCustomArgsValueRead::*)() const>(&org::imm::ImmCmdCustomArgsValueRead::getName),
                                        std::make_tuple()));
  }
  Napi::Value getIsattached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmCmdCustomArgsValueRead::*)() const>(&org::imm::ImmCmdCustomArgsValueRead::getIsattached),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdCustomArgsValueReadJs", {InstanceMethod("getName", &ImmCmdCustomArgsValueReadJs::getName),
                                                                                                                                      InstanceMethod("getIsattached", &ImmCmdCustomArgsValueReadJs::getIsattached)}); }
};

template <>
struct js_to_org_type<ImmCmdCustomArgsValueReadJs> {
  using type = org::imm::ImmCmdCustomArgsValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmCmdCustomArgsValueRead> {
  using type = ImmCmdCustomArgsValueReadJs;
};

struct ImmCmdCustomRawValueReadJs : public SharedPtrWrapBase<ImmCmdCustomRawValueReadJs, org::imm::ImmCmdCustomRawValueRead> {
  using SharedPtrWrapBase<ImmCmdCustomRawValueReadJs, org::imm::ImmCmdCustomRawValueRead>::SharedPtrWrapBase;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdCustomRawValueRead::*)() const>(&org::imm::ImmCmdCustomRawValueRead::getName),
                                        std::make_tuple()));
  }
  Napi::Value getIsattached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmCmdCustomRawValueRead::*)() const>(&org::imm::ImmCmdCustomRawValueRead::getIsattached),
                                        std::make_tuple()));
  }
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdCustomRawValueRead::*)() const>(&org::imm::ImmCmdCustomRawValueRead::getText),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdCustomRawValueReadJs", {InstanceMethod("getName", &ImmCmdCustomRawValueReadJs::getName),
                                                                                                                                     InstanceMethod("getIsattached", &ImmCmdCustomRawValueReadJs::getIsattached),
                                                                                                                                     InstanceMethod("getText", &ImmCmdCustomRawValueReadJs::getText)}); }
};

template <>
struct js_to_org_type<ImmCmdCustomRawValueReadJs> {
  using type = org::imm::ImmCmdCustomRawValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmCmdCustomRawValueRead> {
  using type = ImmCmdCustomRawValueReadJs;
};

struct ImmCmdCustomTextValueReadJs : public SharedPtrWrapBase<ImmCmdCustomTextValueReadJs, org::imm::ImmCmdCustomTextValueRead> {
  using SharedPtrWrapBase<ImmCmdCustomTextValueReadJs, org::imm::ImmCmdCustomTextValueRead>::SharedPtrWrapBase;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdCustomTextValueRead::*)() const>(&org::imm::ImmCmdCustomTextValueRead::getName),
                                        std::make_tuple()));
  }
  Napi::Value getIsattached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmCmdCustomTextValueRead::*)() const>(&org::imm::ImmCmdCustomTextValueRead::getIsattached),
                                        std::make_tuple()));
  }
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmIdT<org::imm::ImmParagraph> const&(org::imm::ImmCmdCustomTextValueRead::*)() const>(&org::imm::ImmCmdCustomTextValueRead::getText),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdCustomTextValueReadJs", {InstanceMethod("getName", &ImmCmdCustomTextValueReadJs::getName),
                                                                                                                                      InstanceMethod("getIsattached", &ImmCmdCustomTextValueReadJs::getIsattached),
                                                                                                                                      InstanceMethod("getText", &ImmCmdCustomTextValueReadJs::getText)}); }
};

template <>
struct js_to_org_type<ImmCmdCustomTextValueReadJs> {
  using type = org::imm::ImmCmdCustomTextValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmCmdCustomTextValueRead> {
  using type = ImmCmdCustomTextValueReadJs;
};

struct ImmCmdCallValueReadJs : public SharedPtrWrapBase<ImmCmdCallValueReadJs, org::imm::ImmCmdCallValueRead> {
  using SharedPtrWrapBase<ImmCmdCallValueReadJs, org::imm::ImmCmdCallValueRead>::SharedPtrWrapBase;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdCallValueRead::*)() const>(&org::imm::ImmCmdCallValueRead::getName),
                                        std::make_tuple()));
  }
  Napi::Value getFilename(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmCmdCallValueRead::*)() const>(&org::imm::ImmCmdCallValueRead::getFilename),
                                        std::make_tuple()));
  }
  Napi::Value getInsideheaderattrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrGroup const&(org::imm::ImmCmdCallValueRead::*)() const>(&org::imm::ImmCmdCallValueRead::getInsideheaderattrs),
                                        std::make_tuple()));
  }
  Napi::Value getCallattrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrGroup const&(org::imm::ImmCmdCallValueRead::*)() const>(&org::imm::ImmCmdCallValueRead::getCallattrs),
                                        std::make_tuple()));
  }
  Napi::Value getEndheaderattrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrGroup const&(org::imm::ImmCmdCallValueRead::*)() const>(&org::imm::ImmCmdCallValueRead::getEndheaderattrs),
                                        std::make_tuple()));
  }
  Napi::Value getResult(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>> const&(org::imm::ImmCmdCallValueRead::*)() const>(&org::imm::ImmCmdCallValueRead::getResult),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdCallValueReadJs", {InstanceMethod("getName", &ImmCmdCallValueReadJs::getName),
                                                                                                                                InstanceMethod("getFilename", &ImmCmdCallValueReadJs::getFilename),
                                                                                                                                InstanceMethod("getInsideheaderattrs", &ImmCmdCallValueReadJs::getInsideheaderattrs),
                                                                                                                                InstanceMethod("getCallattrs", &ImmCmdCallValueReadJs::getCallattrs),
                                                                                                                                InstanceMethod("getEndheaderattrs", &ImmCmdCallValueReadJs::getEndheaderattrs),
                                                                                                                                InstanceMethod("getResult", &ImmCmdCallValueReadJs::getResult)}); }
};

template <>
struct js_to_org_type<ImmCmdCallValueReadJs> {
  using type = org::imm::ImmCmdCallValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmCmdCallValueRead> {
  using type = ImmCmdCallValueReadJs;
};

struct ImmCmdTblfmValueReadJs : public SharedPtrWrapBase<ImmCmdTblfmValueReadJs, org::imm::ImmCmdTblfmValueRead> {
  using SharedPtrWrapBase<ImmCmdTblfmValueReadJs, org::imm::ImmCmdTblfmValueRead>::SharedPtrWrapBase;
  Napi::Value getExpr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::Tblfm const&(org::imm::ImmCmdTblfmValueRead::*)() const>(&org::imm::ImmCmdTblfmValueRead::getExpr),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdTblfmValueReadJs", {InstanceMethod("getExpr", &ImmCmdTblfmValueReadJs::getExpr)}); }
};

template <>
struct js_to_org_type<ImmCmdTblfmValueReadJs> {
  using type = org::imm::ImmCmdTblfmValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmCmdTblfmValueRead> {
  using type = ImmCmdTblfmValueReadJs;
};

struct ImmHashTagValueReadJs : public SharedPtrWrapBase<ImmHashTagValueReadJs, org::imm::ImmHashTagValueRead> {
  using SharedPtrWrapBase<ImmHashTagValueReadJs, org::imm::ImmHashTagValueRead>::SharedPtrWrapBase;
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::HashTagText const&(org::imm::ImmHashTagValueRead::*)() const>(&org::imm::ImmHashTagValueRead::getText),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmHashTagValueReadJs", {InstanceMethod("getText", &ImmHashTagValueReadJs::getText)}); }
};

template <>
struct js_to_org_type<ImmHashTagValueReadJs> {
  using type = org::imm::ImmHashTagValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmHashTagValueRead> {
  using type = ImmHashTagValueReadJs;
};

struct ImmInlineFootnoteValueReadJs : public SharedPtrWrapBase<ImmInlineFootnoteValueReadJs, org::imm::ImmInlineFootnoteValueRead> {
  using SharedPtrWrapBase<ImmInlineFootnoteValueReadJs, org::imm::ImmInlineFootnoteValueRead>::SharedPtrWrapBase;
  Napi::Value getTag(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmInlineFootnoteValueRead::*)() const>(&org::imm::ImmInlineFootnoteValueRead::getTag),
                                        std::make_tuple()));
  }
  Napi::Value getDefinition(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmOrg>>> const&(org::imm::ImmInlineFootnoteValueRead::*)() const>(&org::imm::ImmInlineFootnoteValueRead::getDefinition),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmInlineFootnoteValueReadJs", {InstanceMethod("getTag", &ImmInlineFootnoteValueReadJs::getTag),
                                                                                                                                       InstanceMethod("getDefinition", &ImmInlineFootnoteValueReadJs::getDefinition)}); }
};

template <>
struct js_to_org_type<ImmInlineFootnoteValueReadJs> {
  using type = org::imm::ImmInlineFootnoteValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmInlineFootnoteValueRead> {
  using type = ImmInlineFootnoteValueReadJs;
};

struct ImmInlineExportValueReadJs : public SharedPtrWrapBase<ImmInlineExportValueReadJs, org::imm::ImmInlineExportValueRead> {
  using SharedPtrWrapBase<ImmInlineExportValueReadJs, org::imm::ImmInlineExportValueRead>::SharedPtrWrapBase;
  Napi::Value getExporter(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmInlineExportValueRead::*)() const>(&org::imm::ImmInlineExportValueRead::getExporter),
                                        std::make_tuple()));
  }
  Napi::Value getContent(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmInlineExportValueRead::*)() const>(&org::imm::ImmInlineExportValueRead::getContent),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmInlineExportValueReadJs", {InstanceMethod("getExporter", &ImmInlineExportValueReadJs::getExporter),
                                                                                                                                     InstanceMethod("getContent", &ImmInlineExportValueReadJs::getContent)}); }
};

template <>
struct js_to_org_type<ImmInlineExportValueReadJs> {
  using type = org::imm::ImmInlineExportValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmInlineExportValueRead> {
  using type = ImmInlineExportValueReadJs;
};

struct ImmTimeValueReadJs : public SharedPtrWrapBase<ImmTimeValueReadJs, org::imm::ImmTimeValueRead> {
  using SharedPtrWrapBase<ImmTimeValueReadJs, org::imm::ImmTimeValueRead>::SharedPtrWrapBase;
  Napi::Value getIsactive(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmTimeValueRead::*)() const>(&org::imm::ImmTimeValueRead::getIsactive),
                                        std::make_tuple()));
  }
  Napi::Value getTime(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmTime::TimeVariant const&(org::imm::ImmTimeValueRead::*)() const>(&org::imm::ImmTimeValueRead::getTime),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmTimeValueReadJs", {InstanceMethod("getIsactive", &ImmTimeValueReadJs::getIsactive),
                                                                                                                             InstanceMethod("getTime", &ImmTimeValueReadJs::getTime)}); }
};

template <>
struct js_to_org_type<ImmTimeValueReadJs> {
  using type = org::imm::ImmTimeValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmTimeValueRead> {
  using type = ImmTimeValueReadJs;
};

struct ImmTimeRangeValueReadJs : public SharedPtrWrapBase<ImmTimeRangeValueReadJs, org::imm::ImmTimeRangeValueRead> {
  using SharedPtrWrapBase<ImmTimeRangeValueReadJs, org::imm::ImmTimeRangeValueRead>::SharedPtrWrapBase;
  Napi::Value getFrom(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmIdT<org::imm::ImmTime> const&(org::imm::ImmTimeRangeValueRead::*)() const>(&org::imm::ImmTimeRangeValueRead::getFrom),
                                        std::make_tuple()));
  }
  Napi::Value getTo(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmIdT<org::imm::ImmTime> const&(org::imm::ImmTimeRangeValueRead::*)() const>(&org::imm::ImmTimeRangeValueRead::getTo),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmTimeRangeValueReadJs", {InstanceMethod("getFrom", &ImmTimeRangeValueReadJs::getFrom),
                                                                                                                                  InstanceMethod("getTo", &ImmTimeRangeValueReadJs::getTo)}); }
};

template <>
struct js_to_org_type<ImmTimeRangeValueReadJs> {
  using type = org::imm::ImmTimeRangeValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmTimeRangeValueRead> {
  using type = ImmTimeRangeValueReadJs;
};

struct ImmMacroValueReadJs : public SharedPtrWrapBase<ImmMacroValueReadJs, org::imm::ImmMacroValueRead> {
  using SharedPtrWrapBase<ImmMacroValueReadJs, org::imm::ImmMacroValueRead>::SharedPtrWrapBase;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmMacroValueRead::*)() const>(&org::imm::ImmMacroValueRead::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrGroup const&(org::imm::ImmMacroValueRead::*)() const>(&org::imm::ImmMacroValueRead::getAttrs),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmMacroValueReadJs", {InstanceMethod("getName", &ImmMacroValueReadJs::getName),
                                                                                                                              InstanceMethod("getAttrs", &ImmMacroValueReadJs::getAttrs)}); }
};

template <>
struct js_to_org_type<ImmMacroValueReadJs> {
  using type = org::imm::ImmMacroValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmMacroValueRead> {
  using type = ImmMacroValueReadJs;
};

struct ImmSymbolValueReadJs : public SharedPtrWrapBase<ImmSymbolValueReadJs, org::imm::ImmSymbolValueRead> {
  using SharedPtrWrapBase<ImmSymbolValueReadJs, org::imm::ImmSymbolValueRead>::SharedPtrWrapBase;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmSymbolValueRead::*)() const>(&org::imm::ImmSymbolValueRead::getName),
                                        std::make_tuple()));
  }
  Napi::Value getParameters(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmSymbol::Param> const&(org::imm::ImmSymbolValueRead::*)() const>(&org::imm::ImmSymbolValueRead::getParameters),
                                        std::make_tuple()));
  }
  Napi::Value getPositional(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmOrg>> const&(org::imm::ImmSymbolValueRead::*)() const>(&org::imm::ImmSymbolValueRead::getPositional),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmSymbolValueReadJs", {InstanceMethod("getName", &ImmSymbolValueReadJs::getName),
                                                                                                                               InstanceMethod("getParameters", &ImmSymbolValueReadJs::getParameters),
                                                                                                                               InstanceMethod("getPositional", &ImmSymbolValueReadJs::getPositional)}); }
};

template <>
struct js_to_org_type<ImmSymbolValueReadJs> {
  using type = org::imm::ImmSymbolValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmSymbolValueRead> {
  using type = ImmSymbolValueReadJs;
};

struct ImmEscapedValueReadJs : public SharedPtrWrapBase<ImmEscapedValueReadJs, org::imm::ImmEscapedValueRead> {
  using SharedPtrWrapBase<ImmEscapedValueReadJs, org::imm::ImmEscapedValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmEscapedValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmEscapedValueReadJs> {
  using type = org::imm::ImmEscapedValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmEscapedValueRead> {
  using type = ImmEscapedValueReadJs;
};

struct ImmNewlineValueReadJs : public SharedPtrWrapBase<ImmNewlineValueReadJs, org::imm::ImmNewlineValueRead> {
  using SharedPtrWrapBase<ImmNewlineValueReadJs, org::imm::ImmNewlineValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmNewlineValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmNewlineValueReadJs> {
  using type = org::imm::ImmNewlineValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmNewlineValueRead> {
  using type = ImmNewlineValueReadJs;
};

struct ImmSpaceValueReadJs : public SharedPtrWrapBase<ImmSpaceValueReadJs, org::imm::ImmSpaceValueRead> {
  using SharedPtrWrapBase<ImmSpaceValueReadJs, org::imm::ImmSpaceValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmSpaceValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmSpaceValueReadJs> {
  using type = org::imm::ImmSpaceValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmSpaceValueRead> {
  using type = ImmSpaceValueReadJs;
};

struct ImmWordValueReadJs : public SharedPtrWrapBase<ImmWordValueReadJs, org::imm::ImmWordValueRead> {
  using SharedPtrWrapBase<ImmWordValueReadJs, org::imm::ImmWordValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmWordValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmWordValueReadJs> {
  using type = org::imm::ImmWordValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmWordValueRead> {
  using type = ImmWordValueReadJs;
};

struct ImmAtMentionValueReadJs : public SharedPtrWrapBase<ImmAtMentionValueReadJs, org::imm::ImmAtMentionValueRead> {
  using SharedPtrWrapBase<ImmAtMentionValueReadJs, org::imm::ImmAtMentionValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmAtMentionValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmAtMentionValueReadJs> {
  using type = org::imm::ImmAtMentionValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmAtMentionValueRead> {
  using type = ImmAtMentionValueReadJs;
};

struct ImmRawTextValueReadJs : public SharedPtrWrapBase<ImmRawTextValueReadJs, org::imm::ImmRawTextValueRead> {
  using SharedPtrWrapBase<ImmRawTextValueReadJs, org::imm::ImmRawTextValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmRawTextValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmRawTextValueReadJs> {
  using type = org::imm::ImmRawTextValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmRawTextValueRead> {
  using type = ImmRawTextValueReadJs;
};

struct ImmPunctuationValueReadJs : public SharedPtrWrapBase<ImmPunctuationValueReadJs, org::imm::ImmPunctuationValueRead> {
  using SharedPtrWrapBase<ImmPunctuationValueReadJs, org::imm::ImmPunctuationValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmPunctuationValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmPunctuationValueReadJs> {
  using type = org::imm::ImmPunctuationValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmPunctuationValueRead> {
  using type = ImmPunctuationValueReadJs;
};

struct ImmPlaceholderValueReadJs : public SharedPtrWrapBase<ImmPlaceholderValueReadJs, org::imm::ImmPlaceholderValueRead> {
  using SharedPtrWrapBase<ImmPlaceholderValueReadJs, org::imm::ImmPlaceholderValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmPlaceholderValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmPlaceholderValueReadJs> {
  using type = org::imm::ImmPlaceholderValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmPlaceholderValueRead> {
  using type = ImmPlaceholderValueReadJs;
};

struct ImmBigIdentValueReadJs : public SharedPtrWrapBase<ImmBigIdentValueReadJs, org::imm::ImmBigIdentValueRead> {
  using SharedPtrWrapBase<ImmBigIdentValueReadJs, org::imm::ImmBigIdentValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBigIdentValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmBigIdentValueReadJs> {
  using type = org::imm::ImmBigIdentValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmBigIdentValueRead> {
  using type = ImmBigIdentValueReadJs;
};

struct ImmTextTargetValueReadJs : public SharedPtrWrapBase<ImmTextTargetValueReadJs, org::imm::ImmTextTargetValueRead> {
  using SharedPtrWrapBase<ImmTextTargetValueReadJs, org::imm::ImmTextTargetValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmTextTargetValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmTextTargetValueReadJs> {
  using type = org::imm::ImmTextTargetValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmTextTargetValueRead> {
  using type = ImmTextTargetValueReadJs;
};

struct ImmBoldValueReadJs : public SharedPtrWrapBase<ImmBoldValueReadJs, org::imm::ImmBoldValueRead> {
  using SharedPtrWrapBase<ImmBoldValueReadJs, org::imm::ImmBoldValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBoldValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmBoldValueReadJs> {
  using type = org::imm::ImmBoldValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmBoldValueRead> {
  using type = ImmBoldValueReadJs;
};

struct ImmUnderlineValueReadJs : public SharedPtrWrapBase<ImmUnderlineValueReadJs, org::imm::ImmUnderlineValueRead> {
  using SharedPtrWrapBase<ImmUnderlineValueReadJs, org::imm::ImmUnderlineValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmUnderlineValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmUnderlineValueReadJs> {
  using type = org::imm::ImmUnderlineValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmUnderlineValueRead> {
  using type = ImmUnderlineValueReadJs;
};

struct ImmMonospaceValueReadJs : public SharedPtrWrapBase<ImmMonospaceValueReadJs, org::imm::ImmMonospaceValueRead> {
  using SharedPtrWrapBase<ImmMonospaceValueReadJs, org::imm::ImmMonospaceValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmMonospaceValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmMonospaceValueReadJs> {
  using type = org::imm::ImmMonospaceValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmMonospaceValueRead> {
  using type = ImmMonospaceValueReadJs;
};

struct ImmMarkQuoteValueReadJs : public SharedPtrWrapBase<ImmMarkQuoteValueReadJs, org::imm::ImmMarkQuoteValueRead> {
  using SharedPtrWrapBase<ImmMarkQuoteValueReadJs, org::imm::ImmMarkQuoteValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmMarkQuoteValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmMarkQuoteValueReadJs> {
  using type = org::imm::ImmMarkQuoteValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmMarkQuoteValueRead> {
  using type = ImmMarkQuoteValueReadJs;
};

struct ImmVerbatimValueReadJs : public SharedPtrWrapBase<ImmVerbatimValueReadJs, org::imm::ImmVerbatimValueRead> {
  using SharedPtrWrapBase<ImmVerbatimValueReadJs, org::imm::ImmVerbatimValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmVerbatimValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmVerbatimValueReadJs> {
  using type = org::imm::ImmVerbatimValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmVerbatimValueRead> {
  using type = ImmVerbatimValueReadJs;
};

struct ImmItalicValueReadJs : public SharedPtrWrapBase<ImmItalicValueReadJs, org::imm::ImmItalicValueRead> {
  using SharedPtrWrapBase<ImmItalicValueReadJs, org::imm::ImmItalicValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmItalicValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmItalicValueReadJs> {
  using type = org::imm::ImmItalicValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmItalicValueRead> {
  using type = ImmItalicValueReadJs;
};

struct ImmStrikeValueReadJs : public SharedPtrWrapBase<ImmStrikeValueReadJs, org::imm::ImmStrikeValueRead> {
  using SharedPtrWrapBase<ImmStrikeValueReadJs, org::imm::ImmStrikeValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmStrikeValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmStrikeValueReadJs> {
  using type = org::imm::ImmStrikeValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmStrikeValueRead> {
  using type = ImmStrikeValueReadJs;
};

struct ImmParValueReadJs : public SharedPtrWrapBase<ImmParValueReadJs, org::imm::ImmParValueRead> {
  using SharedPtrWrapBase<ImmParValueReadJs, org::imm::ImmParValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmParValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmParValueReadJs> {
  using type = org::imm::ImmParValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmParValueRead> {
  using type = ImmParValueReadJs;
};

struct ImmRadioTargetValueReadJs : public SharedPtrWrapBase<ImmRadioTargetValueReadJs, org::imm::ImmRadioTargetValueRead> {
  using SharedPtrWrapBase<ImmRadioTargetValueReadJs, org::imm::ImmRadioTargetValueRead>::SharedPtrWrapBase;
  Napi::Value getWords(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<hstd::Str> const&(org::imm::ImmRadioTargetValueRead::*)() const>(&org::imm::ImmRadioTargetValueRead::getWords),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmRadioTargetValueReadJs", {InstanceMethod("getWords", &ImmRadioTargetValueReadJs::getWords)}); }
};

template <>
struct js_to_org_type<ImmRadioTargetValueReadJs> {
  using type = org::imm::ImmRadioTargetValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmRadioTargetValueRead> {
  using type = ImmRadioTargetValueReadJs;
};

struct ImmLatexValueReadJs : public SharedPtrWrapBase<ImmLatexValueReadJs, org::imm::ImmLatexValueRead> {
  using SharedPtrWrapBase<ImmLatexValueReadJs, org::imm::ImmLatexValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmLatexValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmLatexValueReadJs> {
  using type = org::imm::ImmLatexValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmLatexValueRead> {
  using type = ImmLatexValueReadJs;
};

struct ImmLinkValueReadJs : public SharedPtrWrapBase<ImmLinkValueReadJs, org::imm::ImmLinkValueRead> {
  using SharedPtrWrapBase<ImmLinkValueReadJs, org::imm::ImmLinkValueRead>::SharedPtrWrapBase;
  Napi::Value getDescription(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&(org::imm::ImmLinkValueRead::*)() const>(&org::imm::ImmLinkValueRead::getDescription),
                                        std::make_tuple()));
  }
  Napi::Value getTarget(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::LinkTarget const&(org::imm::ImmLinkValueRead::*)() const>(&org::imm::ImmLinkValueRead::getTarget),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmLinkValueReadJs", {InstanceMethod("getDescription", &ImmLinkValueReadJs::getDescription),
                                                                                                                             InstanceMethod("getTarget", &ImmLinkValueReadJs::getTarget)}); }
};

template <>
struct js_to_org_type<ImmLinkValueReadJs> {
  using type = org::imm::ImmLinkValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmLinkValueRead> {
  using type = ImmLinkValueReadJs;
};

struct ImmBlockCenterValueReadJs : public SharedPtrWrapBase<ImmBlockCenterValueReadJs, org::imm::ImmBlockCenterValueRead> {
  using SharedPtrWrapBase<ImmBlockCenterValueReadJs, org::imm::ImmBlockCenterValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockCenterValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmBlockCenterValueReadJs> {
  using type = org::imm::ImmBlockCenterValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmBlockCenterValueRead> {
  using type = ImmBlockCenterValueReadJs;
};

struct ImmBlockQuoteValueReadJs : public SharedPtrWrapBase<ImmBlockQuoteValueReadJs, org::imm::ImmBlockQuoteValueRead> {
  using SharedPtrWrapBase<ImmBlockQuoteValueReadJs, org::imm::ImmBlockQuoteValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockQuoteValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmBlockQuoteValueReadJs> {
  using type = org::imm::ImmBlockQuoteValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmBlockQuoteValueRead> {
  using type = ImmBlockQuoteValueReadJs;
};

struct ImmBlockCommentValueReadJs : public SharedPtrWrapBase<ImmBlockCommentValueReadJs, org::imm::ImmBlockCommentValueRead> {
  using SharedPtrWrapBase<ImmBlockCommentValueReadJs, org::imm::ImmBlockCommentValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockCommentValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmBlockCommentValueReadJs> {
  using type = org::imm::ImmBlockCommentValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmBlockCommentValueRead> {
  using type = ImmBlockCommentValueReadJs;
};

struct ImmBlockVerseValueReadJs : public SharedPtrWrapBase<ImmBlockVerseValueReadJs, org::imm::ImmBlockVerseValueRead> {
  using SharedPtrWrapBase<ImmBlockVerseValueReadJs, org::imm::ImmBlockVerseValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockVerseValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmBlockVerseValueReadJs> {
  using type = org::imm::ImmBlockVerseValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmBlockVerseValueRead> {
  using type = ImmBlockVerseValueReadJs;
};

struct ImmBlockDynamicFallbackValueReadJs : public SharedPtrWrapBase<ImmBlockDynamicFallbackValueReadJs, org::imm::ImmBlockDynamicFallbackValueRead> {
  using SharedPtrWrapBase<ImmBlockDynamicFallbackValueReadJs, org::imm::ImmBlockDynamicFallbackValueRead>::SharedPtrWrapBase;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmBlockDynamicFallbackValueRead::*)() const>(&org::imm::ImmBlockDynamicFallbackValueRead::getName),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockDynamicFallbackValueReadJs", {InstanceMethod("getName", &ImmBlockDynamicFallbackValueReadJs::getName)}); }
};

template <>
struct js_to_org_type<ImmBlockDynamicFallbackValueReadJs> {
  using type = org::imm::ImmBlockDynamicFallbackValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmBlockDynamicFallbackValueRead> {
  using type = ImmBlockDynamicFallbackValueReadJs;
};

struct ImmBlockExampleValueReadJs : public SharedPtrWrapBase<ImmBlockExampleValueReadJs, org::imm::ImmBlockExampleValueRead> {
  using SharedPtrWrapBase<ImmBlockExampleValueReadJs, org::imm::ImmBlockExampleValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockExampleValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmBlockExampleValueReadJs> {
  using type = org::imm::ImmBlockExampleValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmBlockExampleValueRead> {
  using type = ImmBlockExampleValueReadJs;
};

struct ImmBlockExportValueReadJs : public SharedPtrWrapBase<ImmBlockExportValueReadJs, org::imm::ImmBlockExportValueRead> {
  using SharedPtrWrapBase<ImmBlockExportValueReadJs, org::imm::ImmBlockExportValueRead>::SharedPtrWrapBase;
  Napi::Value getExporter(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmBlockExportValueRead::*)() const>(&org::imm::ImmBlockExportValueRead::getExporter),
                                        std::make_tuple()));
  }
  Napi::Value getContent(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmBlockExportValueRead::*)() const>(&org::imm::ImmBlockExportValueRead::getContent),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockExportValueReadJs", {InstanceMethod("getExporter", &ImmBlockExportValueReadJs::getExporter),
                                                                                                                                    InstanceMethod("getContent", &ImmBlockExportValueReadJs::getContent)}); }
};

template <>
struct js_to_org_type<ImmBlockExportValueReadJs> {
  using type = org::imm::ImmBlockExportValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmBlockExportValueRead> {
  using type = ImmBlockExportValueReadJs;
};

struct ImmBlockAdmonitionValueReadJs : public SharedPtrWrapBase<ImmBlockAdmonitionValueReadJs, org::imm::ImmBlockAdmonitionValueRead> {
  using SharedPtrWrapBase<ImmBlockAdmonitionValueReadJs, org::imm::ImmBlockAdmonitionValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockAdmonitionValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmBlockAdmonitionValueReadJs> {
  using type = org::imm::ImmBlockAdmonitionValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmBlockAdmonitionValueRead> {
  using type = ImmBlockAdmonitionValueReadJs;
};

struct ImmBlockCodeEvalResultValueReadJs : public SharedPtrWrapBase<ImmBlockCodeEvalResultValueReadJs, org::imm::ImmBlockCodeEvalResultValueRead> {
  using SharedPtrWrapBase<ImmBlockCodeEvalResultValueReadJs, org::imm::ImmBlockCodeEvalResultValueRead>::SharedPtrWrapBase;
  Napi::Value getRaw(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::sem::OrgCodeEvalOutput> const&(org::imm::ImmBlockCodeEvalResultValueRead::*)() const>(&org::imm::ImmBlockCodeEvalResultValueRead::getRaw),
                                        std::make_tuple()));
  }
  Napi::Value getNode(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmIdT<org::imm::ImmOrg> const&(org::imm::ImmBlockCodeEvalResultValueRead::*)() const>(&org::imm::ImmBlockCodeEvalResultValueRead::getNode),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockCodeEvalResultValueReadJs", {InstanceMethod("getRaw", &ImmBlockCodeEvalResultValueReadJs::getRaw),
                                                                                                                                            InstanceMethod("getNode", &ImmBlockCodeEvalResultValueReadJs::getNode)}); }
};

template <>
struct js_to_org_type<ImmBlockCodeEvalResultValueReadJs> {
  using type = org::imm::ImmBlockCodeEvalResultValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmBlockCodeEvalResultValueRead> {
  using type = ImmBlockCodeEvalResultValueReadJs;
};

struct ImmBlockCodeValueReadJs : public SharedPtrWrapBase<ImmBlockCodeValueReadJs, org::imm::ImmBlockCodeValueRead> {
  using SharedPtrWrapBase<ImmBlockCodeValueReadJs, org::imm::ImmBlockCodeValueRead>::SharedPtrWrapBase;
  Napi::Value getLang(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmBlockCodeValueRead::*)() const>(&org::imm::ImmBlockCodeValueRead::getLang),
                                        std::make_tuple()));
  }
  Napi::Value getExports(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<BlockCodeExports const&(org::imm::ImmBlockCodeValueRead::*)() const>(&org::imm::ImmBlockCodeValueRead::getExports),
                                        std::make_tuple()));
  }
  Napi::Value getResult(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>> const&(org::imm::ImmBlockCodeValueRead::*)() const>(&org::imm::ImmBlockCodeValueRead::getResult),
                                        std::make_tuple()));
  }
  Napi::Value getLines(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::sem::BlockCodeLine> const&(org::imm::ImmBlockCodeValueRead::*)() const>(&org::imm::ImmBlockCodeValueRead::getLines),
                                        std::make_tuple()));
  }
  Napi::Value getCache(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmBlockCodeValueRead::*)() const>(&org::imm::ImmBlockCodeValueRead::getCache),
                                        std::make_tuple()));
  }
  Napi::Value getEval(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmBlockCodeValueRead::*)() const>(&org::imm::ImmBlockCodeValueRead::getEval),
                                        std::make_tuple()));
  }
  Napi::Value getNoweb(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmBlockCodeValueRead::*)() const>(&org::imm::ImmBlockCodeValueRead::getNoweb),
                                        std::make_tuple()));
  }
  Napi::Value getHlines(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmBlockCodeValueRead::*)() const>(&org::imm::ImmBlockCodeValueRead::getHlines),
                                        std::make_tuple()));
  }
  Napi::Value getTangle(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmBlockCodeValueRead::*)() const>(&org::imm::ImmBlockCodeValueRead::getTangle),
                                        std::make_tuple()));
  }
  Napi::Value getSwitches(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrGroup const&(org::imm::ImmBlockCodeValueRead::*)() const>(&org::imm::ImmBlockCodeValueRead::getSwitches),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockCodeValueReadJs", {InstanceMethod("getLang", &ImmBlockCodeValueReadJs::getLang),
                                                                                                                                  InstanceMethod("getExports", &ImmBlockCodeValueReadJs::getExports),
                                                                                                                                  InstanceMethod("getResult", &ImmBlockCodeValueReadJs::getResult),
                                                                                                                                  InstanceMethod("getLines", &ImmBlockCodeValueReadJs::getLines),
                                                                                                                                  InstanceMethod("getCache", &ImmBlockCodeValueReadJs::getCache),
                                                                                                                                  InstanceMethod("getEval", &ImmBlockCodeValueReadJs::getEval),
                                                                                                                                  InstanceMethod("getNoweb", &ImmBlockCodeValueReadJs::getNoweb),
                                                                                                                                  InstanceMethod("getHlines", &ImmBlockCodeValueReadJs::getHlines),
                                                                                                                                  InstanceMethod("getTangle", &ImmBlockCodeValueReadJs::getTangle),
                                                                                                                                  InstanceMethod("getSwitches", &ImmBlockCodeValueReadJs::getSwitches)}); }
};

template <>
struct js_to_org_type<ImmBlockCodeValueReadJs> {
  using type = org::imm::ImmBlockCodeValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmBlockCodeValueRead> {
  using type = ImmBlockCodeValueReadJs;
};

struct ImmSubtreeLogValueReadJs : public SharedPtrWrapBase<ImmSubtreeLogValueReadJs, org::imm::ImmSubtreeLogValueRead> {
  using SharedPtrWrapBase<ImmSubtreeLogValueReadJs, org::imm::ImmSubtreeLogValueRead>::SharedPtrWrapBase;
  Napi::Value getHead(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SubtreeLogHead const&(org::imm::ImmSubtreeLogValueRead::*)() const>(&org::imm::ImmSubtreeLogValueRead::getHead),
                                        std::make_tuple()));
  }
  Napi::Value getDesc(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmStmtList>>> const&(org::imm::ImmSubtreeLogValueRead::*)() const>(&org::imm::ImmSubtreeLogValueRead::getDesc),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmSubtreeLogValueReadJs", {InstanceMethod("getHead", &ImmSubtreeLogValueReadJs::getHead),
                                                                                                                                   InstanceMethod("getDesc", &ImmSubtreeLogValueReadJs::getDesc)}); }
};

template <>
struct js_to_org_type<ImmSubtreeLogValueReadJs> {
  using type = org::imm::ImmSubtreeLogValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmSubtreeLogValueRead> {
  using type = ImmSubtreeLogValueReadJs;
};

struct ImmSubtreeValueReadJs : public SharedPtrWrapBase<ImmSubtreeValueReadJs, org::imm::ImmSubtreeValueRead> {
  using SharedPtrWrapBase<ImmSubtreeValueReadJs, org::imm::ImmSubtreeValueRead>::SharedPtrWrapBase;
  Napi::Value getLevel(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int const&(org::imm::ImmSubtreeValueRead::*)() const>(&org::imm::ImmSubtreeValueRead::getLevel),
                                        std::make_tuple()));
  }
  Napi::Value getTreeid(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmSubtreeValueRead::*)() const>(&org::imm::ImmSubtreeValueRead::getTreeid),
                                        std::make_tuple()));
  }
  Napi::Value getTodo(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmSubtreeValueRead::*)() const>(&org::imm::ImmSubtreeValueRead::getTodo),
                                        std::make_tuple()));
  }
  Napi::Value getCompletion(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::sem::SubtreeCompletion>> const&(org::imm::ImmSubtreeValueRead::*)() const>(&org::imm::ImmSubtreeValueRead::getCompletion),
                                        std::make_tuple()));
  }
  Napi::Value getDescription(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&(org::imm::ImmSubtreeValueRead::*)() const>(&org::imm::ImmSubtreeValueRead::getDescription),
                                        std::make_tuple()));
  }
  Napi::Value getTags(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmHashTag>> const&(org::imm::ImmSubtreeValueRead::*)() const>(&org::imm::ImmSubtreeValueRead::getTags),
                                        std::make_tuple()));
  }
  Napi::Value getTitle(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmIdT<org::imm::ImmParagraph> const&(org::imm::ImmSubtreeValueRead::*)() const>(&org::imm::ImmSubtreeValueRead::getTitle),
                                        std::make_tuple()));
  }
  Napi::Value getLogbook(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmSubtreeLog>> const&(org::imm::ImmSubtreeValueRead::*)() const>(&org::imm::ImmSubtreeValueRead::getLogbook),
                                        std::make_tuple()));
  }
  Napi::Value getProperties(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::sem::NamedProperty> const&(org::imm::ImmSubtreeValueRead::*)() const>(&org::imm::ImmSubtreeValueRead::getProperties),
                                        std::make_tuple()));
  }
  Napi::Value getClosed(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::UserTime>> const&(org::imm::ImmSubtreeValueRead::*)() const>(&org::imm::ImmSubtreeValueRead::getClosed),
                                        std::make_tuple()));
  }
  Napi::Value getDeadline(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::UserTime>> const&(org::imm::ImmSubtreeValueRead::*)() const>(&org::imm::ImmSubtreeValueRead::getDeadline),
                                        std::make_tuple()));
  }
  Napi::Value getScheduled(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::UserTime>> const&(org::imm::ImmSubtreeValueRead::*)() const>(&org::imm::ImmSubtreeValueRead::getScheduled),
                                        std::make_tuple()));
  }
  Napi::Value getIscomment(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmSubtreeValueRead::*)() const>(&org::imm::ImmSubtreeValueRead::getIscomment),
                                        std::make_tuple()));
  }
  Napi::Value getIsarchived(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmSubtreeValueRead::*)() const>(&org::imm::ImmSubtreeValueRead::getIsarchived),
                                        std::make_tuple()));
  }
  Napi::Value getPriority(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmSubtreeValueRead::*)() const>(&org::imm::ImmSubtreeValueRead::getPriority),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmSubtreeValueReadJs", {InstanceMethod("getLevel", &ImmSubtreeValueReadJs::getLevel),
                                                                                                                                InstanceMethod("getTreeid", &ImmSubtreeValueReadJs::getTreeid),
                                                                                                                                InstanceMethod("getTodo", &ImmSubtreeValueReadJs::getTodo),
                                                                                                                                InstanceMethod("getCompletion", &ImmSubtreeValueReadJs::getCompletion),
                                                                                                                                InstanceMethod("getDescription", &ImmSubtreeValueReadJs::getDescription),
                                                                                                                                InstanceMethod("getTags", &ImmSubtreeValueReadJs::getTags),
                                                                                                                                InstanceMethod("getTitle", &ImmSubtreeValueReadJs::getTitle),
                                                                                                                                InstanceMethod("getLogbook", &ImmSubtreeValueReadJs::getLogbook),
                                                                                                                                InstanceMethod("getProperties", &ImmSubtreeValueReadJs::getProperties),
                                                                                                                                InstanceMethod("getClosed", &ImmSubtreeValueReadJs::getClosed),
                                                                                                                                InstanceMethod("getDeadline", &ImmSubtreeValueReadJs::getDeadline),
                                                                                                                                InstanceMethod("getScheduled", &ImmSubtreeValueReadJs::getScheduled),
                                                                                                                                InstanceMethod("getIscomment", &ImmSubtreeValueReadJs::getIscomment),
                                                                                                                                InstanceMethod("getIsarchived", &ImmSubtreeValueReadJs::getIsarchived),
                                                                                                                                InstanceMethod("getPriority", &ImmSubtreeValueReadJs::getPriority)}); }
};

template <>
struct js_to_org_type<ImmSubtreeValueReadJs> {
  using type = org::imm::ImmSubtreeValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmSubtreeValueRead> {
  using type = ImmSubtreeValueReadJs;
};

struct ImmCellValueReadJs : public SharedPtrWrapBase<ImmCellValueReadJs, org::imm::ImmCellValueRead> {
  using SharedPtrWrapBase<ImmCellValueReadJs, org::imm::ImmCellValueRead>::SharedPtrWrapBase;
  Napi::Value getIsblock(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmCellValueRead::*)() const>(&org::imm::ImmCellValueRead::getIsblock),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCellValueReadJs", {InstanceMethod("getIsblock", &ImmCellValueReadJs::getIsblock)}); }
};

template <>
struct js_to_org_type<ImmCellValueReadJs> {
  using type = org::imm::ImmCellValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmCellValueRead> {
  using type = ImmCellValueReadJs;
};

struct ImmRowValueReadJs : public SharedPtrWrapBase<ImmRowValueReadJs, org::imm::ImmRowValueRead> {
  using SharedPtrWrapBase<ImmRowValueReadJs, org::imm::ImmRowValueRead>::SharedPtrWrapBase;
  Napi::Value getCells(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmCell>> const&(org::imm::ImmRowValueRead::*)() const>(&org::imm::ImmRowValueRead::getCells),
                                        std::make_tuple()));
  }
  Napi::Value getIsblock(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmRowValueRead::*)() const>(&org::imm::ImmRowValueRead::getIsblock),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmRowValueReadJs", {InstanceMethod("getCells", &ImmRowValueReadJs::getCells),
                                                                                                                            InstanceMethod("getIsblock", &ImmRowValueReadJs::getIsblock)}); }
};

template <>
struct js_to_org_type<ImmRowValueReadJs> {
  using type = org::imm::ImmRowValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmRowValueRead> {
  using type = ImmRowValueReadJs;
};

struct ImmTableValueReadJs : public SharedPtrWrapBase<ImmTableValueReadJs, org::imm::ImmTableValueRead> {
  using SharedPtrWrapBase<ImmTableValueReadJs, org::imm::ImmTableValueRead>::SharedPtrWrapBase;
  Napi::Value getRows(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmRow>> const&(org::imm::ImmTableValueRead::*)() const>(&org::imm::ImmTableValueRead::getRows),
                                        std::make_tuple()));
  }
  Napi::Value getIsblock(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmTableValueRead::*)() const>(&org::imm::ImmTableValueRead::getIsblock),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmTableValueReadJs", {InstanceMethod("getRows", &ImmTableValueReadJs::getRows),
                                                                                                                              InstanceMethod("getIsblock", &ImmTableValueReadJs::getIsblock)}); }
};

template <>
struct js_to_org_type<ImmTableValueReadJs> {
  using type = org::imm::ImmTableValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmTableValueRead> {
  using type = ImmTableValueReadJs;
};

struct ImmParagraphValueReadJs : public SharedPtrWrapBase<ImmParagraphValueReadJs, org::imm::ImmParagraphValueRead> {
  using SharedPtrWrapBase<ImmParagraphValueReadJs, org::imm::ImmParagraphValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmParagraphValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmParagraphValueReadJs> {
  using type = org::imm::ImmParagraphValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmParagraphValueRead> {
  using type = ImmParagraphValueReadJs;
};

struct ImmColonExampleValueReadJs : public SharedPtrWrapBase<ImmColonExampleValueReadJs, org::imm::ImmColonExampleValueRead> {
  using SharedPtrWrapBase<ImmColonExampleValueReadJs, org::imm::ImmColonExampleValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmColonExampleValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmColonExampleValueReadJs> {
  using type = org::imm::ImmColonExampleValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmColonExampleValueRead> {
  using type = ImmColonExampleValueReadJs;
};

struct ImmCmdAttrValueReadJs : public SharedPtrWrapBase<ImmCmdAttrValueReadJs, org::imm::ImmCmdAttrValueRead> {
  using SharedPtrWrapBase<ImmCmdAttrValueReadJs, org::imm::ImmCmdAttrValueRead>::SharedPtrWrapBase;
  Napi::Value getTarget(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdAttrValueRead::*)() const>(&org::imm::ImmCmdAttrValueRead::getTarget),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdAttrValueReadJs", {InstanceMethod("getTarget", &ImmCmdAttrValueReadJs::getTarget)}); }
};

template <>
struct js_to_org_type<ImmCmdAttrValueReadJs> {
  using type = org::imm::ImmCmdAttrValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmCmdAttrValueRead> {
  using type = ImmCmdAttrValueReadJs;
};

struct ImmCmdExportValueReadJs : public SharedPtrWrapBase<ImmCmdExportValueReadJs, org::imm::ImmCmdExportValueRead> {
  using SharedPtrWrapBase<ImmCmdExportValueReadJs, org::imm::ImmCmdExportValueRead>::SharedPtrWrapBase;
  Napi::Value getExporter(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdExportValueRead::*)() const>(&org::imm::ImmCmdExportValueRead::getExporter),
                                        std::make_tuple()));
  }
  Napi::Value getContent(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdExportValueRead::*)() const>(&org::imm::ImmCmdExportValueRead::getContent),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdExportValueReadJs", {InstanceMethod("getExporter", &ImmCmdExportValueReadJs::getExporter),
                                                                                                                                  InstanceMethod("getContent", &ImmCmdExportValueReadJs::getContent)}); }
};

template <>
struct js_to_org_type<ImmCmdExportValueReadJs> {
  using type = org::imm::ImmCmdExportValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmCmdExportValueRead> {
  using type = ImmCmdExportValueReadJs;
};

struct ImmCallValueReadJs : public SharedPtrWrapBase<ImmCallValueReadJs, org::imm::ImmCallValueRead> {
  using SharedPtrWrapBase<ImmCallValueReadJs, org::imm::ImmCallValueRead>::SharedPtrWrapBase;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCallValueRead::*)() const>(&org::imm::ImmCallValueRead::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrGroup const&(org::imm::ImmCallValueRead::*)() const>(&org::imm::ImmCallValueRead::getAttrs),
                                        std::make_tuple()));
  }
  Napi::Value getIscommand(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmCallValueRead::*)() const>(&org::imm::ImmCallValueRead::getIscommand),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCallValueReadJs", {InstanceMethod("getName", &ImmCallValueReadJs::getName),
                                                                                                                             InstanceMethod("getAttrs", &ImmCallValueReadJs::getAttrs),
                                                                                                                             InstanceMethod("getIscommand", &ImmCallValueReadJs::getIscommand)}); }
};

template <>
struct js_to_org_type<ImmCallValueReadJs> {
  using type = org::imm::ImmCallValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmCallValueRead> {
  using type = ImmCallValueReadJs;
};

struct ImmListValueReadJs : public SharedPtrWrapBase<ImmListValueReadJs, org::imm::ImmListValueRead> {
  using SharedPtrWrapBase<ImmListValueReadJs, org::imm::ImmListValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmListValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmListValueReadJs> {
  using type = org::imm::ImmListValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmListValueRead> {
  using type = ImmListValueReadJs;
};

struct ImmListItemValueReadJs : public SharedPtrWrapBase<ImmListItemValueReadJs, org::imm::ImmListItemValueRead> {
  using SharedPtrWrapBase<ImmListItemValueReadJs, org::imm::ImmListItemValueRead>::SharedPtrWrapBase;
  Napi::Value getCheckbox(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmListItem::Checkbox const&(org::imm::ImmListItemValueRead::*)() const>(&org::imm::ImmListItemValueRead::getCheckbox),
                                        std::make_tuple()));
  }
  Napi::Value getHeader(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&(org::imm::ImmListItemValueRead::*)() const>(&org::imm::ImmListItemValueRead::getHeader),
                                        std::make_tuple()));
  }
  Napi::Value getBullet(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmListItemValueRead::*)() const>(&org::imm::ImmListItemValueRead::getBullet),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmListItemValueReadJs", {InstanceMethod("getCheckbox", &ImmListItemValueReadJs::getCheckbox),
                                                                                                                                 InstanceMethod("getHeader", &ImmListItemValueReadJs::getHeader),
                                                                                                                                 InstanceMethod("getBullet", &ImmListItemValueReadJs::getBullet)}); }
};

template <>
struct js_to_org_type<ImmListItemValueReadJs> {
  using type = org::imm::ImmListItemValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmListItemValueRead> {
  using type = ImmListItemValueReadJs;
};

struct ImmDocumentOptionsValueReadJs : public SharedPtrWrapBase<ImmDocumentOptionsValueReadJs, org::imm::ImmDocumentOptionsValueRead> {
  using SharedPtrWrapBase<ImmDocumentOptionsValueReadJs, org::imm::ImmDocumentOptionsValueRead>::SharedPtrWrapBase;
  Napi::Value getInitialvisibility(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<InitialSubtreeVisibility const&(org::imm::ImmDocumentOptionsValueRead::*)() const>(&org::imm::ImmDocumentOptionsValueRead::getInitialvisibility),
                                        std::make_tuple()));
  }
  Napi::Value getProperties(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::sem::NamedProperty> const&(org::imm::ImmDocumentOptionsValueRead::*)() const>(&org::imm::ImmDocumentOptionsValueRead::getProperties),
                                        std::make_tuple()));
  }
  Napi::Value getExportconfig(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::DocumentExportConfig const&(org::imm::ImmDocumentOptionsValueRead::*)() const>(&org::imm::ImmDocumentOptionsValueRead::getExportconfig),
                                        std::make_tuple()));
  }
  Napi::Value getFixedwidthsections(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<bool>> const&(org::imm::ImmDocumentOptionsValueRead::*)() const>(&org::imm::ImmDocumentOptionsValueRead::getFixedwidthsections),
                                        std::make_tuple()));
  }
  Napi::Value getStartupindented(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<bool>> const&(org::imm::ImmDocumentOptionsValueRead::*)() const>(&org::imm::ImmDocumentOptionsValueRead::getStartupindented),
                                        std::make_tuple()));
  }
  Napi::Value getCategory(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmDocumentOptionsValueRead::*)() const>(&org::imm::ImmDocumentOptionsValueRead::getCategory),
                                        std::make_tuple()));
  }
  Napi::Value getSetupfile(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmDocumentOptionsValueRead::*)() const>(&org::imm::ImmDocumentOptionsValueRead::getSetupfile),
                                        std::make_tuple()));
  }
  Napi::Value getMaxsubtreelevelexport(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<int>> const&(org::imm::ImmDocumentOptionsValueRead::*)() const>(&org::imm::ImmDocumentOptionsValueRead::getMaxsubtreelevelexport),
                                        std::make_tuple()));
  }
  Napi::Value getColumns(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::sem::ColumnView>> const&(org::imm::ImmDocumentOptionsValueRead::*)() const>(&org::imm::ImmDocumentOptionsValueRead::getColumns),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmDocumentOptionsValueReadJs", {InstanceMethod("getInitialvisibility", &ImmDocumentOptionsValueReadJs::getInitialvisibility),
                                                                                                                                        InstanceMethod("getProperties", &ImmDocumentOptionsValueReadJs::getProperties),
                                                                                                                                        InstanceMethod("getExportconfig", &ImmDocumentOptionsValueReadJs::getExportconfig),
                                                                                                                                        InstanceMethod("getFixedwidthsections", &ImmDocumentOptionsValueReadJs::getFixedwidthsections),
                                                                                                                                        InstanceMethod("getStartupindented", &ImmDocumentOptionsValueReadJs::getStartupindented),
                                                                                                                                        InstanceMethod("getCategory", &ImmDocumentOptionsValueReadJs::getCategory),
                                                                                                                                        InstanceMethod("getSetupfile", &ImmDocumentOptionsValueReadJs::getSetupfile),
                                                                                                                                        InstanceMethod("getMaxsubtreelevelexport", &ImmDocumentOptionsValueReadJs::getMaxsubtreelevelexport),
                                                                                                                                        InstanceMethod("getColumns", &ImmDocumentOptionsValueReadJs::getColumns)}); }
};

template <>
struct js_to_org_type<ImmDocumentOptionsValueReadJs> {
  using type = org::imm::ImmDocumentOptionsValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmDocumentOptionsValueRead> {
  using type = ImmDocumentOptionsValueReadJs;
};

struct ImmDocumentFragmentValueReadJs : public SharedPtrWrapBase<ImmDocumentFragmentValueReadJs, org::imm::ImmDocumentFragmentValueRead> {
  using SharedPtrWrapBase<ImmDocumentFragmentValueReadJs, org::imm::ImmDocumentFragmentValueRead>::SharedPtrWrapBase;
  Napi::Value getBaseline(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int const&(org::imm::ImmDocumentFragmentValueRead::*)() const>(&org::imm::ImmDocumentFragmentValueRead::getBaseline),
                                        std::make_tuple()));
  }
  Napi::Value getBasecol(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int const&(org::imm::ImmDocumentFragmentValueRead::*)() const>(&org::imm::ImmDocumentFragmentValueRead::getBasecol),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmDocumentFragmentValueReadJs", {InstanceMethod("getBaseline", &ImmDocumentFragmentValueReadJs::getBaseline),
                                                                                                                                         InstanceMethod("getBasecol", &ImmDocumentFragmentValueReadJs::getBasecol)}); }
};

template <>
struct js_to_org_type<ImmDocumentFragmentValueReadJs> {
  using type = org::imm::ImmDocumentFragmentValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmDocumentFragmentValueRead> {
  using type = ImmDocumentFragmentValueReadJs;
};

struct ImmCriticMarkupValueReadJs : public SharedPtrWrapBase<ImmCriticMarkupValueReadJs, org::imm::ImmCriticMarkupValueRead> {
  using SharedPtrWrapBase<ImmCriticMarkupValueReadJs, org::imm::ImmCriticMarkupValueRead>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCriticMarkup::Kind const&(org::imm::ImmCriticMarkupValueRead::*)() const>(&org::imm::ImmCriticMarkupValueRead::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCriticMarkupValueReadJs", {InstanceMethod("getKind", &ImmCriticMarkupValueReadJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmCriticMarkupValueReadJs> {
  using type = org::imm::ImmCriticMarkupValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmCriticMarkupValueRead> {
  using type = ImmCriticMarkupValueReadJs;
};

struct ImmDocumentValueReadJs : public SharedPtrWrapBase<ImmDocumentValueReadJs, org::imm::ImmDocumentValueRead> {
  using SharedPtrWrapBase<ImmDocumentValueReadJs, org::imm::ImmDocumentValueRead>::SharedPtrWrapBase;
  Napi::Value getTitle(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&(org::imm::ImmDocumentValueRead::*)() const>(&org::imm::ImmDocumentValueRead::getTitle),
                                        std::make_tuple()));
  }
  Napi::Value getAuthor(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&(org::imm::ImmDocumentValueRead::*)() const>(&org::imm::ImmDocumentValueRead::getAuthor),
                                        std::make_tuple()));
  }
  Napi::Value getCreator(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&(org::imm::ImmDocumentValueRead::*)() const>(&org::imm::ImmDocumentValueRead::getCreator),
                                        std::make_tuple()));
  }
  Napi::Value getFiletags(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmHashTag>> const&(org::imm::ImmDocumentValueRead::*)() const>(&org::imm::ImmDocumentValueRead::getFiletags),
                                        std::make_tuple()));
  }
  Napi::Value getEmail(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmRawText>>> const&(org::imm::ImmDocumentValueRead::*)() const>(&org::imm::ImmDocumentValueRead::getEmail),
                                        std::make_tuple()));
  }
  Napi::Value getLanguage(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<hstd::Str> const&(org::imm::ImmDocumentValueRead::*)() const>(&org::imm::ImmDocumentValueRead::getLanguage),
                                        std::make_tuple()));
  }
  Napi::Value getOptions(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmIdT<org::imm::ImmDocumentOptions> const&(org::imm::ImmDocumentValueRead::*)() const>(&org::imm::ImmDocumentValueRead::getOptions),
                                        std::make_tuple()));
  }
  Napi::Value getExportfilename(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmDocumentValueRead::*)() const>(&org::imm::ImmDocumentValueRead::getExportfilename),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmDocumentValueReadJs", {InstanceMethod("getTitle", &ImmDocumentValueReadJs::getTitle),
                                                                                                                                 InstanceMethod("getAuthor", &ImmDocumentValueReadJs::getAuthor),
                                                                                                                                 InstanceMethod("getCreator", &ImmDocumentValueReadJs::getCreator),
                                                                                                                                 InstanceMethod("getFiletags", &ImmDocumentValueReadJs::getFiletags),
                                                                                                                                 InstanceMethod("getEmail", &ImmDocumentValueReadJs::getEmail),
                                                                                                                                 InstanceMethod("getLanguage", &ImmDocumentValueReadJs::getLanguage),
                                                                                                                                 InstanceMethod("getOptions", &ImmDocumentValueReadJs::getOptions),
                                                                                                                                 InstanceMethod("getExportfilename", &ImmDocumentValueReadJs::getExportfilename)}); }
};

template <>
struct js_to_org_type<ImmDocumentValueReadJs> {
  using type = org::imm::ImmDocumentValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmDocumentValueRead> {
  using type = ImmDocumentValueReadJs;
};

struct ImmFileTargetValueReadJs : public SharedPtrWrapBase<ImmFileTargetValueReadJs, org::imm::ImmFileTargetValueRead> {
  using SharedPtrWrapBase<ImmFileTargetValueReadJs, org::imm::ImmFileTargetValueRead>::SharedPtrWrapBase;
  Napi::Value getPath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmFileTargetValueRead::*)() const>(&org::imm::ImmFileTargetValueRead::getPath),
                                        std::make_tuple()));
  }
  Napi::Value getLine(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<int>> const&(org::imm::ImmFileTargetValueRead::*)() const>(&org::imm::ImmFileTargetValueRead::getLine),
                                        std::make_tuple()));
  }
  Napi::Value getSearchtarget(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmFileTargetValueRead::*)() const>(&org::imm::ImmFileTargetValueRead::getSearchtarget),
                                        std::make_tuple()));
  }
  Napi::Value getRestricttoheadlines(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmFileTargetValueRead::*)() const>(&org::imm::ImmFileTargetValueRead::getRestricttoheadlines),
                                        std::make_tuple()));
  }
  Napi::Value getTargetid(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmFileTargetValueRead::*)() const>(&org::imm::ImmFileTargetValueRead::getTargetid),
                                        std::make_tuple()));
  }
  Napi::Value getRegexp(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmFileTargetValueRead::*)() const>(&org::imm::ImmFileTargetValueRead::getRegexp),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmFileTargetValueReadJs", {InstanceMethod("getPath", &ImmFileTargetValueReadJs::getPath),
                                                                                                                                   InstanceMethod("getLine", &ImmFileTargetValueReadJs::getLine),
                                                                                                                                   InstanceMethod("getSearchtarget", &ImmFileTargetValueReadJs::getSearchtarget),
                                                                                                                                   InstanceMethod("getRestricttoheadlines", &ImmFileTargetValueReadJs::getRestricttoheadlines),
                                                                                                                                   InstanceMethod("getTargetid", &ImmFileTargetValueReadJs::getTargetid),
                                                                                                                                   InstanceMethod("getRegexp", &ImmFileTargetValueReadJs::getRegexp)}); }
};

template <>
struct js_to_org_type<ImmFileTargetValueReadJs> {
  using type = org::imm::ImmFileTargetValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmFileTargetValueRead> {
  using type = ImmFileTargetValueReadJs;
};

struct ImmTextSeparatorValueReadJs : public SharedPtrWrapBase<ImmTextSeparatorValueReadJs, org::imm::ImmTextSeparatorValueRead> {
  using SharedPtrWrapBase<ImmTextSeparatorValueReadJs, org::imm::ImmTextSeparatorValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmTextSeparatorValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmTextSeparatorValueReadJs> {
  using type = org::imm::ImmTextSeparatorValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmTextSeparatorValueRead> {
  using type = ImmTextSeparatorValueReadJs;
};

struct ImmDocumentGroupValueReadJs : public SharedPtrWrapBase<ImmDocumentGroupValueReadJs, org::imm::ImmDocumentGroupValueRead> {
  using SharedPtrWrapBase<ImmDocumentGroupValueReadJs, org::imm::ImmDocumentGroupValueRead>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmDocumentGroupValueReadJs", {}); }
};

template <>
struct js_to_org_type<ImmDocumentGroupValueReadJs> {
  using type = org::imm::ImmDocumentGroupValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmDocumentGroupValueRead> {
  using type = ImmDocumentGroupValueReadJs;
};

struct ImmFileValueReadJs : public SharedPtrWrapBase<ImmFileValueReadJs, org::imm::ImmFileValueRead> {
  using SharedPtrWrapBase<ImmFileValueReadJs, org::imm::ImmFileValueRead>::SharedPtrWrapBase;
  Napi::Value getRelpath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmFileValueRead::*)() const>(&org::imm::ImmFileValueRead::getRelpath),
                                        std::make_tuple()));
  }
  Napi::Value getAbspath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmFileValueRead::*)() const>(&org::imm::ImmFileValueRead::getAbspath),
                                        std::make_tuple()));
  }
  Napi::Value getData(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmFile::Data const&(org::imm::ImmFileValueRead::*)() const>(&org::imm::ImmFileValueRead::getData),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmFileValueReadJs", {InstanceMethod("getRelpath", &ImmFileValueReadJs::getRelpath),
                                                                                                                             InstanceMethod("getAbspath", &ImmFileValueReadJs::getAbspath),
                                                                                                                             InstanceMethod("getData", &ImmFileValueReadJs::getData)}); }
};

template <>
struct js_to_org_type<ImmFileValueReadJs> {
  using type = org::imm::ImmFileValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmFileValueRead> {
  using type = ImmFileValueReadJs;
};

struct ImmDirectoryValueReadJs : public SharedPtrWrapBase<ImmDirectoryValueReadJs, org::imm::ImmDirectoryValueRead> {
  using SharedPtrWrapBase<ImmDirectoryValueReadJs, org::imm::ImmDirectoryValueRead>::SharedPtrWrapBase;
  Napi::Value getRelpath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmDirectoryValueRead::*)() const>(&org::imm::ImmDirectoryValueRead::getRelpath),
                                        std::make_tuple()));
  }
  Napi::Value getAbspath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmDirectoryValueRead::*)() const>(&org::imm::ImmDirectoryValueRead::getAbspath),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmDirectoryValueReadJs", {InstanceMethod("getRelpath", &ImmDirectoryValueReadJs::getRelpath),
                                                                                                                                  InstanceMethod("getAbspath", &ImmDirectoryValueReadJs::getAbspath)}); }
};

template <>
struct js_to_org_type<ImmDirectoryValueReadJs> {
  using type = org::imm::ImmDirectoryValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmDirectoryValueRead> {
  using type = ImmDirectoryValueReadJs;
};

struct ImmSymlinkValueReadJs : public SharedPtrWrapBase<ImmSymlinkValueReadJs, org::imm::ImmSymlinkValueRead> {
  using SharedPtrWrapBase<ImmSymlinkValueReadJs, org::imm::ImmSymlinkValueRead>::SharedPtrWrapBase;
  Napi::Value getIsdirectory(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmSymlinkValueRead::*)() const>(&org::imm::ImmSymlinkValueRead::getIsdirectory),
                                        std::make_tuple()));
  }
  Napi::Value getAbspath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmSymlinkValueRead::*)() const>(&org::imm::ImmSymlinkValueRead::getAbspath),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmSymlinkValueReadJs", {InstanceMethod("getIsdirectory", &ImmSymlinkValueReadJs::getIsdirectory),
                                                                                                                                InstanceMethod("getAbspath", &ImmSymlinkValueReadJs::getAbspath)}); }
};

template <>
struct js_to_org_type<ImmSymlinkValueReadJs> {
  using type = org::imm::ImmSymlinkValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmSymlinkValueRead> {
  using type = ImmSymlinkValueReadJs;
};

struct ImmCmdIncludeValueReadJs : public SharedPtrWrapBase<ImmCmdIncludeValueReadJs, org::imm::ImmCmdIncludeValueRead> {
  using SharedPtrWrapBase<ImmCmdIncludeValueReadJs, org::imm::ImmCmdIncludeValueRead>::SharedPtrWrapBase;
  Napi::Value getPath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdIncludeValueRead::*)() const>(&org::imm::ImmCmdIncludeValueRead::getPath),
                                        std::make_tuple()));
  }
  Napi::Value getFirstline(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<int>> const&(org::imm::ImmCmdIncludeValueRead::*)() const>(&org::imm::ImmCmdIncludeValueRead::getFirstline),
                                        std::make_tuple()));
  }
  Napi::Value getLastline(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<int>> const&(org::imm::ImmCmdIncludeValueRead::*)() const>(&org::imm::ImmCmdIncludeValueRead::getLastline),
                                        std::make_tuple()));
  }
  Napi::Value getData(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCmdInclude::Data const&(org::imm::ImmCmdIncludeValueRead::*)() const>(&org::imm::ImmCmdIncludeValueRead::getData),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdIncludeValueReadJs", {InstanceMethod("getPath", &ImmCmdIncludeValueReadJs::getPath),
                                                                                                                                   InstanceMethod("getFirstline", &ImmCmdIncludeValueReadJs::getFirstline),
                                                                                                                                   InstanceMethod("getLastline", &ImmCmdIncludeValueReadJs::getLastline),
                                                                                                                                   InstanceMethod("getData", &ImmCmdIncludeValueReadJs::getData)}); }
};

template <>
struct js_to_org_type<ImmCmdIncludeValueReadJs> {
  using type = org::imm::ImmCmdIncludeValueRead;
};

template <>
struct org_to_js_type<org::imm::ImmCmdIncludeValueRead> {
  using type = ImmCmdIncludeValueReadJs;
};

struct ImmAstContextJs : public SharedPtrWrapBase<ImmAstContextJs, org::imm::ImmAstContext> {
  using SharedPtrWrapBase<ImmAstContextJs, org::imm::ImmAstContext>::SharedPtrWrapBase;
  Napi::Value addRoot(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::imm::ImmAstVersion(org::imm::ImmAstContext::*)(org::sem::SemId<org::sem::Org>)>(&org::imm::ImmAstContext::addRoot),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"data"})));
  }
  Napi::Value get(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::imm::ImmAstContext::*)(org::imm::ImmId)>(&org::imm::ImmAstContext::get),
                                   std::make_tuple(CxxArgSpec<org::imm::ImmId>{"id"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmAstContextJs", {InstanceMethod("addRoot", &ImmAstContextJs::addRoot),
                                                                                                                          InstanceMethod("get", &ImmAstContextJs::get)}); }
};

template <>
struct js_to_org_type<ImmAstContextJs> {
  using type = org::imm::ImmAstContext;
};

template <>
struct org_to_js_type<org::imm::ImmAstContext> {
  using type = ImmAstContextJs;
};

struct ImmAstVersionJs : public SharedPtrWrapBase<ImmAstVersionJs, org::imm::ImmAstVersion> {
  using SharedPtrWrapBase<ImmAstVersionJs, org::imm::ImmAstVersion>::SharedPtrWrapBase;
  Napi::Value getRoot(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId(org::imm::ImmAstVersion::*)() const>(&org::imm::ImmAstVersion::getRoot),
                                        std::make_tuple()));
  }
  Napi::Value getRootAdapter(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmAdapter(org::imm::ImmAstVersion::*)() const>(&org::imm::ImmAstVersion::getRootAdapter),
                                        std::make_tuple()));
  }
  Napi::Value getContext(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::shared_ptr<org::imm::ImmAstContext>(org::imm::ImmAstVersion::*)() const>(&org::imm::ImmAstVersion::getContext),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmAstVersionJs", {InstanceMethod("getRoot", &ImmAstVersionJs::getRoot),
                                                                                                                          InstanceMethod("getRootAdapter", &ImmAstVersionJs::getRootAdapter),
                                                                                                                          InstanceMethod("getContext", &ImmAstVersionJs::getContext)}); }
};

template <>
struct js_to_org_type<ImmAstVersionJs> {
  using type = org::imm::ImmAstVersion;
};

template <>
struct org_to_js_type<org::imm::ImmAstVersion> {
  using type = ImmAstVersionJs;
};

struct ImmAdapterJs : public SharedPtrWrapBase<ImmAdapterJs, org::imm::ImmAdapter> {
  using SharedPtrWrapBase<ImmAdapterJs, org::imm::ImmAdapter>::SharedPtrWrapBase;
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::imm::ImmAdapter::*)() const>(&org::imm::ImmAdapter::size),
                                        std::make_tuple()));
  }
  Napi::Value isNil(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmAdapter::*)() const>(&org::imm::ImmAdapter::isNil),
                                        std::make_tuple()));
  }
  Napi::Value isRoot(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmAdapter::*)() const>(&org::imm::ImmAdapter::isRoot),
                                        std::make_tuple()));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmAdapter::*)() const>(&org::imm::ImmAdapter::getKind),
                                        std::make_tuple()));
  }
  Napi::Value uniq(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmUniqId(org::imm::ImmAdapter::*)() const>(&org::imm::ImmAdapter::uniq),
                                        std::make_tuple()));
  }
  Napi::Value treeReprString(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmAdapter::*)() const>(&org::imm::ImmAdapter::treeReprString),
                                        std::make_tuple()));
  }
  Napi::Value treeReprStringOpts(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmAdapter::*)(org::imm::ImmAdapter::TreeReprConf const&) const>(&org::imm::ImmAdapter::treeReprStringOpts),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmAdapter::TreeReprConf>{"conf"})));
  }
  Napi::Value isDirectParentOf(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmAdapter::*)(org::imm::ImmAdapter const&) const>(&org::imm::ImmAdapter::isDirectParentOf),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmAdapter>{"other"})));
  }
  Napi::Value isIndirectParentOf(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmAdapter::*)(org::imm::ImmAdapter const&) const>(&org::imm::ImmAdapter::isIndirectParentOf),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmAdapter>{"other"})));
  }
  Napi::Value isSubnodeOf(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmAdapter::*)(org::imm::ImmAdapter const&) const>(&org::imm::ImmAdapter::isSubnodeOf),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmAdapter>{"other"})));
  }
  Napi::Value getParent(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::optional<org::imm::ImmAdapter>(org::imm::ImmAdapter::*)() const>(&org::imm::ImmAdapter::getParent),
                                        std::make_tuple()));
  }
  Napi::Value getSelfIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::imm::ImmAdapter::*)() const>(&org::imm::ImmAdapter::getSelfIndex),
                                        std::make_tuple()));
  }
  Napi::Value atPath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmAdapter(org::imm::ImmAdapter::*)(hstd::Vec<int> const&, bool) const>(&org::imm::ImmAdapter::at),
                                        std::make_tuple(CxxArgSpec<hstd::Vec<int>>{"path"},
                                                        CxxArgSpec<bool>{"withPath", 1})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmAdapter::*)(OrgSemKind) const>(&org::imm::ImmAdapter::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value sub(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::imm::ImmAdapter>(org::imm::ImmAdapter::*)(bool) const>(&org::imm::ImmAdapter::sub),
                                        std::make_tuple(CxxArgSpec<bool>{"withPath", 1})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmAdapterJs", {InstanceMethod("size", &ImmAdapterJs::size),
                                                                                                                       InstanceMethod("isNil", &ImmAdapterJs::isNil),
                                                                                                                       InstanceMethod("isRoot", &ImmAdapterJs::isRoot),
                                                                                                                       InstanceMethod("getKind", &ImmAdapterJs::getKind),
                                                                                                                       InstanceMethod("uniq", &ImmAdapterJs::uniq),
                                                                                                                       InstanceMethod("treeReprString", &ImmAdapterJs::treeReprString),
                                                                                                                       InstanceMethod("treeReprStringOpts", &ImmAdapterJs::treeReprStringOpts),
                                                                                                                       InstanceMethod("isDirectParentOf", &ImmAdapterJs::isDirectParentOf),
                                                                                                                       InstanceMethod("isIndirectParentOf", &ImmAdapterJs::isIndirectParentOf),
                                                                                                                       InstanceMethod("isSubnodeOf", &ImmAdapterJs::isSubnodeOf),
                                                                                                                       InstanceMethod("getParent", &ImmAdapterJs::getParent),
                                                                                                                       InstanceMethod("getSelfIndex", &ImmAdapterJs::getSelfIndex),
                                                                                                                       InstanceMethod("atPath", &ImmAdapterJs::atPath),
                                                                                                                       InstanceMethod("is", &ImmAdapterJs::is),
                                                                                                                       InstanceMethod("sub", &ImmAdapterJs::sub)}); }
};

template <>
struct js_to_org_type<ImmAdapterJs> {
  using type = org::imm::ImmAdapter;
};

template <>
struct org_to_js_type<org::imm::ImmAdapter> {
  using type = ImmAdapterJs;
};

struct TreeReprConfImmAdapterJs : public SharedPtrWrapBase<TreeReprConfImmAdapterJs, org::imm::ImmAdapter::TreeReprConf> {
  using SharedPtrWrapBase<TreeReprConfImmAdapterJs, org::imm::ImmAdapter::TreeReprConf>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "TreeReprConfImmAdapterJs", {}); }
};

template <>
struct js_to_org_type<TreeReprConfImmAdapterJs> {
  using type = org::imm::ImmAdapter::TreeReprConf;
};

template <>
struct org_to_js_type<org::imm::ImmAdapter::TreeReprConf> {
  using type = TreeReprConfImmAdapterJs;
};

struct OrgParseFragmentJs : public SharedPtrWrapBase<OrgParseFragmentJs, org::OrgParseFragment> {
  using SharedPtrWrapBase<OrgParseFragmentJs, org::OrgParseFragment>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "OrgParseFragmentJs", {}); }
};

template <>
struct js_to_org_type<OrgParseFragmentJs> {
  using type = org::OrgParseFragment;
};

template <>
struct org_to_js_type<org::OrgParseFragment> {
  using type = OrgParseFragmentJs;
};

struct OrgParseParametersJs : public SharedPtrWrapBase<OrgParseParametersJs, org::OrgParseParameters> {
  using SharedPtrWrapBase<OrgParseParametersJs, org::OrgParseParameters>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "OrgParseParametersJs", {}); }
};

template <>
struct js_to_org_type<OrgParseParametersJs> {
  using type = org::OrgParseParameters;
};

template <>
struct org_to_js_type<org::OrgParseParameters> {
  using type = OrgParseParametersJs;
};

struct OrgDirectoryParseParametersJs : public SharedPtrWrapBase<OrgDirectoryParseParametersJs, org::OrgDirectoryParseParameters> {
  using SharedPtrWrapBase<OrgDirectoryParseParametersJs, org::OrgDirectoryParseParameters>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "OrgDirectoryParseParametersJs", {}); }
};

template <>
struct js_to_org_type<OrgDirectoryParseParametersJs> {
  using type = org::OrgDirectoryParseParameters;
};

template <>
struct org_to_js_type<org::OrgDirectoryParseParameters> {
  using type = OrgDirectoryParseParametersJs;
};

struct OrgYamlExportOptsJs : public SharedPtrWrapBase<OrgYamlExportOptsJs, org::OrgYamlExportOpts> {
  using SharedPtrWrapBase<OrgYamlExportOptsJs, org::OrgYamlExportOpts>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "OrgYamlExportOptsJs", {}); }
};

template <>
struct js_to_org_type<OrgYamlExportOptsJs> {
  using type = org::OrgYamlExportOpts;
};

template <>
struct org_to_js_type<org::OrgYamlExportOpts> {
  using type = OrgYamlExportOptsJs;
};

struct OrgTreeExportOptsJs : public SharedPtrWrapBase<OrgTreeExportOptsJs, org::OrgTreeExportOpts> {
  using SharedPtrWrapBase<OrgTreeExportOptsJs, org::OrgTreeExportOpts>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "OrgTreeExportOptsJs", {}); }
};

template <>
struct js_to_org_type<OrgTreeExportOptsJs> {
  using type = org::OrgTreeExportOpts;
};

template <>
struct org_to_js_type<org::OrgTreeExportOpts> {
  using type = OrgTreeExportOptsJs;
};

struct AstTrackingPathJs : public SharedPtrWrapBase<AstTrackingPathJs, org::AstTrackingPath> {
  using SharedPtrWrapBase<AstTrackingPathJs, org::AstTrackingPath>::SharedPtrWrapBase;
  Napi::Value getParent(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::AstTrackingPath::*)(int) const>(&org::AstTrackingPath::getParent),
                                        std::make_tuple(CxxArgSpec<int>{"offset", 0})));
  }
  Napi::Value getNode(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::AstTrackingPath::*)() const>(&org::AstTrackingPath::getNode),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "AstTrackingPathJs", {InstanceMethod("getParent", &AstTrackingPathJs::getParent),
                                                                                                                            InstanceMethod("getNode", &AstTrackingPathJs::getNode)}); }
};

template <>
struct js_to_org_type<AstTrackingPathJs> {
  using type = org::AstTrackingPath;
};

template <>
struct org_to_js_type<org::AstTrackingPath> {
  using type = AstTrackingPathJs;
};

struct AstTrackingAlternativesJs : public SharedPtrWrapBase<AstTrackingAlternativesJs, org::AstTrackingAlternatives> {
  using SharedPtrWrapBase<AstTrackingAlternativesJs, org::AstTrackingAlternatives>::SharedPtrWrapBase;
  Napi::Value getAllNodes(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::AstTrackingAlternatives::*)() const>(&org::AstTrackingAlternatives::getAllNodes),
                                        std::make_tuple()));
  }
  Napi::Value getNode(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::AstTrackingAlternatives::*)() const>(&org::AstTrackingAlternatives::getNode),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "AstTrackingAlternativesJs", {InstanceMethod("getAllNodes", &AstTrackingAlternativesJs::getAllNodes),
                                                                                                                                    InstanceMethod("getNode", &AstTrackingAlternativesJs::getNode)}); }
};

template <>
struct js_to_org_type<AstTrackingAlternativesJs> {
  using type = org::AstTrackingAlternatives;
};

template <>
struct org_to_js_type<org::AstTrackingAlternatives> {
  using type = AstTrackingAlternativesJs;
};

struct AstTrackingGroupJs : public SharedPtrWrapBase<AstTrackingGroupJs, org::AstTrackingGroup> {
  using SharedPtrWrapBase<AstTrackingGroupJs, org::AstTrackingGroup>::SharedPtrWrapBase;
  Napi::Value getRadioTargetMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::AstTrackingGroup::RadioTarget&(org::AstTrackingGroup::*)()>(&org::AstTrackingGroup::getRadioTarget),
                                   std::make_tuple()));
  }
  Napi::Value getTrackedHashtagMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::AstTrackingGroup::TrackedHashtag&(org::AstTrackingGroup::*)()>(&org::AstTrackingGroup::getTrackedHashtag),
                                   std::make_tuple()));
  }
  Napi::Value getSingleMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::AstTrackingGroup::Single&(org::AstTrackingGroup::*)()>(&org::AstTrackingGroup::getSingle),
                                   std::make_tuple()));
  }
  Napi::Value isSingle(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::AstTrackingGroup::*)() const>(&org::AstTrackingGroup::isSingle),
                                        std::make_tuple()));
  }
  Napi::Value isTrackedHashtag(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::AstTrackingGroup::*)() const>(&org::AstTrackingGroup::isTrackedHashtag),
                                        std::make_tuple()));
  }
  Napi::Value isRadioTarget(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::AstTrackingGroup::*)() const>(&org::AstTrackingGroup::isRadioTarget),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "AstTrackingGroupJs", {InstanceMethod("getRadioTargetMut", &AstTrackingGroupJs::getRadioTargetMut),
                                                                                                                             InstanceMethod("getTrackedHashtagMut", &AstTrackingGroupJs::getTrackedHashtagMut),
                                                                                                                             InstanceMethod("getSingleMut", &AstTrackingGroupJs::getSingleMut),
                                                                                                                             InstanceMethod("isSingle", &AstTrackingGroupJs::isSingle),
                                                                                                                             InstanceMethod("isTrackedHashtag", &AstTrackingGroupJs::isTrackedHashtag),
                                                                                                                             InstanceMethod("isRadioTarget", &AstTrackingGroupJs::isRadioTarget)}); }
};

template <>
struct js_to_org_type<AstTrackingGroupJs> {
  using type = org::AstTrackingGroup;
};

template <>
struct org_to_js_type<org::AstTrackingGroup> {
  using type = AstTrackingGroupJs;
};

struct RadioTargetAstTrackingGroupJs : public SharedPtrWrapBase<RadioTargetAstTrackingGroupJs, org::AstTrackingGroup::RadioTarget> {
  using SharedPtrWrapBase<RadioTargetAstTrackingGroupJs, org::AstTrackingGroup::RadioTarget>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "RadioTargetAstTrackingGroupJs", {}); }
};

template <>
struct js_to_org_type<RadioTargetAstTrackingGroupJs> {
  using type = org::AstTrackingGroup::RadioTarget;
};

template <>
struct org_to_js_type<org::AstTrackingGroup::RadioTarget> {
  using type = RadioTargetAstTrackingGroupJs;
};

struct SingleAstTrackingGroupJs : public SharedPtrWrapBase<SingleAstTrackingGroupJs, org::AstTrackingGroup::Single> {
  using SharedPtrWrapBase<SingleAstTrackingGroupJs, org::AstTrackingGroup::Single>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "SingleAstTrackingGroupJs", {}); }
};

template <>
struct js_to_org_type<SingleAstTrackingGroupJs> {
  using type = org::AstTrackingGroup::Single;
};

template <>
struct org_to_js_type<org::AstTrackingGroup::Single> {
  using type = SingleAstTrackingGroupJs;
};

struct TrackedHashtagAstTrackingGroupJs : public SharedPtrWrapBase<TrackedHashtagAstTrackingGroupJs, org::AstTrackingGroup::TrackedHashtag> {
  using SharedPtrWrapBase<TrackedHashtagAstTrackingGroupJs, org::AstTrackingGroup::TrackedHashtag>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "TrackedHashtagAstTrackingGroupJs", {}); }
};

template <>
struct js_to_org_type<TrackedHashtagAstTrackingGroupJs> {
  using type = org::AstTrackingGroup::TrackedHashtag;
};

template <>
struct org_to_js_type<org::AstTrackingGroup::TrackedHashtag> {
  using type = TrackedHashtagAstTrackingGroupJs;
};

struct AstTrackingMapJs : public SharedPtrWrapBase<AstTrackingMapJs, org::AstTrackingMap> {
  using SharedPtrWrapBase<AstTrackingMapJs, org::AstTrackingMap>::SharedPtrWrapBase;
  Napi::Value getIdPath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::optional<org::AstTrackingAlternatives>(org::AstTrackingMap::*)(hstd::Str const&) const>(&org::AstTrackingMap::getIdPath),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"id"})));
  }
  Napi::Value getNamePath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::optional<org::AstTrackingAlternatives>(org::AstTrackingMap::*)(hstd::Str const&) const>(&org::AstTrackingMap::getNamePath),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"id"})));
  }
  Napi::Value getAnchorTarget(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::optional<org::AstTrackingAlternatives>(org::AstTrackingMap::*)(hstd::Str const&) const>(&org::AstTrackingMap::getAnchorTarget),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"id"})));
  }
  Napi::Value getFootnotePath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::optional<org::AstTrackingAlternatives>(org::AstTrackingMap::*)(hstd::Str const&) const>(&org::AstTrackingMap::getFootnotePath),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"id"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "AstTrackingMapJs", {InstanceMethod("getIdPath", &AstTrackingMapJs::getIdPath),
                                                                                                                           InstanceMethod("getNamePath", &AstTrackingMapJs::getNamePath),
                                                                                                                           InstanceMethod("getAnchorTarget", &AstTrackingMapJs::getAnchorTarget),
                                                                                                                           InstanceMethod("getFootnotePath", &AstTrackingMapJs::getFootnotePath)}); }
};

template <>
struct js_to_org_type<AstTrackingMapJs> {
  using type = org::AstTrackingMap;
};

template <>
struct org_to_js_type<org::AstTrackingMap> {
  using type = AstTrackingMapJs;
};

struct SequenceSegmentJs : public SharedPtrWrapBase<SequenceSegmentJs, hstd::SequenceSegment> {
  using SharedPtrWrapBase<SequenceSegmentJs, hstd::SequenceSegment>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "SequenceSegmentJs", {}); }
};

template <>
struct js_to_org_type<SequenceSegmentJs> {
  using type = hstd::SequenceSegment;
};

template <>
struct org_to_js_type<hstd::SequenceSegment> {
  using type = SequenceSegmentJs;
};

struct SequenceSegmentGroupJs : public SharedPtrWrapBase<SequenceSegmentGroupJs, hstd::SequenceSegmentGroup> {
  using SharedPtrWrapBase<SequenceSegmentGroupJs, hstd::SequenceSegmentGroup>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "SequenceSegmentGroupJs", {}); }
};

template <>
struct js_to_org_type<SequenceSegmentGroupJs> {
  using type = hstd::SequenceSegmentGroup;
};

template <>
struct org_to_js_type<hstd::SequenceSegmentGroup> {
  using type = SequenceSegmentGroupJs;
};

struct SequenceAnnotationTagJs : public SharedPtrWrapBase<SequenceAnnotationTagJs, hstd::SequenceAnnotationTag> {
  using SharedPtrWrapBase<SequenceAnnotationTagJs, hstd::SequenceAnnotationTag>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "SequenceAnnotationTagJs", {}); }
};

template <>
struct js_to_org_type<SequenceAnnotationTagJs> {
  using type = hstd::SequenceAnnotationTag;
};

template <>
struct org_to_js_type<hstd::SequenceAnnotationTag> {
  using type = SequenceAnnotationTagJs;
};

struct SequenceAnnotationJs : public SharedPtrWrapBase<SequenceAnnotationJs, hstd::SequenceAnnotation> {
  using SharedPtrWrapBase<SequenceAnnotationJs, hstd::SequenceAnnotation>::SharedPtrWrapBase;
  Napi::Value isAnnotatedWith(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(hstd::SequenceAnnotation::*)(int, int) const>(&hstd::SequenceAnnotation::isAnnotatedWith),
                                        std::make_tuple(CxxArgSpec<int>{"groupKind"},
                                                        CxxArgSpec<int>{"segmentKind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "SequenceAnnotationJs", {InstanceMethod("isAnnotatedWith", &SequenceAnnotationJs::isAnnotatedWith)}); }
};

template <>
struct js_to_org_type<SequenceAnnotationJs> {
  using type = hstd::SequenceAnnotation;
};

template <>
struct org_to_js_type<hstd::SequenceAnnotation> {
  using type = SequenceAnnotationJs;
};

struct MapLinkGraphJs : public SharedPtrWrapBase<MapLinkGraphJs, org::graph::MapLink> {
  using SharedPtrWrapBase<MapLinkGraphJs, org::graph::MapLink>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "MapLinkGraphJs", {}); }
};

template <>
struct js_to_org_type<MapLinkGraphJs> {
  using type = org::graph::MapLink;
};

template <>
struct org_to_js_type<org::graph::MapLink> {
  using type = MapLinkGraphJs;
};

struct LinkGraphMapLinkJs : public SharedPtrWrapBase<LinkGraphMapLinkJs, org::graph::MapLink::Link> {
  using SharedPtrWrapBase<LinkGraphMapLinkJs, org::graph::MapLink::Link>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "LinkGraphMapLinkJs", {}); }
};

template <>
struct js_to_org_type<LinkGraphMapLinkJs> {
  using type = org::graph::MapLink::Link;
};

template <>
struct org_to_js_type<org::graph::MapLink::Link> {
  using type = LinkGraphMapLinkJs;
};

struct RadioGraphMapLinkJs : public SharedPtrWrapBase<RadioGraphMapLinkJs, org::graph::MapLink::Radio> {
  using SharedPtrWrapBase<RadioGraphMapLinkJs, org::graph::MapLink::Radio>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "RadioGraphMapLinkJs", {}); }
};

template <>
struct js_to_org_type<RadioGraphMapLinkJs> {
  using type = org::graph::MapLink::Radio;
};

template <>
struct org_to_js_type<org::graph::MapLink::Radio> {
  using type = RadioGraphMapLinkJs;
};

struct MapNodePropGraphJs : public SharedPtrWrapBase<MapNodePropGraphJs, org::graph::MapNodeProp> {
  using SharedPtrWrapBase<MapNodePropGraphJs, org::graph::MapNodeProp>::SharedPtrWrapBase;
  Napi::Value getSubtreeId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::optional<hstd::Str>(org::graph::MapNodeProp::*)() const>(&org::graph::MapNodeProp::getSubtreeId),
                                        std::make_tuple()));
  }
  Napi::Value getFootnoteName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::optional<hstd::Str>(org::graph::MapNodeProp::*)() const>(&org::graph::MapNodeProp::getFootnoteName),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "MapNodePropGraphJs", {InstanceMethod("getSubtreeId", &MapNodePropGraphJs::getSubtreeId),
                                                                                                                             InstanceMethod("getFootnoteName", &MapNodePropGraphJs::getFootnoteName)}); }
};

template <>
struct js_to_org_type<MapNodePropGraphJs> {
  using type = org::graph::MapNodeProp;
};

template <>
struct org_to_js_type<org::graph::MapNodeProp> {
  using type = MapNodePropGraphJs;
};

struct MapEdgePropGraphJs : public SharedPtrWrapBase<MapEdgePropGraphJs, org::graph::MapEdgeProp> {
  using SharedPtrWrapBase<MapEdgePropGraphJs, org::graph::MapEdgeProp>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "MapEdgePropGraphJs", {}); }
};

template <>
struct js_to_org_type<MapEdgePropGraphJs> {
  using type = org::graph::MapEdgeProp;
};

template <>
struct org_to_js_type<org::graph::MapEdgeProp> {
  using type = MapEdgePropGraphJs;
};

struct MapNodeGraphJs : public SharedPtrWrapBase<MapNodeGraphJs, org::graph::MapNode> {
  using SharedPtrWrapBase<MapNodeGraphJs, org::graph::MapNode>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::graph::MapNode::*)(org::graph::MapNode const&) const>(&org::graph::MapNode::operator==),
                                        std::make_tuple(CxxArgSpec<org::graph::MapNode>{"other"})));
  }
  Napi::Value operator<(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::graph::MapNode::*)(org::graph::MapNode const&) const>(&org::graph::MapNode::operator<),
                                        std::make_tuple(CxxArgSpec<org::graph::MapNode>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "MapNodeGraphJs", {InstanceMethod("operator==", &MapNodeGraphJs::operator==),
                                                                                                                         InstanceMethod("operator<", &MapNodeGraphJs::operator<)}); }
};

template <>
struct js_to_org_type<MapNodeGraphJs> {
  using type = org::graph::MapNode;
};

template <>
struct org_to_js_type<org::graph::MapNode> {
  using type = MapNodeGraphJs;
};

struct MapEdgeGraphJs : public SharedPtrWrapBase<MapEdgeGraphJs, org::graph::MapEdge> {
  using SharedPtrWrapBase<MapEdgeGraphJs, org::graph::MapEdge>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "MapEdgeGraphJs", {}); }
};

template <>
struct js_to_org_type<MapEdgeGraphJs> {
  using type = org::graph::MapEdge;
};

template <>
struct org_to_js_type<org::graph::MapEdge> {
  using type = MapEdgeGraphJs;
};

struct MapGraphGraphJs : public SharedPtrWrapBase<MapGraphGraphJs, org::graph::MapGraph> {
  using SharedPtrWrapBase<MapGraphGraphJs, org::graph::MapGraph>::SharedPtrWrapBase;
  Napi::Value nodeCount(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::graph::MapGraph::*)() const>(&org::graph::MapGraph::nodeCount),
                                        std::make_tuple()));
  }
  Napi::Value edgeCount(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::graph::MapGraph::*)() const>(&org::graph::MapGraph::edgeCount),
                                        std::make_tuple()));
  }
  Napi::Value outNodes(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::graph::AdjNodesList const&(org::graph::MapGraph::*)(org::graph::MapNode const&) const>(&org::graph::MapGraph::outNodes),
                                        std::make_tuple(CxxArgSpec<org::graph::MapNode>{"node"})));
  }
  Napi::Value inNodes(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::graph::AdjNodesList const&(org::graph::MapGraph::*)(org::graph::MapNode const&) const>(&org::graph::MapGraph::inNodes),
                                        std::make_tuple(CxxArgSpec<org::graph::MapNode>{"node"})));
  }
  Napi::Value adjEdges(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::graph::MapEdge>(org::graph::MapGraph::*)(org::graph::MapNode const&) const>(&org::graph::MapGraph::adjEdges),
                                        std::make_tuple(CxxArgSpec<org::graph::MapNode>{"node"})));
  }
  Napi::Value adjNodes(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::graph::MapNode>(org::graph::MapGraph::*)(org::graph::MapNode const&) const>(&org::graph::MapGraph::adjNodes),
                                        std::make_tuple(CxxArgSpec<org::graph::MapNode>{"node"})));
  }
  Napi::Value outEdges(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::graph::MapEdge>(org::graph::MapGraph::*)(org::graph::MapNode const&) const>(&org::graph::MapGraph::outEdges),
                                        std::make_tuple(CxxArgSpec<org::graph::MapNode>{"node"})));
  }
  Napi::Value inEdges(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::graph::MapEdge>(org::graph::MapGraph::*)(org::graph::MapNode const&) const>(&org::graph::MapGraph::inEdges),
                                        std::make_tuple(CxxArgSpec<org::graph::MapNode>{"node"})));
  }
  Napi::Value outDegree(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::graph::MapGraph::*)(org::graph::MapNode const&) const>(&org::graph::MapGraph::outDegree),
                                        std::make_tuple(CxxArgSpec<org::graph::MapNode>{"node"})));
  }
  Napi::Value inDegree(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::graph::MapGraph::*)(org::graph::MapNode const&) const>(&org::graph::MapGraph::inDegree),
                                        std::make_tuple(CxxArgSpec<org::graph::MapNode>{"node"})));
  }
  Napi::Value isRegisteredNodeById(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::graph::MapGraph::*)(org::imm::ImmUniqId const&) const>(&org::graph::MapGraph::isRegisteredNode),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmUniqId>{"id"})));
  }
  Napi::Value atMapEdge(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::graph::MapEdgeProp const&(org::graph::MapGraph::*)(org::graph::MapEdge const&) const>(&org::graph::MapGraph::at),
                                        std::make_tuple(CxxArgSpec<org::graph::MapEdge>{"edge"})));
  }
  Napi::Value addEdgeWithProp(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::graph::MapGraph::*)(org::graph::MapEdge const&, org::graph::MapEdgeProp const&)>(&org::graph::MapGraph::addEdge),
                                   std::make_tuple(CxxArgSpec<org::graph::MapEdge>{"edge"},
                                                   CxxArgSpec<org::graph::MapEdgeProp>{"prop"})));
  }
  Napi::Value addNodeWithProp(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::graph::MapGraph::*)(org::graph::MapNode const&, org::graph::MapNodeProp const&)>(&org::graph::MapGraph::addNode),
                                   std::make_tuple(CxxArgSpec<org::graph::MapNode>{"node"},
                                                   CxxArgSpec<org::graph::MapNodeProp>{"prop"})));
  }
  Napi::Value has2AdapterEdge(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::graph::MapGraph::*)(org::imm::ImmAdapter const&, org::imm::ImmAdapter const&) const>(&org::graph::MapGraph::hasEdge),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmAdapter>{"source"},
                                                        CxxArgSpec<org::imm::ImmAdapter>{"target"})));
  }
  Napi::Value hasNode(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::graph::MapGraph::*)(org::graph::MapNode const&) const>(&org::graph::MapGraph::hasNode),
                                        std::make_tuple(CxxArgSpec<org::graph::MapNode>{"node"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "MapGraphGraphJs", {InstanceMethod("nodeCount", &MapGraphGraphJs::nodeCount),
                                                                                                                          InstanceMethod("edgeCount", &MapGraphGraphJs::edgeCount),
                                                                                                                          InstanceMethod("outNodes", &MapGraphGraphJs::outNodes),
                                                                                                                          InstanceMethod("inNodes", &MapGraphGraphJs::inNodes),
                                                                                                                          InstanceMethod("adjEdges", &MapGraphGraphJs::adjEdges),
                                                                                                                          InstanceMethod("adjNodes", &MapGraphGraphJs::adjNodes),
                                                                                                                          InstanceMethod("outEdges", &MapGraphGraphJs::outEdges),
                                                                                                                          InstanceMethod("inEdges", &MapGraphGraphJs::inEdges),
                                                                                                                          InstanceMethod("outDegree", &MapGraphGraphJs::outDegree),
                                                                                                                          InstanceMethod("inDegree", &MapGraphGraphJs::inDegree),
                                                                                                                          InstanceMethod("isRegisteredNodeById", &MapGraphGraphJs::isRegisteredNodeById),
                                                                                                                          InstanceMethod("atMapEdge", &MapGraphGraphJs::atMapEdge),
                                                                                                                          InstanceMethod("addEdgeWithProp", &MapGraphGraphJs::addEdgeWithProp),
                                                                                                                          InstanceMethod("addNodeWithProp", &MapGraphGraphJs::addNodeWithProp),
                                                                                                                          InstanceMethod("has2AdapterEdge", &MapGraphGraphJs::has2AdapterEdge),
                                                                                                                          InstanceMethod("hasNode", &MapGraphGraphJs::hasNode)}); }
};

template <>
struct js_to_org_type<MapGraphGraphJs> {
  using type = org::graph::MapGraph;
};

template <>
struct org_to_js_type<org::graph::MapGraph> {
  using type = MapGraphGraphJs;
};

struct MapGraphStateGraphJs : public SharedPtrWrapBase<MapGraphStateGraphJs, org::graph::MapGraphState> {
  using SharedPtrWrapBase<MapGraphStateGraphJs, org::graph::MapGraphState>::SharedPtrWrapBase;
  Napi::Value registerNode(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::graph::MapGraphState::*)(org::graph::MapNodeProp const&, org::graph::MapConfig*)>(&org::graph::MapGraphState::registerNode),
                                   std::make_tuple(CxxArgSpec<org::graph::MapNodeProp>{"node"},
                                                   CxxArgSpec<org::graph::MapConfig*>{"conf"})));
  }
  Napi::Value addNode(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::graph::MapGraphState::*)(org::imm::ImmAdapter const&, org::graph::MapConfig*)>(&org::graph::MapGraphState::addNode),
                                   std::make_tuple(CxxArgSpec<org::imm::ImmAdapter>{"node"},
                                                   CxxArgSpec<org::graph::MapConfig*>{"conf"})));
  }
  Napi::Value addNodeRec(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::graph::MapGraphState::*)(org::imm::ImmAdapter const&, org::graph::MapConfig*)>(&org::graph::MapGraphState::addNodeRec),
                                   std::make_tuple(CxxArgSpec<org::imm::ImmAdapter>{"node"},
                                                   CxxArgSpec<org::graph::MapConfig*>{"conf"})));
  }
  Napi::Value getUnresolvedSubtreeLinks(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::graph::MapLink>(org::graph::MapGraphState::*)(org::imm::ImmAdapterT<org::imm::ImmSubtree>, org::graph::MapConfig*) const>(&org::graph::MapGraphState::getUnresolvedSubtreeLinks),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmAdapterT<org::imm::ImmSubtree>>{"node"},
                                                        CxxArgSpec<org::graph::MapConfig*>{"conf"})));
  }
  Napi::Value getUnresolvedLink(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::optional<org::graph::MapLink>(org::graph::MapGraphState::*)(org::imm::ImmAdapterT<org::imm::ImmLink>, org::graph::MapConfig*) const>(&org::graph::MapGraphState::getUnresolvedLink),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmAdapterT<org::imm::ImmLink>>{"node"},
                                                        CxxArgSpec<org::graph::MapConfig*>{"conf"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "MapGraphStateGraphJs", {InstanceMethod("registerNode", &MapGraphStateGraphJs::registerNode),
                                                                                                                               InstanceMethod("addNode", &MapGraphStateGraphJs::addNode),
                                                                                                                               InstanceMethod("addNodeRec", &MapGraphStateGraphJs::addNodeRec),
                                                                                                                               InstanceMethod("getUnresolvedSubtreeLinks", &MapGraphStateGraphJs::getUnresolvedSubtreeLinks),
                                                                                                                               InstanceMethod("getUnresolvedLink", &MapGraphStateGraphJs::getUnresolvedLink)}); }
};

template <>
struct js_to_org_type<MapGraphStateGraphJs> {
  using type = org::graph::MapGraphState;
};

template <>
struct org_to_js_type<org::graph::MapGraphState> {
  using type = MapGraphStateGraphJs;
};

struct LispCodeJs : public SharedPtrWrapBase<LispCodeJs, org::sem::LispCode> {
  using SharedPtrWrapBase<LispCodeJs, org::sem::LispCode>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::*)(org::sem::LispCode const&) const>(&org::sem::LispCode::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LispCode>{"other"})));
  }
  Napi::Value isCall(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::*)() const>(&org::sem::LispCode::isCall),
                                        std::make_tuple()));
  }
  Napi::Value getCallMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LispCode::Call&(org::sem::LispCode::*)()>(&org::sem::LispCode::getCall),
                                   std::make_tuple()));
  }
  Napi::Value isList(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::*)() const>(&org::sem::LispCode::isList),
                                        std::make_tuple()));
  }
  Napi::Value getListMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LispCode::List&(org::sem::LispCode::*)()>(&org::sem::LispCode::getList),
                                   std::make_tuple()));
  }
  Napi::Value isKeyValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::*)() const>(&org::sem::LispCode::isKeyValue),
                                        std::make_tuple()));
  }
  Napi::Value getKeyValueMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LispCode::KeyValue&(org::sem::LispCode::*)()>(&org::sem::LispCode::getKeyValue),
                                   std::make_tuple()));
  }
  Napi::Value isNumber(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::*)() const>(&org::sem::LispCode::isNumber),
                                        std::make_tuple()));
  }
  Napi::Value getNumberMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LispCode::Number&(org::sem::LispCode::*)()>(&org::sem::LispCode::getNumber),
                                   std::make_tuple()));
  }
  Napi::Value isText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::*)() const>(&org::sem::LispCode::isText),
                                        std::make_tuple()));
  }
  Napi::Value getTextMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LispCode::Text&(org::sem::LispCode::*)()>(&org::sem::LispCode::getText),
                                   std::make_tuple()));
  }
  Napi::Value isIdent(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::*)() const>(&org::sem::LispCode::isIdent),
                                        std::make_tuple()));
  }
  Napi::Value getIdentMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LispCode::Ident&(org::sem::LispCode::*)()>(&org::sem::LispCode::getIdent),
                                   std::make_tuple()));
  }
  Napi::Value isBoolean(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::*)() const>(&org::sem::LispCode::isBoolean),
                                        std::make_tuple()));
  }
  Napi::Value getBooleanMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LispCode::Boolean&(org::sem::LispCode::*)()>(&org::sem::LispCode::getBoolean),
                                   std::make_tuple()));
  }
  Napi::Value isReal(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::*)() const>(&org::sem::LispCode::isReal),
                                        std::make_tuple()));
  }
  Napi::Value getRealMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LispCode::Real&(org::sem::LispCode::*)()>(&org::sem::LispCode::getReal),
                                   std::make_tuple()));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::LispCode::Kind(org::sem::LispCode::*)() const>(&org::sem::LispCode::getKind),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_kind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::LispCode::Kind(org::sem::LispCode::*)() const>(&org::sem::LispCode::sub_variant_get_kind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "LispCodeJs", {InstanceMethod("operator==", &LispCodeJs::operator==),
                                                                                                                     InstanceMethod("isCall", &LispCodeJs::isCall),
                                                                                                                     InstanceMethod("getCallMut", &LispCodeJs::getCallMut),
                                                                                                                     InstanceMethod("isList", &LispCodeJs::isList),
                                                                                                                     InstanceMethod("getListMut", &LispCodeJs::getListMut),
                                                                                                                     InstanceMethod("isKeyValue", &LispCodeJs::isKeyValue),
                                                                                                                     InstanceMethod("getKeyValueMut", &LispCodeJs::getKeyValueMut),
                                                                                                                     InstanceMethod("isNumber", &LispCodeJs::isNumber),
                                                                                                                     InstanceMethod("getNumberMut", &LispCodeJs::getNumberMut),
                                                                                                                     InstanceMethod("isText", &LispCodeJs::isText),
                                                                                                                     InstanceMethod("getTextMut", &LispCodeJs::getTextMut),
                                                                                                                     InstanceMethod("isIdent", &LispCodeJs::isIdent),
                                                                                                                     InstanceMethod("getIdentMut", &LispCodeJs::getIdentMut),
                                                                                                                     InstanceMethod("isBoolean", &LispCodeJs::isBoolean),
                                                                                                                     InstanceMethod("getBooleanMut", &LispCodeJs::getBooleanMut),
                                                                                                                     InstanceMethod("isReal", &LispCodeJs::isReal),
                                                                                                                     InstanceMethod("getRealMut", &LispCodeJs::getRealMut),
                                                                                                                     InstanceMethod("getKind", &LispCodeJs::getKind),
                                                                                                                     InstanceMethod("sub_variant_get_kind", &LispCodeJs::sub_variant_get_kind)}); }
};

template <>
struct js_to_org_type<LispCodeJs> {
  using type = org::sem::LispCode;
};

template <>
struct org_to_js_type<org::sem::LispCode> {
  using type = LispCodeJs;
};

struct CallLispCodeJs : public SharedPtrWrapBase<CallLispCodeJs, org::sem::LispCode::Call> {
  using SharedPtrWrapBase<CallLispCodeJs, org::sem::LispCode::Call>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::Call::*)(org::sem::LispCode::Call const&) const>(&org::sem::LispCode::Call::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LispCode::Call>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "CallLispCodeJs", {InstanceMethod("operator==", &CallLispCodeJs::operator==)}); }
};

template <>
struct js_to_org_type<CallLispCodeJs> {
  using type = org::sem::LispCode::Call;
};

template <>
struct org_to_js_type<org::sem::LispCode::Call> {
  using type = CallLispCodeJs;
};

struct ListLispCodeJs : public SharedPtrWrapBase<ListLispCodeJs, org::sem::LispCode::List> {
  using SharedPtrWrapBase<ListLispCodeJs, org::sem::LispCode::List>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::List::*)(org::sem::LispCode::List const&) const>(&org::sem::LispCode::List::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LispCode::List>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ListLispCodeJs", {InstanceMethod("operator==", &ListLispCodeJs::operator==)}); }
};

template <>
struct js_to_org_type<ListLispCodeJs> {
  using type = org::sem::LispCode::List;
};

template <>
struct org_to_js_type<org::sem::LispCode::List> {
  using type = ListLispCodeJs;
};

struct KeyValueLispCodeJs : public SharedPtrWrapBase<KeyValueLispCodeJs, org::sem::LispCode::KeyValue> {
  using SharedPtrWrapBase<KeyValueLispCodeJs, org::sem::LispCode::KeyValue>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::KeyValue::*)(org::sem::LispCode::KeyValue const&) const>(&org::sem::LispCode::KeyValue::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LispCode::KeyValue>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "KeyValueLispCodeJs", {InstanceMethod("operator==", &KeyValueLispCodeJs::operator==)}); }
};

template <>
struct js_to_org_type<KeyValueLispCodeJs> {
  using type = org::sem::LispCode::KeyValue;
};

template <>
struct org_to_js_type<org::sem::LispCode::KeyValue> {
  using type = KeyValueLispCodeJs;
};

struct NumberLispCodeJs : public SharedPtrWrapBase<NumberLispCodeJs, org::sem::LispCode::Number> {
  using SharedPtrWrapBase<NumberLispCodeJs, org::sem::LispCode::Number>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::Number::*)(org::sem::LispCode::Number const&) const>(&org::sem::LispCode::Number::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LispCode::Number>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "NumberLispCodeJs", {InstanceMethod("operator==", &NumberLispCodeJs::operator==)}); }
};

template <>
struct js_to_org_type<NumberLispCodeJs> {
  using type = org::sem::LispCode::Number;
};

template <>
struct org_to_js_type<org::sem::LispCode::Number> {
  using type = NumberLispCodeJs;
};

struct TextLispCodeJs : public SharedPtrWrapBase<TextLispCodeJs, org::sem::LispCode::Text> {
  using SharedPtrWrapBase<TextLispCodeJs, org::sem::LispCode::Text>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::Text::*)(org::sem::LispCode::Text const&) const>(&org::sem::LispCode::Text::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LispCode::Text>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "TextLispCodeJs", {InstanceMethod("operator==", &TextLispCodeJs::operator==)}); }
};

template <>
struct js_to_org_type<TextLispCodeJs> {
  using type = org::sem::LispCode::Text;
};

template <>
struct org_to_js_type<org::sem::LispCode::Text> {
  using type = TextLispCodeJs;
};

struct IdentLispCodeJs : public SharedPtrWrapBase<IdentLispCodeJs, org::sem::LispCode::Ident> {
  using SharedPtrWrapBase<IdentLispCodeJs, org::sem::LispCode::Ident>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::Ident::*)(org::sem::LispCode::Ident const&) const>(&org::sem::LispCode::Ident::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LispCode::Ident>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "IdentLispCodeJs", {InstanceMethod("operator==", &IdentLispCodeJs::operator==)}); }
};

template <>
struct js_to_org_type<IdentLispCodeJs> {
  using type = org::sem::LispCode::Ident;
};

template <>
struct org_to_js_type<org::sem::LispCode::Ident> {
  using type = IdentLispCodeJs;
};

struct BooleanLispCodeJs : public SharedPtrWrapBase<BooleanLispCodeJs, org::sem::LispCode::Boolean> {
  using SharedPtrWrapBase<BooleanLispCodeJs, org::sem::LispCode::Boolean>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::Boolean::*)(org::sem::LispCode::Boolean const&) const>(&org::sem::LispCode::Boolean::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LispCode::Boolean>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "BooleanLispCodeJs", {InstanceMethod("operator==", &BooleanLispCodeJs::operator==)}); }
};

template <>
struct js_to_org_type<BooleanLispCodeJs> {
  using type = org::sem::LispCode::Boolean;
};

template <>
struct org_to_js_type<org::sem::LispCode::Boolean> {
  using type = BooleanLispCodeJs;
};

struct RealLispCodeJs : public SharedPtrWrapBase<RealLispCodeJs, org::sem::LispCode::Real> {
  using SharedPtrWrapBase<RealLispCodeJs, org::sem::LispCode::Real>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LispCode::Real::*)(org::sem::LispCode::Real const&) const>(&org::sem::LispCode::Real::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LispCode::Real>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "RealLispCodeJs", {InstanceMethod("operator==", &RealLispCodeJs::operator==)}); }
};

template <>
struct js_to_org_type<RealLispCodeJs> {
  using type = org::sem::LispCode::Real;
};

template <>
struct org_to_js_type<org::sem::LispCode::Real> {
  using type = RealLispCodeJs;
};

struct TblfmJs : public SharedPtrWrapBase<TblfmJs, org::sem::Tblfm> {
  using SharedPtrWrapBase<TblfmJs, org::sem::Tblfm>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::*)(org::sem::Tblfm const&) const>(&org::sem::Tblfm::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::Tblfm>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "TblfmJs", {InstanceMethod("operator==", &TblfmJs::operator==)}); }
};

template <>
struct js_to_org_type<TblfmJs> {
  using type = org::sem::Tblfm;
};

template <>
struct org_to_js_type<org::sem::Tblfm> {
  using type = TblfmJs;
};

struct ExprTblfmJs : public SharedPtrWrapBase<ExprTblfmJs, org::sem::Tblfm::Expr> {
  using SharedPtrWrapBase<ExprTblfmJs, org::sem::Tblfm::Expr>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::*)(org::sem::Tblfm::Expr const&) const>(&org::sem::Tblfm::Expr::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::Tblfm::Expr>{"other"})));
  }
  Napi::Value isAxisRef(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::*)() const>(&org::sem::Tblfm::Expr::isAxisRef),
                                        std::make_tuple()));
  }
  Napi::Value getAxisRefMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::Tblfm::Expr::AxisRef&(org::sem::Tblfm::Expr::*)()>(&org::sem::Tblfm::Expr::getAxisRef),
                                   std::make_tuple()));
  }
  Napi::Value isAxisName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::*)() const>(&org::sem::Tblfm::Expr::isAxisName),
                                        std::make_tuple()));
  }
  Napi::Value getAxisNameMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::Tblfm::Expr::AxisName&(org::sem::Tblfm::Expr::*)()>(&org::sem::Tblfm::Expr::getAxisName),
                                   std::make_tuple()));
  }
  Napi::Value isIntLiteral(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::*)() const>(&org::sem::Tblfm::Expr::isIntLiteral),
                                        std::make_tuple()));
  }
  Napi::Value getIntLiteralMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::Tblfm::Expr::IntLiteral&(org::sem::Tblfm::Expr::*)()>(&org::sem::Tblfm::Expr::getIntLiteral),
                                   std::make_tuple()));
  }
  Napi::Value isFloatLiteral(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::*)() const>(&org::sem::Tblfm::Expr::isFloatLiteral),
                                        std::make_tuple()));
  }
  Napi::Value getFloatLiteralMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::Tblfm::Expr::FloatLiteral&(org::sem::Tblfm::Expr::*)()>(&org::sem::Tblfm::Expr::getFloatLiteral),
                                   std::make_tuple()));
  }
  Napi::Value isRangeRef(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::*)() const>(&org::sem::Tblfm::Expr::isRangeRef),
                                        std::make_tuple()));
  }
  Napi::Value getRangeRefMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::Tblfm::Expr::RangeRef&(org::sem::Tblfm::Expr::*)()>(&org::sem::Tblfm::Expr::getRangeRef),
                                   std::make_tuple()));
  }
  Napi::Value isCall(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::*)() const>(&org::sem::Tblfm::Expr::isCall),
                                        std::make_tuple()));
  }
  Napi::Value getCallMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::Tblfm::Expr::Call&(org::sem::Tblfm::Expr::*)()>(&org::sem::Tblfm::Expr::getCall),
                                   std::make_tuple()));
  }
  Napi::Value isElisp(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::*)() const>(&org::sem::Tblfm::Expr::isElisp),
                                        std::make_tuple()));
  }
  Napi::Value getElispMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::Tblfm::Expr::Elisp&(org::sem::Tblfm::Expr::*)()>(&org::sem::Tblfm::Expr::getElisp),
                                   std::make_tuple()));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::Tblfm::Expr::Kind(org::sem::Tblfm::Expr::*)() const>(&org::sem::Tblfm::Expr::getKind),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_kind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::Tblfm::Expr::Kind(org::sem::Tblfm::Expr::*)() const>(&org::sem::Tblfm::Expr::sub_variant_get_kind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ExprTblfmJs", {InstanceMethod("operator==", &ExprTblfmJs::operator==),
                                                                                                                      InstanceMethod("isAxisRef", &ExprTblfmJs::isAxisRef),
                                                                                                                      InstanceMethod("getAxisRefMut", &ExprTblfmJs::getAxisRefMut),
                                                                                                                      InstanceMethod("isAxisName", &ExprTblfmJs::isAxisName),
                                                                                                                      InstanceMethod("getAxisNameMut", &ExprTblfmJs::getAxisNameMut),
                                                                                                                      InstanceMethod("isIntLiteral", &ExprTblfmJs::isIntLiteral),
                                                                                                                      InstanceMethod("getIntLiteralMut", &ExprTblfmJs::getIntLiteralMut),
                                                                                                                      InstanceMethod("isFloatLiteral", &ExprTblfmJs::isFloatLiteral),
                                                                                                                      InstanceMethod("getFloatLiteralMut", &ExprTblfmJs::getFloatLiteralMut),
                                                                                                                      InstanceMethod("isRangeRef", &ExprTblfmJs::isRangeRef),
                                                                                                                      InstanceMethod("getRangeRefMut", &ExprTblfmJs::getRangeRefMut),
                                                                                                                      InstanceMethod("isCall", &ExprTblfmJs::isCall),
                                                                                                                      InstanceMethod("getCallMut", &ExprTblfmJs::getCallMut),
                                                                                                                      InstanceMethod("isElisp", &ExprTblfmJs::isElisp),
                                                                                                                      InstanceMethod("getElispMut", &ExprTblfmJs::getElispMut),
                                                                                                                      InstanceMethod("getKind", &ExprTblfmJs::getKind),
                                                                                                                      InstanceMethod("sub_variant_get_kind", &ExprTblfmJs::sub_variant_get_kind)}); }
};

template <>
struct js_to_org_type<ExprTblfmJs> {
  using type = org::sem::Tblfm::Expr;
};

template <>
struct org_to_js_type<org::sem::Tblfm::Expr> {
  using type = ExprTblfmJs;
};

struct AxisRefTblfmExprJs : public SharedPtrWrapBase<AxisRefTblfmExprJs, org::sem::Tblfm::Expr::AxisRef> {
  using SharedPtrWrapBase<AxisRefTblfmExprJs, org::sem::Tblfm::Expr::AxisRef>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::AxisRef::*)(org::sem::Tblfm::Expr::AxisRef const&) const>(&org::sem::Tblfm::Expr::AxisRef::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::Tblfm::Expr::AxisRef>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "AxisRefTblfmExprJs", {InstanceMethod("operator==", &AxisRefTblfmExprJs::operator==)}); }
};

template <>
struct js_to_org_type<AxisRefTblfmExprJs> {
  using type = org::sem::Tblfm::Expr::AxisRef;
};

template <>
struct org_to_js_type<org::sem::Tblfm::Expr::AxisRef> {
  using type = AxisRefTblfmExprJs;
};

struct PositionTblfmExprAxisRefJs : public SharedPtrWrapBase<PositionTblfmExprAxisRefJs, org::sem::Tblfm::Expr::AxisRef::Position> {
  using SharedPtrWrapBase<PositionTblfmExprAxisRefJs, org::sem::Tblfm::Expr::AxisRef::Position>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::AxisRef::Position::*)(org::sem::Tblfm::Expr::AxisRef::Position const&) const>(&org::sem::Tblfm::Expr::AxisRef::Position::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::Tblfm::Expr::AxisRef::Position>{"other"})));
  }
  Napi::Value isIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::AxisRef::Position::*)() const>(&org::sem::Tblfm::Expr::AxisRef::Position::isIndex),
                                        std::make_tuple()));
  }
  Napi::Value getIndexMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::Tblfm::Expr::AxisRef::Position::Index&(org::sem::Tblfm::Expr::AxisRef::Position::*)()>(&org::sem::Tblfm::Expr::AxisRef::Position::getIndex),
                                   std::make_tuple()));
  }
  Napi::Value isName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::AxisRef::Position::*)() const>(&org::sem::Tblfm::Expr::AxisRef::Position::isName),
                                        std::make_tuple()));
  }
  Napi::Value getNameMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::Tblfm::Expr::AxisRef::Position::Name&(org::sem::Tblfm::Expr::AxisRef::Position::*)()>(&org::sem::Tblfm::Expr::AxisRef::Position::getName),
                                   std::make_tuple()));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::Tblfm::Expr::AxisRef::Position::Kind(org::sem::Tblfm::Expr::AxisRef::Position::*)() const>(&org::sem::Tblfm::Expr::AxisRef::Position::getKind),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_kind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::Tblfm::Expr::AxisRef::Position::Kind(org::sem::Tblfm::Expr::AxisRef::Position::*)() const>(&org::sem::Tblfm::Expr::AxisRef::Position::sub_variant_get_kind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "PositionTblfmExprAxisRefJs", {InstanceMethod("operator==", &PositionTblfmExprAxisRefJs::operator==),
                                                                                                                                     InstanceMethod("isIndex", &PositionTblfmExprAxisRefJs::isIndex),
                                                                                                                                     InstanceMethod("getIndexMut", &PositionTblfmExprAxisRefJs::getIndexMut),
                                                                                                                                     InstanceMethod("isName", &PositionTblfmExprAxisRefJs::isName),
                                                                                                                                     InstanceMethod("getNameMut", &PositionTblfmExprAxisRefJs::getNameMut),
                                                                                                                                     InstanceMethod("getKind", &PositionTblfmExprAxisRefJs::getKind),
                                                                                                                                     InstanceMethod("sub_variant_get_kind", &PositionTblfmExprAxisRefJs::sub_variant_get_kind)}); }
};

template <>
struct js_to_org_type<PositionTblfmExprAxisRefJs> {
  using type = org::sem::Tblfm::Expr::AxisRef::Position;
};

template <>
struct org_to_js_type<org::sem::Tblfm::Expr::AxisRef::Position> {
  using type = PositionTblfmExprAxisRefJs;
};

struct IndexTblfmExprAxisRefPositionJs : public SharedPtrWrapBase<IndexTblfmExprAxisRefPositionJs, org::sem::Tblfm::Expr::AxisRef::Position::Index> {
  using SharedPtrWrapBase<IndexTblfmExprAxisRefPositionJs, org::sem::Tblfm::Expr::AxisRef::Position::Index>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::AxisRef::Position::Index::*)(org::sem::Tblfm::Expr::AxisRef::Position::Index const&) const>(&org::sem::Tblfm::Expr::AxisRef::Position::Index::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::Tblfm::Expr::AxisRef::Position::Index>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "IndexTblfmExprAxisRefPositionJs", {InstanceMethod("operator==", &IndexTblfmExprAxisRefPositionJs::operator==)}); }
};

template <>
struct js_to_org_type<IndexTblfmExprAxisRefPositionJs> {
  using type = org::sem::Tblfm::Expr::AxisRef::Position::Index;
};

template <>
struct org_to_js_type<org::sem::Tblfm::Expr::AxisRef::Position::Index> {
  using type = IndexTblfmExprAxisRefPositionJs;
};

struct NameTblfmExprAxisRefPositionJs : public SharedPtrWrapBase<NameTblfmExprAxisRefPositionJs, org::sem::Tblfm::Expr::AxisRef::Position::Name> {
  using SharedPtrWrapBase<NameTblfmExprAxisRefPositionJs, org::sem::Tblfm::Expr::AxisRef::Position::Name>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::AxisRef::Position::Name::*)(org::sem::Tblfm::Expr::AxisRef::Position::Name const&) const>(&org::sem::Tblfm::Expr::AxisRef::Position::Name::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::Tblfm::Expr::AxisRef::Position::Name>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "NameTblfmExprAxisRefPositionJs", {InstanceMethod("operator==", &NameTblfmExprAxisRefPositionJs::operator==)}); }
};

template <>
struct js_to_org_type<NameTblfmExprAxisRefPositionJs> {
  using type = org::sem::Tblfm::Expr::AxisRef::Position::Name;
};

template <>
struct org_to_js_type<org::sem::Tblfm::Expr::AxisRef::Position::Name> {
  using type = NameTblfmExprAxisRefPositionJs;
};

struct AxisNameTblfmExprJs : public SharedPtrWrapBase<AxisNameTblfmExprJs, org::sem::Tblfm::Expr::AxisName> {
  using SharedPtrWrapBase<AxisNameTblfmExprJs, org::sem::Tblfm::Expr::AxisName>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::AxisName::*)(org::sem::Tblfm::Expr::AxisName const&) const>(&org::sem::Tblfm::Expr::AxisName::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::Tblfm::Expr::AxisName>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "AxisNameTblfmExprJs", {InstanceMethod("operator==", &AxisNameTblfmExprJs::operator==)}); }
};

template <>
struct js_to_org_type<AxisNameTblfmExprJs> {
  using type = org::sem::Tblfm::Expr::AxisName;
};

template <>
struct org_to_js_type<org::sem::Tblfm::Expr::AxisName> {
  using type = AxisNameTblfmExprJs;
};

struct IntLiteralTblfmExprJs : public SharedPtrWrapBase<IntLiteralTblfmExprJs, org::sem::Tblfm::Expr::IntLiteral> {
  using SharedPtrWrapBase<IntLiteralTblfmExprJs, org::sem::Tblfm::Expr::IntLiteral>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::IntLiteral::*)(org::sem::Tblfm::Expr::IntLiteral const&) const>(&org::sem::Tblfm::Expr::IntLiteral::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::Tblfm::Expr::IntLiteral>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "IntLiteralTblfmExprJs", {InstanceMethod("operator==", &IntLiteralTblfmExprJs::operator==)}); }
};

template <>
struct js_to_org_type<IntLiteralTblfmExprJs> {
  using type = org::sem::Tblfm::Expr::IntLiteral;
};

template <>
struct org_to_js_type<org::sem::Tblfm::Expr::IntLiteral> {
  using type = IntLiteralTblfmExprJs;
};

struct FloatLiteralTblfmExprJs : public SharedPtrWrapBase<FloatLiteralTblfmExprJs, org::sem::Tblfm::Expr::FloatLiteral> {
  using SharedPtrWrapBase<FloatLiteralTblfmExprJs, org::sem::Tblfm::Expr::FloatLiteral>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::FloatLiteral::*)(org::sem::Tblfm::Expr::FloatLiteral const&) const>(&org::sem::Tblfm::Expr::FloatLiteral::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::Tblfm::Expr::FloatLiteral>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "FloatLiteralTblfmExprJs", {InstanceMethod("operator==", &FloatLiteralTblfmExprJs::operator==)}); }
};

template <>
struct js_to_org_type<FloatLiteralTblfmExprJs> {
  using type = org::sem::Tblfm::Expr::FloatLiteral;
};

template <>
struct org_to_js_type<org::sem::Tblfm::Expr::FloatLiteral> {
  using type = FloatLiteralTblfmExprJs;
};

struct RangeRefTblfmExprJs : public SharedPtrWrapBase<RangeRefTblfmExprJs, org::sem::Tblfm::Expr::RangeRef> {
  using SharedPtrWrapBase<RangeRefTblfmExprJs, org::sem::Tblfm::Expr::RangeRef>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::RangeRef::*)(org::sem::Tblfm::Expr::RangeRef const&) const>(&org::sem::Tblfm::Expr::RangeRef::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::Tblfm::Expr::RangeRef>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "RangeRefTblfmExprJs", {InstanceMethod("operator==", &RangeRefTblfmExprJs::operator==)}); }
};

template <>
struct js_to_org_type<RangeRefTblfmExprJs> {
  using type = org::sem::Tblfm::Expr::RangeRef;
};

template <>
struct org_to_js_type<org::sem::Tblfm::Expr::RangeRef> {
  using type = RangeRefTblfmExprJs;
};

struct CallTblfmExprJs : public SharedPtrWrapBase<CallTblfmExprJs, org::sem::Tblfm::Expr::Call> {
  using SharedPtrWrapBase<CallTblfmExprJs, org::sem::Tblfm::Expr::Call>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::Call::*)(org::sem::Tblfm::Expr::Call const&) const>(&org::sem::Tblfm::Expr::Call::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::Tblfm::Expr::Call>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "CallTblfmExprJs", {InstanceMethod("operator==", &CallTblfmExprJs::operator==)}); }
};

template <>
struct js_to_org_type<CallTblfmExprJs> {
  using type = org::sem::Tblfm::Expr::Call;
};

template <>
struct org_to_js_type<org::sem::Tblfm::Expr::Call> {
  using type = CallTblfmExprJs;
};

struct ElispTblfmExprJs : public SharedPtrWrapBase<ElispTblfmExprJs, org::sem::Tblfm::Expr::Elisp> {
  using SharedPtrWrapBase<ElispTblfmExprJs, org::sem::Tblfm::Expr::Elisp>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Expr::Elisp::*)(org::sem::Tblfm::Expr::Elisp const&) const>(&org::sem::Tblfm::Expr::Elisp::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::Tblfm::Expr::Elisp>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ElispTblfmExprJs", {InstanceMethod("operator==", &ElispTblfmExprJs::operator==)}); }
};

template <>
struct js_to_org_type<ElispTblfmExprJs> {
  using type = org::sem::Tblfm::Expr::Elisp;
};

template <>
struct org_to_js_type<org::sem::Tblfm::Expr::Elisp> {
  using type = ElispTblfmExprJs;
};

struct AssignTblfmJs : public SharedPtrWrapBase<AssignTblfmJs, org::sem::Tblfm::Assign> {
  using SharedPtrWrapBase<AssignTblfmJs, org::sem::Tblfm::Assign>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Tblfm::Assign::*)(org::sem::Tblfm::Assign const&) const>(&org::sem::Tblfm::Assign::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::Tblfm::Assign>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "AssignTblfmJs", {InstanceMethod("operator==", &AssignTblfmJs::operator==)}); }
};

template <>
struct js_to_org_type<AssignTblfmJs> {
  using type = org::sem::Tblfm::Assign;
};

template <>
struct org_to_js_type<org::sem::Tblfm::Assign> {
  using type = AssignTblfmJs;
};

struct AttrValueJs : public SharedPtrWrapBase<AttrValueJs, org::sem::AttrValue> {
  using SharedPtrWrapBase<AttrValueJs, org::sem::AttrValue>::SharedPtrWrapBase;
  Napi::Value getBool(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<bool>(org::sem::AttrValue::*)() const>(&org::sem::AttrValue::getBool),
                                        std::make_tuple()));
  }
  Napi::Value getInt(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<int>(org::sem::AttrValue::*)() const>(&org::sem::AttrValue::getInt),
                                        std::make_tuple()));
  }
  Napi::Value getString(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Str(org::sem::AttrValue::*)() const>(&org::sem::AttrValue::getString),
                                        std::make_tuple()));
  }
  Napi::Value getFile(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Str(org::sem::AttrValue::*)() const>(&org::sem::AttrValue::getFile),
                                        std::make_tuple()));
  }
  Napi::Value getReference(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Str(org::sem::AttrValue::*)() const>(&org::sem::AttrValue::getReference),
                                        std::make_tuple()));
  }
  Napi::Value getDouble(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<double>(org::sem::AttrValue::*)() const>(&org::sem::AttrValue::getDouble),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::AttrValue::*)(org::sem::AttrValue const&) const>(&org::sem::AttrValue::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::AttrValue>{"other"})));
  }
  Napi::Value isTextValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::AttrValue::*)() const>(&org::sem::AttrValue::isTextValue),
                                        std::make_tuple()));
  }
  Napi::Value getTextValueMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::AttrValue::TextValue&(org::sem::AttrValue::*)()>(&org::sem::AttrValue::getTextValue),
                                   std::make_tuple()));
  }
  Napi::Value isFileReference(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::AttrValue::*)() const>(&org::sem::AttrValue::isFileReference),
                                        std::make_tuple()));
  }
  Napi::Value getFileReferenceMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::AttrValue::FileReference&(org::sem::AttrValue::*)()>(&org::sem::AttrValue::getFileReference),
                                   std::make_tuple()));
  }
  Napi::Value isLispValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::AttrValue::*)() const>(&org::sem::AttrValue::isLispValue),
                                        std::make_tuple()));
  }
  Napi::Value getLispValueMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::AttrValue::LispValue&(org::sem::AttrValue::*)()>(&org::sem::AttrValue::getLispValue),
                                   std::make_tuple()));
  }
  Napi::Value getDataKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrValue::DataKind(org::sem::AttrValue::*)() const>(&org::sem::AttrValue::getDataKind),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_kind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrValue::DataKind(org::sem::AttrValue::*)() const>(&org::sem::AttrValue::sub_variant_get_kind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "AttrValueJs", {InstanceMethod("getBool", &AttrValueJs::getBool),
                                                                                                                      InstanceMethod("getInt", &AttrValueJs::getInt),
                                                                                                                      InstanceMethod("getString", &AttrValueJs::getString),
                                                                                                                      InstanceMethod("getFile", &AttrValueJs::getFile),
                                                                                                                      InstanceMethod("getReference", &AttrValueJs::getReference),
                                                                                                                      InstanceMethod("getDouble", &AttrValueJs::getDouble),
                                                                                                                      InstanceMethod("operator==", &AttrValueJs::operator==),
                                                                                                                      InstanceMethod("isTextValue", &AttrValueJs::isTextValue),
                                                                                                                      InstanceMethod("getTextValueMut", &AttrValueJs::getTextValueMut),
                                                                                                                      InstanceMethod("isFileReference", &AttrValueJs::isFileReference),
                                                                                                                      InstanceMethod("getFileReferenceMut", &AttrValueJs::getFileReferenceMut),
                                                                                                                      InstanceMethod("isLispValue", &AttrValueJs::isLispValue),
                                                                                                                      InstanceMethod("getLispValueMut", &AttrValueJs::getLispValueMut),
                                                                                                                      InstanceMethod("getDataKind", &AttrValueJs::getDataKind),
                                                                                                                      InstanceMethod("sub_variant_get_kind", &AttrValueJs::sub_variant_get_kind)}); }
};

template <>
struct js_to_org_type<AttrValueJs> {
  using type = org::sem::AttrValue;
};

template <>
struct org_to_js_type<org::sem::AttrValue> {
  using type = AttrValueJs;
};

struct DimensionSpanAttrValueJs : public SharedPtrWrapBase<DimensionSpanAttrValueJs, org::sem::AttrValue::DimensionSpan> {
  using SharedPtrWrapBase<DimensionSpanAttrValueJs, org::sem::AttrValue::DimensionSpan>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::AttrValue::DimensionSpan::*)(org::sem::AttrValue::DimensionSpan const&) const>(&org::sem::AttrValue::DimensionSpan::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::AttrValue::DimensionSpan>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "DimensionSpanAttrValueJs", {InstanceMethod("operator==", &DimensionSpanAttrValueJs::operator==)}); }
};

template <>
struct js_to_org_type<DimensionSpanAttrValueJs> {
  using type = org::sem::AttrValue::DimensionSpan;
};

template <>
struct org_to_js_type<org::sem::AttrValue::DimensionSpan> {
  using type = DimensionSpanAttrValueJs;
};

struct TextValueAttrValueJs : public SharedPtrWrapBase<TextValueAttrValueJs, org::sem::AttrValue::TextValue> {
  using SharedPtrWrapBase<TextValueAttrValueJs, org::sem::AttrValue::TextValue>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::AttrValue::TextValue::*)(org::sem::AttrValue::TextValue const&) const>(&org::sem::AttrValue::TextValue::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::AttrValue::TextValue>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "TextValueAttrValueJs", {InstanceMethod("operator==", &TextValueAttrValueJs::operator==)}); }
};

template <>
struct js_to_org_type<TextValueAttrValueJs> {
  using type = org::sem::AttrValue::TextValue;
};

template <>
struct org_to_js_type<org::sem::AttrValue::TextValue> {
  using type = TextValueAttrValueJs;
};

struct FileReferenceAttrValueJs : public SharedPtrWrapBase<FileReferenceAttrValueJs, org::sem::AttrValue::FileReference> {
  using SharedPtrWrapBase<FileReferenceAttrValueJs, org::sem::AttrValue::FileReference>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::AttrValue::FileReference::*)(org::sem::AttrValue::FileReference const&) const>(&org::sem::AttrValue::FileReference::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::AttrValue::FileReference>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "FileReferenceAttrValueJs", {InstanceMethod("operator==", &FileReferenceAttrValueJs::operator==)}); }
};

template <>
struct js_to_org_type<FileReferenceAttrValueJs> {
  using type = org::sem::AttrValue::FileReference;
};

template <>
struct org_to_js_type<org::sem::AttrValue::FileReference> {
  using type = FileReferenceAttrValueJs;
};

struct LispValueAttrValueJs : public SharedPtrWrapBase<LispValueAttrValueJs, org::sem::AttrValue::LispValue> {
  using SharedPtrWrapBase<LispValueAttrValueJs, org::sem::AttrValue::LispValue>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::AttrValue::LispValue::*)(org::sem::AttrValue::LispValue const&) const>(&org::sem::AttrValue::LispValue::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::AttrValue::LispValue>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "LispValueAttrValueJs", {InstanceMethod("operator==", &LispValueAttrValueJs::operator==)}); }
};

template <>
struct js_to_org_type<LispValueAttrValueJs> {
  using type = org::sem::AttrValue::LispValue;
};

template <>
struct org_to_js_type<org::sem::AttrValue::LispValue> {
  using type = LispValueAttrValueJs;
};

struct HashTagFlatJs : public SharedPtrWrapBase<HashTagFlatJs, org::sem::HashTagFlat> {
  using SharedPtrWrapBase<HashTagFlatJs, org::sem::HashTagFlat>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::HashTagFlat::*)(org::sem::HashTagFlat const&) const>(&org::sem::HashTagFlat::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::HashTagFlat>{"other"})));
  }
  Napi::Value operator<(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::HashTagFlat::*)(org::sem::HashTagFlat const&) const>(&org::sem::HashTagFlat::operator<),
                                        std::make_tuple(CxxArgSpec<org::sem::HashTagFlat>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "HashTagFlatJs", {InstanceMethod("operator==", &HashTagFlatJs::operator==),
                                                                                                                        InstanceMethod("operator<", &HashTagFlatJs::operator<)}); }
};

template <>
struct js_to_org_type<HashTagFlatJs> {
  using type = org::sem::HashTagFlat;
};

template <>
struct org_to_js_type<org::sem::HashTagFlat> {
  using type = HashTagFlatJs;
};

struct HashTagTextJs : public SharedPtrWrapBase<HashTagTextJs, org::sem::HashTagText> {
  using SharedPtrWrapBase<HashTagTextJs, org::sem::HashTagText>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::HashTagText::*)(org::sem::HashTagText const&) const>(&org::sem::HashTagText::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::HashTagText>{"other"})));
  }
  Napi::Value prefixMatch(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::HashTagText::*)(hstd::Vec<hstd::Str> const&) const>(&org::sem::HashTagText::prefixMatch),
                                        std::make_tuple(CxxArgSpec<hstd::Vec<hstd::Str>>{"prefix"})));
  }
  Napi::Value getFlatHashes(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::HashTagFlat>(org::sem::HashTagText::*)(bool) const>(&org::sem::HashTagText::getFlatHashes),
                                        std::make_tuple(CxxArgSpec<bool>{"withIntermediate", true})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "HashTagTextJs", {InstanceMethod("operator==", &HashTagTextJs::operator==),
                                                                                                                        InstanceMethod("prefixMatch", &HashTagTextJs::prefixMatch),
                                                                                                                        InstanceMethod("getFlatHashes", &HashTagTextJs::getFlatHashes)}); }
};

template <>
struct js_to_org_type<HashTagTextJs> {
  using type = org::sem::HashTagText;
};

template <>
struct org_to_js_type<org::sem::HashTagText> {
  using type = HashTagTextJs;
};

struct SubtreePathJs : public SharedPtrWrapBase<SubtreePathJs, org::sem::SubtreePath> {
  using SharedPtrWrapBase<SubtreePathJs, org::sem::SubtreePath>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreePath::*)(org::sem::SubtreePath const&) const>(&org::sem::SubtreePath::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::SubtreePath>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "SubtreePathJs", {InstanceMethod("operator==", &SubtreePathJs::operator==)}); }
};

template <>
struct js_to_org_type<SubtreePathJs> {
  using type = org::sem::SubtreePath;
};

template <>
struct org_to_js_type<org::sem::SubtreePath> {
  using type = SubtreePathJs;
};

struct LinkTargetJs : public SharedPtrWrapBase<LinkTargetJs, org::sem::LinkTarget> {
  using SharedPtrWrapBase<LinkTargetJs, org::sem::LinkTarget>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::*)(org::sem::LinkTarget const&) const>(&org::sem::LinkTarget::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LinkTarget>{"other"})));
  }
  Napi::Value isRaw(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::*)() const>(&org::sem::LinkTarget::isRaw),
                                        std::make_tuple()));
  }
  Napi::Value getRawMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LinkTarget::Raw&(org::sem::LinkTarget::*)()>(&org::sem::LinkTarget::getRaw),
                                   std::make_tuple()));
  }
  Napi::Value isId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::*)() const>(&org::sem::LinkTarget::isId),
                                        std::make_tuple()));
  }
  Napi::Value getIdMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LinkTarget::Id&(org::sem::LinkTarget::*)()>(&org::sem::LinkTarget::getId),
                                   std::make_tuple()));
  }
  Napi::Value isCustomId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::*)() const>(&org::sem::LinkTarget::isCustomId),
                                        std::make_tuple()));
  }
  Napi::Value getCustomIdMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LinkTarget::CustomId&(org::sem::LinkTarget::*)()>(&org::sem::LinkTarget::getCustomId),
                                   std::make_tuple()));
  }
  Napi::Value isSubtreeTitle(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::*)() const>(&org::sem::LinkTarget::isSubtreeTitle),
                                        std::make_tuple()));
  }
  Napi::Value getSubtreeTitleMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LinkTarget::SubtreeTitle&(org::sem::LinkTarget::*)()>(&org::sem::LinkTarget::getSubtreeTitle),
                                   std::make_tuple()));
  }
  Napi::Value isPerson(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::*)() const>(&org::sem::LinkTarget::isPerson),
                                        std::make_tuple()));
  }
  Napi::Value getPersonMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LinkTarget::Person&(org::sem::LinkTarget::*)()>(&org::sem::LinkTarget::getPerson),
                                   std::make_tuple()));
  }
  Napi::Value isUserProtocol(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::*)() const>(&org::sem::LinkTarget::isUserProtocol),
                                        std::make_tuple()));
  }
  Napi::Value getUserProtocolMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LinkTarget::UserProtocol&(org::sem::LinkTarget::*)()>(&org::sem::LinkTarget::getUserProtocol),
                                   std::make_tuple()));
  }
  Napi::Value isInternal(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::*)() const>(&org::sem::LinkTarget::isInternal),
                                        std::make_tuple()));
  }
  Napi::Value getInternalMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LinkTarget::Internal&(org::sem::LinkTarget::*)()>(&org::sem::LinkTarget::getInternal),
                                   std::make_tuple()));
  }
  Napi::Value isFootnote(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::*)() const>(&org::sem::LinkTarget::isFootnote),
                                        std::make_tuple()));
  }
  Napi::Value getFootnoteMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LinkTarget::Footnote&(org::sem::LinkTarget::*)()>(&org::sem::LinkTarget::getFootnote),
                                   std::make_tuple()));
  }
  Napi::Value isFile(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::*)() const>(&org::sem::LinkTarget::isFile),
                                        std::make_tuple()));
  }
  Napi::Value getFileMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LinkTarget::File&(org::sem::LinkTarget::*)()>(&org::sem::LinkTarget::getFile),
                                   std::make_tuple()));
  }
  Napi::Value isAttachment(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::*)() const>(&org::sem::LinkTarget::isAttachment),
                                        std::make_tuple()));
  }
  Napi::Value getAttachmentMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::LinkTarget::Attachment&(org::sem::LinkTarget::*)()>(&org::sem::LinkTarget::getAttachment),
                                   std::make_tuple()));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::LinkTarget::Kind(org::sem::LinkTarget::*)() const>(&org::sem::LinkTarget::getKind),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_kind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::LinkTarget::Kind(org::sem::LinkTarget::*)() const>(&org::sem::LinkTarget::sub_variant_get_kind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "LinkTargetJs", {InstanceMethod("operator==", &LinkTargetJs::operator==),
                                                                                                                       InstanceMethod("isRaw", &LinkTargetJs::isRaw),
                                                                                                                       InstanceMethod("getRawMut", &LinkTargetJs::getRawMut),
                                                                                                                       InstanceMethod("isId", &LinkTargetJs::isId),
                                                                                                                       InstanceMethod("getIdMut", &LinkTargetJs::getIdMut),
                                                                                                                       InstanceMethod("isCustomId", &LinkTargetJs::isCustomId),
                                                                                                                       InstanceMethod("getCustomIdMut", &LinkTargetJs::getCustomIdMut),
                                                                                                                       InstanceMethod("isSubtreeTitle", &LinkTargetJs::isSubtreeTitle),
                                                                                                                       InstanceMethod("getSubtreeTitleMut", &LinkTargetJs::getSubtreeTitleMut),
                                                                                                                       InstanceMethod("isPerson", &LinkTargetJs::isPerson),
                                                                                                                       InstanceMethod("getPersonMut", &LinkTargetJs::getPersonMut),
                                                                                                                       InstanceMethod("isUserProtocol", &LinkTargetJs::isUserProtocol),
                                                                                                                       InstanceMethod("getUserProtocolMut", &LinkTargetJs::getUserProtocolMut),
                                                                                                                       InstanceMethod("isInternal", &LinkTargetJs::isInternal),
                                                                                                                       InstanceMethod("getInternalMut", &LinkTargetJs::getInternalMut),
                                                                                                                       InstanceMethod("isFootnote", &LinkTargetJs::isFootnote),
                                                                                                                       InstanceMethod("getFootnoteMut", &LinkTargetJs::getFootnoteMut),
                                                                                                                       InstanceMethod("isFile", &LinkTargetJs::isFile),
                                                                                                                       InstanceMethod("getFileMut", &LinkTargetJs::getFileMut),
                                                                                                                       InstanceMethod("isAttachment", &LinkTargetJs::isAttachment),
                                                                                                                       InstanceMethod("getAttachmentMut", &LinkTargetJs::getAttachmentMut),
                                                                                                                       InstanceMethod("getKind", &LinkTargetJs::getKind),
                                                                                                                       InstanceMethod("sub_variant_get_kind", &LinkTargetJs::sub_variant_get_kind)}); }
};

template <>
struct js_to_org_type<LinkTargetJs> {
  using type = org::sem::LinkTarget;
};

template <>
struct org_to_js_type<org::sem::LinkTarget> {
  using type = LinkTargetJs;
};

struct RawLinkTargetJs : public SharedPtrWrapBase<RawLinkTargetJs, org::sem::LinkTarget::Raw> {
  using SharedPtrWrapBase<RawLinkTargetJs, org::sem::LinkTarget::Raw>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::Raw::*)(org::sem::LinkTarget::Raw const&) const>(&org::sem::LinkTarget::Raw::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LinkTarget::Raw>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "RawLinkTargetJs", {InstanceMethod("operator==", &RawLinkTargetJs::operator==)}); }
};

template <>
struct js_to_org_type<RawLinkTargetJs> {
  using type = org::sem::LinkTarget::Raw;
};

template <>
struct org_to_js_type<org::sem::LinkTarget::Raw> {
  using type = RawLinkTargetJs;
};

struct IdLinkTargetJs : public SharedPtrWrapBase<IdLinkTargetJs, org::sem::LinkTarget::Id> {
  using SharedPtrWrapBase<IdLinkTargetJs, org::sem::LinkTarget::Id>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::Id::*)(org::sem::LinkTarget::Id const&) const>(&org::sem::LinkTarget::Id::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LinkTarget::Id>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "IdLinkTargetJs", {InstanceMethod("operator==", &IdLinkTargetJs::operator==)}); }
};

template <>
struct js_to_org_type<IdLinkTargetJs> {
  using type = org::sem::LinkTarget::Id;
};

template <>
struct org_to_js_type<org::sem::LinkTarget::Id> {
  using type = IdLinkTargetJs;
};

struct CustomIdLinkTargetJs : public SharedPtrWrapBase<CustomIdLinkTargetJs, org::sem::LinkTarget::CustomId> {
  using SharedPtrWrapBase<CustomIdLinkTargetJs, org::sem::LinkTarget::CustomId>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::CustomId::*)(org::sem::LinkTarget::CustomId const&) const>(&org::sem::LinkTarget::CustomId::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LinkTarget::CustomId>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "CustomIdLinkTargetJs", {InstanceMethod("operator==", &CustomIdLinkTargetJs::operator==)}); }
};

template <>
struct js_to_org_type<CustomIdLinkTargetJs> {
  using type = org::sem::LinkTarget::CustomId;
};

template <>
struct org_to_js_type<org::sem::LinkTarget::CustomId> {
  using type = CustomIdLinkTargetJs;
};

struct SubtreeTitleLinkTargetJs : public SharedPtrWrapBase<SubtreeTitleLinkTargetJs, org::sem::LinkTarget::SubtreeTitle> {
  using SharedPtrWrapBase<SubtreeTitleLinkTargetJs, org::sem::LinkTarget::SubtreeTitle>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::SubtreeTitle::*)(org::sem::LinkTarget::SubtreeTitle const&) const>(&org::sem::LinkTarget::SubtreeTitle::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LinkTarget::SubtreeTitle>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "SubtreeTitleLinkTargetJs", {InstanceMethod("operator==", &SubtreeTitleLinkTargetJs::operator==)}); }
};

template <>
struct js_to_org_type<SubtreeTitleLinkTargetJs> {
  using type = org::sem::LinkTarget::SubtreeTitle;
};

template <>
struct org_to_js_type<org::sem::LinkTarget::SubtreeTitle> {
  using type = SubtreeTitleLinkTargetJs;
};

struct PersonLinkTargetJs : public SharedPtrWrapBase<PersonLinkTargetJs, org::sem::LinkTarget::Person> {
  using SharedPtrWrapBase<PersonLinkTargetJs, org::sem::LinkTarget::Person>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::Person::*)(org::sem::LinkTarget::Person const&) const>(&org::sem::LinkTarget::Person::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LinkTarget::Person>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "PersonLinkTargetJs", {InstanceMethod("operator==", &PersonLinkTargetJs::operator==)}); }
};

template <>
struct js_to_org_type<PersonLinkTargetJs> {
  using type = org::sem::LinkTarget::Person;
};

template <>
struct org_to_js_type<org::sem::LinkTarget::Person> {
  using type = PersonLinkTargetJs;
};

struct UserProtocolLinkTargetJs : public SharedPtrWrapBase<UserProtocolLinkTargetJs, org::sem::LinkTarget::UserProtocol> {
  using SharedPtrWrapBase<UserProtocolLinkTargetJs, org::sem::LinkTarget::UserProtocol>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::UserProtocol::*)(org::sem::LinkTarget::UserProtocol const&) const>(&org::sem::LinkTarget::UserProtocol::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LinkTarget::UserProtocol>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "UserProtocolLinkTargetJs", {InstanceMethod("operator==", &UserProtocolLinkTargetJs::operator==)}); }
};

template <>
struct js_to_org_type<UserProtocolLinkTargetJs> {
  using type = org::sem::LinkTarget::UserProtocol;
};

template <>
struct org_to_js_type<org::sem::LinkTarget::UserProtocol> {
  using type = UserProtocolLinkTargetJs;
};

struct InternalLinkTargetJs : public SharedPtrWrapBase<InternalLinkTargetJs, org::sem::LinkTarget::Internal> {
  using SharedPtrWrapBase<InternalLinkTargetJs, org::sem::LinkTarget::Internal>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::Internal::*)(org::sem::LinkTarget::Internal const&) const>(&org::sem::LinkTarget::Internal::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LinkTarget::Internal>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "InternalLinkTargetJs", {InstanceMethod("operator==", &InternalLinkTargetJs::operator==)}); }
};

template <>
struct js_to_org_type<InternalLinkTargetJs> {
  using type = org::sem::LinkTarget::Internal;
};

template <>
struct org_to_js_type<org::sem::LinkTarget::Internal> {
  using type = InternalLinkTargetJs;
};

struct FootnoteLinkTargetJs : public SharedPtrWrapBase<FootnoteLinkTargetJs, org::sem::LinkTarget::Footnote> {
  using SharedPtrWrapBase<FootnoteLinkTargetJs, org::sem::LinkTarget::Footnote>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::Footnote::*)(org::sem::LinkTarget::Footnote const&) const>(&org::sem::LinkTarget::Footnote::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LinkTarget::Footnote>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "FootnoteLinkTargetJs", {InstanceMethod("operator==", &FootnoteLinkTargetJs::operator==)}); }
};

template <>
struct js_to_org_type<FootnoteLinkTargetJs> {
  using type = org::sem::LinkTarget::Footnote;
};

template <>
struct org_to_js_type<org::sem::LinkTarget::Footnote> {
  using type = FootnoteLinkTargetJs;
};

struct FileLinkTargetJs : public SharedPtrWrapBase<FileLinkTargetJs, org::sem::LinkTarget::File> {
  using SharedPtrWrapBase<FileLinkTargetJs, org::sem::LinkTarget::File>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::File::*)(org::sem::LinkTarget::File const&) const>(&org::sem::LinkTarget::File::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LinkTarget::File>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "FileLinkTargetJs", {InstanceMethod("operator==", &FileLinkTargetJs::operator==)}); }
};

template <>
struct js_to_org_type<FileLinkTargetJs> {
  using type = org::sem::LinkTarget::File;
};

template <>
struct org_to_js_type<org::sem::LinkTarget::File> {
  using type = FileLinkTargetJs;
};

struct AttachmentLinkTargetJs : public SharedPtrWrapBase<AttachmentLinkTargetJs, org::sem::LinkTarget::Attachment> {
  using SharedPtrWrapBase<AttachmentLinkTargetJs, org::sem::LinkTarget::Attachment>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::LinkTarget::Attachment::*)(org::sem::LinkTarget::Attachment const&) const>(&org::sem::LinkTarget::Attachment::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::LinkTarget::Attachment>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "AttachmentLinkTargetJs", {InstanceMethod("operator==", &AttachmentLinkTargetJs::operator==)}); }
};

template <>
struct js_to_org_type<AttachmentLinkTargetJs> {
  using type = org::sem::LinkTarget::Attachment;
};

template <>
struct org_to_js_type<org::sem::LinkTarget::Attachment> {
  using type = AttachmentLinkTargetJs;
};

struct SubtreeLogHeadJs : public SharedPtrWrapBase<SubtreeLogHeadJs, org::sem::SubtreeLogHead> {
  using SharedPtrWrapBase<SubtreeLogHeadJs, org::sem::SubtreeLogHead>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::*)(org::sem::SubtreeLogHead const&) const>(&org::sem::SubtreeLogHead::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::SubtreeLogHead>{"other"})));
  }
  Napi::Value isPriority(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::*)() const>(&org::sem::SubtreeLogHead::isPriority),
                                        std::make_tuple()));
  }
  Napi::Value getPriorityMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::SubtreeLogHead::Priority&(org::sem::SubtreeLogHead::*)()>(&org::sem::SubtreeLogHead::getPriority),
                                   std::make_tuple()));
  }
  Napi::Value isNote(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::*)() const>(&org::sem::SubtreeLogHead::isNote),
                                        std::make_tuple()));
  }
  Napi::Value getNoteMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::SubtreeLogHead::Note&(org::sem::SubtreeLogHead::*)()>(&org::sem::SubtreeLogHead::getNote),
                                   std::make_tuple()));
  }
  Napi::Value isRefile(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::*)() const>(&org::sem::SubtreeLogHead::isRefile),
                                        std::make_tuple()));
  }
  Napi::Value getRefileMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::SubtreeLogHead::Refile&(org::sem::SubtreeLogHead::*)()>(&org::sem::SubtreeLogHead::getRefile),
                                   std::make_tuple()));
  }
  Napi::Value isClock(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::*)() const>(&org::sem::SubtreeLogHead::isClock),
                                        std::make_tuple()));
  }
  Napi::Value getClockMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::SubtreeLogHead::Clock&(org::sem::SubtreeLogHead::*)()>(&org::sem::SubtreeLogHead::getClock),
                                   std::make_tuple()));
  }
  Napi::Value isState(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::*)() const>(&org::sem::SubtreeLogHead::isState),
                                        std::make_tuple()));
  }
  Napi::Value getStateMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::SubtreeLogHead::State&(org::sem::SubtreeLogHead::*)()>(&org::sem::SubtreeLogHead::getState),
                                   std::make_tuple()));
  }
  Napi::Value isDeadline(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::*)() const>(&org::sem::SubtreeLogHead::isDeadline),
                                        std::make_tuple()));
  }
  Napi::Value getDeadlineMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::SubtreeLogHead::Deadline&(org::sem::SubtreeLogHead::*)()>(&org::sem::SubtreeLogHead::getDeadline),
                                   std::make_tuple()));
  }
  Napi::Value isSchedule(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::*)() const>(&org::sem::SubtreeLogHead::isSchedule),
                                        std::make_tuple()));
  }
  Napi::Value getScheduleMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::SubtreeLogHead::Schedule&(org::sem::SubtreeLogHead::*)()>(&org::sem::SubtreeLogHead::getSchedule),
                                   std::make_tuple()));
  }
  Napi::Value isTag(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::*)() const>(&org::sem::SubtreeLogHead::isTag),
                                        std::make_tuple()));
  }
  Napi::Value getTagMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::SubtreeLogHead::Tag&(org::sem::SubtreeLogHead::*)()>(&org::sem::SubtreeLogHead::getTag),
                                   std::make_tuple()));
  }
  Napi::Value isUnknown(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::*)() const>(&org::sem::SubtreeLogHead::isUnknown),
                                        std::make_tuple()));
  }
  Napi::Value getUnknownMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::SubtreeLogHead::Unknown&(org::sem::SubtreeLogHead::*)()>(&org::sem::SubtreeLogHead::getUnknown),
                                   std::make_tuple()));
  }
  Napi::Value getLogKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SubtreeLogHead::Kind(org::sem::SubtreeLogHead::*)() const>(&org::sem::SubtreeLogHead::getLogKind),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_kind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SubtreeLogHead::Kind(org::sem::SubtreeLogHead::*)() const>(&org::sem::SubtreeLogHead::sub_variant_get_kind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "SubtreeLogHeadJs", {InstanceMethod("operator==", &SubtreeLogHeadJs::operator==),
                                                                                                                           InstanceMethod("isPriority", &SubtreeLogHeadJs::isPriority),
                                                                                                                           InstanceMethod("getPriorityMut", &SubtreeLogHeadJs::getPriorityMut),
                                                                                                                           InstanceMethod("isNote", &SubtreeLogHeadJs::isNote),
                                                                                                                           InstanceMethod("getNoteMut", &SubtreeLogHeadJs::getNoteMut),
                                                                                                                           InstanceMethod("isRefile", &SubtreeLogHeadJs::isRefile),
                                                                                                                           InstanceMethod("getRefileMut", &SubtreeLogHeadJs::getRefileMut),
                                                                                                                           InstanceMethod("isClock", &SubtreeLogHeadJs::isClock),
                                                                                                                           InstanceMethod("getClockMut", &SubtreeLogHeadJs::getClockMut),
                                                                                                                           InstanceMethod("isState", &SubtreeLogHeadJs::isState),
                                                                                                                           InstanceMethod("getStateMut", &SubtreeLogHeadJs::getStateMut),
                                                                                                                           InstanceMethod("isDeadline", &SubtreeLogHeadJs::isDeadline),
                                                                                                                           InstanceMethod("getDeadlineMut", &SubtreeLogHeadJs::getDeadlineMut),
                                                                                                                           InstanceMethod("isSchedule", &SubtreeLogHeadJs::isSchedule),
                                                                                                                           InstanceMethod("getScheduleMut", &SubtreeLogHeadJs::getScheduleMut),
                                                                                                                           InstanceMethod("isTag", &SubtreeLogHeadJs::isTag),
                                                                                                                           InstanceMethod("getTagMut", &SubtreeLogHeadJs::getTagMut),
                                                                                                                           InstanceMethod("isUnknown", &SubtreeLogHeadJs::isUnknown),
                                                                                                                           InstanceMethod("getUnknownMut", &SubtreeLogHeadJs::getUnknownMut),
                                                                                                                           InstanceMethod("getLogKind", &SubtreeLogHeadJs::getLogKind),
                                                                                                                           InstanceMethod("sub_variant_get_kind", &SubtreeLogHeadJs::sub_variant_get_kind)}); }
};

template <>
struct js_to_org_type<SubtreeLogHeadJs> {
  using type = org::sem::SubtreeLogHead;
};

template <>
struct org_to_js_type<org::sem::SubtreeLogHead> {
  using type = SubtreeLogHeadJs;
};

struct PrioritySubtreeLogHeadJs : public SharedPtrWrapBase<PrioritySubtreeLogHeadJs, org::sem::SubtreeLogHead::Priority> {
  using SharedPtrWrapBase<PrioritySubtreeLogHeadJs, org::sem::SubtreeLogHead::Priority>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::Priority::*)(org::sem::SubtreeLogHead::Priority const&) const>(&org::sem::SubtreeLogHead::Priority::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::SubtreeLogHead::Priority>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "PrioritySubtreeLogHeadJs", {InstanceMethod("operator==", &PrioritySubtreeLogHeadJs::operator==)}); }
};

template <>
struct js_to_org_type<PrioritySubtreeLogHeadJs> {
  using type = org::sem::SubtreeLogHead::Priority;
};

template <>
struct org_to_js_type<org::sem::SubtreeLogHead::Priority> {
  using type = PrioritySubtreeLogHeadJs;
};

struct NoteSubtreeLogHeadJs : public SharedPtrWrapBase<NoteSubtreeLogHeadJs, org::sem::SubtreeLogHead::Note> {
  using SharedPtrWrapBase<NoteSubtreeLogHeadJs, org::sem::SubtreeLogHead::Note>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::Note::*)(org::sem::SubtreeLogHead::Note const&) const>(&org::sem::SubtreeLogHead::Note::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::SubtreeLogHead::Note>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "NoteSubtreeLogHeadJs", {InstanceMethod("operator==", &NoteSubtreeLogHeadJs::operator==)}); }
};

template <>
struct js_to_org_type<NoteSubtreeLogHeadJs> {
  using type = org::sem::SubtreeLogHead::Note;
};

template <>
struct org_to_js_type<org::sem::SubtreeLogHead::Note> {
  using type = NoteSubtreeLogHeadJs;
};

struct RefileSubtreeLogHeadJs : public SharedPtrWrapBase<RefileSubtreeLogHeadJs, org::sem::SubtreeLogHead::Refile> {
  using SharedPtrWrapBase<RefileSubtreeLogHeadJs, org::sem::SubtreeLogHead::Refile>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::Refile::*)(org::sem::SubtreeLogHead::Refile const&) const>(&org::sem::SubtreeLogHead::Refile::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::SubtreeLogHead::Refile>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "RefileSubtreeLogHeadJs", {InstanceMethod("operator==", &RefileSubtreeLogHeadJs::operator==)}); }
};

template <>
struct js_to_org_type<RefileSubtreeLogHeadJs> {
  using type = org::sem::SubtreeLogHead::Refile;
};

template <>
struct org_to_js_type<org::sem::SubtreeLogHead::Refile> {
  using type = RefileSubtreeLogHeadJs;
};

struct ClockSubtreeLogHeadJs : public SharedPtrWrapBase<ClockSubtreeLogHeadJs, org::sem::SubtreeLogHead::Clock> {
  using SharedPtrWrapBase<ClockSubtreeLogHeadJs, org::sem::SubtreeLogHead::Clock>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::Clock::*)(org::sem::SubtreeLogHead::Clock const&) const>(&org::sem::SubtreeLogHead::Clock::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::SubtreeLogHead::Clock>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ClockSubtreeLogHeadJs", {InstanceMethod("operator==", &ClockSubtreeLogHeadJs::operator==)}); }
};

template <>
struct js_to_org_type<ClockSubtreeLogHeadJs> {
  using type = org::sem::SubtreeLogHead::Clock;
};

template <>
struct org_to_js_type<org::sem::SubtreeLogHead::Clock> {
  using type = ClockSubtreeLogHeadJs;
};

struct StateSubtreeLogHeadJs : public SharedPtrWrapBase<StateSubtreeLogHeadJs, org::sem::SubtreeLogHead::State> {
  using SharedPtrWrapBase<StateSubtreeLogHeadJs, org::sem::SubtreeLogHead::State>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::State::*)(org::sem::SubtreeLogHead::State const&) const>(&org::sem::SubtreeLogHead::State::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::SubtreeLogHead::State>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "StateSubtreeLogHeadJs", {InstanceMethod("operator==", &StateSubtreeLogHeadJs::operator==)}); }
};

template <>
struct js_to_org_type<StateSubtreeLogHeadJs> {
  using type = org::sem::SubtreeLogHead::State;
};

template <>
struct org_to_js_type<org::sem::SubtreeLogHead::State> {
  using type = StateSubtreeLogHeadJs;
};

struct DeadlineSubtreeLogHeadJs : public SharedPtrWrapBase<DeadlineSubtreeLogHeadJs, org::sem::SubtreeLogHead::Deadline> {
  using SharedPtrWrapBase<DeadlineSubtreeLogHeadJs, org::sem::SubtreeLogHead::Deadline>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::Deadline::*)(org::sem::SubtreeLogHead::Deadline const&) const>(&org::sem::SubtreeLogHead::Deadline::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::SubtreeLogHead::Deadline>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "DeadlineSubtreeLogHeadJs", {InstanceMethod("operator==", &DeadlineSubtreeLogHeadJs::operator==)}); }
};

template <>
struct js_to_org_type<DeadlineSubtreeLogHeadJs> {
  using type = org::sem::SubtreeLogHead::Deadline;
};

template <>
struct org_to_js_type<org::sem::SubtreeLogHead::Deadline> {
  using type = DeadlineSubtreeLogHeadJs;
};

struct ScheduleSubtreeLogHeadJs : public SharedPtrWrapBase<ScheduleSubtreeLogHeadJs, org::sem::SubtreeLogHead::Schedule> {
  using SharedPtrWrapBase<ScheduleSubtreeLogHeadJs, org::sem::SubtreeLogHead::Schedule>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::Schedule::*)(org::sem::SubtreeLogHead::Schedule const&) const>(&org::sem::SubtreeLogHead::Schedule::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::SubtreeLogHead::Schedule>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ScheduleSubtreeLogHeadJs", {InstanceMethod("operator==", &ScheduleSubtreeLogHeadJs::operator==)}); }
};

template <>
struct js_to_org_type<ScheduleSubtreeLogHeadJs> {
  using type = org::sem::SubtreeLogHead::Schedule;
};

template <>
struct org_to_js_type<org::sem::SubtreeLogHead::Schedule> {
  using type = ScheduleSubtreeLogHeadJs;
};

struct TagSubtreeLogHeadJs : public SharedPtrWrapBase<TagSubtreeLogHeadJs, org::sem::SubtreeLogHead::Tag> {
  using SharedPtrWrapBase<TagSubtreeLogHeadJs, org::sem::SubtreeLogHead::Tag>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::Tag::*)(org::sem::SubtreeLogHead::Tag const&) const>(&org::sem::SubtreeLogHead::Tag::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::SubtreeLogHead::Tag>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "TagSubtreeLogHeadJs", {InstanceMethod("operator==", &TagSubtreeLogHeadJs::operator==)}); }
};

template <>
struct js_to_org_type<TagSubtreeLogHeadJs> {
  using type = org::sem::SubtreeLogHead::Tag;
};

template <>
struct org_to_js_type<org::sem::SubtreeLogHead::Tag> {
  using type = TagSubtreeLogHeadJs;
};

struct UnknownSubtreeLogHeadJs : public SharedPtrWrapBase<UnknownSubtreeLogHeadJs, org::sem::SubtreeLogHead::Unknown> {
  using SharedPtrWrapBase<UnknownSubtreeLogHeadJs, org::sem::SubtreeLogHead::Unknown>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLogHead::Unknown::*)(org::sem::SubtreeLogHead::Unknown const&) const>(&org::sem::SubtreeLogHead::Unknown::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::SubtreeLogHead::Unknown>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "UnknownSubtreeLogHeadJs", {InstanceMethod("operator==", &UnknownSubtreeLogHeadJs::operator==)}); }
};

template <>
struct js_to_org_type<UnknownSubtreeLogHeadJs> {
  using type = org::sem::SubtreeLogHead::Unknown;
};

template <>
struct org_to_js_type<org::sem::SubtreeLogHead::Unknown> {
  using type = UnknownSubtreeLogHeadJs;
};

struct SubtreeCompletionJs : public SharedPtrWrapBase<SubtreeCompletionJs, org::sem::SubtreeCompletion> {
  using SharedPtrWrapBase<SubtreeCompletionJs, org::sem::SubtreeCompletion>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeCompletion::*)(org::sem::SubtreeCompletion const&) const>(&org::sem::SubtreeCompletion::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::SubtreeCompletion>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "SubtreeCompletionJs", {InstanceMethod("operator==", &SubtreeCompletionJs::operator==)}); }
};

template <>
struct js_to_org_type<SubtreeCompletionJs> {
  using type = org::sem::SubtreeCompletion;
};

template <>
struct org_to_js_type<org::sem::SubtreeCompletion> {
  using type = SubtreeCompletionJs;
};

struct AttrListJs : public SharedPtrWrapBase<AttrListJs, org::sem::AttrList> {
  using SharedPtrWrapBase<AttrListJs, org::sem::AttrList>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::AttrList::*)(org::sem::AttrList const&) const>(&org::sem::AttrList::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::AttrList>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "AttrListJs", {InstanceMethod("operator==", &AttrListJs::operator==)}); }
};

template <>
struct js_to_org_type<AttrListJs> {
  using type = org::sem::AttrList;
};

template <>
struct org_to_js_type<org::sem::AttrList> {
  using type = AttrListJs;
};

struct AttrGroupJs : public SharedPtrWrapBase<AttrGroupJs, org::sem::AttrGroup> {
  using SharedPtrWrapBase<AttrGroupJs, org::sem::AttrGroup>::SharedPtrWrapBase;
  Napi::Value getFlatArgs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::AttrGroup::*)() const>(&org::sem::AttrGroup::getFlatArgs),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::AttrGroup::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::AttrGroup::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value setNamedAttr(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::AttrGroup::*)(hstd::Str const&, hstd::Vec<org::sem::AttrValue> const&)>(&org::sem::AttrGroup::setNamedAttr),
                                   std::make_tuple(CxxArgSpec<hstd::Str>{"key"},
                                                   CxxArgSpec<hstd::Vec<org::sem::AttrValue>>{"attrs"})));
  }
  Napi::Value setPositionalAttr(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::AttrGroup::*)(hstd::Vec<org::sem::AttrValue> const&)>(&org::sem::AttrGroup::setPositionalAttr),
                                   std::make_tuple(CxxArgSpec<hstd::Vec<org::sem::AttrValue>>{"items"})));
  }
  Napi::Value getPositionalSize(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::AttrGroup::*)() const>(&org::sem::AttrGroup::getPositionalSize),
                                        std::make_tuple()));
  }
  Napi::Value getNamedSize(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::AttrGroup::*)() const>(&org::sem::AttrGroup::getNamedSize),
                                        std::make_tuple()));
  }
  Napi::Value isEmpty(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::AttrGroup::*)() const>(&org::sem::AttrGroup::isEmpty),
                                        std::make_tuple()));
  }
  Napi::Value getAll(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrList(org::sem::AttrGroup::*)() const>(&org::sem::AttrGroup::getAll),
                                        std::make_tuple()));
  }
  Napi::Value atPositional(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrValue const&(org::sem::AttrGroup::*)(int) const>(&org::sem::AttrGroup::atPositional),
                                        std::make_tuple(CxxArgSpec<int>{"index"})));
  }
  Napi::Value getPositional(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::AttrGroup::*)(int) const>(&org::sem::AttrGroup::getPositional),
                                        std::make_tuple(CxxArgSpec<int>{"index"})));
  }
  Napi::Value atNamed(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrList const&(org::sem::AttrGroup::*)(hstd::Str const&) const>(&org::sem::AttrGroup::atNamed),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"index"})));
  }
  Napi::Value getNamed(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrList>(org::sem::AttrGroup::*)(hstd::Str const&) const>(&org::sem::AttrGroup::getNamed),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"index"})));
  }
  Napi::Value atFirstNamed(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrValue const&(org::sem::AttrGroup::*)(hstd::Str const&) const>(&org::sem::AttrGroup::atFirstNamed),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"index"})));
  }
  Napi::Value getFirstNamed(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::AttrGroup::*)(hstd::Str const&) const>(&org::sem::AttrGroup::getFirstNamed),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"index"})));
  }
  Napi::Value atVarNamed(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrList(org::sem::AttrGroup::*)(hstd::Str const&) const>(&org::sem::AttrGroup::atVarNamed),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"index"})));
  }
  Napi::Value getVarNamed(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrList>(org::sem::AttrGroup::*)(hstd::Str const&) const>(&org::sem::AttrGroup::getVarNamed),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"index"})));
  }
  Napi::Value atFirstVarNamed(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrValue(org::sem::AttrGroup::*)(hstd::Str const&) const>(&org::sem::AttrGroup::atFirstVarNamed),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"index"})));
  }
  Napi::Value getFirstVarNamed(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::AttrGroup::*)(hstd::Str const&) const>(&org::sem::AttrGroup::getFirstVarNamed),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"index"})));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::AttrGroup::*)(org::sem::AttrGroup const&) const>(&org::sem::AttrGroup::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::AttrGroup>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "AttrGroupJs", {InstanceMethod("getFlatArgs", &AttrGroupJs::getFlatArgs),
                                                                                                                      InstanceMethod("getAttrs", &AttrGroupJs::getAttrs),
                                                                                                                      InstanceMethod("setNamedAttr", &AttrGroupJs::setNamedAttr),
                                                                                                                      InstanceMethod("setPositionalAttr", &AttrGroupJs::setPositionalAttr),
                                                                                                                      InstanceMethod("getPositionalSize", &AttrGroupJs::getPositionalSize),
                                                                                                                      InstanceMethod("getNamedSize", &AttrGroupJs::getNamedSize),
                                                                                                                      InstanceMethod("isEmpty", &AttrGroupJs::isEmpty),
                                                                                                                      InstanceMethod("getAll", &AttrGroupJs::getAll),
                                                                                                                      InstanceMethod("atPositional", &AttrGroupJs::atPositional),
                                                                                                                      InstanceMethod("getPositional", &AttrGroupJs::getPositional),
                                                                                                                      InstanceMethod("atNamed", &AttrGroupJs::atNamed),
                                                                                                                      InstanceMethod("getNamed", &AttrGroupJs::getNamed),
                                                                                                                      InstanceMethod("atFirstNamed", &AttrGroupJs::atFirstNamed),
                                                                                                                      InstanceMethod("getFirstNamed", &AttrGroupJs::getFirstNamed),
                                                                                                                      InstanceMethod("atVarNamed", &AttrGroupJs::atVarNamed),
                                                                                                                      InstanceMethod("getVarNamed", &AttrGroupJs::getVarNamed),
                                                                                                                      InstanceMethod("atFirstVarNamed", &AttrGroupJs::atFirstVarNamed),
                                                                                                                      InstanceMethod("getFirstVarNamed", &AttrGroupJs::getFirstVarNamed),
                                                                                                                      InstanceMethod("operator==", &AttrGroupJs::operator==)}); }
};

template <>
struct js_to_org_type<AttrGroupJs> {
  using type = org::sem::AttrGroup;
};

template <>
struct org_to_js_type<org::sem::AttrGroup> {
  using type = AttrGroupJs;
};

struct OrgCodeEvalInputJs : public SharedPtrWrapBase<OrgCodeEvalInputJs, org::sem::OrgCodeEvalInput> {
  using SharedPtrWrapBase<OrgCodeEvalInputJs, org::sem::OrgCodeEvalInput>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::OrgCodeEvalInput::*)(org::sem::OrgCodeEvalInput const&) const>(&org::sem::OrgCodeEvalInput::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::OrgCodeEvalInput>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "OrgCodeEvalInputJs", {InstanceMethod("operator==", &OrgCodeEvalInputJs::operator==)}); }
};

template <>
struct js_to_org_type<OrgCodeEvalInputJs> {
  using type = org::sem::OrgCodeEvalInput;
};

template <>
struct org_to_js_type<org::sem::OrgCodeEvalInput> {
  using type = OrgCodeEvalInputJs;
};

struct VarOrgCodeEvalInputJs : public SharedPtrWrapBase<VarOrgCodeEvalInputJs, org::sem::OrgCodeEvalInput::Var> {
  using SharedPtrWrapBase<VarOrgCodeEvalInputJs, org::sem::OrgCodeEvalInput::Var>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::OrgCodeEvalInput::Var::*)(org::sem::OrgCodeEvalInput::Var const&) const>(&org::sem::OrgCodeEvalInput::Var::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::OrgCodeEvalInput::Var>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "VarOrgCodeEvalInputJs", {InstanceMethod("operator==", &VarOrgCodeEvalInputJs::operator==)}); }
};

template <>
struct js_to_org_type<VarOrgCodeEvalInputJs> {
  using type = org::sem::OrgCodeEvalInput::Var;
};

template <>
struct org_to_js_type<org::sem::OrgCodeEvalInput::Var> {
  using type = VarOrgCodeEvalInputJs;
};

struct OrgCodeEvalOutputJs : public SharedPtrWrapBase<OrgCodeEvalOutputJs, org::sem::OrgCodeEvalOutput> {
  using SharedPtrWrapBase<OrgCodeEvalOutputJs, org::sem::OrgCodeEvalOutput>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::OrgCodeEvalOutput::*)(org::sem::OrgCodeEvalOutput const&) const>(&org::sem::OrgCodeEvalOutput::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::OrgCodeEvalOutput>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "OrgCodeEvalOutputJs", {InstanceMethod("operator==", &OrgCodeEvalOutputJs::operator==)}); }
};

template <>
struct js_to_org_type<OrgCodeEvalOutputJs> {
  using type = org::sem::OrgCodeEvalOutput;
};

template <>
struct org_to_js_type<org::sem::OrgCodeEvalOutput> {
  using type = OrgCodeEvalOutputJs;
};

struct ColumnViewJs : public SharedPtrWrapBase<ColumnViewJs, org::sem::ColumnView> {
  using SharedPtrWrapBase<ColumnViewJs, org::sem::ColumnView>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ColumnView::*)(org::sem::ColumnView const&) const>(&org::sem::ColumnView::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::ColumnView>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ColumnViewJs", {InstanceMethod("operator==", &ColumnViewJs::operator==)}); }
};

template <>
struct js_to_org_type<ColumnViewJs> {
  using type = org::sem::ColumnView;
};

template <>
struct org_to_js_type<org::sem::ColumnView> {
  using type = ColumnViewJs;
};

struct SummaryColumnViewJs : public SharedPtrWrapBase<SummaryColumnViewJs, org::sem::ColumnView::Summary> {
  using SharedPtrWrapBase<SummaryColumnViewJs, org::sem::ColumnView::Summary>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ColumnView::Summary::*)(org::sem::ColumnView::Summary const&) const>(&org::sem::ColumnView::Summary::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::ColumnView::Summary>{"other"})));
  }
  Napi::Value isCheckboxAggregate(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ColumnView::Summary::*)() const>(&org::sem::ColumnView::Summary::isCheckboxAggregate),
                                        std::make_tuple()));
  }
  Napi::Value getCheckboxAggregateMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::ColumnView::Summary::CheckboxAggregate&(org::sem::ColumnView::Summary::*)()>(&org::sem::ColumnView::Summary::getCheckboxAggregate),
                                   std::make_tuple()));
  }
  Napi::Value isMathAggregate(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ColumnView::Summary::*)() const>(&org::sem::ColumnView::Summary::isMathAggregate),
                                        std::make_tuple()));
  }
  Napi::Value getMathAggregateMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::ColumnView::Summary::MathAggregate&(org::sem::ColumnView::Summary::*)()>(&org::sem::ColumnView::Summary::getMathAggregate),
                                   std::make_tuple()));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::ColumnView::Summary::Kind(org::sem::ColumnView::Summary::*)() const>(&org::sem::ColumnView::Summary::getKind),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_kind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::ColumnView::Summary::Kind(org::sem::ColumnView::Summary::*)() const>(&org::sem::ColumnView::Summary::sub_variant_get_kind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "SummaryColumnViewJs", {InstanceMethod("operator==", &SummaryColumnViewJs::operator==),
                                                                                                                              InstanceMethod("isCheckboxAggregate", &SummaryColumnViewJs::isCheckboxAggregate),
                                                                                                                              InstanceMethod("getCheckboxAggregateMut", &SummaryColumnViewJs::getCheckboxAggregateMut),
                                                                                                                              InstanceMethod("isMathAggregate", &SummaryColumnViewJs::isMathAggregate),
                                                                                                                              InstanceMethod("getMathAggregateMut", &SummaryColumnViewJs::getMathAggregateMut),
                                                                                                                              InstanceMethod("getKind", &SummaryColumnViewJs::getKind),
                                                                                                                              InstanceMethod("sub_variant_get_kind", &SummaryColumnViewJs::sub_variant_get_kind)}); }
};

template <>
struct js_to_org_type<SummaryColumnViewJs> {
  using type = org::sem::ColumnView::Summary;
};

template <>
struct org_to_js_type<org::sem::ColumnView::Summary> {
  using type = SummaryColumnViewJs;
};

struct CheckboxAggregateColumnViewSummaryJs : public SharedPtrWrapBase<CheckboxAggregateColumnViewSummaryJs, org::sem::ColumnView::Summary::CheckboxAggregate> {
  using SharedPtrWrapBase<CheckboxAggregateColumnViewSummaryJs, org::sem::ColumnView::Summary::CheckboxAggregate>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ColumnView::Summary::CheckboxAggregate::*)(org::sem::ColumnView::Summary::CheckboxAggregate const&) const>(&org::sem::ColumnView::Summary::CheckboxAggregate::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::ColumnView::Summary::CheckboxAggregate>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "CheckboxAggregateColumnViewSummaryJs", {InstanceMethod("operator==", &CheckboxAggregateColumnViewSummaryJs::operator==)}); }
};

template <>
struct js_to_org_type<CheckboxAggregateColumnViewSummaryJs> {
  using type = org::sem::ColumnView::Summary::CheckboxAggregate;
};

template <>
struct org_to_js_type<org::sem::ColumnView::Summary::CheckboxAggregate> {
  using type = CheckboxAggregateColumnViewSummaryJs;
};

struct MathAggregateColumnViewSummaryJs : public SharedPtrWrapBase<MathAggregateColumnViewSummaryJs, org::sem::ColumnView::Summary::MathAggregate> {
  using SharedPtrWrapBase<MathAggregateColumnViewSummaryJs, org::sem::ColumnView::Summary::MathAggregate>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ColumnView::Summary::MathAggregate::*)(org::sem::ColumnView::Summary::MathAggregate const&) const>(&org::sem::ColumnView::Summary::MathAggregate::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::ColumnView::Summary::MathAggregate>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "MathAggregateColumnViewSummaryJs", {InstanceMethod("operator==", &MathAggregateColumnViewSummaryJs::operator==)}); }
};

template <>
struct js_to_org_type<MathAggregateColumnViewSummaryJs> {
  using type = org::sem::ColumnView::Summary::MathAggregate;
};

template <>
struct org_to_js_type<org::sem::ColumnView::Summary::MathAggregate> {
  using type = MathAggregateColumnViewSummaryJs;
};

struct ColumnColumnViewJs : public SharedPtrWrapBase<ColumnColumnViewJs, org::sem::ColumnView::Column> {
  using SharedPtrWrapBase<ColumnColumnViewJs, org::sem::ColumnView::Column>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ColumnView::Column::*)(org::sem::ColumnView::Column const&) const>(&org::sem::ColumnView::Column::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::ColumnView::Column>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ColumnColumnViewJs", {InstanceMethod("operator==", &ColumnColumnViewJs::operator==)}); }
};

template <>
struct js_to_org_type<ColumnColumnViewJs> {
  using type = org::sem::ColumnView::Column;
};

template <>
struct org_to_js_type<org::sem::ColumnView::Column> {
  using type = ColumnColumnViewJs;
};

struct BlockCodeLineJs : public SharedPtrWrapBase<BlockCodeLineJs, org::sem::BlockCodeLine> {
  using SharedPtrWrapBase<BlockCodeLineJs, org::sem::BlockCodeLine>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockCodeLine::*)(org::sem::BlockCodeLine const&) const>(&org::sem::BlockCodeLine::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::BlockCodeLine>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "BlockCodeLineJs", {InstanceMethod("operator==", &BlockCodeLineJs::operator==)}); }
};

template <>
struct js_to_org_type<BlockCodeLineJs> {
  using type = org::sem::BlockCodeLine;
};

template <>
struct org_to_js_type<org::sem::BlockCodeLine> {
  using type = BlockCodeLineJs;
};

struct PartBlockCodeLineJs : public SharedPtrWrapBase<PartBlockCodeLineJs, org::sem::BlockCodeLine::Part> {
  using SharedPtrWrapBase<PartBlockCodeLineJs, org::sem::BlockCodeLine::Part>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockCodeLine::Part::*)(org::sem::BlockCodeLine::Part const&) const>(&org::sem::BlockCodeLine::Part::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::BlockCodeLine::Part>{"other"})));
  }
  Napi::Value isRaw(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockCodeLine::Part::*)() const>(&org::sem::BlockCodeLine::Part::isRaw),
                                        std::make_tuple()));
  }
  Napi::Value getRawMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::BlockCodeLine::Part::Raw&(org::sem::BlockCodeLine::Part::*)()>(&org::sem::BlockCodeLine::Part::getRaw),
                                   std::make_tuple()));
  }
  Napi::Value isCallout(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockCodeLine::Part::*)() const>(&org::sem::BlockCodeLine::Part::isCallout),
                                        std::make_tuple()));
  }
  Napi::Value getCalloutMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::BlockCodeLine::Part::Callout&(org::sem::BlockCodeLine::Part::*)()>(&org::sem::BlockCodeLine::Part::getCallout),
                                   std::make_tuple()));
  }
  Napi::Value isTangle(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockCodeLine::Part::*)() const>(&org::sem::BlockCodeLine::Part::isTangle),
                                        std::make_tuple()));
  }
  Napi::Value getTangleMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::BlockCodeLine::Part::Tangle&(org::sem::BlockCodeLine::Part::*)()>(&org::sem::BlockCodeLine::Part::getTangle),
                                   std::make_tuple()));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::BlockCodeLine::Part::Kind(org::sem::BlockCodeLine::Part::*)() const>(&org::sem::BlockCodeLine::Part::getKind),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_kind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::BlockCodeLine::Part::Kind(org::sem::BlockCodeLine::Part::*)() const>(&org::sem::BlockCodeLine::Part::sub_variant_get_kind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "PartBlockCodeLineJs", {InstanceMethod("operator==", &PartBlockCodeLineJs::operator==),
                                                                                                                              InstanceMethod("isRaw", &PartBlockCodeLineJs::isRaw),
                                                                                                                              InstanceMethod("getRawMut", &PartBlockCodeLineJs::getRawMut),
                                                                                                                              InstanceMethod("isCallout", &PartBlockCodeLineJs::isCallout),
                                                                                                                              InstanceMethod("getCalloutMut", &PartBlockCodeLineJs::getCalloutMut),
                                                                                                                              InstanceMethod("isTangle", &PartBlockCodeLineJs::isTangle),
                                                                                                                              InstanceMethod("getTangleMut", &PartBlockCodeLineJs::getTangleMut),
                                                                                                                              InstanceMethod("getKind", &PartBlockCodeLineJs::getKind),
                                                                                                                              InstanceMethod("sub_variant_get_kind", &PartBlockCodeLineJs::sub_variant_get_kind)}); }
};

template <>
struct js_to_org_type<PartBlockCodeLineJs> {
  using type = org::sem::BlockCodeLine::Part;
};

template <>
struct org_to_js_type<org::sem::BlockCodeLine::Part> {
  using type = PartBlockCodeLineJs;
};

struct RawBlockCodeLinePartJs : public SharedPtrWrapBase<RawBlockCodeLinePartJs, org::sem::BlockCodeLine::Part::Raw> {
  using SharedPtrWrapBase<RawBlockCodeLinePartJs, org::sem::BlockCodeLine::Part::Raw>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockCodeLine::Part::Raw::*)(org::sem::BlockCodeLine::Part::Raw const&) const>(&org::sem::BlockCodeLine::Part::Raw::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::BlockCodeLine::Part::Raw>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "RawBlockCodeLinePartJs", {InstanceMethod("operator==", &RawBlockCodeLinePartJs::operator==)}); }
};

template <>
struct js_to_org_type<RawBlockCodeLinePartJs> {
  using type = org::sem::BlockCodeLine::Part::Raw;
};

template <>
struct org_to_js_type<org::sem::BlockCodeLine::Part::Raw> {
  using type = RawBlockCodeLinePartJs;
};

struct CalloutBlockCodeLinePartJs : public SharedPtrWrapBase<CalloutBlockCodeLinePartJs, org::sem::BlockCodeLine::Part::Callout> {
  using SharedPtrWrapBase<CalloutBlockCodeLinePartJs, org::sem::BlockCodeLine::Part::Callout>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockCodeLine::Part::Callout::*)(org::sem::BlockCodeLine::Part::Callout const&) const>(&org::sem::BlockCodeLine::Part::Callout::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::BlockCodeLine::Part::Callout>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "CalloutBlockCodeLinePartJs", {InstanceMethod("operator==", &CalloutBlockCodeLinePartJs::operator==)}); }
};

template <>
struct js_to_org_type<CalloutBlockCodeLinePartJs> {
  using type = org::sem::BlockCodeLine::Part::Callout;
};

template <>
struct org_to_js_type<org::sem::BlockCodeLine::Part::Callout> {
  using type = CalloutBlockCodeLinePartJs;
};

struct TangleBlockCodeLinePartJs : public SharedPtrWrapBase<TangleBlockCodeLinePartJs, org::sem::BlockCodeLine::Part::Tangle> {
  using SharedPtrWrapBase<TangleBlockCodeLinePartJs, org::sem::BlockCodeLine::Part::Tangle>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockCodeLine::Part::Tangle::*)(org::sem::BlockCodeLine::Part::Tangle const&) const>(&org::sem::BlockCodeLine::Part::Tangle::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::BlockCodeLine::Part::Tangle>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "TangleBlockCodeLinePartJs", {InstanceMethod("operator==", &TangleBlockCodeLinePartJs::operator==)}); }
};

template <>
struct js_to_org_type<TangleBlockCodeLinePartJs> {
  using type = org::sem::BlockCodeLine::Part::Tangle;
};

template <>
struct org_to_js_type<org::sem::BlockCodeLine::Part::Tangle> {
  using type = TangleBlockCodeLinePartJs;
};

struct DocumentExportConfigJs : public SharedPtrWrapBase<DocumentExportConfigJs, org::sem::DocumentExportConfig> {
  using SharedPtrWrapBase<DocumentExportConfigJs, org::sem::DocumentExportConfig>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::DocumentExportConfig::*)(org::sem::DocumentExportConfig const&) const>(&org::sem::DocumentExportConfig::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::DocumentExportConfig>{"other"})));
  }
  Napi::Value isDoExport(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::DocumentExportConfig::*)() const>(&org::sem::DocumentExportConfig::isDoExport),
                                        std::make_tuple()));
  }
  Napi::Value getDoExportMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::DocumentExportConfig::DoExport&(org::sem::DocumentExportConfig::*)()>(&org::sem::DocumentExportConfig::getDoExport),
                                   std::make_tuple()));
  }
  Napi::Value isExportFixed(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::DocumentExportConfig::*)() const>(&org::sem::DocumentExportConfig::isExportFixed),
                                        std::make_tuple()));
  }
  Napi::Value getExportFixedMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::DocumentExportConfig::ExportFixed&(org::sem::DocumentExportConfig::*)()>(&org::sem::DocumentExportConfig::getExportFixed),
                                   std::make_tuple()));
  }
  Napi::Value getTocExportKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::DocumentExportConfig::TocExportKind(org::sem::DocumentExportConfig::*)() const>(&org::sem::DocumentExportConfig::getTocExportKind),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_kind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::DocumentExportConfig::TocExportKind(org::sem::DocumentExportConfig::*)() const>(&org::sem::DocumentExportConfig::sub_variant_get_kind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "DocumentExportConfigJs", {InstanceMethod("operator==", &DocumentExportConfigJs::operator==),
                                                                                                                                 InstanceMethod("isDoExport", &DocumentExportConfigJs::isDoExport),
                                                                                                                                 InstanceMethod("getDoExportMut", &DocumentExportConfigJs::getDoExportMut),
                                                                                                                                 InstanceMethod("isExportFixed", &DocumentExportConfigJs::isExportFixed),
                                                                                                                                 InstanceMethod("getExportFixedMut", &DocumentExportConfigJs::getExportFixedMut),
                                                                                                                                 InstanceMethod("getTocExportKind", &DocumentExportConfigJs::getTocExportKind),
                                                                                                                                 InstanceMethod("sub_variant_get_kind", &DocumentExportConfigJs::sub_variant_get_kind)}); }
};

template <>
struct js_to_org_type<DocumentExportConfigJs> {
  using type = org::sem::DocumentExportConfig;
};

template <>
struct org_to_js_type<org::sem::DocumentExportConfig> {
  using type = DocumentExportConfigJs;
};

struct TaskExportDocumentExportConfigJs : public SharedPtrWrapBase<TaskExportDocumentExportConfigJs, org::sem::DocumentExportConfig::TaskExport> {
  using SharedPtrWrapBase<TaskExportDocumentExportConfigJs, org::sem::DocumentExportConfig::TaskExport>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::DocumentExportConfig::TaskExport::*)(org::sem::DocumentExportConfig::TaskExport const&) const>(&org::sem::DocumentExportConfig::TaskExport::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::DocumentExportConfig::TaskExport>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "TaskExportDocumentExportConfigJs", {InstanceMethod("operator==", &TaskExportDocumentExportConfigJs::operator==)}); }
};

template <>
struct js_to_org_type<TaskExportDocumentExportConfigJs> {
  using type = org::sem::DocumentExportConfig::TaskExport;
};

template <>
struct org_to_js_type<org::sem::DocumentExportConfig::TaskExport> {
  using type = TaskExportDocumentExportConfigJs;
};

struct DoExportDocumentExportConfigJs : public SharedPtrWrapBase<DoExportDocumentExportConfigJs, org::sem::DocumentExportConfig::DoExport> {
  using SharedPtrWrapBase<DoExportDocumentExportConfigJs, org::sem::DocumentExportConfig::DoExport>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::DocumentExportConfig::DoExport::*)(org::sem::DocumentExportConfig::DoExport const&) const>(&org::sem::DocumentExportConfig::DoExport::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::DocumentExportConfig::DoExport>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "DoExportDocumentExportConfigJs", {InstanceMethod("operator==", &DoExportDocumentExportConfigJs::operator==)}); }
};

template <>
struct js_to_org_type<DoExportDocumentExportConfigJs> {
  using type = org::sem::DocumentExportConfig::DoExport;
};

template <>
struct org_to_js_type<org::sem::DocumentExportConfig::DoExport> {
  using type = DoExportDocumentExportConfigJs;
};

struct ExportFixedDocumentExportConfigJs : public SharedPtrWrapBase<ExportFixedDocumentExportConfigJs, org::sem::DocumentExportConfig::ExportFixed> {
  using SharedPtrWrapBase<ExportFixedDocumentExportConfigJs, org::sem::DocumentExportConfig::ExportFixed>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::DocumentExportConfig::ExportFixed::*)(org::sem::DocumentExportConfig::ExportFixed const&) const>(&org::sem::DocumentExportConfig::ExportFixed::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::DocumentExportConfig::ExportFixed>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ExportFixedDocumentExportConfigJs", {InstanceMethod("operator==", &ExportFixedDocumentExportConfigJs::operator==)}); }
};

template <>
struct js_to_org_type<ExportFixedDocumentExportConfigJs> {
  using type = org::sem::DocumentExportConfig::ExportFixed;
};

template <>
struct org_to_js_type<org::sem::DocumentExportConfig::ExportFixed> {
  using type = ExportFixedDocumentExportConfigJs;
};

struct SubtreePeriodJs : public SharedPtrWrapBase<SubtreePeriodJs, org::sem::SubtreePeriod> {
  using SharedPtrWrapBase<SubtreePeriodJs, org::sem::SubtreePeriod>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreePeriod::*)(org::sem::SubtreePeriod const&) const>(&org::sem::SubtreePeriod::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::SubtreePeriod>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "SubtreePeriodJs", {InstanceMethod("operator==", &SubtreePeriodJs::operator==)}); }
};

template <>
struct js_to_org_type<SubtreePeriodJs> {
  using type = org::sem::SubtreePeriod;
};

template <>
struct org_to_js_type<org::sem::SubtreePeriod> {
  using type = SubtreePeriodJs;
};

struct NamedPropertyJs : public SharedPtrWrapBase<NamedPropertyJs, org::sem::NamedProperty> {
  using SharedPtrWrapBase<NamedPropertyJs, org::sem::NamedProperty>::SharedPtrWrapBase;
  Napi::Value isMatching(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)(hstd::Str const&, hstd::Opt<hstd::Str> const&) const>(&org::sem::NamedProperty::isMatching),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"},
                                                        CxxArgSpec<hstd::Opt<hstd::Str>>{"subKind", std::nullopt})));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Str(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::getName),
                                        std::make_tuple()));
  }
  Napi::Value getSubKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<hstd::Str>(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::getSubKind),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)(org::sem::NamedProperty const&) const>(&org::sem::NamedProperty::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty>{"other"})));
  }
  Napi::Value isNonblocking(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isNonblocking),
                                        std::make_tuple()));
  }
  Napi::Value getNonblockingMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::Nonblocking&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getNonblocking),
                                   std::make_tuple()));
  }
  Napi::Value isArchiveTime(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isArchiveTime),
                                        std::make_tuple()));
  }
  Napi::Value getArchiveTimeMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::ArchiveTime&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getArchiveTime),
                                   std::make_tuple()));
  }
  Napi::Value isArchiveFile(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isArchiveFile),
                                        std::make_tuple()));
  }
  Napi::Value getArchiveFileMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::ArchiveFile&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getArchiveFile),
                                   std::make_tuple()));
  }
  Napi::Value isArchiveOlpath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isArchiveOlpath),
                                        std::make_tuple()));
  }
  Napi::Value getArchiveOlpathMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::ArchiveOlpath&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getArchiveOlpath),
                                   std::make_tuple()));
  }
  Napi::Value isArchiveTarget(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isArchiveTarget),
                                        std::make_tuple()));
  }
  Napi::Value getArchiveTargetMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::ArchiveTarget&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getArchiveTarget),
                                   std::make_tuple()));
  }
  Napi::Value isArchiveCategory(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isArchiveCategory),
                                        std::make_tuple()));
  }
  Napi::Value getArchiveCategoryMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::ArchiveCategory&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getArchiveCategory),
                                   std::make_tuple()));
  }
  Napi::Value isArchiveTodo(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isArchiveTodo),
                                        std::make_tuple()));
  }
  Napi::Value getArchiveTodoMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::ArchiveTodo&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getArchiveTodo),
                                   std::make_tuple()));
  }
  Napi::Value isTrigger(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isTrigger),
                                        std::make_tuple()));
  }
  Napi::Value getTriggerMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::Trigger&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getTrigger),
                                   std::make_tuple()));
  }
  Napi::Value isExportLatexClass(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isExportLatexClass),
                                        std::make_tuple()));
  }
  Napi::Value getExportLatexClassMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::ExportLatexClass&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getExportLatexClass),
                                   std::make_tuple()));
  }
  Napi::Value isCookieData(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isCookieData),
                                        std::make_tuple()));
  }
  Napi::Value getCookieDataMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::CookieData&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getCookieData),
                                   std::make_tuple()));
  }
  Napi::Value isExportLatexClassOptions(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isExportLatexClassOptions),
                                        std::make_tuple()));
  }
  Napi::Value getExportLatexClassOptionsMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::ExportLatexClassOptions&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getExportLatexClassOptions),
                                   std::make_tuple()));
  }
  Napi::Value isExportLatexHeader(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isExportLatexHeader),
                                        std::make_tuple()));
  }
  Napi::Value getExportLatexHeaderMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::ExportLatexHeader&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getExportLatexHeader),
                                   std::make_tuple()));
  }
  Napi::Value isExportLatexCompiler(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isExportLatexCompiler),
                                        std::make_tuple()));
  }
  Napi::Value getExportLatexCompilerMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::ExportLatexCompiler&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getExportLatexCompiler),
                                   std::make_tuple()));
  }
  Napi::Value isOrdered(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isOrdered),
                                        std::make_tuple()));
  }
  Napi::Value getOrderedMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::Ordered&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getOrdered),
                                   std::make_tuple()));
  }
  Napi::Value isEffort(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isEffort),
                                        std::make_tuple()));
  }
  Napi::Value getEffortMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::Effort&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getEffort),
                                   std::make_tuple()));
  }
  Napi::Value isVisibility(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isVisibility),
                                        std::make_tuple()));
  }
  Napi::Value getVisibilityMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::Visibility&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getVisibility),
                                   std::make_tuple()));
  }
  Napi::Value isExportOptions(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isExportOptions),
                                        std::make_tuple()));
  }
  Napi::Value getExportOptionsMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::ExportOptions&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getExportOptions),
                                   std::make_tuple()));
  }
  Napi::Value isBlocker(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isBlocker),
                                        std::make_tuple()));
  }
  Napi::Value getBlockerMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::Blocker&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getBlocker),
                                   std::make_tuple()));
  }
  Napi::Value isUnnumbered(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isUnnumbered),
                                        std::make_tuple()));
  }
  Napi::Value getUnnumberedMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::Unnumbered&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getUnnumbered),
                                   std::make_tuple()));
  }
  Napi::Value isCreated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isCreated),
                                        std::make_tuple()));
  }
  Napi::Value getCreatedMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::Created&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getCreated),
                                   std::make_tuple()));
  }
  Napi::Value isRadioId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isRadioId),
                                        std::make_tuple()));
  }
  Napi::Value getRadioIdMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::RadioId&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getRadioId),
                                   std::make_tuple()));
  }
  Napi::Value isHashtagDef(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isHashtagDef),
                                        std::make_tuple()));
  }
  Napi::Value getHashtagDefMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::HashtagDef&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getHashtagDef),
                                   std::make_tuple()));
  }
  Napi::Value isCustomArgs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isCustomArgs),
                                        std::make_tuple()));
  }
  Napi::Value getCustomArgsMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::CustomArgs&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getCustomArgs),
                                   std::make_tuple()));
  }
  Napi::Value isCustomRaw(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isCustomRaw),
                                        std::make_tuple()));
  }
  Napi::Value getCustomRawMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::CustomRaw&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getCustomRaw),
                                   std::make_tuple()));
  }
  Napi::Value isCustomSubtreeJson(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isCustomSubtreeJson),
                                        std::make_tuple()));
  }
  Napi::Value getCustomSubtreeJsonMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::CustomSubtreeJson&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getCustomSubtreeJson),
                                   std::make_tuple()));
  }
  Napi::Value isCustomSubtreeFlags(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::isCustomSubtreeFlags),
                                        std::make_tuple()));
  }
  Napi::Value getCustomSubtreeFlagsMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::NamedProperty::CustomSubtreeFlags&(org::sem::NamedProperty::*)()>(&org::sem::NamedProperty::getCustomSubtreeFlags),
                                   std::make_tuple()));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::NamedProperty::Kind(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::getKind),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_kind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::NamedProperty::Kind(org::sem::NamedProperty::*)() const>(&org::sem::NamedProperty::sub_variant_get_kind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "NamedPropertyJs", {InstanceMethod("isMatching", &NamedPropertyJs::isMatching),
                                                                                                                          InstanceMethod("getName", &NamedPropertyJs::getName),
                                                                                                                          InstanceMethod("getSubKind", &NamedPropertyJs::getSubKind),
                                                                                                                          InstanceMethod("operator==", &NamedPropertyJs::operator==),
                                                                                                                          InstanceMethod("isNonblocking", &NamedPropertyJs::isNonblocking),
                                                                                                                          InstanceMethod("getNonblockingMut", &NamedPropertyJs::getNonblockingMut),
                                                                                                                          InstanceMethod("isArchiveTime", &NamedPropertyJs::isArchiveTime),
                                                                                                                          InstanceMethod("getArchiveTimeMut", &NamedPropertyJs::getArchiveTimeMut),
                                                                                                                          InstanceMethod("isArchiveFile", &NamedPropertyJs::isArchiveFile),
                                                                                                                          InstanceMethod("getArchiveFileMut", &NamedPropertyJs::getArchiveFileMut),
                                                                                                                          InstanceMethod("isArchiveOlpath", &NamedPropertyJs::isArchiveOlpath),
                                                                                                                          InstanceMethod("getArchiveOlpathMut", &NamedPropertyJs::getArchiveOlpathMut),
                                                                                                                          InstanceMethod("isArchiveTarget", &NamedPropertyJs::isArchiveTarget),
                                                                                                                          InstanceMethod("getArchiveTargetMut", &NamedPropertyJs::getArchiveTargetMut),
                                                                                                                          InstanceMethod("isArchiveCategory", &NamedPropertyJs::isArchiveCategory),
                                                                                                                          InstanceMethod("getArchiveCategoryMut", &NamedPropertyJs::getArchiveCategoryMut),
                                                                                                                          InstanceMethod("isArchiveTodo", &NamedPropertyJs::isArchiveTodo),
                                                                                                                          InstanceMethod("getArchiveTodoMut", &NamedPropertyJs::getArchiveTodoMut),
                                                                                                                          InstanceMethod("isTrigger", &NamedPropertyJs::isTrigger),
                                                                                                                          InstanceMethod("getTriggerMut", &NamedPropertyJs::getTriggerMut),
                                                                                                                          InstanceMethod("isExportLatexClass", &NamedPropertyJs::isExportLatexClass),
                                                                                                                          InstanceMethod("getExportLatexClassMut", &NamedPropertyJs::getExportLatexClassMut),
                                                                                                                          InstanceMethod("isCookieData", &NamedPropertyJs::isCookieData),
                                                                                                                          InstanceMethod("getCookieDataMut", &NamedPropertyJs::getCookieDataMut),
                                                                                                                          InstanceMethod("isExportLatexClassOptions", &NamedPropertyJs::isExportLatexClassOptions),
                                                                                                                          InstanceMethod("getExportLatexClassOptionsMut", &NamedPropertyJs::getExportLatexClassOptionsMut),
                                                                                                                          InstanceMethod("isExportLatexHeader", &NamedPropertyJs::isExportLatexHeader),
                                                                                                                          InstanceMethod("getExportLatexHeaderMut", &NamedPropertyJs::getExportLatexHeaderMut),
                                                                                                                          InstanceMethod("isExportLatexCompiler", &NamedPropertyJs::isExportLatexCompiler),
                                                                                                                          InstanceMethod("getExportLatexCompilerMut", &NamedPropertyJs::getExportLatexCompilerMut),
                                                                                                                          InstanceMethod("isOrdered", &NamedPropertyJs::isOrdered),
                                                                                                                          InstanceMethod("getOrderedMut", &NamedPropertyJs::getOrderedMut),
                                                                                                                          InstanceMethod("isEffort", &NamedPropertyJs::isEffort),
                                                                                                                          InstanceMethod("getEffortMut", &NamedPropertyJs::getEffortMut),
                                                                                                                          InstanceMethod("isVisibility", &NamedPropertyJs::isVisibility),
                                                                                                                          InstanceMethod("getVisibilityMut", &NamedPropertyJs::getVisibilityMut),
                                                                                                                          InstanceMethod("isExportOptions", &NamedPropertyJs::isExportOptions),
                                                                                                                          InstanceMethod("getExportOptionsMut", &NamedPropertyJs::getExportOptionsMut),
                                                                                                                          InstanceMethod("isBlocker", &NamedPropertyJs::isBlocker),
                                                                                                                          InstanceMethod("getBlockerMut", &NamedPropertyJs::getBlockerMut),
                                                                                                                          InstanceMethod("isUnnumbered", &NamedPropertyJs::isUnnumbered),
                                                                                                                          InstanceMethod("getUnnumberedMut", &NamedPropertyJs::getUnnumberedMut),
                                                                                                                          InstanceMethod("isCreated", &NamedPropertyJs::isCreated),
                                                                                                                          InstanceMethod("getCreatedMut", &NamedPropertyJs::getCreatedMut),
                                                                                                                          InstanceMethod("isRadioId", &NamedPropertyJs::isRadioId),
                                                                                                                          InstanceMethod("getRadioIdMut", &NamedPropertyJs::getRadioIdMut),
                                                                                                                          InstanceMethod("isHashtagDef", &NamedPropertyJs::isHashtagDef),
                                                                                                                          InstanceMethod("getHashtagDefMut", &NamedPropertyJs::getHashtagDefMut),
                                                                                                                          InstanceMethod("isCustomArgs", &NamedPropertyJs::isCustomArgs),
                                                                                                                          InstanceMethod("getCustomArgsMut", &NamedPropertyJs::getCustomArgsMut),
                                                                                                                          InstanceMethod("isCustomRaw", &NamedPropertyJs::isCustomRaw),
                                                                                                                          InstanceMethod("getCustomRawMut", &NamedPropertyJs::getCustomRawMut),
                                                                                                                          InstanceMethod("isCustomSubtreeJson", &NamedPropertyJs::isCustomSubtreeJson),
                                                                                                                          InstanceMethod("getCustomSubtreeJsonMut", &NamedPropertyJs::getCustomSubtreeJsonMut),
                                                                                                                          InstanceMethod("isCustomSubtreeFlags", &NamedPropertyJs::isCustomSubtreeFlags),
                                                                                                                          InstanceMethod("getCustomSubtreeFlagsMut", &NamedPropertyJs::getCustomSubtreeFlagsMut),
                                                                                                                          InstanceMethod("getKind", &NamedPropertyJs::getKind),
                                                                                                                          InstanceMethod("sub_variant_get_kind", &NamedPropertyJs::sub_variant_get_kind)}); }
};

template <>
struct js_to_org_type<NamedPropertyJs> {
  using type = org::sem::NamedProperty;
};

template <>
struct org_to_js_type<org::sem::NamedProperty> {
  using type = NamedPropertyJs;
};

struct NonblockingNamedPropertyJs : public SharedPtrWrapBase<NonblockingNamedPropertyJs, org::sem::NamedProperty::Nonblocking> {
  using SharedPtrWrapBase<NonblockingNamedPropertyJs, org::sem::NamedProperty::Nonblocking>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::Nonblocking::*)(org::sem::NamedProperty::Nonblocking const&) const>(&org::sem::NamedProperty::Nonblocking::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::Nonblocking>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "NonblockingNamedPropertyJs", {InstanceMethod("operator==", &NonblockingNamedPropertyJs::operator==)}); }
};

template <>
struct js_to_org_type<NonblockingNamedPropertyJs> {
  using type = org::sem::NamedProperty::Nonblocking;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::Nonblocking> {
  using type = NonblockingNamedPropertyJs;
};

struct ArchiveTimeNamedPropertyJs : public SharedPtrWrapBase<ArchiveTimeNamedPropertyJs, org::sem::NamedProperty::ArchiveTime> {
  using SharedPtrWrapBase<ArchiveTimeNamedPropertyJs, org::sem::NamedProperty::ArchiveTime>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::ArchiveTime::*)(org::sem::NamedProperty::ArchiveTime const&) const>(&org::sem::NamedProperty::ArchiveTime::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::ArchiveTime>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ArchiveTimeNamedPropertyJs", {InstanceMethod("operator==", &ArchiveTimeNamedPropertyJs::operator==)}); }
};

template <>
struct js_to_org_type<ArchiveTimeNamedPropertyJs> {
  using type = org::sem::NamedProperty::ArchiveTime;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::ArchiveTime> {
  using type = ArchiveTimeNamedPropertyJs;
};

struct ArchiveFileNamedPropertyJs : public SharedPtrWrapBase<ArchiveFileNamedPropertyJs, org::sem::NamedProperty::ArchiveFile> {
  using SharedPtrWrapBase<ArchiveFileNamedPropertyJs, org::sem::NamedProperty::ArchiveFile>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::ArchiveFile::*)(org::sem::NamedProperty::ArchiveFile const&) const>(&org::sem::NamedProperty::ArchiveFile::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::ArchiveFile>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ArchiveFileNamedPropertyJs", {InstanceMethod("operator==", &ArchiveFileNamedPropertyJs::operator==)}); }
};

template <>
struct js_to_org_type<ArchiveFileNamedPropertyJs> {
  using type = org::sem::NamedProperty::ArchiveFile;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::ArchiveFile> {
  using type = ArchiveFileNamedPropertyJs;
};

struct ArchiveOlpathNamedPropertyJs : public SharedPtrWrapBase<ArchiveOlpathNamedPropertyJs, org::sem::NamedProperty::ArchiveOlpath> {
  using SharedPtrWrapBase<ArchiveOlpathNamedPropertyJs, org::sem::NamedProperty::ArchiveOlpath>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::ArchiveOlpath::*)(org::sem::NamedProperty::ArchiveOlpath const&) const>(&org::sem::NamedProperty::ArchiveOlpath::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::ArchiveOlpath>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ArchiveOlpathNamedPropertyJs", {InstanceMethod("operator==", &ArchiveOlpathNamedPropertyJs::operator==)}); }
};

template <>
struct js_to_org_type<ArchiveOlpathNamedPropertyJs> {
  using type = org::sem::NamedProperty::ArchiveOlpath;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::ArchiveOlpath> {
  using type = ArchiveOlpathNamedPropertyJs;
};

struct ArchiveTargetNamedPropertyJs : public SharedPtrWrapBase<ArchiveTargetNamedPropertyJs, org::sem::NamedProperty::ArchiveTarget> {
  using SharedPtrWrapBase<ArchiveTargetNamedPropertyJs, org::sem::NamedProperty::ArchiveTarget>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::ArchiveTarget::*)(org::sem::NamedProperty::ArchiveTarget const&) const>(&org::sem::NamedProperty::ArchiveTarget::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::ArchiveTarget>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ArchiveTargetNamedPropertyJs", {InstanceMethod("operator==", &ArchiveTargetNamedPropertyJs::operator==)}); }
};

template <>
struct js_to_org_type<ArchiveTargetNamedPropertyJs> {
  using type = org::sem::NamedProperty::ArchiveTarget;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::ArchiveTarget> {
  using type = ArchiveTargetNamedPropertyJs;
};

struct ArchiveCategoryNamedPropertyJs : public SharedPtrWrapBase<ArchiveCategoryNamedPropertyJs, org::sem::NamedProperty::ArchiveCategory> {
  using SharedPtrWrapBase<ArchiveCategoryNamedPropertyJs, org::sem::NamedProperty::ArchiveCategory>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::ArchiveCategory::*)(org::sem::NamedProperty::ArchiveCategory const&) const>(&org::sem::NamedProperty::ArchiveCategory::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::ArchiveCategory>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ArchiveCategoryNamedPropertyJs", {InstanceMethod("operator==", &ArchiveCategoryNamedPropertyJs::operator==)}); }
};

template <>
struct js_to_org_type<ArchiveCategoryNamedPropertyJs> {
  using type = org::sem::NamedProperty::ArchiveCategory;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::ArchiveCategory> {
  using type = ArchiveCategoryNamedPropertyJs;
};

struct ArchiveTodoNamedPropertyJs : public SharedPtrWrapBase<ArchiveTodoNamedPropertyJs, org::sem::NamedProperty::ArchiveTodo> {
  using SharedPtrWrapBase<ArchiveTodoNamedPropertyJs, org::sem::NamedProperty::ArchiveTodo>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::ArchiveTodo::*)(org::sem::NamedProperty::ArchiveTodo const&) const>(&org::sem::NamedProperty::ArchiveTodo::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::ArchiveTodo>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ArchiveTodoNamedPropertyJs", {InstanceMethod("operator==", &ArchiveTodoNamedPropertyJs::operator==)}); }
};

template <>
struct js_to_org_type<ArchiveTodoNamedPropertyJs> {
  using type = org::sem::NamedProperty::ArchiveTodo;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::ArchiveTodo> {
  using type = ArchiveTodoNamedPropertyJs;
};

struct TriggerNamedPropertyJs : public SharedPtrWrapBase<TriggerNamedPropertyJs, org::sem::NamedProperty::Trigger> {
  using SharedPtrWrapBase<TriggerNamedPropertyJs, org::sem::NamedProperty::Trigger>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::Trigger::*)(org::sem::NamedProperty::Trigger const&) const>(&org::sem::NamedProperty::Trigger::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::Trigger>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "TriggerNamedPropertyJs", {InstanceMethod("operator==", &TriggerNamedPropertyJs::operator==)}); }
};

template <>
struct js_to_org_type<TriggerNamedPropertyJs> {
  using type = org::sem::NamedProperty::Trigger;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::Trigger> {
  using type = TriggerNamedPropertyJs;
};

struct ExportLatexClassNamedPropertyJs : public SharedPtrWrapBase<ExportLatexClassNamedPropertyJs, org::sem::NamedProperty::ExportLatexClass> {
  using SharedPtrWrapBase<ExportLatexClassNamedPropertyJs, org::sem::NamedProperty::ExportLatexClass>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::ExportLatexClass::*)(org::sem::NamedProperty::ExportLatexClass const&) const>(&org::sem::NamedProperty::ExportLatexClass::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::ExportLatexClass>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ExportLatexClassNamedPropertyJs", {InstanceMethod("operator==", &ExportLatexClassNamedPropertyJs::operator==)}); }
};

template <>
struct js_to_org_type<ExportLatexClassNamedPropertyJs> {
  using type = org::sem::NamedProperty::ExportLatexClass;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::ExportLatexClass> {
  using type = ExportLatexClassNamedPropertyJs;
};

struct CookieDataNamedPropertyJs : public SharedPtrWrapBase<CookieDataNamedPropertyJs, org::sem::NamedProperty::CookieData> {
  using SharedPtrWrapBase<CookieDataNamedPropertyJs, org::sem::NamedProperty::CookieData>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::CookieData::*)(org::sem::NamedProperty::CookieData const&) const>(&org::sem::NamedProperty::CookieData::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::CookieData>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "CookieDataNamedPropertyJs", {InstanceMethod("operator==", &CookieDataNamedPropertyJs::operator==)}); }
};

template <>
struct js_to_org_type<CookieDataNamedPropertyJs> {
  using type = org::sem::NamedProperty::CookieData;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::CookieData> {
  using type = CookieDataNamedPropertyJs;
};

struct ExportLatexClassOptionsNamedPropertyJs : public SharedPtrWrapBase<ExportLatexClassOptionsNamedPropertyJs, org::sem::NamedProperty::ExportLatexClassOptions> {
  using SharedPtrWrapBase<ExportLatexClassOptionsNamedPropertyJs, org::sem::NamedProperty::ExportLatexClassOptions>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::ExportLatexClassOptions::*)(org::sem::NamedProperty::ExportLatexClassOptions const&) const>(&org::sem::NamedProperty::ExportLatexClassOptions::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::ExportLatexClassOptions>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ExportLatexClassOptionsNamedPropertyJs", {InstanceMethod("operator==", &ExportLatexClassOptionsNamedPropertyJs::operator==)}); }
};

template <>
struct js_to_org_type<ExportLatexClassOptionsNamedPropertyJs> {
  using type = org::sem::NamedProperty::ExportLatexClassOptions;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::ExportLatexClassOptions> {
  using type = ExportLatexClassOptionsNamedPropertyJs;
};

struct ExportLatexHeaderNamedPropertyJs : public SharedPtrWrapBase<ExportLatexHeaderNamedPropertyJs, org::sem::NamedProperty::ExportLatexHeader> {
  using SharedPtrWrapBase<ExportLatexHeaderNamedPropertyJs, org::sem::NamedProperty::ExportLatexHeader>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::ExportLatexHeader::*)(org::sem::NamedProperty::ExportLatexHeader const&) const>(&org::sem::NamedProperty::ExportLatexHeader::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::ExportLatexHeader>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ExportLatexHeaderNamedPropertyJs", {InstanceMethod("operator==", &ExportLatexHeaderNamedPropertyJs::operator==)}); }
};

template <>
struct js_to_org_type<ExportLatexHeaderNamedPropertyJs> {
  using type = org::sem::NamedProperty::ExportLatexHeader;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::ExportLatexHeader> {
  using type = ExportLatexHeaderNamedPropertyJs;
};

struct ExportLatexCompilerNamedPropertyJs : public SharedPtrWrapBase<ExportLatexCompilerNamedPropertyJs, org::sem::NamedProperty::ExportLatexCompiler> {
  using SharedPtrWrapBase<ExportLatexCompilerNamedPropertyJs, org::sem::NamedProperty::ExportLatexCompiler>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::ExportLatexCompiler::*)(org::sem::NamedProperty::ExportLatexCompiler const&) const>(&org::sem::NamedProperty::ExportLatexCompiler::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::ExportLatexCompiler>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ExportLatexCompilerNamedPropertyJs", {InstanceMethod("operator==", &ExportLatexCompilerNamedPropertyJs::operator==)}); }
};

template <>
struct js_to_org_type<ExportLatexCompilerNamedPropertyJs> {
  using type = org::sem::NamedProperty::ExportLatexCompiler;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::ExportLatexCompiler> {
  using type = ExportLatexCompilerNamedPropertyJs;
};

struct OrderedNamedPropertyJs : public SharedPtrWrapBase<OrderedNamedPropertyJs, org::sem::NamedProperty::Ordered> {
  using SharedPtrWrapBase<OrderedNamedPropertyJs, org::sem::NamedProperty::Ordered>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::Ordered::*)(org::sem::NamedProperty::Ordered const&) const>(&org::sem::NamedProperty::Ordered::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::Ordered>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "OrderedNamedPropertyJs", {InstanceMethod("operator==", &OrderedNamedPropertyJs::operator==)}); }
};

template <>
struct js_to_org_type<OrderedNamedPropertyJs> {
  using type = org::sem::NamedProperty::Ordered;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::Ordered> {
  using type = OrderedNamedPropertyJs;
};

struct EffortNamedPropertyJs : public SharedPtrWrapBase<EffortNamedPropertyJs, org::sem::NamedProperty::Effort> {
  using SharedPtrWrapBase<EffortNamedPropertyJs, org::sem::NamedProperty::Effort>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::Effort::*)(org::sem::NamedProperty::Effort const&) const>(&org::sem::NamedProperty::Effort::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::Effort>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "EffortNamedPropertyJs", {InstanceMethod("operator==", &EffortNamedPropertyJs::operator==)}); }
};

template <>
struct js_to_org_type<EffortNamedPropertyJs> {
  using type = org::sem::NamedProperty::Effort;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::Effort> {
  using type = EffortNamedPropertyJs;
};

struct VisibilityNamedPropertyJs : public SharedPtrWrapBase<VisibilityNamedPropertyJs, org::sem::NamedProperty::Visibility> {
  using SharedPtrWrapBase<VisibilityNamedPropertyJs, org::sem::NamedProperty::Visibility>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::Visibility::*)(org::sem::NamedProperty::Visibility const&) const>(&org::sem::NamedProperty::Visibility::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::Visibility>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "VisibilityNamedPropertyJs", {InstanceMethod("operator==", &VisibilityNamedPropertyJs::operator==)}); }
};

template <>
struct js_to_org_type<VisibilityNamedPropertyJs> {
  using type = org::sem::NamedProperty::Visibility;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::Visibility> {
  using type = VisibilityNamedPropertyJs;
};

struct ExportOptionsNamedPropertyJs : public SharedPtrWrapBase<ExportOptionsNamedPropertyJs, org::sem::NamedProperty::ExportOptions> {
  using SharedPtrWrapBase<ExportOptionsNamedPropertyJs, org::sem::NamedProperty::ExportOptions>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::ExportOptions::*)(org::sem::NamedProperty::ExportOptions const&) const>(&org::sem::NamedProperty::ExportOptions::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::ExportOptions>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ExportOptionsNamedPropertyJs", {InstanceMethod("operator==", &ExportOptionsNamedPropertyJs::operator==)}); }
};

template <>
struct js_to_org_type<ExportOptionsNamedPropertyJs> {
  using type = org::sem::NamedProperty::ExportOptions;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::ExportOptions> {
  using type = ExportOptionsNamedPropertyJs;
};

struct BlockerNamedPropertyJs : public SharedPtrWrapBase<BlockerNamedPropertyJs, org::sem::NamedProperty::Blocker> {
  using SharedPtrWrapBase<BlockerNamedPropertyJs, org::sem::NamedProperty::Blocker>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::Blocker::*)(org::sem::NamedProperty::Blocker const&) const>(&org::sem::NamedProperty::Blocker::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::Blocker>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "BlockerNamedPropertyJs", {InstanceMethod("operator==", &BlockerNamedPropertyJs::operator==)}); }
};

template <>
struct js_to_org_type<BlockerNamedPropertyJs> {
  using type = org::sem::NamedProperty::Blocker;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::Blocker> {
  using type = BlockerNamedPropertyJs;
};

struct UnnumberedNamedPropertyJs : public SharedPtrWrapBase<UnnumberedNamedPropertyJs, org::sem::NamedProperty::Unnumbered> {
  using SharedPtrWrapBase<UnnumberedNamedPropertyJs, org::sem::NamedProperty::Unnumbered>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::Unnumbered::*)(org::sem::NamedProperty::Unnumbered const&) const>(&org::sem::NamedProperty::Unnumbered::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::Unnumbered>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "UnnumberedNamedPropertyJs", {InstanceMethod("operator==", &UnnumberedNamedPropertyJs::operator==)}); }
};

template <>
struct js_to_org_type<UnnumberedNamedPropertyJs> {
  using type = org::sem::NamedProperty::Unnumbered;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::Unnumbered> {
  using type = UnnumberedNamedPropertyJs;
};

struct CreatedNamedPropertyJs : public SharedPtrWrapBase<CreatedNamedPropertyJs, org::sem::NamedProperty::Created> {
  using SharedPtrWrapBase<CreatedNamedPropertyJs, org::sem::NamedProperty::Created>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::Created::*)(org::sem::NamedProperty::Created const&) const>(&org::sem::NamedProperty::Created::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::Created>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "CreatedNamedPropertyJs", {InstanceMethod("operator==", &CreatedNamedPropertyJs::operator==)}); }
};

template <>
struct js_to_org_type<CreatedNamedPropertyJs> {
  using type = org::sem::NamedProperty::Created;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::Created> {
  using type = CreatedNamedPropertyJs;
};

struct RadioIdNamedPropertyJs : public SharedPtrWrapBase<RadioIdNamedPropertyJs, org::sem::NamedProperty::RadioId> {
  using SharedPtrWrapBase<RadioIdNamedPropertyJs, org::sem::NamedProperty::RadioId>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::RadioId::*)(org::sem::NamedProperty::RadioId const&) const>(&org::sem::NamedProperty::RadioId::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::RadioId>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "RadioIdNamedPropertyJs", {InstanceMethod("operator==", &RadioIdNamedPropertyJs::operator==)}); }
};

template <>
struct js_to_org_type<RadioIdNamedPropertyJs> {
  using type = org::sem::NamedProperty::RadioId;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::RadioId> {
  using type = RadioIdNamedPropertyJs;
};

struct HashtagDefNamedPropertyJs : public SharedPtrWrapBase<HashtagDefNamedPropertyJs, org::sem::NamedProperty::HashtagDef> {
  using SharedPtrWrapBase<HashtagDefNamedPropertyJs, org::sem::NamedProperty::HashtagDef>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::HashtagDef::*)(org::sem::NamedProperty::HashtagDef const&) const>(&org::sem::NamedProperty::HashtagDef::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::HashtagDef>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "HashtagDefNamedPropertyJs", {InstanceMethod("operator==", &HashtagDefNamedPropertyJs::operator==)}); }
};

template <>
struct js_to_org_type<HashtagDefNamedPropertyJs> {
  using type = org::sem::NamedProperty::HashtagDef;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::HashtagDef> {
  using type = HashtagDefNamedPropertyJs;
};

struct CustomArgsNamedPropertyJs : public SharedPtrWrapBase<CustomArgsNamedPropertyJs, org::sem::NamedProperty::CustomArgs> {
  using SharedPtrWrapBase<CustomArgsNamedPropertyJs, org::sem::NamedProperty::CustomArgs>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::CustomArgs::*)(org::sem::NamedProperty::CustomArgs const&) const>(&org::sem::NamedProperty::CustomArgs::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::CustomArgs>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "CustomArgsNamedPropertyJs", {InstanceMethod("operator==", &CustomArgsNamedPropertyJs::operator==)}); }
};

template <>
struct js_to_org_type<CustomArgsNamedPropertyJs> {
  using type = org::sem::NamedProperty::CustomArgs;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::CustomArgs> {
  using type = CustomArgsNamedPropertyJs;
};

struct CustomRawNamedPropertyJs : public SharedPtrWrapBase<CustomRawNamedPropertyJs, org::sem::NamedProperty::CustomRaw> {
  using SharedPtrWrapBase<CustomRawNamedPropertyJs, org::sem::NamedProperty::CustomRaw>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::CustomRaw::*)(org::sem::NamedProperty::CustomRaw const&) const>(&org::sem::NamedProperty::CustomRaw::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::CustomRaw>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "CustomRawNamedPropertyJs", {InstanceMethod("operator==", &CustomRawNamedPropertyJs::operator==)}); }
};

template <>
struct js_to_org_type<CustomRawNamedPropertyJs> {
  using type = org::sem::NamedProperty::CustomRaw;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::CustomRaw> {
  using type = CustomRawNamedPropertyJs;
};

struct CustomSubtreeJsonNamedPropertyJs : public SharedPtrWrapBase<CustomSubtreeJsonNamedPropertyJs, org::sem::NamedProperty::CustomSubtreeJson> {
  using SharedPtrWrapBase<CustomSubtreeJsonNamedPropertyJs, org::sem::NamedProperty::CustomSubtreeJson>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::CustomSubtreeJson::*)(org::sem::NamedProperty::CustomSubtreeJson const&) const>(&org::sem::NamedProperty::CustomSubtreeJson::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::CustomSubtreeJson>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "CustomSubtreeJsonNamedPropertyJs", {InstanceMethod("operator==", &CustomSubtreeJsonNamedPropertyJs::operator==)}); }
};

template <>
struct js_to_org_type<CustomSubtreeJsonNamedPropertyJs> {
  using type = org::sem::NamedProperty::CustomSubtreeJson;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::CustomSubtreeJson> {
  using type = CustomSubtreeJsonNamedPropertyJs;
};

struct CustomSubtreeFlagsNamedPropertyJs : public SharedPtrWrapBase<CustomSubtreeFlagsNamedPropertyJs, org::sem::NamedProperty::CustomSubtreeFlags> {
  using SharedPtrWrapBase<CustomSubtreeFlagsNamedPropertyJs, org::sem::NamedProperty::CustomSubtreeFlags>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::NamedProperty::CustomSubtreeFlags::*)(org::sem::NamedProperty::CustomSubtreeFlags const&) const>(&org::sem::NamedProperty::CustomSubtreeFlags::operator==),
                                        std::make_tuple(CxxArgSpec<org::sem::NamedProperty::CustomSubtreeFlags>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "CustomSubtreeFlagsNamedPropertyJs", {InstanceMethod("operator==", &CustomSubtreeFlagsNamedPropertyJs::operator==)}); }
};

template <>
struct js_to_org_type<CustomSubtreeFlagsNamedPropertyJs> {
  using type = org::sem::NamedProperty::CustomSubtreeFlags;
};

template <>
struct org_to_js_type<org::sem::NamedProperty::CustomSubtreeFlags> {
  using type = CustomSubtreeFlagsNamedPropertyJs;
};

struct ImmNoneJs : public SharedPtrWrapBase<ImmNoneJs, org::imm::ImmNone> {
  using SharedPtrWrapBase<ImmNoneJs, org::imm::ImmNone>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmNone::*)() const>(&org::imm::ImmNone::getKind),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmNone::*)(org::imm::ImmNone const&) const>(&org::imm::ImmNone::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmNone>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmNoneJs", {InstanceMethod("getKind", &ImmNoneJs::getKind),
                                                                                                                    InstanceMethod("operator==", &ImmNoneJs::operator==)}); }
};

template <>
struct js_to_org_type<ImmNoneJs> {
  using type = org::imm::ImmNone;
};

template <>
struct org_to_js_type<org::imm::ImmNone> {
  using type = ImmNoneJs;
};

struct ImmErrorItemJs : public SharedPtrWrapBase<ImmErrorItemJs, org::imm::ImmErrorItem> {
  using SharedPtrWrapBase<ImmErrorItemJs, org::imm::ImmErrorItem>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmErrorItem::*)() const>(&org::imm::ImmErrorItem::getKind),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmErrorItem::*)(org::imm::ImmErrorItem const&) const>(&org::imm::ImmErrorItem::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmErrorItem>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmErrorItemJs", {InstanceMethod("getKind", &ImmErrorItemJs::getKind),
                                                                                                                         InstanceMethod("operator==", &ImmErrorItemJs::operator==)}); }
};

template <>
struct js_to_org_type<ImmErrorItemJs> {
  using type = org::imm::ImmErrorItem;
};

template <>
struct org_to_js_type<org::imm::ImmErrorItem> {
  using type = ImmErrorItemJs;
};

struct ImmErrorGroupJs : public SharedPtrWrapBase<ImmErrorGroupJs, org::imm::ImmErrorGroup> {
  using SharedPtrWrapBase<ImmErrorGroupJs, org::imm::ImmErrorGroup>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmErrorGroup::*)() const>(&org::imm::ImmErrorGroup::getKind),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmErrorGroup::*)(org::imm::ImmErrorGroup const&) const>(&org::imm::ImmErrorGroup::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmErrorGroup>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmErrorGroupJs", {InstanceMethod("getKind", &ImmErrorGroupJs::getKind),
                                                                                                                          InstanceMethod("operator==", &ImmErrorGroupJs::operator==)}); }
};

template <>
struct js_to_org_type<ImmErrorGroupJs> {
  using type = org::imm::ImmErrorGroup;
};

template <>
struct org_to_js_type<org::imm::ImmErrorGroup> {
  using type = ImmErrorGroupJs;
};

struct ImmStmtListJs : public SharedPtrWrapBase<ImmStmtListJs, org::imm::ImmStmtList> {
  using SharedPtrWrapBase<ImmStmtListJs, org::imm::ImmStmtList>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmStmtList::*)() const>(&org::imm::ImmStmtList::getKind),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmStmtList::*)(org::imm::ImmStmtList const&) const>(&org::imm::ImmStmtList::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmStmtList>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmStmtListJs", {InstanceMethod("getKind", &ImmStmtListJs::getKind),
                                                                                                                        InstanceMethod("operator==", &ImmStmtListJs::operator==)}); }
};

template <>
struct js_to_org_type<ImmStmtListJs> {
  using type = org::imm::ImmStmtList;
};

template <>
struct org_to_js_type<org::imm::ImmStmtList> {
  using type = ImmStmtListJs;
};

struct ImmEmptyJs : public SharedPtrWrapBase<ImmEmptyJs, org::imm::ImmEmpty> {
  using SharedPtrWrapBase<ImmEmptyJs, org::imm::ImmEmpty>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmEmpty::*)() const>(&org::imm::ImmEmpty::getKind),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmEmpty::*)(org::imm::ImmEmpty const&) const>(&org::imm::ImmEmpty::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmEmpty>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmEmptyJs", {InstanceMethod("getKind", &ImmEmptyJs::getKind),
                                                                                                                     InstanceMethod("operator==", &ImmEmptyJs::operator==)}); }
};

template <>
struct js_to_org_type<ImmEmptyJs> {
  using type = org::imm::ImmEmpty;
};

template <>
struct org_to_js_type<org::imm::ImmEmpty> {
  using type = ImmEmptyJs;
};

struct ImmTimeJs : public SharedPtrWrapBase<ImmTimeJs, org::imm::ImmTime> {
  using SharedPtrWrapBase<ImmTimeJs, org::imm::ImmTime>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmTime::*)() const>(&org::imm::ImmTime::getKind),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmTime::*)(org::imm::ImmTime const&) const>(&org::imm::ImmTime::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmTime>{"other"})));
  }
  Napi::Value isStatic(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmTime::*)() const>(&org::imm::ImmTime::isStatic),
                                        std::make_tuple()));
  }
  Napi::Value getStaticMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::imm::ImmTime::Static&(org::imm::ImmTime::*)()>(&org::imm::ImmTime::getStatic),
                                   std::make_tuple()));
  }
  Napi::Value isDynamic(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmTime::*)() const>(&org::imm::ImmTime::isDynamic),
                                        std::make_tuple()));
  }
  Napi::Value getDynamicMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::imm::ImmTime::Dynamic&(org::imm::ImmTime::*)()>(&org::imm::ImmTime::getDynamic),
                                   std::make_tuple()));
  }
  Napi::Value getTimeKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmTime::TimeKind(org::imm::ImmTime::*)() const>(&org::imm::ImmTime::getTimeKind),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_kind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmTime::TimeKind(org::imm::ImmTime::*)() const>(&org::imm::ImmTime::sub_variant_get_kind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmTimeJs", {InstanceMethod("getKind", &ImmTimeJs::getKind),
                                                                                                                    InstanceMethod("operator==", &ImmTimeJs::operator==),
                                                                                                                    InstanceMethod("isStatic", &ImmTimeJs::isStatic),
                                                                                                                    InstanceMethod("getStaticMut", &ImmTimeJs::getStaticMut),
                                                                                                                    InstanceMethod("isDynamic", &ImmTimeJs::isDynamic),
                                                                                                                    InstanceMethod("getDynamicMut", &ImmTimeJs::getDynamicMut),
                                                                                                                    InstanceMethod("getTimeKind", &ImmTimeJs::getTimeKind),
                                                                                                                    InstanceMethod("sub_variant_get_kind", &ImmTimeJs::sub_variant_get_kind)}); }
};

template <>
struct js_to_org_type<ImmTimeJs> {
  using type = org::imm::ImmTime;
};

template <>
struct org_to_js_type<org::imm::ImmTime> {
  using type = ImmTimeJs;
};

struct RepeatImmTimeJs : public SharedPtrWrapBase<RepeatImmTimeJs, org::imm::ImmTime::Repeat> {
  using SharedPtrWrapBase<RepeatImmTimeJs, org::imm::ImmTime::Repeat>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmTime::Repeat::*)(org::imm::ImmTime::Repeat const&) const>(&org::imm::ImmTime::Repeat::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmTime::Repeat>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "RepeatImmTimeJs", {InstanceMethod("operator==", &RepeatImmTimeJs::operator==)}); }
};

template <>
struct js_to_org_type<RepeatImmTimeJs> {
  using type = org::imm::ImmTime::Repeat;
};

template <>
struct org_to_js_type<org::imm::ImmTime::Repeat> {
  using type = RepeatImmTimeJs;
};

struct StaticImmTimeJs : public SharedPtrWrapBase<StaticImmTimeJs, org::imm::ImmTime::Static> {
  using SharedPtrWrapBase<StaticImmTimeJs, org::imm::ImmTime::Static>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmTime::Static::*)(org::imm::ImmTime::Static const&) const>(&org::imm::ImmTime::Static::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmTime::Static>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "StaticImmTimeJs", {InstanceMethod("operator==", &StaticImmTimeJs::operator==)}); }
};

template <>
struct js_to_org_type<StaticImmTimeJs> {
  using type = org::imm::ImmTime::Static;
};

template <>
struct org_to_js_type<org::imm::ImmTime::Static> {
  using type = StaticImmTimeJs;
};

struct DynamicImmTimeJs : public SharedPtrWrapBase<DynamicImmTimeJs, org::imm::ImmTime::Dynamic> {
  using SharedPtrWrapBase<DynamicImmTimeJs, org::imm::ImmTime::Dynamic>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmTime::Dynamic::*)(org::imm::ImmTime::Dynamic const&) const>(&org::imm::ImmTime::Dynamic::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmTime::Dynamic>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "DynamicImmTimeJs", {InstanceMethod("operator==", &DynamicImmTimeJs::operator==)}); }
};

template <>
struct js_to_org_type<DynamicImmTimeJs> {
  using type = org::imm::ImmTime::Dynamic;
};

template <>
struct org_to_js_type<org::imm::ImmTime::Dynamic> {
  using type = DynamicImmTimeJs;
};

struct ImmTimeRangeJs : public SharedPtrWrapBase<ImmTimeRangeJs, org::imm::ImmTimeRange> {
  using SharedPtrWrapBase<ImmTimeRangeJs, org::imm::ImmTimeRange>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmTimeRange::*)() const>(&org::imm::ImmTimeRange::getKind),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmTimeRange::*)(org::imm::ImmTimeRange const&) const>(&org::imm::ImmTimeRange::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmTimeRange>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmTimeRangeJs", {InstanceMethod("getKind", &ImmTimeRangeJs::getKind),
                                                                                                                         InstanceMethod("operator==", &ImmTimeRangeJs::operator==)}); }
};

template <>
struct js_to_org_type<ImmTimeRangeJs> {
  using type = org::imm::ImmTimeRange;
};

template <>
struct org_to_js_type<org::imm::ImmTimeRange> {
  using type = ImmTimeRangeJs;
};

struct ImmMacroJs : public SharedPtrWrapBase<ImmMacroJs, org::imm::ImmMacro> {
  using SharedPtrWrapBase<ImmMacroJs, org::imm::ImmMacro>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmMacro::*)() const>(&org::imm::ImmMacro::getKind),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmMacro::*)(org::imm::ImmMacro const&) const>(&org::imm::ImmMacro::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmMacro>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmMacroJs", {InstanceMethod("getKind", &ImmMacroJs::getKind),
                                                                                                                     InstanceMethod("operator==", &ImmMacroJs::operator==)}); }
};

template <>
struct js_to_org_type<ImmMacroJs> {
  using type = org::imm::ImmMacro;
};

template <>
struct org_to_js_type<org::imm::ImmMacro> {
  using type = ImmMacroJs;
};

struct ImmSymbolJs : public SharedPtrWrapBase<ImmSymbolJs, org::imm::ImmSymbol> {
  using SharedPtrWrapBase<ImmSymbolJs, org::imm::ImmSymbol>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmSymbol::*)() const>(&org::imm::ImmSymbol::getKind),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmSymbol::*)(org::imm::ImmSymbol const&) const>(&org::imm::ImmSymbol::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmSymbol>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmSymbolJs", {InstanceMethod("getKind", &ImmSymbolJs::getKind),
                                                                                                                      InstanceMethod("operator==", &ImmSymbolJs::operator==)}); }
};

template <>
struct js_to_org_type<ImmSymbolJs> {
  using type = org::imm::ImmSymbol;
};

template <>
struct org_to_js_type<org::imm::ImmSymbol> {
  using type = ImmSymbolJs;
};

struct ParamImmSymbolJs : public SharedPtrWrapBase<ParamImmSymbolJs, org::imm::ImmSymbol::Param> {
  using SharedPtrWrapBase<ParamImmSymbolJs, org::imm::ImmSymbol::Param>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmSymbol::Param::*)(org::imm::ImmSymbol::Param const&) const>(&org::imm::ImmSymbol::Param::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmSymbol::Param>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ParamImmSymbolJs", {InstanceMethod("operator==", &ParamImmSymbolJs::operator==)}); }
};

template <>
struct js_to_org_type<ParamImmSymbolJs> {
  using type = org::imm::ImmSymbol::Param;
};

template <>
struct org_to_js_type<org::imm::ImmSymbol::Param> {
  using type = ParamImmSymbolJs;
};

struct ImmRadioTargetJs : public SharedPtrWrapBase<ImmRadioTargetJs, org::imm::ImmRadioTarget> {
  using SharedPtrWrapBase<ImmRadioTargetJs, org::imm::ImmRadioTarget>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmRadioTarget::*)() const>(&org::imm::ImmRadioTarget::getKind),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmRadioTarget::*)(org::imm::ImmRadioTarget const&) const>(&org::imm::ImmRadioTarget::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmRadioTarget>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmRadioTargetJs", {InstanceMethod("getKind", &ImmRadioTargetJs::getKind),
                                                                                                                           InstanceMethod("operator==", &ImmRadioTargetJs::operator==)}); }
};

template <>
struct js_to_org_type<ImmRadioTargetJs> {
  using type = org::imm::ImmRadioTarget;
};

template <>
struct org_to_js_type<org::imm::ImmRadioTarget> {
  using type = ImmRadioTargetJs;
};

struct ImmLatexJs : public SharedPtrWrapBase<ImmLatexJs, org::imm::ImmLatex> {
  using SharedPtrWrapBase<ImmLatexJs, org::imm::ImmLatex>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmLatex::*)() const>(&org::imm::ImmLatex::getKind),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmLatex::*)(org::imm::ImmLatex const&) const>(&org::imm::ImmLatex::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmLatex>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmLatexJs", {InstanceMethod("getKind", &ImmLatexJs::getKind),
                                                                                                                     InstanceMethod("operator==", &ImmLatexJs::operator==)}); }
};

template <>
struct js_to_org_type<ImmLatexJs> {
  using type = org::imm::ImmLatex;
};

template <>
struct org_to_js_type<org::imm::ImmLatex> {
  using type = ImmLatexJs;
};

struct ImmSubtreeLogJs : public SharedPtrWrapBase<ImmSubtreeLogJs, org::imm::ImmSubtreeLog> {
  using SharedPtrWrapBase<ImmSubtreeLogJs, org::imm::ImmSubtreeLog>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmSubtreeLog::*)() const>(&org::imm::ImmSubtreeLog::getKind),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmSubtreeLog::*)(org::imm::ImmSubtreeLog const&) const>(&org::imm::ImmSubtreeLog::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmSubtreeLog>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmSubtreeLogJs", {InstanceMethod("getKind", &ImmSubtreeLogJs::getKind),
                                                                                                                          InstanceMethod("operator==", &ImmSubtreeLogJs::operator==)}); }
};

template <>
struct js_to_org_type<ImmSubtreeLogJs> {
  using type = org::imm::ImmSubtreeLog;
};

template <>
struct org_to_js_type<org::imm::ImmSubtreeLog> {
  using type = ImmSubtreeLogJs;
};

struct ImmSubtreeJs : public SharedPtrWrapBase<ImmSubtreeJs, org::imm::ImmSubtree> {
  using SharedPtrWrapBase<ImmSubtreeJs, org::imm::ImmSubtree>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmSubtree::*)() const>(&org::imm::ImmSubtree::getKind),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmSubtree::*)(org::imm::ImmSubtree const&) const>(&org::imm::ImmSubtree::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmSubtree>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmSubtreeJs", {InstanceMethod("getKind", &ImmSubtreeJs::getKind),
                                                                                                                       InstanceMethod("operator==", &ImmSubtreeJs::operator==)}); }
};

template <>
struct js_to_org_type<ImmSubtreeJs> {
  using type = org::imm::ImmSubtree;
};

template <>
struct org_to_js_type<org::imm::ImmSubtree> {
  using type = ImmSubtreeJs;
};

struct ImmColonExampleJs : public SharedPtrWrapBase<ImmColonExampleJs, org::imm::ImmColonExample> {
  using SharedPtrWrapBase<ImmColonExampleJs, org::imm::ImmColonExample>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmColonExample::*)() const>(&org::imm::ImmColonExample::getKind),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmColonExample::*)(org::imm::ImmColonExample const&) const>(&org::imm::ImmColonExample::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmColonExample>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmColonExampleJs", {InstanceMethod("getKind", &ImmColonExampleJs::getKind),
                                                                                                                            InstanceMethod("operator==", &ImmColonExampleJs::operator==)}); }
};

template <>
struct js_to_org_type<ImmColonExampleJs> {
  using type = org::imm::ImmColonExample;
};

template <>
struct org_to_js_type<org::imm::ImmColonExample> {
  using type = ImmColonExampleJs;
};

struct ImmCallJs : public SharedPtrWrapBase<ImmCallJs, org::imm::ImmCall> {
  using SharedPtrWrapBase<ImmCallJs, org::imm::ImmCall>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmCall::*)() const>(&org::imm::ImmCall::getKind),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmCall::*)(org::imm::ImmCall const&) const>(&org::imm::ImmCall::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmCall>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCallJs", {InstanceMethod("getKind", &ImmCallJs::getKind),
                                                                                                                    InstanceMethod("operator==", &ImmCallJs::operator==)}); }
};

template <>
struct js_to_org_type<ImmCallJs> {
  using type = org::imm::ImmCall;
};

template <>
struct org_to_js_type<org::imm::ImmCall> {
  using type = ImmCallJs;
};

struct ImmListItemJs : public SharedPtrWrapBase<ImmListItemJs, org::imm::ImmListItem> {
  using SharedPtrWrapBase<ImmListItemJs, org::imm::ImmListItem>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmListItem::*)() const>(&org::imm::ImmListItem::getKind),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmListItem::*)(org::imm::ImmListItem const&) const>(&org::imm::ImmListItem::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmListItem>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmListItemJs", {InstanceMethod("getKind", &ImmListItemJs::getKind),
                                                                                                                        InstanceMethod("operator==", &ImmListItemJs::operator==)}); }
};

template <>
struct js_to_org_type<ImmListItemJs> {
  using type = org::imm::ImmListItem;
};

template <>
struct org_to_js_type<org::imm::ImmListItem> {
  using type = ImmListItemJs;
};

struct ImmDocumentOptionsJs : public SharedPtrWrapBase<ImmDocumentOptionsJs, org::imm::ImmDocumentOptions> {
  using SharedPtrWrapBase<ImmDocumentOptionsJs, org::imm::ImmDocumentOptions>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmDocumentOptions::*)() const>(&org::imm::ImmDocumentOptions::getKind),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmDocumentOptions::*)(org::imm::ImmDocumentOptions const&) const>(&org::imm::ImmDocumentOptions::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmDocumentOptions>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmDocumentOptionsJs", {InstanceMethod("getKind", &ImmDocumentOptionsJs::getKind),
                                                                                                                               InstanceMethod("operator==", &ImmDocumentOptionsJs::operator==)}); }
};

template <>
struct js_to_org_type<ImmDocumentOptionsJs> {
  using type = org::imm::ImmDocumentOptions;
};

template <>
struct org_to_js_type<org::imm::ImmDocumentOptions> {
  using type = ImmDocumentOptionsJs;
};

struct ImmDocumentFragmentJs : public SharedPtrWrapBase<ImmDocumentFragmentJs, org::imm::ImmDocumentFragment> {
  using SharedPtrWrapBase<ImmDocumentFragmentJs, org::imm::ImmDocumentFragment>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmDocumentFragment::*)() const>(&org::imm::ImmDocumentFragment::getKind),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmDocumentFragment::*)(org::imm::ImmDocumentFragment const&) const>(&org::imm::ImmDocumentFragment::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmDocumentFragment>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmDocumentFragmentJs", {InstanceMethod("getKind", &ImmDocumentFragmentJs::getKind),
                                                                                                                                InstanceMethod("operator==", &ImmDocumentFragmentJs::operator==)}); }
};

template <>
struct js_to_org_type<ImmDocumentFragmentJs> {
  using type = org::imm::ImmDocumentFragment;
};

template <>
struct org_to_js_type<org::imm::ImmDocumentFragment> {
  using type = ImmDocumentFragmentJs;
};

struct ImmCriticMarkupJs : public SharedPtrWrapBase<ImmCriticMarkupJs, org::imm::ImmCriticMarkup> {
  using SharedPtrWrapBase<ImmCriticMarkupJs, org::imm::ImmCriticMarkup>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmCriticMarkup::*)() const>(&org::imm::ImmCriticMarkup::getKind),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmCriticMarkup::*)(org::imm::ImmCriticMarkup const&) const>(&org::imm::ImmCriticMarkup::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmCriticMarkup>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCriticMarkupJs", {InstanceMethod("getKind", &ImmCriticMarkupJs::getKind),
                                                                                                                            InstanceMethod("operator==", &ImmCriticMarkupJs::operator==)}); }
};

template <>
struct js_to_org_type<ImmCriticMarkupJs> {
  using type = org::imm::ImmCriticMarkup;
};

template <>
struct org_to_js_type<org::imm::ImmCriticMarkup> {
  using type = ImmCriticMarkupJs;
};

struct ImmDocumentJs : public SharedPtrWrapBase<ImmDocumentJs, org::imm::ImmDocument> {
  using SharedPtrWrapBase<ImmDocumentJs, org::imm::ImmDocument>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmDocument::*)() const>(&org::imm::ImmDocument::getKind),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmDocument::*)(org::imm::ImmDocument const&) const>(&org::imm::ImmDocument::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmDocument>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmDocumentJs", {InstanceMethod("getKind", &ImmDocumentJs::getKind),
                                                                                                                        InstanceMethod("operator==", &ImmDocumentJs::operator==)}); }
};

template <>
struct js_to_org_type<ImmDocumentJs> {
  using type = org::imm::ImmDocument;
};

template <>
struct org_to_js_type<org::imm::ImmDocument> {
  using type = ImmDocumentJs;
};

struct ImmFileTargetJs : public SharedPtrWrapBase<ImmFileTargetJs, org::imm::ImmFileTarget> {
  using SharedPtrWrapBase<ImmFileTargetJs, org::imm::ImmFileTarget>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmFileTarget::*)() const>(&org::imm::ImmFileTarget::getKind),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmFileTarget::*)(org::imm::ImmFileTarget const&) const>(&org::imm::ImmFileTarget::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmFileTarget>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmFileTargetJs", {InstanceMethod("getKind", &ImmFileTargetJs::getKind),
                                                                                                                          InstanceMethod("operator==", &ImmFileTargetJs::operator==)}); }
};

template <>
struct js_to_org_type<ImmFileTargetJs> {
  using type = org::imm::ImmFileTarget;
};

template <>
struct org_to_js_type<org::imm::ImmFileTarget> {
  using type = ImmFileTargetJs;
};

struct ImmTextSeparatorJs : public SharedPtrWrapBase<ImmTextSeparatorJs, org::imm::ImmTextSeparator> {
  using SharedPtrWrapBase<ImmTextSeparatorJs, org::imm::ImmTextSeparator>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmTextSeparator::*)() const>(&org::imm::ImmTextSeparator::getKind),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmTextSeparator::*)(org::imm::ImmTextSeparator const&) const>(&org::imm::ImmTextSeparator::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmTextSeparator>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmTextSeparatorJs", {InstanceMethod("getKind", &ImmTextSeparatorJs::getKind),
                                                                                                                             InstanceMethod("operator==", &ImmTextSeparatorJs::operator==)}); }
};

template <>
struct js_to_org_type<ImmTextSeparatorJs> {
  using type = org::imm::ImmTextSeparator;
};

template <>
struct org_to_js_type<org::imm::ImmTextSeparator> {
  using type = ImmTextSeparatorJs;
};

struct ImmDocumentGroupJs : public SharedPtrWrapBase<ImmDocumentGroupJs, org::imm::ImmDocumentGroup> {
  using SharedPtrWrapBase<ImmDocumentGroupJs, org::imm::ImmDocumentGroup>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmDocumentGroup::*)() const>(&org::imm::ImmDocumentGroup::getKind),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmDocumentGroup::*)(org::imm::ImmDocumentGroup const&) const>(&org::imm::ImmDocumentGroup::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmDocumentGroup>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmDocumentGroupJs", {InstanceMethod("getKind", &ImmDocumentGroupJs::getKind),
                                                                                                                             InstanceMethod("operator==", &ImmDocumentGroupJs::operator==)}); }
};

template <>
struct js_to_org_type<ImmDocumentGroupJs> {
  using type = org::imm::ImmDocumentGroup;
};

template <>
struct org_to_js_type<org::imm::ImmDocumentGroup> {
  using type = ImmDocumentGroupJs;
};

struct ImmFileJs : public SharedPtrWrapBase<ImmFileJs, org::imm::ImmFile> {
  using SharedPtrWrapBase<ImmFileJs, org::imm::ImmFile>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmFile::*)() const>(&org::imm::ImmFile::getKind),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmFile::*)(org::imm::ImmFile const&) const>(&org::imm::ImmFile::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmFile>{"other"})));
  }
  Napi::Value isDocument(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmFile::*)() const>(&org::imm::ImmFile::isDocument),
                                        std::make_tuple()));
  }
  Napi::Value getDocumentMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::imm::ImmFile::Document&(org::imm::ImmFile::*)()>(&org::imm::ImmFile::getDocument),
                                   std::make_tuple()));
  }
  Napi::Value isAttachment(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmFile::*)() const>(&org::imm::ImmFile::isAttachment),
                                        std::make_tuple()));
  }
  Napi::Value getAttachmentMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::imm::ImmFile::Attachment&(org::imm::ImmFile::*)()>(&org::imm::ImmFile::getAttachment),
                                   std::make_tuple()));
  }
  Napi::Value isSource(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmFile::*)() const>(&org::imm::ImmFile::isSource),
                                        std::make_tuple()));
  }
  Napi::Value getSourceMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::imm::ImmFile::Source&(org::imm::ImmFile::*)()>(&org::imm::ImmFile::getSource),
                                   std::make_tuple()));
  }
  Napi::Value getFileKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmFile::Kind(org::imm::ImmFile::*)() const>(&org::imm::ImmFile::getFileKind),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_kind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmFile::Kind(org::imm::ImmFile::*)() const>(&org::imm::ImmFile::sub_variant_get_kind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmFileJs", {InstanceMethod("getKind", &ImmFileJs::getKind),
                                                                                                                    InstanceMethod("operator==", &ImmFileJs::operator==),
                                                                                                                    InstanceMethod("isDocument", &ImmFileJs::isDocument),
                                                                                                                    InstanceMethod("getDocumentMut", &ImmFileJs::getDocumentMut),
                                                                                                                    InstanceMethod("isAttachment", &ImmFileJs::isAttachment),
                                                                                                                    InstanceMethod("getAttachmentMut", &ImmFileJs::getAttachmentMut),
                                                                                                                    InstanceMethod("isSource", &ImmFileJs::isSource),
                                                                                                                    InstanceMethod("getSourceMut", &ImmFileJs::getSourceMut),
                                                                                                                    InstanceMethod("getFileKind", &ImmFileJs::getFileKind),
                                                                                                                    InstanceMethod("sub_variant_get_kind", &ImmFileJs::sub_variant_get_kind)}); }
};

template <>
struct js_to_org_type<ImmFileJs> {
  using type = org::imm::ImmFile;
};

template <>
struct org_to_js_type<org::imm::ImmFile> {
  using type = ImmFileJs;
};

struct DocumentImmFileJs : public SharedPtrWrapBase<DocumentImmFileJs, org::imm::ImmFile::Document> {
  using SharedPtrWrapBase<DocumentImmFileJs, org::imm::ImmFile::Document>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmFile::Document::*)(org::imm::ImmFile::Document const&) const>(&org::imm::ImmFile::Document::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmFile::Document>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "DocumentImmFileJs", {InstanceMethod("operator==", &DocumentImmFileJs::operator==)}); }
};

template <>
struct js_to_org_type<DocumentImmFileJs> {
  using type = org::imm::ImmFile::Document;
};

template <>
struct org_to_js_type<org::imm::ImmFile::Document> {
  using type = DocumentImmFileJs;
};

struct AttachmentImmFileJs : public SharedPtrWrapBase<AttachmentImmFileJs, org::imm::ImmFile::Attachment> {
  using SharedPtrWrapBase<AttachmentImmFileJs, org::imm::ImmFile::Attachment>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmFile::Attachment::*)(org::imm::ImmFile::Attachment const&) const>(&org::imm::ImmFile::Attachment::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmFile::Attachment>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "AttachmentImmFileJs", {InstanceMethod("operator==", &AttachmentImmFileJs::operator==)}); }
};

template <>
struct js_to_org_type<AttachmentImmFileJs> {
  using type = org::imm::ImmFile::Attachment;
};

template <>
struct org_to_js_type<org::imm::ImmFile::Attachment> {
  using type = AttachmentImmFileJs;
};

struct SourceImmFileJs : public SharedPtrWrapBase<SourceImmFileJs, org::imm::ImmFile::Source> {
  using SharedPtrWrapBase<SourceImmFileJs, org::imm::ImmFile::Source>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmFile::Source::*)(org::imm::ImmFile::Source const&) const>(&org::imm::ImmFile::Source::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmFile::Source>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "SourceImmFileJs", {InstanceMethod("operator==", &SourceImmFileJs::operator==)}); }
};

template <>
struct js_to_org_type<SourceImmFileJs> {
  using type = org::imm::ImmFile::Source;
};

template <>
struct org_to_js_type<org::imm::ImmFile::Source> {
  using type = SourceImmFileJs;
};

struct ImmDirectoryJs : public SharedPtrWrapBase<ImmDirectoryJs, org::imm::ImmDirectory> {
  using SharedPtrWrapBase<ImmDirectoryJs, org::imm::ImmDirectory>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmDirectory::*)() const>(&org::imm::ImmDirectory::getKind),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmDirectory::*)(org::imm::ImmDirectory const&) const>(&org::imm::ImmDirectory::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmDirectory>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmDirectoryJs", {InstanceMethod("getKind", &ImmDirectoryJs::getKind),
                                                                                                                         InstanceMethod("operator==", &ImmDirectoryJs::operator==)}); }
};

template <>
struct js_to_org_type<ImmDirectoryJs> {
  using type = org::imm::ImmDirectory;
};

template <>
struct org_to_js_type<org::imm::ImmDirectory> {
  using type = ImmDirectoryJs;
};

struct ImmSymlinkJs : public SharedPtrWrapBase<ImmSymlinkJs, org::imm::ImmSymlink> {
  using SharedPtrWrapBase<ImmSymlinkJs, org::imm::ImmSymlink>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmSymlink::*)() const>(&org::imm::ImmSymlink::getKind),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmSymlink::*)(org::imm::ImmSymlink const&) const>(&org::imm::ImmSymlink::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmSymlink>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmSymlinkJs", {InstanceMethod("getKind", &ImmSymlinkJs::getKind),
                                                                                                                       InstanceMethod("operator==", &ImmSymlinkJs::operator==)}); }
};

template <>
struct js_to_org_type<ImmSymlinkJs> {
  using type = org::imm::ImmSymlink;
};

template <>
struct org_to_js_type<org::imm::ImmSymlink> {
  using type = ImmSymlinkJs;
};

struct ImmCmdIncludeJs : public SharedPtrWrapBase<ImmCmdIncludeJs, org::imm::ImmCmdInclude> {
  using SharedPtrWrapBase<ImmCmdIncludeJs, org::imm::ImmCmdInclude>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmCmdInclude::*)() const>(&org::imm::ImmCmdInclude::getKind),
                                        std::make_tuple()));
  }
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmCmdInclude::*)(org::imm::ImmCmdInclude const&) const>(&org::imm::ImmCmdInclude::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmCmdInclude>{"other"})));
  }
  Napi::Value isExample(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmCmdInclude::*)() const>(&org::imm::ImmCmdInclude::isExample),
                                        std::make_tuple()));
  }
  Napi::Value getExampleMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::imm::ImmCmdInclude::Example&(org::imm::ImmCmdInclude::*)()>(&org::imm::ImmCmdInclude::getExample),
                                   std::make_tuple()));
  }
  Napi::Value isExport(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmCmdInclude::*)() const>(&org::imm::ImmCmdInclude::isExport),
                                        std::make_tuple()));
  }
  Napi::Value getExportMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::imm::ImmCmdInclude::Export&(org::imm::ImmCmdInclude::*)()>(&org::imm::ImmCmdInclude::getExport),
                                   std::make_tuple()));
  }
  Napi::Value isCustom(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmCmdInclude::*)() const>(&org::imm::ImmCmdInclude::isCustom),
                                        std::make_tuple()));
  }
  Napi::Value getCustomMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::imm::ImmCmdInclude::Custom&(org::imm::ImmCmdInclude::*)()>(&org::imm::ImmCmdInclude::getCustom),
                                   std::make_tuple()));
  }
  Napi::Value isSrc(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmCmdInclude::*)() const>(&org::imm::ImmCmdInclude::isSrc),
                                        std::make_tuple()));
  }
  Napi::Value getSrcMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::imm::ImmCmdInclude::Src&(org::imm::ImmCmdInclude::*)()>(&org::imm::ImmCmdInclude::getSrc),
                                   std::make_tuple()));
  }
  Napi::Value isOrgDocument(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmCmdInclude::*)() const>(&org::imm::ImmCmdInclude::isOrgDocument),
                                        std::make_tuple()));
  }
  Napi::Value getOrgDocumentMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::imm::ImmCmdInclude::OrgDocument&(org::imm::ImmCmdInclude::*)()>(&org::imm::ImmCmdInclude::getOrgDocument),
                                   std::make_tuple()));
  }
  Napi::Value getIncludeKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCmdInclude::Kind(org::imm::ImmCmdInclude::*)() const>(&org::imm::ImmCmdInclude::getIncludeKind),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_kind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCmdInclude::Kind(org::imm::ImmCmdInclude::*)() const>(&org::imm::ImmCmdInclude::sub_variant_get_kind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdIncludeJs", {InstanceMethod("getKind", &ImmCmdIncludeJs::getKind),
                                                                                                                          InstanceMethod("operator==", &ImmCmdIncludeJs::operator==),
                                                                                                                          InstanceMethod("isExample", &ImmCmdIncludeJs::isExample),
                                                                                                                          InstanceMethod("getExampleMut", &ImmCmdIncludeJs::getExampleMut),
                                                                                                                          InstanceMethod("isExport", &ImmCmdIncludeJs::isExport),
                                                                                                                          InstanceMethod("getExportMut", &ImmCmdIncludeJs::getExportMut),
                                                                                                                          InstanceMethod("isCustom", &ImmCmdIncludeJs::isCustom),
                                                                                                                          InstanceMethod("getCustomMut", &ImmCmdIncludeJs::getCustomMut),
                                                                                                                          InstanceMethod("isSrc", &ImmCmdIncludeJs::isSrc),
                                                                                                                          InstanceMethod("getSrcMut", &ImmCmdIncludeJs::getSrcMut),
                                                                                                                          InstanceMethod("isOrgDocument", &ImmCmdIncludeJs::isOrgDocument),
                                                                                                                          InstanceMethod("getOrgDocumentMut", &ImmCmdIncludeJs::getOrgDocumentMut),
                                                                                                                          InstanceMethod("getIncludeKind", &ImmCmdIncludeJs::getIncludeKind),
                                                                                                                          InstanceMethod("sub_variant_get_kind", &ImmCmdIncludeJs::sub_variant_get_kind)}); }
};

template <>
struct js_to_org_type<ImmCmdIncludeJs> {
  using type = org::imm::ImmCmdInclude;
};

template <>
struct org_to_js_type<org::imm::ImmCmdInclude> {
  using type = ImmCmdIncludeJs;
};

struct IncludeBaseImmCmdIncludeJs : public SharedPtrWrapBase<IncludeBaseImmCmdIncludeJs, org::imm::ImmCmdInclude::IncludeBase> {
  using SharedPtrWrapBase<IncludeBaseImmCmdIncludeJs, org::imm::ImmCmdInclude::IncludeBase>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmCmdInclude::IncludeBase::*)(org::imm::ImmCmdInclude::IncludeBase const&) const>(&org::imm::ImmCmdInclude::IncludeBase::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmCmdInclude::IncludeBase>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "IncludeBaseImmCmdIncludeJs", {InstanceMethod("operator==", &IncludeBaseImmCmdIncludeJs::operator==)}); }
};

template <>
struct js_to_org_type<IncludeBaseImmCmdIncludeJs> {
  using type = org::imm::ImmCmdInclude::IncludeBase;
};

template <>
struct org_to_js_type<org::imm::ImmCmdInclude::IncludeBase> {
  using type = IncludeBaseImmCmdIncludeJs;
};

struct ExampleImmCmdIncludeJs : public SharedPtrWrapBase<ExampleImmCmdIncludeJs, org::imm::ImmCmdInclude::Example> {
  using SharedPtrWrapBase<ExampleImmCmdIncludeJs, org::imm::ImmCmdInclude::Example>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmCmdInclude::Example::*)(org::imm::ImmCmdInclude::Example const&) const>(&org::imm::ImmCmdInclude::Example::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmCmdInclude::Example>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ExampleImmCmdIncludeJs", {InstanceMethod("operator==", &ExampleImmCmdIncludeJs::operator==)}); }
};

template <>
struct js_to_org_type<ExampleImmCmdIncludeJs> {
  using type = org::imm::ImmCmdInclude::Example;
};

template <>
struct org_to_js_type<org::imm::ImmCmdInclude::Example> {
  using type = ExampleImmCmdIncludeJs;
};

struct ExportImmCmdIncludeJs : public SharedPtrWrapBase<ExportImmCmdIncludeJs, org::imm::ImmCmdInclude::Export> {
  using SharedPtrWrapBase<ExportImmCmdIncludeJs, org::imm::ImmCmdInclude::Export>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmCmdInclude::Export::*)(org::imm::ImmCmdInclude::Export const&) const>(&org::imm::ImmCmdInclude::Export::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmCmdInclude::Export>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ExportImmCmdIncludeJs", {InstanceMethod("operator==", &ExportImmCmdIncludeJs::operator==)}); }
};

template <>
struct js_to_org_type<ExportImmCmdIncludeJs> {
  using type = org::imm::ImmCmdInclude::Export;
};

template <>
struct org_to_js_type<org::imm::ImmCmdInclude::Export> {
  using type = ExportImmCmdIncludeJs;
};

struct CustomImmCmdIncludeJs : public SharedPtrWrapBase<CustomImmCmdIncludeJs, org::imm::ImmCmdInclude::Custom> {
  using SharedPtrWrapBase<CustomImmCmdIncludeJs, org::imm::ImmCmdInclude::Custom>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmCmdInclude::Custom::*)(org::imm::ImmCmdInclude::Custom const&) const>(&org::imm::ImmCmdInclude::Custom::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmCmdInclude::Custom>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "CustomImmCmdIncludeJs", {InstanceMethod("operator==", &CustomImmCmdIncludeJs::operator==)}); }
};

template <>
struct js_to_org_type<CustomImmCmdIncludeJs> {
  using type = org::imm::ImmCmdInclude::Custom;
};

template <>
struct org_to_js_type<org::imm::ImmCmdInclude::Custom> {
  using type = CustomImmCmdIncludeJs;
};

struct SrcImmCmdIncludeJs : public SharedPtrWrapBase<SrcImmCmdIncludeJs, org::imm::ImmCmdInclude::Src> {
  using SharedPtrWrapBase<SrcImmCmdIncludeJs, org::imm::ImmCmdInclude::Src>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmCmdInclude::Src::*)(org::imm::ImmCmdInclude::Src const&) const>(&org::imm::ImmCmdInclude::Src::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmCmdInclude::Src>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "SrcImmCmdIncludeJs", {InstanceMethod("operator==", &SrcImmCmdIncludeJs::operator==)}); }
};

template <>
struct js_to_org_type<SrcImmCmdIncludeJs> {
  using type = org::imm::ImmCmdInclude::Src;
};

template <>
struct org_to_js_type<org::imm::ImmCmdInclude::Src> {
  using type = SrcImmCmdIncludeJs;
};

struct OrgDocumentImmCmdIncludeJs : public SharedPtrWrapBase<OrgDocumentImmCmdIncludeJs, org::imm::ImmCmdInclude::OrgDocument> {
  using SharedPtrWrapBase<OrgDocumentImmCmdIncludeJs, org::imm::ImmCmdInclude::OrgDocument>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmCmdInclude::OrgDocument::*)(org::imm::ImmCmdInclude::OrgDocument const&) const>(&org::imm::ImmCmdInclude::OrgDocument::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmCmdInclude::OrgDocument>{"other"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "OrgDocumentImmCmdIncludeJs", {InstanceMethod("operator==", &OrgDocumentImmCmdIncludeJs::operator==)}); }
};

template <>
struct js_to_org_type<OrgDocumentImmCmdIncludeJs> {
  using type = org::imm::ImmCmdInclude::OrgDocument;
};

template <>
struct org_to_js_type<org::imm::ImmCmdInclude::OrgDocument> {
  using type = OrgDocumentImmCmdIncludeJs;
};

struct NoneJs : public SharedPtrWrapBase<NoneJs, org::sem::None> {
  using SharedPtrWrapBase<NoneJs, org::sem::None>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::None::*)() const>(&org::sem::None::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::None::*)() const>(&org::sem::None::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::None::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::None::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::None::*)() const>(&org::sem::None::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::None::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::None::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::None::*)(int) const>(&org::sem::None::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::None::*)(OrgSemKind) const>(&org::sem::None::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "NoneJs", {InstanceMethod("getKind", &NoneJs::getKind),
                                                                                                                 InstanceMethod("isGenerated", &NoneJs::isGenerated),
                                                                                                                 InstanceMethod("push_back", &NoneJs::push_back),
                                                                                                                 InstanceMethod("size", &NoneJs::size),
                                                                                                                 InstanceMethod("insert", &NoneJs::insert),
                                                                                                                 InstanceMethod("at", &NoneJs::at),
                                                                                                                 InstanceMethod("is", &NoneJs::is)}); }
};

template <>
struct js_to_org_type<NoneJs> {
  using type = org::sem::None;
};

template <>
struct org_to_js_type<org::sem::None> {
  using type = NoneJs;
};

struct ErrorItemJs : public SharedPtrWrapBase<ErrorItemJs, org::sem::ErrorItem> {
  using SharedPtrWrapBase<ErrorItemJs, org::sem::ErrorItem>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::ErrorItem::*)() const>(&org::sem::ErrorItem::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ErrorItem::*)() const>(&org::sem::ErrorItem::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::ErrorItem::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::ErrorItem::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::ErrorItem::*)() const>(&org::sem::ErrorItem::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::ErrorItem::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::ErrorItem::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::ErrorItem::*)(int) const>(&org::sem::ErrorItem::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ErrorItem::*)(OrgSemKind) const>(&org::sem::ErrorItem::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ErrorItemJs", {InstanceMethod("getKind", &ErrorItemJs::getKind),
                                                                                                                      InstanceMethod("isGenerated", &ErrorItemJs::isGenerated),
                                                                                                                      InstanceMethod("push_back", &ErrorItemJs::push_back),
                                                                                                                      InstanceMethod("size", &ErrorItemJs::size),
                                                                                                                      InstanceMethod("insert", &ErrorItemJs::insert),
                                                                                                                      InstanceMethod("at", &ErrorItemJs::at),
                                                                                                                      InstanceMethod("is", &ErrorItemJs::is)}); }
};

template <>
struct js_to_org_type<ErrorItemJs> {
  using type = org::sem::ErrorItem;
};

template <>
struct org_to_js_type<org::sem::ErrorItem> {
  using type = ErrorItemJs;
};

struct ErrorGroupJs : public SharedPtrWrapBase<ErrorGroupJs, org::sem::ErrorGroup> {
  using SharedPtrWrapBase<ErrorGroupJs, org::sem::ErrorGroup>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::ErrorGroup::*)() const>(&org::sem::ErrorGroup::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ErrorGroup::*)() const>(&org::sem::ErrorGroup::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::ErrorGroup::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::ErrorGroup::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::ErrorGroup::*)() const>(&org::sem::ErrorGroup::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::ErrorGroup::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::ErrorGroup::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::ErrorGroup::*)(int) const>(&org::sem::ErrorGroup::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ErrorGroup::*)(OrgSemKind) const>(&org::sem::ErrorGroup::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ErrorGroupJs", {InstanceMethod("getKind", &ErrorGroupJs::getKind),
                                                                                                                       InstanceMethod("isGenerated", &ErrorGroupJs::isGenerated),
                                                                                                                       InstanceMethod("push_back", &ErrorGroupJs::push_back),
                                                                                                                       InstanceMethod("size", &ErrorGroupJs::size),
                                                                                                                       InstanceMethod("insert", &ErrorGroupJs::insert),
                                                                                                                       InstanceMethod("at", &ErrorGroupJs::at),
                                                                                                                       InstanceMethod("is", &ErrorGroupJs::is)}); }
};

template <>
struct js_to_org_type<ErrorGroupJs> {
  using type = org::sem::ErrorGroup;
};

template <>
struct org_to_js_type<org::sem::ErrorGroup> {
  using type = ErrorGroupJs;
};

struct StmtListJs : public SharedPtrWrapBase<StmtListJs, org::sem::StmtList> {
  using SharedPtrWrapBase<StmtListJs, org::sem::StmtList>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::StmtList::*)() const>(&org::sem::StmtList::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::StmtList::*)() const>(&org::sem::StmtList::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::StmtList::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::StmtList::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::StmtList::*)() const>(&org::sem::StmtList::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::StmtList::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::StmtList::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::StmtList::*)(int) const>(&org::sem::StmtList::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::StmtList::*)(OrgSemKind) const>(&org::sem::StmtList::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "StmtListJs", {InstanceMethod("getKind", &StmtListJs::getKind),
                                                                                                                     InstanceMethod("isGenerated", &StmtListJs::isGenerated),
                                                                                                                     InstanceMethod("push_back", &StmtListJs::push_back),
                                                                                                                     InstanceMethod("size", &StmtListJs::size),
                                                                                                                     InstanceMethod("insert", &StmtListJs::insert),
                                                                                                                     InstanceMethod("at", &StmtListJs::at),
                                                                                                                     InstanceMethod("is", &StmtListJs::is)}); }
};

template <>
struct js_to_org_type<StmtListJs> {
  using type = org::sem::StmtList;
};

template <>
struct org_to_js_type<org::sem::StmtList> {
  using type = StmtListJs;
};

struct EmptyJs : public SharedPtrWrapBase<EmptyJs, org::sem::Empty> {
  using SharedPtrWrapBase<EmptyJs, org::sem::Empty>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Empty::*)() const>(&org::sem::Empty::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Empty::*)() const>(&org::sem::Empty::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Empty::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Empty::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::Empty::*)() const>(&org::sem::Empty::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Empty::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Empty::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Empty::*)(int) const>(&org::sem::Empty::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Empty::*)(OrgSemKind) const>(&org::sem::Empty::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "EmptyJs", {InstanceMethod("getKind", &EmptyJs::getKind),
                                                                                                                  InstanceMethod("isGenerated", &EmptyJs::isGenerated),
                                                                                                                  InstanceMethod("push_back", &EmptyJs::push_back),
                                                                                                                  InstanceMethod("size", &EmptyJs::size),
                                                                                                                  InstanceMethod("insert", &EmptyJs::insert),
                                                                                                                  InstanceMethod("at", &EmptyJs::at),
                                                                                                                  InstanceMethod("is", &EmptyJs::is)}); }
};

template <>
struct js_to_org_type<EmptyJs> {
  using type = org::sem::Empty;
};

template <>
struct org_to_js_type<org::sem::Empty> {
  using type = EmptyJs;
};

struct TimeJs : public SharedPtrWrapBase<TimeJs, org::sem::Time> {
  using SharedPtrWrapBase<TimeJs, org::sem::Time>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Time::*)() const>(&org::sem::Time::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Time::*)() const>(&org::sem::Time::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Time::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Time::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::Time::*)() const>(&org::sem::Time::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Time::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Time::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Time::*)(int) const>(&org::sem::Time::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Time::*)(OrgSemKind) const>(&org::sem::Time::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getYear(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<int>(org::sem::Time::*)() const>(&org::sem::Time::getYear),
                                        std::make_tuple()));
  }
  Napi::Value getMonth(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<int>(org::sem::Time::*)() const>(&org::sem::Time::getMonth),
                                        std::make_tuple()));
  }
  Napi::Value getDay(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<int>(org::sem::Time::*)() const>(&org::sem::Time::getDay),
                                        std::make_tuple()));
  }
  Napi::Value getHour(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<int>(org::sem::Time::*)() const>(&org::sem::Time::getHour),
                                        std::make_tuple()));
  }
  Napi::Value getMinute(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<int>(org::sem::Time::*)() const>(&org::sem::Time::getMinute),
                                        std::make_tuple()));
  }
  Napi::Value getSecond(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<int>(org::sem::Time::*)() const>(&org::sem::Time::getSecond),
                                        std::make_tuple()));
  }
  Napi::Value getStaticTime(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::UserTime(org::sem::Time::*)() const>(&org::sem::Time::getStaticTime),
                                        std::make_tuple()));
  }
  Napi::Value isStatic(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Time::*)() const>(&org::sem::Time::isStatic),
                                        std::make_tuple()));
  }
  Napi::Value getStaticMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::Time::Static&(org::sem::Time::*)()>(&org::sem::Time::getStatic),
                                   std::make_tuple()));
  }
  Napi::Value isDynamic(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Time::*)() const>(&org::sem::Time::isDynamic),
                                        std::make_tuple()));
  }
  Napi::Value getDynamicMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::Time::Dynamic&(org::sem::Time::*)()>(&org::sem::Time::getDynamic),
                                   std::make_tuple()));
  }
  Napi::Value getTimeKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::Time::TimeKind(org::sem::Time::*)() const>(&org::sem::Time::getTimeKind),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_kind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::Time::TimeKind(org::sem::Time::*)() const>(&org::sem::Time::sub_variant_get_kind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "TimeJs", {InstanceMethod("getKind", &TimeJs::getKind),
                                                                                                                 InstanceMethod("isGenerated", &TimeJs::isGenerated),
                                                                                                                 InstanceMethod("push_back", &TimeJs::push_back),
                                                                                                                 InstanceMethod("size", &TimeJs::size),
                                                                                                                 InstanceMethod("insert", &TimeJs::insert),
                                                                                                                 InstanceMethod("at", &TimeJs::at),
                                                                                                                 InstanceMethod("is", &TimeJs::is),
                                                                                                                 InstanceMethod("getYear", &TimeJs::getYear),
                                                                                                                 InstanceMethod("getMonth", &TimeJs::getMonth),
                                                                                                                 InstanceMethod("getDay", &TimeJs::getDay),
                                                                                                                 InstanceMethod("getHour", &TimeJs::getHour),
                                                                                                                 InstanceMethod("getMinute", &TimeJs::getMinute),
                                                                                                                 InstanceMethod("getSecond", &TimeJs::getSecond),
                                                                                                                 InstanceMethod("getStaticTime", &TimeJs::getStaticTime),
                                                                                                                 InstanceMethod("isStatic", &TimeJs::isStatic),
                                                                                                                 InstanceMethod("getStaticMut", &TimeJs::getStaticMut),
                                                                                                                 InstanceMethod("isDynamic", &TimeJs::isDynamic),
                                                                                                                 InstanceMethod("getDynamicMut", &TimeJs::getDynamicMut),
                                                                                                                 InstanceMethod("getTimeKind", &TimeJs::getTimeKind),
                                                                                                                 InstanceMethod("sub_variant_get_kind", &TimeJs::sub_variant_get_kind)}); }
};

template <>
struct js_to_org_type<TimeJs> {
  using type = org::sem::Time;
};

template <>
struct org_to_js_type<org::sem::Time> {
  using type = TimeJs;
};

struct RepeatTimeJs : public SharedPtrWrapBase<RepeatTimeJs, org::sem::Time::Repeat> {
  using SharedPtrWrapBase<RepeatTimeJs, org::sem::Time::Repeat>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "RepeatTimeJs", {}); }
};

template <>
struct js_to_org_type<RepeatTimeJs> {
  using type = org::sem::Time::Repeat;
};

template <>
struct org_to_js_type<org::sem::Time::Repeat> {
  using type = RepeatTimeJs;
};

struct StaticTimeJs : public SharedPtrWrapBase<StaticTimeJs, org::sem::Time::Static> {
  using SharedPtrWrapBase<StaticTimeJs, org::sem::Time::Static>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "StaticTimeJs", {}); }
};

template <>
struct js_to_org_type<StaticTimeJs> {
  using type = org::sem::Time::Static;
};

template <>
struct org_to_js_type<org::sem::Time::Static> {
  using type = StaticTimeJs;
};

struct DynamicTimeJs : public SharedPtrWrapBase<DynamicTimeJs, org::sem::Time::Dynamic> {
  using SharedPtrWrapBase<DynamicTimeJs, org::sem::Time::Dynamic>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "DynamicTimeJs", {}); }
};

template <>
struct js_to_org_type<DynamicTimeJs> {
  using type = org::sem::Time::Dynamic;
};

template <>
struct org_to_js_type<org::sem::Time::Dynamic> {
  using type = DynamicTimeJs;
};

struct TimeRangeJs : public SharedPtrWrapBase<TimeRangeJs, org::sem::TimeRange> {
  using SharedPtrWrapBase<TimeRangeJs, org::sem::TimeRange>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::TimeRange::*)() const>(&org::sem::TimeRange::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::TimeRange::*)() const>(&org::sem::TimeRange::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::TimeRange::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::TimeRange::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::TimeRange::*)() const>(&org::sem::TimeRange::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::TimeRange::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::TimeRange::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::TimeRange::*)(int) const>(&org::sem::TimeRange::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::TimeRange::*)(OrgSemKind) const>(&org::sem::TimeRange::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "TimeRangeJs", {InstanceMethod("getKind", &TimeRangeJs::getKind),
                                                                                                                      InstanceMethod("isGenerated", &TimeRangeJs::isGenerated),
                                                                                                                      InstanceMethod("push_back", &TimeRangeJs::push_back),
                                                                                                                      InstanceMethod("size", &TimeRangeJs::size),
                                                                                                                      InstanceMethod("insert", &TimeRangeJs::insert),
                                                                                                                      InstanceMethod("at", &TimeRangeJs::at),
                                                                                                                      InstanceMethod("is", &TimeRangeJs::is)}); }
};

template <>
struct js_to_org_type<TimeRangeJs> {
  using type = org::sem::TimeRange;
};

template <>
struct org_to_js_type<org::sem::TimeRange> {
  using type = TimeRangeJs;
};

struct MacroJs : public SharedPtrWrapBase<MacroJs, org::sem::Macro> {
  using SharedPtrWrapBase<MacroJs, org::sem::Macro>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Macro::*)() const>(&org::sem::Macro::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Macro::*)() const>(&org::sem::Macro::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Macro::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Macro::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::Macro::*)() const>(&org::sem::Macro::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Macro::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Macro::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Macro::*)(int) const>(&org::sem::Macro::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Macro::*)(OrgSemKind) const>(&org::sem::Macro::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "MacroJs", {InstanceMethod("getKind", &MacroJs::getKind),
                                                                                                                  InstanceMethod("isGenerated", &MacroJs::isGenerated),
                                                                                                                  InstanceMethod("push_back", &MacroJs::push_back),
                                                                                                                  InstanceMethod("size", &MacroJs::size),
                                                                                                                  InstanceMethod("insert", &MacroJs::insert),
                                                                                                                  InstanceMethod("at", &MacroJs::at),
                                                                                                                  InstanceMethod("is", &MacroJs::is)}); }
};

template <>
struct js_to_org_type<MacroJs> {
  using type = org::sem::Macro;
};

template <>
struct org_to_js_type<org::sem::Macro> {
  using type = MacroJs;
};

struct SymbolJs : public SharedPtrWrapBase<SymbolJs, org::sem::Symbol> {
  using SharedPtrWrapBase<SymbolJs, org::sem::Symbol>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Symbol::*)() const>(&org::sem::Symbol::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Symbol::*)() const>(&org::sem::Symbol::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Symbol::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Symbol::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::Symbol::*)() const>(&org::sem::Symbol::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Symbol::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Symbol::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Symbol::*)(int) const>(&org::sem::Symbol::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Symbol::*)(OrgSemKind) const>(&org::sem::Symbol::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "SymbolJs", {InstanceMethod("getKind", &SymbolJs::getKind),
                                                                                                                   InstanceMethod("isGenerated", &SymbolJs::isGenerated),
                                                                                                                   InstanceMethod("push_back", &SymbolJs::push_back),
                                                                                                                   InstanceMethod("size", &SymbolJs::size),
                                                                                                                   InstanceMethod("insert", &SymbolJs::insert),
                                                                                                                   InstanceMethod("at", &SymbolJs::at),
                                                                                                                   InstanceMethod("is", &SymbolJs::is)}); }
};

template <>
struct js_to_org_type<SymbolJs> {
  using type = org::sem::Symbol;
};

template <>
struct org_to_js_type<org::sem::Symbol> {
  using type = SymbolJs;
};

struct ParamSymbolJs : public SharedPtrWrapBase<ParamSymbolJs, org::sem::Symbol::Param> {
  using SharedPtrWrapBase<ParamSymbolJs, org::sem::Symbol::Param>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ParamSymbolJs", {}); }
};

template <>
struct js_to_org_type<ParamSymbolJs> {
  using type = org::sem::Symbol::Param;
};

template <>
struct org_to_js_type<org::sem::Symbol::Param> {
  using type = ParamSymbolJs;
};

struct RadioTargetJs : public SharedPtrWrapBase<RadioTargetJs, org::sem::RadioTarget> {
  using SharedPtrWrapBase<RadioTargetJs, org::sem::RadioTarget>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::RadioTarget::*)() const>(&org::sem::RadioTarget::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::RadioTarget::*)() const>(&org::sem::RadioTarget::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::RadioTarget::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::RadioTarget::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::RadioTarget::*)() const>(&org::sem::RadioTarget::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::RadioTarget::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::RadioTarget::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::RadioTarget::*)(int) const>(&org::sem::RadioTarget::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::RadioTarget::*)(OrgSemKind) const>(&org::sem::RadioTarget::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "RadioTargetJs", {InstanceMethod("getKind", &RadioTargetJs::getKind),
                                                                                                                        InstanceMethod("isGenerated", &RadioTargetJs::isGenerated),
                                                                                                                        InstanceMethod("push_back", &RadioTargetJs::push_back),
                                                                                                                        InstanceMethod("size", &RadioTargetJs::size),
                                                                                                                        InstanceMethod("insert", &RadioTargetJs::insert),
                                                                                                                        InstanceMethod("at", &RadioTargetJs::at),
                                                                                                                        InstanceMethod("is", &RadioTargetJs::is)}); }
};

template <>
struct js_to_org_type<RadioTargetJs> {
  using type = org::sem::RadioTarget;
};

template <>
struct org_to_js_type<org::sem::RadioTarget> {
  using type = RadioTargetJs;
};

struct LatexJs : public SharedPtrWrapBase<LatexJs, org::sem::Latex> {
  using SharedPtrWrapBase<LatexJs, org::sem::Latex>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Latex::*)() const>(&org::sem::Latex::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Latex::*)() const>(&org::sem::Latex::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Latex::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Latex::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::Latex::*)() const>(&org::sem::Latex::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Latex::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Latex::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Latex::*)(int) const>(&org::sem::Latex::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Latex::*)(OrgSemKind) const>(&org::sem::Latex::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "LatexJs", {InstanceMethod("getKind", &LatexJs::getKind),
                                                                                                                  InstanceMethod("isGenerated", &LatexJs::isGenerated),
                                                                                                                  InstanceMethod("push_back", &LatexJs::push_back),
                                                                                                                  InstanceMethod("size", &LatexJs::size),
                                                                                                                  InstanceMethod("insert", &LatexJs::insert),
                                                                                                                  InstanceMethod("at", &LatexJs::at),
                                                                                                                  InstanceMethod("is", &LatexJs::is)}); }
};

template <>
struct js_to_org_type<LatexJs> {
  using type = org::sem::Latex;
};

template <>
struct org_to_js_type<org::sem::Latex> {
  using type = LatexJs;
};

struct SubtreeLogJs : public SharedPtrWrapBase<SubtreeLogJs, org::sem::SubtreeLog> {
  using SharedPtrWrapBase<SubtreeLogJs, org::sem::SubtreeLog>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::SubtreeLog::*)() const>(&org::sem::SubtreeLog::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLog::*)() const>(&org::sem::SubtreeLog::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::SubtreeLog::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::SubtreeLog::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::SubtreeLog::*)() const>(&org::sem::SubtreeLog::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::SubtreeLog::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::SubtreeLog::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::SubtreeLog::*)(int) const>(&org::sem::SubtreeLog::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::SubtreeLog::*)(OrgSemKind) const>(&org::sem::SubtreeLog::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value setDescription(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::SubtreeLog::*)(org::sem::SemId<org::sem::StmtList>)>(&org::sem::SubtreeLog::setDescription),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::StmtList>>{"desc"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "SubtreeLogJs", {InstanceMethod("getKind", &SubtreeLogJs::getKind),
                                                                                                                       InstanceMethod("isGenerated", &SubtreeLogJs::isGenerated),
                                                                                                                       InstanceMethod("push_back", &SubtreeLogJs::push_back),
                                                                                                                       InstanceMethod("size", &SubtreeLogJs::size),
                                                                                                                       InstanceMethod("insert", &SubtreeLogJs::insert),
                                                                                                                       InstanceMethod("at", &SubtreeLogJs::at),
                                                                                                                       InstanceMethod("is", &SubtreeLogJs::is),
                                                                                                                       InstanceMethod("setDescription", &SubtreeLogJs::setDescription)}); }
};

template <>
struct js_to_org_type<SubtreeLogJs> {
  using type = org::sem::SubtreeLog;
};

template <>
struct org_to_js_type<org::sem::SubtreeLog> {
  using type = SubtreeLogJs;
};

struct SubtreeJs : public SharedPtrWrapBase<SubtreeJs, org::sem::Subtree> {
  using SharedPtrWrapBase<SubtreeJs, org::sem::Subtree>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Subtree::*)() const>(&org::sem::Subtree::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Subtree::*)() const>(&org::sem::Subtree::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Subtree::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Subtree::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::Subtree::*)() const>(&org::sem::Subtree::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Subtree::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Subtree::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Subtree::*)(int) const>(&org::sem::Subtree::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Subtree::*)(OrgSemKind) const>(&org::sem::Subtree::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getTimePeriods(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SubtreePeriod>(org::sem::Subtree::*)(hstd::IntSet<org::sem::SubtreePeriod::Kind>) const>(&org::sem::Subtree::getTimePeriods),
                                        std::make_tuple(CxxArgSpec<hstd::IntSet<org::sem::SubtreePeriod::Kind>>{"kinds"})));
  }
  Napi::Value getProperties(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::NamedProperty>(org::sem::Subtree::*)(hstd::Str const&, hstd::Opt<hstd::Str> const&) const>(&org::sem::Subtree::getProperties),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"},
                                                        CxxArgSpec<hstd::Opt<hstd::Str>>{"subkind", std::nullopt})));
  }
  Napi::Value getProperty(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::NamedProperty>(org::sem::Subtree::*)(hstd::Str const&, hstd::Opt<hstd::Str> const&) const>(&org::sem::Subtree::getProperty),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"},
                                                        CxxArgSpec<hstd::Opt<hstd::Str>>{"subkind", std::nullopt})));
  }
  Napi::Value removeProperty(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Subtree::*)(hstd::Str const&, hstd::Opt<hstd::Str> const&)>(&org::sem::Subtree::removeProperty),
                                   std::make_tuple(CxxArgSpec<hstd::Str>{"kind"},
                                                   CxxArgSpec<hstd::Opt<hstd::Str>>{"subkind", std::nullopt})));
  }
  Napi::Value setProperty(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Subtree::*)(org::sem::NamedProperty const&)>(&org::sem::Subtree::setProperty),
                                   std::make_tuple(CxxArgSpec<org::sem::NamedProperty>{"value"})));
  }
  Napi::Value setPropertyStrValue(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Subtree::*)(hstd::Str const&, hstd::Str const&, hstd::Opt<hstd::Str> const&)>(&org::sem::Subtree::setPropertyStrValue),
                                   std::make_tuple(CxxArgSpec<hstd::Str>{"value"},
                                                   CxxArgSpec<hstd::Str>{"kind"},
                                                   CxxArgSpec<hstd::Opt<hstd::Str>>{"subkind", std::nullopt})));
  }
  Napi::Value getCleanTitle(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Str(org::sem::Subtree::*)() const>(&org::sem::Subtree::getCleanTitle),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "SubtreeJs", {InstanceMethod("getKind", &SubtreeJs::getKind),
                                                                                                                    InstanceMethod("isGenerated", &SubtreeJs::isGenerated),
                                                                                                                    InstanceMethod("push_back", &SubtreeJs::push_back),
                                                                                                                    InstanceMethod("size", &SubtreeJs::size),
                                                                                                                    InstanceMethod("insert", &SubtreeJs::insert),
                                                                                                                    InstanceMethod("at", &SubtreeJs::at),
                                                                                                                    InstanceMethod("is", &SubtreeJs::is),
                                                                                                                    InstanceMethod("getTimePeriods", &SubtreeJs::getTimePeriods),
                                                                                                                    InstanceMethod("getProperties", &SubtreeJs::getProperties),
                                                                                                                    InstanceMethod("getProperty", &SubtreeJs::getProperty),
                                                                                                                    InstanceMethod("removeProperty", &SubtreeJs::removeProperty),
                                                                                                                    InstanceMethod("setProperty", &SubtreeJs::setProperty),
                                                                                                                    InstanceMethod("setPropertyStrValue", &SubtreeJs::setPropertyStrValue),
                                                                                                                    InstanceMethod("getCleanTitle", &SubtreeJs::getCleanTitle)}); }
};

template <>
struct js_to_org_type<SubtreeJs> {
  using type = org::sem::Subtree;
};

template <>
struct org_to_js_type<org::sem::Subtree> {
  using type = SubtreeJs;
};

struct ColonExampleJs : public SharedPtrWrapBase<ColonExampleJs, org::sem::ColonExample> {
  using SharedPtrWrapBase<ColonExampleJs, org::sem::ColonExample>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::ColonExample::*)() const>(&org::sem::ColonExample::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ColonExample::*)() const>(&org::sem::ColonExample::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::ColonExample::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::ColonExample::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::ColonExample::*)() const>(&org::sem::ColonExample::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::ColonExample::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::ColonExample::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::ColonExample::*)(int) const>(&org::sem::ColonExample::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ColonExample::*)(OrgSemKind) const>(&org::sem::ColonExample::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ColonExampleJs", {InstanceMethod("getKind", &ColonExampleJs::getKind),
                                                                                                                         InstanceMethod("isGenerated", &ColonExampleJs::isGenerated),
                                                                                                                         InstanceMethod("push_back", &ColonExampleJs::push_back),
                                                                                                                         InstanceMethod("size", &ColonExampleJs::size),
                                                                                                                         InstanceMethod("insert", &ColonExampleJs::insert),
                                                                                                                         InstanceMethod("at", &ColonExampleJs::at),
                                                                                                                         InstanceMethod("is", &ColonExampleJs::is)}); }
};

template <>
struct js_to_org_type<ColonExampleJs> {
  using type = org::sem::ColonExample;
};

template <>
struct org_to_js_type<org::sem::ColonExample> {
  using type = ColonExampleJs;
};

struct CallJs : public SharedPtrWrapBase<CallJs, org::sem::Call> {
  using SharedPtrWrapBase<CallJs, org::sem::Call>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Call::*)() const>(&org::sem::Call::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Call::*)() const>(&org::sem::Call::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Call::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Call::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::Call::*)() const>(&org::sem::Call::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Call::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Call::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Call::*)(int) const>(&org::sem::Call::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Call::*)(OrgSemKind) const>(&org::sem::Call::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "CallJs", {InstanceMethod("getKind", &CallJs::getKind),
                                                                                                                 InstanceMethod("isGenerated", &CallJs::isGenerated),
                                                                                                                 InstanceMethod("push_back", &CallJs::push_back),
                                                                                                                 InstanceMethod("size", &CallJs::size),
                                                                                                                 InstanceMethod("insert", &CallJs::insert),
                                                                                                                 InstanceMethod("at", &CallJs::at),
                                                                                                                 InstanceMethod("is", &CallJs::is)}); }
};

template <>
struct js_to_org_type<CallJs> {
  using type = org::sem::Call;
};

template <>
struct org_to_js_type<org::sem::Call> {
  using type = CallJs;
};

struct ListItemJs : public SharedPtrWrapBase<ListItemJs, org::sem::ListItem> {
  using SharedPtrWrapBase<ListItemJs, org::sem::ListItem>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::ListItem::*)() const>(&org::sem::ListItem::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ListItem::*)() const>(&org::sem::ListItem::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::ListItem::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::ListItem::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::ListItem::*)() const>(&org::sem::ListItem::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::ListItem::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::ListItem::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::ListItem::*)(int) const>(&org::sem::ListItem::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ListItem::*)(OrgSemKind) const>(&org::sem::ListItem::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value isDescriptionItem(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::ListItem::*)() const>(&org::sem::ListItem::isDescriptionItem),
                                        std::make_tuple()));
  }
  Napi::Value getCleanHeader(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<hstd::Str>(org::sem::ListItem::*)() const>(&org::sem::ListItem::getCleanHeader),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ListItemJs", {InstanceMethod("getKind", &ListItemJs::getKind),
                                                                                                                     InstanceMethod("isGenerated", &ListItemJs::isGenerated),
                                                                                                                     InstanceMethod("push_back", &ListItemJs::push_back),
                                                                                                                     InstanceMethod("size", &ListItemJs::size),
                                                                                                                     InstanceMethod("insert", &ListItemJs::insert),
                                                                                                                     InstanceMethod("at", &ListItemJs::at),
                                                                                                                     InstanceMethod("is", &ListItemJs::is),
                                                                                                                     InstanceMethod("isDescriptionItem", &ListItemJs::isDescriptionItem),
                                                                                                                     InstanceMethod("getCleanHeader", &ListItemJs::getCleanHeader)}); }
};

template <>
struct js_to_org_type<ListItemJs> {
  using type = org::sem::ListItem;
};

template <>
struct org_to_js_type<org::sem::ListItem> {
  using type = ListItemJs;
};

struct DocumentOptionsJs : public SharedPtrWrapBase<DocumentOptionsJs, org::sem::DocumentOptions> {
  using SharedPtrWrapBase<DocumentOptionsJs, org::sem::DocumentOptions>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::DocumentOptions::*)() const>(&org::sem::DocumentOptions::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::DocumentOptions::*)() const>(&org::sem::DocumentOptions::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::DocumentOptions::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::DocumentOptions::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::DocumentOptions::*)() const>(&org::sem::DocumentOptions::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::DocumentOptions::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::DocumentOptions::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::DocumentOptions::*)(int) const>(&org::sem::DocumentOptions::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::DocumentOptions::*)(OrgSemKind) const>(&org::sem::DocumentOptions::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getProperties(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::NamedProperty>(org::sem::DocumentOptions::*)(hstd::Str const&, hstd::Opt<hstd::Str> const&) const>(&org::sem::DocumentOptions::getProperties),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"},
                                                        CxxArgSpec<hstd::Opt<hstd::Str>>{"subKind", std::nullopt})));
  }
  Napi::Value getProperty(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::NamedProperty>(org::sem::DocumentOptions::*)(hstd::Str const&, hstd::Opt<hstd::Str> const&) const>(&org::sem::DocumentOptions::getProperty),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"},
                                                        CxxArgSpec<hstd::Opt<hstd::Str>>{"subKind", std::nullopt})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "DocumentOptionsJs", {InstanceMethod("getKind", &DocumentOptionsJs::getKind),
                                                                                                                            InstanceMethod("isGenerated", &DocumentOptionsJs::isGenerated),
                                                                                                                            InstanceMethod("push_back", &DocumentOptionsJs::push_back),
                                                                                                                            InstanceMethod("size", &DocumentOptionsJs::size),
                                                                                                                            InstanceMethod("insert", &DocumentOptionsJs::insert),
                                                                                                                            InstanceMethod("at", &DocumentOptionsJs::at),
                                                                                                                            InstanceMethod("is", &DocumentOptionsJs::is),
                                                                                                                            InstanceMethod("getProperties", &DocumentOptionsJs::getProperties),
                                                                                                                            InstanceMethod("getProperty", &DocumentOptionsJs::getProperty)}); }
};

template <>
struct js_to_org_type<DocumentOptionsJs> {
  using type = org::sem::DocumentOptions;
};

template <>
struct org_to_js_type<org::sem::DocumentOptions> {
  using type = DocumentOptionsJs;
};

struct DocumentFragmentJs : public SharedPtrWrapBase<DocumentFragmentJs, org::sem::DocumentFragment> {
  using SharedPtrWrapBase<DocumentFragmentJs, org::sem::DocumentFragment>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::DocumentFragment::*)() const>(&org::sem::DocumentFragment::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::DocumentFragment::*)() const>(&org::sem::DocumentFragment::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::DocumentFragment::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::DocumentFragment::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::DocumentFragment::*)() const>(&org::sem::DocumentFragment::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::DocumentFragment::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::DocumentFragment::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::DocumentFragment::*)(int) const>(&org::sem::DocumentFragment::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::DocumentFragment::*)(OrgSemKind) const>(&org::sem::DocumentFragment::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "DocumentFragmentJs", {InstanceMethod("getKind", &DocumentFragmentJs::getKind),
                                                                                                                             InstanceMethod("isGenerated", &DocumentFragmentJs::isGenerated),
                                                                                                                             InstanceMethod("push_back", &DocumentFragmentJs::push_back),
                                                                                                                             InstanceMethod("size", &DocumentFragmentJs::size),
                                                                                                                             InstanceMethod("insert", &DocumentFragmentJs::insert),
                                                                                                                             InstanceMethod("at", &DocumentFragmentJs::at),
                                                                                                                             InstanceMethod("is", &DocumentFragmentJs::is)}); }
};

template <>
struct js_to_org_type<DocumentFragmentJs> {
  using type = org::sem::DocumentFragment;
};

template <>
struct org_to_js_type<org::sem::DocumentFragment> {
  using type = DocumentFragmentJs;
};

struct CriticMarkupJs : public SharedPtrWrapBase<CriticMarkupJs, org::sem::CriticMarkup> {
  using SharedPtrWrapBase<CriticMarkupJs, org::sem::CriticMarkup>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::CriticMarkup::*)() const>(&org::sem::CriticMarkup::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CriticMarkup::*)() const>(&org::sem::CriticMarkup::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CriticMarkup::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::CriticMarkup::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::CriticMarkup::*)() const>(&org::sem::CriticMarkup::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CriticMarkup::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::CriticMarkup::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::CriticMarkup::*)(int) const>(&org::sem::CriticMarkup::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CriticMarkup::*)(OrgSemKind) const>(&org::sem::CriticMarkup::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "CriticMarkupJs", {InstanceMethod("getKind", &CriticMarkupJs::getKind),
                                                                                                                         InstanceMethod("isGenerated", &CriticMarkupJs::isGenerated),
                                                                                                                         InstanceMethod("push_back", &CriticMarkupJs::push_back),
                                                                                                                         InstanceMethod("size", &CriticMarkupJs::size),
                                                                                                                         InstanceMethod("insert", &CriticMarkupJs::insert),
                                                                                                                         InstanceMethod("at", &CriticMarkupJs::at),
                                                                                                                         InstanceMethod("is", &CriticMarkupJs::is)}); }
};

template <>
struct js_to_org_type<CriticMarkupJs> {
  using type = org::sem::CriticMarkup;
};

template <>
struct org_to_js_type<org::sem::CriticMarkup> {
  using type = CriticMarkupJs;
};

struct DocumentJs : public SharedPtrWrapBase<DocumentJs, org::sem::Document> {
  using SharedPtrWrapBase<DocumentJs, org::sem::Document>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Document::*)() const>(&org::sem::Document::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Document::*)() const>(&org::sem::Document::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Document::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Document::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::Document::*)() const>(&org::sem::Document::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Document::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Document::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Document::*)(int) const>(&org::sem::Document::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Document::*)(OrgSemKind) const>(&org::sem::Document::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getProperties(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::NamedProperty>(org::sem::Document::*)(hstd::Str const&, hstd::Opt<hstd::Str> const&) const>(&org::sem::Document::getProperties),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"},
                                                        CxxArgSpec<hstd::Opt<hstd::Str>>{"subKind", std::nullopt})));
  }
  Napi::Value getProperty(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::NamedProperty>(org::sem::Document::*)(hstd::Str const&, hstd::Opt<hstd::Str> const&) const>(&org::sem::Document::getProperty),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"},
                                                        CxxArgSpec<hstd::Opt<hstd::Str>>{"subKind", std::nullopt})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "DocumentJs", {InstanceMethod("getKind", &DocumentJs::getKind),
                                                                                                                     InstanceMethod("isGenerated", &DocumentJs::isGenerated),
                                                                                                                     InstanceMethod("push_back", &DocumentJs::push_back),
                                                                                                                     InstanceMethod("size", &DocumentJs::size),
                                                                                                                     InstanceMethod("insert", &DocumentJs::insert),
                                                                                                                     InstanceMethod("at", &DocumentJs::at),
                                                                                                                     InstanceMethod("is", &DocumentJs::is),
                                                                                                                     InstanceMethod("getProperties", &DocumentJs::getProperties),
                                                                                                                     InstanceMethod("getProperty", &DocumentJs::getProperty)}); }
};

template <>
struct js_to_org_type<DocumentJs> {
  using type = org::sem::Document;
};

template <>
struct org_to_js_type<org::sem::Document> {
  using type = DocumentJs;
};

struct FileTargetJs : public SharedPtrWrapBase<FileTargetJs, org::sem::FileTarget> {
  using SharedPtrWrapBase<FileTargetJs, org::sem::FileTarget>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::FileTarget::*)() const>(&org::sem::FileTarget::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::FileTarget::*)() const>(&org::sem::FileTarget::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::FileTarget::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::FileTarget::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::FileTarget::*)() const>(&org::sem::FileTarget::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::FileTarget::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::FileTarget::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::FileTarget::*)(int) const>(&org::sem::FileTarget::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::FileTarget::*)(OrgSemKind) const>(&org::sem::FileTarget::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "FileTargetJs", {InstanceMethod("getKind", &FileTargetJs::getKind),
                                                                                                                       InstanceMethod("isGenerated", &FileTargetJs::isGenerated),
                                                                                                                       InstanceMethod("push_back", &FileTargetJs::push_back),
                                                                                                                       InstanceMethod("size", &FileTargetJs::size),
                                                                                                                       InstanceMethod("insert", &FileTargetJs::insert),
                                                                                                                       InstanceMethod("at", &FileTargetJs::at),
                                                                                                                       InstanceMethod("is", &FileTargetJs::is)}); }
};

template <>
struct js_to_org_type<FileTargetJs> {
  using type = org::sem::FileTarget;
};

template <>
struct org_to_js_type<org::sem::FileTarget> {
  using type = FileTargetJs;
};

struct TextSeparatorJs : public SharedPtrWrapBase<TextSeparatorJs, org::sem::TextSeparator> {
  using SharedPtrWrapBase<TextSeparatorJs, org::sem::TextSeparator>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::TextSeparator::*)() const>(&org::sem::TextSeparator::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::TextSeparator::*)() const>(&org::sem::TextSeparator::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::TextSeparator::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::TextSeparator::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::TextSeparator::*)() const>(&org::sem::TextSeparator::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::TextSeparator::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::TextSeparator::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::TextSeparator::*)(int) const>(&org::sem::TextSeparator::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::TextSeparator::*)(OrgSemKind) const>(&org::sem::TextSeparator::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "TextSeparatorJs", {InstanceMethod("getKind", &TextSeparatorJs::getKind),
                                                                                                                          InstanceMethod("isGenerated", &TextSeparatorJs::isGenerated),
                                                                                                                          InstanceMethod("push_back", &TextSeparatorJs::push_back),
                                                                                                                          InstanceMethod("size", &TextSeparatorJs::size),
                                                                                                                          InstanceMethod("insert", &TextSeparatorJs::insert),
                                                                                                                          InstanceMethod("at", &TextSeparatorJs::at),
                                                                                                                          InstanceMethod("is", &TextSeparatorJs::is)}); }
};

template <>
struct js_to_org_type<TextSeparatorJs> {
  using type = org::sem::TextSeparator;
};

template <>
struct org_to_js_type<org::sem::TextSeparator> {
  using type = TextSeparatorJs;
};

struct DocumentGroupJs : public SharedPtrWrapBase<DocumentGroupJs, org::sem::DocumentGroup> {
  using SharedPtrWrapBase<DocumentGroupJs, org::sem::DocumentGroup>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::DocumentGroup::*)() const>(&org::sem::DocumentGroup::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::DocumentGroup::*)() const>(&org::sem::DocumentGroup::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::DocumentGroup::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::DocumentGroup::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::DocumentGroup::*)() const>(&org::sem::DocumentGroup::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::DocumentGroup::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::DocumentGroup::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::DocumentGroup::*)(int) const>(&org::sem::DocumentGroup::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::DocumentGroup::*)(OrgSemKind) const>(&org::sem::DocumentGroup::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "DocumentGroupJs", {InstanceMethod("getKind", &DocumentGroupJs::getKind),
                                                                                                                          InstanceMethod("isGenerated", &DocumentGroupJs::isGenerated),
                                                                                                                          InstanceMethod("push_back", &DocumentGroupJs::push_back),
                                                                                                                          InstanceMethod("size", &DocumentGroupJs::size),
                                                                                                                          InstanceMethod("insert", &DocumentGroupJs::insert),
                                                                                                                          InstanceMethod("at", &DocumentGroupJs::at),
                                                                                                                          InstanceMethod("is", &DocumentGroupJs::is)}); }
};

template <>
struct js_to_org_type<DocumentGroupJs> {
  using type = org::sem::DocumentGroup;
};

template <>
struct org_to_js_type<org::sem::DocumentGroup> {
  using type = DocumentGroupJs;
};

struct FileJs : public SharedPtrWrapBase<FileJs, org::sem::File> {
  using SharedPtrWrapBase<FileJs, org::sem::File>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::File::*)() const>(&org::sem::File::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::File::*)() const>(&org::sem::File::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::File::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::File::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::File::*)() const>(&org::sem::File::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::File::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::File::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::File::*)(int) const>(&org::sem::File::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::File::*)(OrgSemKind) const>(&org::sem::File::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value isDocument(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::File::*)() const>(&org::sem::File::isDocument),
                                        std::make_tuple()));
  }
  Napi::Value getDocumentMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::File::Document&(org::sem::File::*)()>(&org::sem::File::getDocument),
                                   std::make_tuple()));
  }
  Napi::Value isAttachment(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::File::*)() const>(&org::sem::File::isAttachment),
                                        std::make_tuple()));
  }
  Napi::Value getAttachmentMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::File::Attachment&(org::sem::File::*)()>(&org::sem::File::getAttachment),
                                   std::make_tuple()));
  }
  Napi::Value isSource(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::File::*)() const>(&org::sem::File::isSource),
                                        std::make_tuple()));
  }
  Napi::Value getSourceMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::File::Source&(org::sem::File::*)()>(&org::sem::File::getSource),
                                   std::make_tuple()));
  }
  Napi::Value getFileKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::File::Kind(org::sem::File::*)() const>(&org::sem::File::getFileKind),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_kind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::File::Kind(org::sem::File::*)() const>(&org::sem::File::sub_variant_get_kind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "FileJs", {InstanceMethod("getKind", &FileJs::getKind),
                                                                                                                 InstanceMethod("isGenerated", &FileJs::isGenerated),
                                                                                                                 InstanceMethod("push_back", &FileJs::push_back),
                                                                                                                 InstanceMethod("size", &FileJs::size),
                                                                                                                 InstanceMethod("insert", &FileJs::insert),
                                                                                                                 InstanceMethod("at", &FileJs::at),
                                                                                                                 InstanceMethod("is", &FileJs::is),
                                                                                                                 InstanceMethod("isDocument", &FileJs::isDocument),
                                                                                                                 InstanceMethod("getDocumentMut", &FileJs::getDocumentMut),
                                                                                                                 InstanceMethod("isAttachment", &FileJs::isAttachment),
                                                                                                                 InstanceMethod("getAttachmentMut", &FileJs::getAttachmentMut),
                                                                                                                 InstanceMethod("isSource", &FileJs::isSource),
                                                                                                                 InstanceMethod("getSourceMut", &FileJs::getSourceMut),
                                                                                                                 InstanceMethod("getFileKind", &FileJs::getFileKind),
                                                                                                                 InstanceMethod("sub_variant_get_kind", &FileJs::sub_variant_get_kind)}); }
};

template <>
struct js_to_org_type<FileJs> {
  using type = org::sem::File;
};

template <>
struct org_to_js_type<org::sem::File> {
  using type = FileJs;
};

struct DocumentFileJs : public SharedPtrWrapBase<DocumentFileJs, org::sem::File::Document> {
  using SharedPtrWrapBase<DocumentFileJs, org::sem::File::Document>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "DocumentFileJs", {}); }
};

template <>
struct js_to_org_type<DocumentFileJs> {
  using type = org::sem::File::Document;
};

template <>
struct org_to_js_type<org::sem::File::Document> {
  using type = DocumentFileJs;
};

struct AttachmentFileJs : public SharedPtrWrapBase<AttachmentFileJs, org::sem::File::Attachment> {
  using SharedPtrWrapBase<AttachmentFileJs, org::sem::File::Attachment>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "AttachmentFileJs", {}); }
};

template <>
struct js_to_org_type<AttachmentFileJs> {
  using type = org::sem::File::Attachment;
};

template <>
struct org_to_js_type<org::sem::File::Attachment> {
  using type = AttachmentFileJs;
};

struct SourceFileJs : public SharedPtrWrapBase<SourceFileJs, org::sem::File::Source> {
  using SharedPtrWrapBase<SourceFileJs, org::sem::File::Source>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "SourceFileJs", {}); }
};

template <>
struct js_to_org_type<SourceFileJs> {
  using type = org::sem::File::Source;
};

template <>
struct org_to_js_type<org::sem::File::Source> {
  using type = SourceFileJs;
};

struct DirectoryJs : public SharedPtrWrapBase<DirectoryJs, org::sem::Directory> {
  using SharedPtrWrapBase<DirectoryJs, org::sem::Directory>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Directory::*)() const>(&org::sem::Directory::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Directory::*)() const>(&org::sem::Directory::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Directory::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Directory::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::Directory::*)() const>(&org::sem::Directory::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Directory::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Directory::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Directory::*)(int) const>(&org::sem::Directory::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Directory::*)(OrgSemKind) const>(&org::sem::Directory::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "DirectoryJs", {InstanceMethod("getKind", &DirectoryJs::getKind),
                                                                                                                      InstanceMethod("isGenerated", &DirectoryJs::isGenerated),
                                                                                                                      InstanceMethod("push_back", &DirectoryJs::push_back),
                                                                                                                      InstanceMethod("size", &DirectoryJs::size),
                                                                                                                      InstanceMethod("insert", &DirectoryJs::insert),
                                                                                                                      InstanceMethod("at", &DirectoryJs::at),
                                                                                                                      InstanceMethod("is", &DirectoryJs::is)}); }
};

template <>
struct js_to_org_type<DirectoryJs> {
  using type = org::sem::Directory;
};

template <>
struct org_to_js_type<org::sem::Directory> {
  using type = DirectoryJs;
};

struct SymlinkJs : public SharedPtrWrapBase<SymlinkJs, org::sem::Symlink> {
  using SharedPtrWrapBase<SymlinkJs, org::sem::Symlink>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Symlink::*)() const>(&org::sem::Symlink::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Symlink::*)() const>(&org::sem::Symlink::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Symlink::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Symlink::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::Symlink::*)() const>(&org::sem::Symlink::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Symlink::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Symlink::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Symlink::*)(int) const>(&org::sem::Symlink::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Symlink::*)(OrgSemKind) const>(&org::sem::Symlink::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "SymlinkJs", {InstanceMethod("getKind", &SymlinkJs::getKind),
                                                                                                                    InstanceMethod("isGenerated", &SymlinkJs::isGenerated),
                                                                                                                    InstanceMethod("push_back", &SymlinkJs::push_back),
                                                                                                                    InstanceMethod("size", &SymlinkJs::size),
                                                                                                                    InstanceMethod("insert", &SymlinkJs::insert),
                                                                                                                    InstanceMethod("at", &SymlinkJs::at),
                                                                                                                    InstanceMethod("is", &SymlinkJs::is)}); }
};

template <>
struct js_to_org_type<SymlinkJs> {
  using type = org::sem::Symlink;
};

template <>
struct org_to_js_type<org::sem::Symlink> {
  using type = SymlinkJs;
};

struct CmdIncludeJs : public SharedPtrWrapBase<CmdIncludeJs, org::sem::CmdInclude> {
  using SharedPtrWrapBase<CmdIncludeJs, org::sem::CmdInclude>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::CmdInclude::*)() const>(&org::sem::CmdInclude::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdInclude::*)() const>(&org::sem::CmdInclude::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdInclude::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::CmdInclude::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::CmdInclude::*)() const>(&org::sem::CmdInclude::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdInclude::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::CmdInclude::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::CmdInclude::*)(int) const>(&org::sem::CmdInclude::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdInclude::*)(OrgSemKind) const>(&org::sem::CmdInclude::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value isExample(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdInclude::*)() const>(&org::sem::CmdInclude::isExample),
                                        std::make_tuple()));
  }
  Napi::Value getExampleMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::CmdInclude::Example&(org::sem::CmdInclude::*)()>(&org::sem::CmdInclude::getExample),
                                   std::make_tuple()));
  }
  Napi::Value isExport(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdInclude::*)() const>(&org::sem::CmdInclude::isExport),
                                        std::make_tuple()));
  }
  Napi::Value getExportMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::CmdInclude::Export&(org::sem::CmdInclude::*)()>(&org::sem::CmdInclude::getExport),
                                   std::make_tuple()));
  }
  Napi::Value isCustom(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdInclude::*)() const>(&org::sem::CmdInclude::isCustom),
                                        std::make_tuple()));
  }
  Napi::Value getCustomMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::CmdInclude::Custom&(org::sem::CmdInclude::*)()>(&org::sem::CmdInclude::getCustom),
                                   std::make_tuple()));
  }
  Napi::Value isSrc(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdInclude::*)() const>(&org::sem::CmdInclude::isSrc),
                                        std::make_tuple()));
  }
  Napi::Value getSrcMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::CmdInclude::Src&(org::sem::CmdInclude::*)()>(&org::sem::CmdInclude::getSrc),
                                   std::make_tuple()));
  }
  Napi::Value isOrgDocument(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdInclude::*)() const>(&org::sem::CmdInclude::isOrgDocument),
                                        std::make_tuple()));
  }
  Napi::Value getOrgDocumentMut(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<org::sem::CmdInclude::OrgDocument&(org::sem::CmdInclude::*)()>(&org::sem::CmdInclude::getOrgDocument),
                                   std::make_tuple()));
  }
  Napi::Value getIncludeKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::CmdInclude::Kind(org::sem::CmdInclude::*)() const>(&org::sem::CmdInclude::getIncludeKind),
                                        std::make_tuple()));
  }
  Napi::Value sub_variant_get_kind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::CmdInclude::Kind(org::sem::CmdInclude::*)() const>(&org::sem::CmdInclude::sub_variant_get_kind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "CmdIncludeJs", {InstanceMethod("getKind", &CmdIncludeJs::getKind),
                                                                                                                       InstanceMethod("isGenerated", &CmdIncludeJs::isGenerated),
                                                                                                                       InstanceMethod("push_back", &CmdIncludeJs::push_back),
                                                                                                                       InstanceMethod("size", &CmdIncludeJs::size),
                                                                                                                       InstanceMethod("insert", &CmdIncludeJs::insert),
                                                                                                                       InstanceMethod("at", &CmdIncludeJs::at),
                                                                                                                       InstanceMethod("is", &CmdIncludeJs::is),
                                                                                                                       InstanceMethod("isExample", &CmdIncludeJs::isExample),
                                                                                                                       InstanceMethod("getExampleMut", &CmdIncludeJs::getExampleMut),
                                                                                                                       InstanceMethod("isExport", &CmdIncludeJs::isExport),
                                                                                                                       InstanceMethod("getExportMut", &CmdIncludeJs::getExportMut),
                                                                                                                       InstanceMethod("isCustom", &CmdIncludeJs::isCustom),
                                                                                                                       InstanceMethod("getCustomMut", &CmdIncludeJs::getCustomMut),
                                                                                                                       InstanceMethod("isSrc", &CmdIncludeJs::isSrc),
                                                                                                                       InstanceMethod("getSrcMut", &CmdIncludeJs::getSrcMut),
                                                                                                                       InstanceMethod("isOrgDocument", &CmdIncludeJs::isOrgDocument),
                                                                                                                       InstanceMethod("getOrgDocumentMut", &CmdIncludeJs::getOrgDocumentMut),
                                                                                                                       InstanceMethod("getIncludeKind", &CmdIncludeJs::getIncludeKind),
                                                                                                                       InstanceMethod("sub_variant_get_kind", &CmdIncludeJs::sub_variant_get_kind)}); }
};

template <>
struct js_to_org_type<CmdIncludeJs> {
  using type = org::sem::CmdInclude;
};

template <>
struct org_to_js_type<org::sem::CmdInclude> {
  using type = CmdIncludeJs;
};

struct IncludeBaseCmdIncludeJs : public SharedPtrWrapBase<IncludeBaseCmdIncludeJs, org::sem::CmdInclude::IncludeBase> {
  using SharedPtrWrapBase<IncludeBaseCmdIncludeJs, org::sem::CmdInclude::IncludeBase>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "IncludeBaseCmdIncludeJs", {}); }
};

template <>
struct js_to_org_type<IncludeBaseCmdIncludeJs> {
  using type = org::sem::CmdInclude::IncludeBase;
};

template <>
struct org_to_js_type<org::sem::CmdInclude::IncludeBase> {
  using type = IncludeBaseCmdIncludeJs;
};

struct ExampleCmdIncludeJs : public SharedPtrWrapBase<ExampleCmdIncludeJs, org::sem::CmdInclude::Example> {
  using SharedPtrWrapBase<ExampleCmdIncludeJs, org::sem::CmdInclude::Example>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ExampleCmdIncludeJs", {}); }
};

template <>
struct js_to_org_type<ExampleCmdIncludeJs> {
  using type = org::sem::CmdInclude::Example;
};

template <>
struct org_to_js_type<org::sem::CmdInclude::Example> {
  using type = ExampleCmdIncludeJs;
};

struct ExportCmdIncludeJs : public SharedPtrWrapBase<ExportCmdIncludeJs, org::sem::CmdInclude::Export> {
  using SharedPtrWrapBase<ExportCmdIncludeJs, org::sem::CmdInclude::Export>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ExportCmdIncludeJs", {}); }
};

template <>
struct js_to_org_type<ExportCmdIncludeJs> {
  using type = org::sem::CmdInclude::Export;
};

template <>
struct org_to_js_type<org::sem::CmdInclude::Export> {
  using type = ExportCmdIncludeJs;
};

struct CustomCmdIncludeJs : public SharedPtrWrapBase<CustomCmdIncludeJs, org::sem::CmdInclude::Custom> {
  using SharedPtrWrapBase<CustomCmdIncludeJs, org::sem::CmdInclude::Custom>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "CustomCmdIncludeJs", {}); }
};

template <>
struct js_to_org_type<CustomCmdIncludeJs> {
  using type = org::sem::CmdInclude::Custom;
};

template <>
struct org_to_js_type<org::sem::CmdInclude::Custom> {
  using type = CustomCmdIncludeJs;
};

struct SrcCmdIncludeJs : public SharedPtrWrapBase<SrcCmdIncludeJs, org::sem::CmdInclude::Src> {
  using SharedPtrWrapBase<SrcCmdIncludeJs, org::sem::CmdInclude::Src>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "SrcCmdIncludeJs", {}); }
};

template <>
struct js_to_org_type<SrcCmdIncludeJs> {
  using type = org::sem::CmdInclude::Src;
};

template <>
struct org_to_js_type<org::sem::CmdInclude::Src> {
  using type = SrcCmdIncludeJs;
};

struct OrgDocumentCmdIncludeJs : public SharedPtrWrapBase<OrgDocumentCmdIncludeJs, org::sem::CmdInclude::OrgDocument> {
  using SharedPtrWrapBase<OrgDocumentCmdIncludeJs, org::sem::CmdInclude::OrgDocument>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "OrgDocumentCmdIncludeJs", {}); }
};

template <>
struct js_to_org_type<OrgDocumentCmdIncludeJs> {
  using type = org::sem::CmdInclude::OrgDocument;
};

template <>
struct org_to_js_type<org::sem::CmdInclude::OrgDocument> {
  using type = OrgDocumentCmdIncludeJs;
};

struct MapConfigGraphJs : public SharedPtrWrapBase<MapConfigGraphJs, org::graph::MapConfig> {
  using SharedPtrWrapBase<MapConfigGraphJs, org::graph::MapConfig>::SharedPtrWrapBase;
  Napi::Value setTraceFileStr(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::graph::MapConfig::*)(std::string const&, bool)>(&org::graph::MapConfig::setTraceFileStr),
                                   std::make_tuple(CxxArgSpec<std::string>{"outfile"},
                                                   CxxArgSpec<bool>{"overwrite"})));
  }
  Napi::Value sendMessage(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::graph::MapConfig::*)(std::string const&, std::string const&, int, std::string const&)>(&org::graph::MapConfig::sendMessage),
                                   std::make_tuple(CxxArgSpec<std::string>{"value"},
                                                   CxxArgSpec<std::string>{"function"},
                                                   CxxArgSpec<int>{"line"},
                                                   CxxArgSpec<std::string>{"file"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "MapConfigGraphJs", {InstanceMethod("setTraceFileStr", &MapConfigGraphJs::setTraceFileStr),
                                                                                                                           InstanceMethod("sendMessage", &MapConfigGraphJs::sendMessage)}); }
};

template <>
struct js_to_org_type<MapConfigGraphJs> {
  using type = org::graph::MapConfig;
};

template <>
struct org_to_js_type<org::graph::MapConfig> {
  using type = MapConfigGraphJs;
};

struct ImmIdTNone : public SharedPtrWrapBase<ImmIdTNone, org::imm::ImmIdT<org::imm::ImmNone>> {
  using SharedPtrWrapBase<ImmIdTNone, org::imm::ImmIdT<org::imm::ImmNone>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmNone>::*)() const>(&org::imm::ImmIdT<org::imm::ImmNone>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmNone>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmNone>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmNone>::*)() const>(&org::imm::ImmIdT<org::imm::ImmNone>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmNone>::*)() const>(&org::imm::ImmIdT<org::imm::ImmNone>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTNone", {InstanceMethod("getKind", &ImmIdTNone::getKind),
                                                                                                                     InstanceMethod("is", &ImmIdTNone::is),
                                                                                                                     InstanceMethod("getNodeIndex", &ImmIdTNone::getNodeIndex),
                                                                                                                     InstanceMethod("getReadableId", &ImmIdTNone::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTNone> {
  using type = org::imm::ImmIdT<org::imm::ImmNone>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmNone>> {
  using type = ImmIdTNone;
};

struct ImmIdTErrorItem : public SharedPtrWrapBase<ImmIdTErrorItem, org::imm::ImmIdT<org::imm::ImmErrorItem>> {
  using SharedPtrWrapBase<ImmIdTErrorItem, org::imm::ImmIdT<org::imm::ImmErrorItem>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmErrorItem>::*)() const>(&org::imm::ImmIdT<org::imm::ImmErrorItem>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmErrorItem>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmErrorItem>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmErrorItem>::*)() const>(&org::imm::ImmIdT<org::imm::ImmErrorItem>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmErrorItem>::*)() const>(&org::imm::ImmIdT<org::imm::ImmErrorItem>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTErrorItem", {InstanceMethod("getKind", &ImmIdTErrorItem::getKind),
                                                                                                                          InstanceMethod("is", &ImmIdTErrorItem::is),
                                                                                                                          InstanceMethod("getNodeIndex", &ImmIdTErrorItem::getNodeIndex),
                                                                                                                          InstanceMethod("getReadableId", &ImmIdTErrorItem::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTErrorItem> {
  using type = org::imm::ImmIdT<org::imm::ImmErrorItem>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmErrorItem>> {
  using type = ImmIdTErrorItem;
};

struct ImmIdTErrorGroup : public SharedPtrWrapBase<ImmIdTErrorGroup, org::imm::ImmIdT<org::imm::ImmErrorGroup>> {
  using SharedPtrWrapBase<ImmIdTErrorGroup, org::imm::ImmIdT<org::imm::ImmErrorGroup>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmErrorGroup>::*)() const>(&org::imm::ImmIdT<org::imm::ImmErrorGroup>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmErrorGroup>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmErrorGroup>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmErrorGroup>::*)() const>(&org::imm::ImmIdT<org::imm::ImmErrorGroup>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmErrorGroup>::*)() const>(&org::imm::ImmIdT<org::imm::ImmErrorGroup>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTErrorGroup", {InstanceMethod("getKind", &ImmIdTErrorGroup::getKind),
                                                                                                                           InstanceMethod("is", &ImmIdTErrorGroup::is),
                                                                                                                           InstanceMethod("getNodeIndex", &ImmIdTErrorGroup::getNodeIndex),
                                                                                                                           InstanceMethod("getReadableId", &ImmIdTErrorGroup::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTErrorGroup> {
  using type = org::imm::ImmIdT<org::imm::ImmErrorGroup>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmErrorGroup>> {
  using type = ImmIdTErrorGroup;
};

struct ImmIdTStmt : public SharedPtrWrapBase<ImmIdTStmt, org::imm::ImmIdT<org::imm::ImmStmt>> {
  using SharedPtrWrapBase<ImmIdTStmt, org::imm::ImmIdT<org::imm::ImmStmt>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmStmt>::*)() const>(&org::imm::ImmIdT<org::imm::ImmStmt>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmStmt>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmStmt>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmStmt>::*)() const>(&org::imm::ImmIdT<org::imm::ImmStmt>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmStmt>::*)() const>(&org::imm::ImmIdT<org::imm::ImmStmt>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTStmt", {InstanceMethod("getKind", &ImmIdTStmt::getKind),
                                                                                                                     InstanceMethod("is", &ImmIdTStmt::is),
                                                                                                                     InstanceMethod("getNodeIndex", &ImmIdTStmt::getNodeIndex),
                                                                                                                     InstanceMethod("getReadableId", &ImmIdTStmt::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTStmt> {
  using type = org::imm::ImmIdT<org::imm::ImmStmt>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmStmt>> {
  using type = ImmIdTStmt;
};

struct ImmIdTInline : public SharedPtrWrapBase<ImmIdTInline, org::imm::ImmIdT<org::imm::ImmInline>> {
  using SharedPtrWrapBase<ImmIdTInline, org::imm::ImmIdT<org::imm::ImmInline>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmInline>::*)() const>(&org::imm::ImmIdT<org::imm::ImmInline>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmInline>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmInline>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmInline>::*)() const>(&org::imm::ImmIdT<org::imm::ImmInline>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmInline>::*)() const>(&org::imm::ImmIdT<org::imm::ImmInline>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTInline", {InstanceMethod("getKind", &ImmIdTInline::getKind),
                                                                                                                       InstanceMethod("is", &ImmIdTInline::is),
                                                                                                                       InstanceMethod("getNodeIndex", &ImmIdTInline::getNodeIndex),
                                                                                                                       InstanceMethod("getReadableId", &ImmIdTInline::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTInline> {
  using type = org::imm::ImmIdT<org::imm::ImmInline>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmInline>> {
  using type = ImmIdTInline;
};

struct ImmIdTStmtList : public SharedPtrWrapBase<ImmIdTStmtList, org::imm::ImmIdT<org::imm::ImmStmtList>> {
  using SharedPtrWrapBase<ImmIdTStmtList, org::imm::ImmIdT<org::imm::ImmStmtList>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmStmtList>::*)() const>(&org::imm::ImmIdT<org::imm::ImmStmtList>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmStmtList>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmStmtList>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmStmtList>::*)() const>(&org::imm::ImmIdT<org::imm::ImmStmtList>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmStmtList>::*)() const>(&org::imm::ImmIdT<org::imm::ImmStmtList>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTStmtList", {InstanceMethod("getKind", &ImmIdTStmtList::getKind),
                                                                                                                         InstanceMethod("is", &ImmIdTStmtList::is),
                                                                                                                         InstanceMethod("getNodeIndex", &ImmIdTStmtList::getNodeIndex),
                                                                                                                         InstanceMethod("getReadableId", &ImmIdTStmtList::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTStmtList> {
  using type = org::imm::ImmIdT<org::imm::ImmStmtList>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmStmtList>> {
  using type = ImmIdTStmtList;
};

struct ImmIdTEmpty : public SharedPtrWrapBase<ImmIdTEmpty, org::imm::ImmIdT<org::imm::ImmEmpty>> {
  using SharedPtrWrapBase<ImmIdTEmpty, org::imm::ImmIdT<org::imm::ImmEmpty>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmEmpty>::*)() const>(&org::imm::ImmIdT<org::imm::ImmEmpty>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmEmpty>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmEmpty>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmEmpty>::*)() const>(&org::imm::ImmIdT<org::imm::ImmEmpty>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmEmpty>::*)() const>(&org::imm::ImmIdT<org::imm::ImmEmpty>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTEmpty", {InstanceMethod("getKind", &ImmIdTEmpty::getKind),
                                                                                                                      InstanceMethod("is", &ImmIdTEmpty::is),
                                                                                                                      InstanceMethod("getNodeIndex", &ImmIdTEmpty::getNodeIndex),
                                                                                                                      InstanceMethod("getReadableId", &ImmIdTEmpty::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTEmpty> {
  using type = org::imm::ImmIdT<org::imm::ImmEmpty>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmEmpty>> {
  using type = ImmIdTEmpty;
};

struct ImmIdTCmd : public SharedPtrWrapBase<ImmIdTCmd, org::imm::ImmIdT<org::imm::ImmCmd>> {
  using SharedPtrWrapBase<ImmIdTCmd, org::imm::ImmIdT<org::imm::ImmCmd>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmCmd>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmd>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmCmd>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmCmd>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmCmd>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmd>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmCmd>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmd>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTCmd", {InstanceMethod("getKind", &ImmIdTCmd::getKind),
                                                                                                                    InstanceMethod("is", &ImmIdTCmd::is),
                                                                                                                    InstanceMethod("getNodeIndex", &ImmIdTCmd::getNodeIndex),
                                                                                                                    InstanceMethod("getReadableId", &ImmIdTCmd::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTCmd> {
  using type = org::imm::ImmIdT<org::imm::ImmCmd>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmCmd>> {
  using type = ImmIdTCmd;
};

struct ImmIdTBlock : public SharedPtrWrapBase<ImmIdTBlock, org::imm::ImmIdT<org::imm::ImmBlock>> {
  using SharedPtrWrapBase<ImmIdTBlock, org::imm::ImmIdT<org::imm::ImmBlock>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmBlock>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlock>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmBlock>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmBlock>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmBlock>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlock>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmBlock>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlock>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTBlock", {InstanceMethod("getKind", &ImmIdTBlock::getKind),
                                                                                                                      InstanceMethod("is", &ImmIdTBlock::is),
                                                                                                                      InstanceMethod("getNodeIndex", &ImmIdTBlock::getNodeIndex),
                                                                                                                      InstanceMethod("getReadableId", &ImmIdTBlock::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTBlock> {
  using type = org::imm::ImmIdT<org::imm::ImmBlock>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmBlock>> {
  using type = ImmIdTBlock;
};

struct ImmIdTLineCommand : public SharedPtrWrapBase<ImmIdTLineCommand, org::imm::ImmIdT<org::imm::ImmLineCommand>> {
  using SharedPtrWrapBase<ImmIdTLineCommand, org::imm::ImmIdT<org::imm::ImmLineCommand>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmLineCommand>::*)() const>(&org::imm::ImmIdT<org::imm::ImmLineCommand>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmLineCommand>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmLineCommand>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmLineCommand>::*)() const>(&org::imm::ImmIdT<org::imm::ImmLineCommand>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmLineCommand>::*)() const>(&org::imm::ImmIdT<org::imm::ImmLineCommand>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTLineCommand", {InstanceMethod("getKind", &ImmIdTLineCommand::getKind),
                                                                                                                            InstanceMethod("is", &ImmIdTLineCommand::is),
                                                                                                                            InstanceMethod("getNodeIndex", &ImmIdTLineCommand::getNodeIndex),
                                                                                                                            InstanceMethod("getReadableId", &ImmIdTLineCommand::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTLineCommand> {
  using type = org::imm::ImmIdT<org::imm::ImmLineCommand>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmLineCommand>> {
  using type = ImmIdTLineCommand;
};

struct ImmIdTAttached : public SharedPtrWrapBase<ImmIdTAttached, org::imm::ImmIdT<org::imm::ImmAttached>> {
  using SharedPtrWrapBase<ImmIdTAttached, org::imm::ImmIdT<org::imm::ImmAttached>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmAttached>::*)() const>(&org::imm::ImmIdT<org::imm::ImmAttached>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmAttached>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmAttached>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmAttached>::*)() const>(&org::imm::ImmIdT<org::imm::ImmAttached>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmAttached>::*)() const>(&org::imm::ImmIdT<org::imm::ImmAttached>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTAttached", {InstanceMethod("getKind", &ImmIdTAttached::getKind),
                                                                                                                         InstanceMethod("is", &ImmIdTAttached::is),
                                                                                                                         InstanceMethod("getNodeIndex", &ImmIdTAttached::getNodeIndex),
                                                                                                                         InstanceMethod("getReadableId", &ImmIdTAttached::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTAttached> {
  using type = org::imm::ImmIdT<org::imm::ImmAttached>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmAttached>> {
  using type = ImmIdTAttached;
};

struct ImmIdTLeaf : public SharedPtrWrapBase<ImmIdTLeaf, org::imm::ImmIdT<org::imm::ImmLeaf>> {
  using SharedPtrWrapBase<ImmIdTLeaf, org::imm::ImmIdT<org::imm::ImmLeaf>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmLeaf>::*)() const>(&org::imm::ImmIdT<org::imm::ImmLeaf>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmLeaf>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmLeaf>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmLeaf>::*)() const>(&org::imm::ImmIdT<org::imm::ImmLeaf>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmLeaf>::*)() const>(&org::imm::ImmIdT<org::imm::ImmLeaf>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTLeaf", {InstanceMethod("getKind", &ImmIdTLeaf::getKind),
                                                                                                                     InstanceMethod("is", &ImmIdTLeaf::is),
                                                                                                                     InstanceMethod("getNodeIndex", &ImmIdTLeaf::getNodeIndex),
                                                                                                                     InstanceMethod("getReadableId", &ImmIdTLeaf::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTLeaf> {
  using type = org::imm::ImmIdT<org::imm::ImmLeaf>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmLeaf>> {
  using type = ImmIdTLeaf;
};

struct ImmIdTCmdCaption : public SharedPtrWrapBase<ImmIdTCmdCaption, org::imm::ImmIdT<org::imm::ImmCmdCaption>> {
  using SharedPtrWrapBase<ImmIdTCmdCaption, org::imm::ImmIdT<org::imm::ImmCmdCaption>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmCmdCaption>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdCaption>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmCmdCaption>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmCmdCaption>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmCmdCaption>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdCaption>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmCmdCaption>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdCaption>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTCmdCaption", {InstanceMethod("getKind", &ImmIdTCmdCaption::getKind),
                                                                                                                           InstanceMethod("is", &ImmIdTCmdCaption::is),
                                                                                                                           InstanceMethod("getNodeIndex", &ImmIdTCmdCaption::getNodeIndex),
                                                                                                                           InstanceMethod("getReadableId", &ImmIdTCmdCaption::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTCmdCaption> {
  using type = org::imm::ImmIdT<org::imm::ImmCmdCaption>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmCmdCaption>> {
  using type = ImmIdTCmdCaption;
};

struct ImmIdTCmdColumns : public SharedPtrWrapBase<ImmIdTCmdColumns, org::imm::ImmIdT<org::imm::ImmCmdColumns>> {
  using SharedPtrWrapBase<ImmIdTCmdColumns, org::imm::ImmIdT<org::imm::ImmCmdColumns>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmCmdColumns>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdColumns>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmCmdColumns>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmCmdColumns>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmCmdColumns>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdColumns>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmCmdColumns>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdColumns>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTCmdColumns", {InstanceMethod("getKind", &ImmIdTCmdColumns::getKind),
                                                                                                                           InstanceMethod("is", &ImmIdTCmdColumns::is),
                                                                                                                           InstanceMethod("getNodeIndex", &ImmIdTCmdColumns::getNodeIndex),
                                                                                                                           InstanceMethod("getReadableId", &ImmIdTCmdColumns::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTCmdColumns> {
  using type = org::imm::ImmIdT<org::imm::ImmCmdColumns>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmCmdColumns>> {
  using type = ImmIdTCmdColumns;
};

struct ImmIdTCmdName : public SharedPtrWrapBase<ImmIdTCmdName, org::imm::ImmIdT<org::imm::ImmCmdName>> {
  using SharedPtrWrapBase<ImmIdTCmdName, org::imm::ImmIdT<org::imm::ImmCmdName>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmCmdName>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdName>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmCmdName>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmCmdName>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmCmdName>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdName>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmCmdName>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdName>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTCmdName", {InstanceMethod("getKind", &ImmIdTCmdName::getKind),
                                                                                                                        InstanceMethod("is", &ImmIdTCmdName::is),
                                                                                                                        InstanceMethod("getNodeIndex", &ImmIdTCmdName::getNodeIndex),
                                                                                                                        InstanceMethod("getReadableId", &ImmIdTCmdName::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTCmdName> {
  using type = org::imm::ImmIdT<org::imm::ImmCmdName>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmCmdName>> {
  using type = ImmIdTCmdName;
};

struct ImmIdTCmdCustomArgs : public SharedPtrWrapBase<ImmIdTCmdCustomArgs, org::imm::ImmIdT<org::imm::ImmCmdCustomArgs>> {
  using SharedPtrWrapBase<ImmIdTCmdCustomArgs, org::imm::ImmIdT<org::imm::ImmCmdCustomArgs>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmCmdCustomArgs>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdCustomArgs>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmCmdCustomArgs>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmCmdCustomArgs>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmCmdCustomArgs>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdCustomArgs>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmCmdCustomArgs>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdCustomArgs>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTCmdCustomArgs", {InstanceMethod("getKind", &ImmIdTCmdCustomArgs::getKind),
                                                                                                                              InstanceMethod("is", &ImmIdTCmdCustomArgs::is),
                                                                                                                              InstanceMethod("getNodeIndex", &ImmIdTCmdCustomArgs::getNodeIndex),
                                                                                                                              InstanceMethod("getReadableId", &ImmIdTCmdCustomArgs::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTCmdCustomArgs> {
  using type = org::imm::ImmIdT<org::imm::ImmCmdCustomArgs>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmCmdCustomArgs>> {
  using type = ImmIdTCmdCustomArgs;
};

struct ImmIdTCmdCustomRaw : public SharedPtrWrapBase<ImmIdTCmdCustomRaw, org::imm::ImmIdT<org::imm::ImmCmdCustomRaw>> {
  using SharedPtrWrapBase<ImmIdTCmdCustomRaw, org::imm::ImmIdT<org::imm::ImmCmdCustomRaw>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmCmdCustomRaw>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdCustomRaw>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmCmdCustomRaw>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmCmdCustomRaw>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmCmdCustomRaw>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdCustomRaw>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmCmdCustomRaw>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdCustomRaw>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTCmdCustomRaw", {InstanceMethod("getKind", &ImmIdTCmdCustomRaw::getKind),
                                                                                                                             InstanceMethod("is", &ImmIdTCmdCustomRaw::is),
                                                                                                                             InstanceMethod("getNodeIndex", &ImmIdTCmdCustomRaw::getNodeIndex),
                                                                                                                             InstanceMethod("getReadableId", &ImmIdTCmdCustomRaw::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTCmdCustomRaw> {
  using type = org::imm::ImmIdT<org::imm::ImmCmdCustomRaw>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmCmdCustomRaw>> {
  using type = ImmIdTCmdCustomRaw;
};

struct ImmIdTCmdCustomText : public SharedPtrWrapBase<ImmIdTCmdCustomText, org::imm::ImmIdT<org::imm::ImmCmdCustomText>> {
  using SharedPtrWrapBase<ImmIdTCmdCustomText, org::imm::ImmIdT<org::imm::ImmCmdCustomText>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmCmdCustomText>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdCustomText>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmCmdCustomText>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmCmdCustomText>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmCmdCustomText>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdCustomText>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmCmdCustomText>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdCustomText>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTCmdCustomText", {InstanceMethod("getKind", &ImmIdTCmdCustomText::getKind),
                                                                                                                              InstanceMethod("is", &ImmIdTCmdCustomText::is),
                                                                                                                              InstanceMethod("getNodeIndex", &ImmIdTCmdCustomText::getNodeIndex),
                                                                                                                              InstanceMethod("getReadableId", &ImmIdTCmdCustomText::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTCmdCustomText> {
  using type = org::imm::ImmIdT<org::imm::ImmCmdCustomText>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmCmdCustomText>> {
  using type = ImmIdTCmdCustomText;
};

struct ImmIdTCmdCall : public SharedPtrWrapBase<ImmIdTCmdCall, org::imm::ImmIdT<org::imm::ImmCmdCall>> {
  using SharedPtrWrapBase<ImmIdTCmdCall, org::imm::ImmIdT<org::imm::ImmCmdCall>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmCmdCall>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdCall>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmCmdCall>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmCmdCall>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmCmdCall>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdCall>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmCmdCall>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdCall>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTCmdCall", {InstanceMethod("getKind", &ImmIdTCmdCall::getKind),
                                                                                                                        InstanceMethod("is", &ImmIdTCmdCall::is),
                                                                                                                        InstanceMethod("getNodeIndex", &ImmIdTCmdCall::getNodeIndex),
                                                                                                                        InstanceMethod("getReadableId", &ImmIdTCmdCall::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTCmdCall> {
  using type = org::imm::ImmIdT<org::imm::ImmCmdCall>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmCmdCall>> {
  using type = ImmIdTCmdCall;
};

struct ImmIdTCmdTblfm : public SharedPtrWrapBase<ImmIdTCmdTblfm, org::imm::ImmIdT<org::imm::ImmCmdTblfm>> {
  using SharedPtrWrapBase<ImmIdTCmdTblfm, org::imm::ImmIdT<org::imm::ImmCmdTblfm>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmCmdTblfm>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdTblfm>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmCmdTblfm>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmCmdTblfm>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmCmdTblfm>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdTblfm>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmCmdTblfm>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdTblfm>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTCmdTblfm", {InstanceMethod("getKind", &ImmIdTCmdTblfm::getKind),
                                                                                                                         InstanceMethod("is", &ImmIdTCmdTblfm::is),
                                                                                                                         InstanceMethod("getNodeIndex", &ImmIdTCmdTblfm::getNodeIndex),
                                                                                                                         InstanceMethod("getReadableId", &ImmIdTCmdTblfm::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTCmdTblfm> {
  using type = org::imm::ImmIdT<org::imm::ImmCmdTblfm>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmCmdTblfm>> {
  using type = ImmIdTCmdTblfm;
};

struct ImmIdTHashTag : public SharedPtrWrapBase<ImmIdTHashTag, org::imm::ImmIdT<org::imm::ImmHashTag>> {
  using SharedPtrWrapBase<ImmIdTHashTag, org::imm::ImmIdT<org::imm::ImmHashTag>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmHashTag>::*)() const>(&org::imm::ImmIdT<org::imm::ImmHashTag>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmHashTag>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmHashTag>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmHashTag>::*)() const>(&org::imm::ImmIdT<org::imm::ImmHashTag>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmHashTag>::*)() const>(&org::imm::ImmIdT<org::imm::ImmHashTag>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTHashTag", {InstanceMethod("getKind", &ImmIdTHashTag::getKind),
                                                                                                                        InstanceMethod("is", &ImmIdTHashTag::is),
                                                                                                                        InstanceMethod("getNodeIndex", &ImmIdTHashTag::getNodeIndex),
                                                                                                                        InstanceMethod("getReadableId", &ImmIdTHashTag::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTHashTag> {
  using type = org::imm::ImmIdT<org::imm::ImmHashTag>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmHashTag>> {
  using type = ImmIdTHashTag;
};

struct ImmIdTInlineFootnote : public SharedPtrWrapBase<ImmIdTInlineFootnote, org::imm::ImmIdT<org::imm::ImmInlineFootnote>> {
  using SharedPtrWrapBase<ImmIdTInlineFootnote, org::imm::ImmIdT<org::imm::ImmInlineFootnote>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmInlineFootnote>::*)() const>(&org::imm::ImmIdT<org::imm::ImmInlineFootnote>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmInlineFootnote>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmInlineFootnote>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmInlineFootnote>::*)() const>(&org::imm::ImmIdT<org::imm::ImmInlineFootnote>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmInlineFootnote>::*)() const>(&org::imm::ImmIdT<org::imm::ImmInlineFootnote>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTInlineFootnote", {InstanceMethod("getKind", &ImmIdTInlineFootnote::getKind),
                                                                                                                               InstanceMethod("is", &ImmIdTInlineFootnote::is),
                                                                                                                               InstanceMethod("getNodeIndex", &ImmIdTInlineFootnote::getNodeIndex),
                                                                                                                               InstanceMethod("getReadableId", &ImmIdTInlineFootnote::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTInlineFootnote> {
  using type = org::imm::ImmIdT<org::imm::ImmInlineFootnote>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmInlineFootnote>> {
  using type = ImmIdTInlineFootnote;
};

struct ImmIdTInlineExport : public SharedPtrWrapBase<ImmIdTInlineExport, org::imm::ImmIdT<org::imm::ImmInlineExport>> {
  using SharedPtrWrapBase<ImmIdTInlineExport, org::imm::ImmIdT<org::imm::ImmInlineExport>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmInlineExport>::*)() const>(&org::imm::ImmIdT<org::imm::ImmInlineExport>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmInlineExport>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmInlineExport>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmInlineExport>::*)() const>(&org::imm::ImmIdT<org::imm::ImmInlineExport>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmInlineExport>::*)() const>(&org::imm::ImmIdT<org::imm::ImmInlineExport>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTInlineExport", {InstanceMethod("getKind", &ImmIdTInlineExport::getKind),
                                                                                                                             InstanceMethod("is", &ImmIdTInlineExport::is),
                                                                                                                             InstanceMethod("getNodeIndex", &ImmIdTInlineExport::getNodeIndex),
                                                                                                                             InstanceMethod("getReadableId", &ImmIdTInlineExport::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTInlineExport> {
  using type = org::imm::ImmIdT<org::imm::ImmInlineExport>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmInlineExport>> {
  using type = ImmIdTInlineExport;
};

struct ImmIdTTime : public SharedPtrWrapBase<ImmIdTTime, org::imm::ImmIdT<org::imm::ImmTime>> {
  using SharedPtrWrapBase<ImmIdTTime, org::imm::ImmIdT<org::imm::ImmTime>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmTime>::*)() const>(&org::imm::ImmIdT<org::imm::ImmTime>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmTime>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmTime>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmTime>::*)() const>(&org::imm::ImmIdT<org::imm::ImmTime>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmTime>::*)() const>(&org::imm::ImmIdT<org::imm::ImmTime>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTTime", {InstanceMethod("getKind", &ImmIdTTime::getKind),
                                                                                                                     InstanceMethod("is", &ImmIdTTime::is),
                                                                                                                     InstanceMethod("getNodeIndex", &ImmIdTTime::getNodeIndex),
                                                                                                                     InstanceMethod("getReadableId", &ImmIdTTime::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTTime> {
  using type = org::imm::ImmIdT<org::imm::ImmTime>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmTime>> {
  using type = ImmIdTTime;
};

struct ImmIdTTimeRange : public SharedPtrWrapBase<ImmIdTTimeRange, org::imm::ImmIdT<org::imm::ImmTimeRange>> {
  using SharedPtrWrapBase<ImmIdTTimeRange, org::imm::ImmIdT<org::imm::ImmTimeRange>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmTimeRange>::*)() const>(&org::imm::ImmIdT<org::imm::ImmTimeRange>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmTimeRange>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmTimeRange>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmTimeRange>::*)() const>(&org::imm::ImmIdT<org::imm::ImmTimeRange>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmTimeRange>::*)() const>(&org::imm::ImmIdT<org::imm::ImmTimeRange>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTTimeRange", {InstanceMethod("getKind", &ImmIdTTimeRange::getKind),
                                                                                                                          InstanceMethod("is", &ImmIdTTimeRange::is),
                                                                                                                          InstanceMethod("getNodeIndex", &ImmIdTTimeRange::getNodeIndex),
                                                                                                                          InstanceMethod("getReadableId", &ImmIdTTimeRange::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTTimeRange> {
  using type = org::imm::ImmIdT<org::imm::ImmTimeRange>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmTimeRange>> {
  using type = ImmIdTTimeRange;
};

struct ImmIdTMacro : public SharedPtrWrapBase<ImmIdTMacro, org::imm::ImmIdT<org::imm::ImmMacro>> {
  using SharedPtrWrapBase<ImmIdTMacro, org::imm::ImmIdT<org::imm::ImmMacro>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmMacro>::*)() const>(&org::imm::ImmIdT<org::imm::ImmMacro>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmMacro>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmMacro>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmMacro>::*)() const>(&org::imm::ImmIdT<org::imm::ImmMacro>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmMacro>::*)() const>(&org::imm::ImmIdT<org::imm::ImmMacro>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTMacro", {InstanceMethod("getKind", &ImmIdTMacro::getKind),
                                                                                                                      InstanceMethod("is", &ImmIdTMacro::is),
                                                                                                                      InstanceMethod("getNodeIndex", &ImmIdTMacro::getNodeIndex),
                                                                                                                      InstanceMethod("getReadableId", &ImmIdTMacro::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTMacro> {
  using type = org::imm::ImmIdT<org::imm::ImmMacro>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmMacro>> {
  using type = ImmIdTMacro;
};

struct ImmIdTSymbol : public SharedPtrWrapBase<ImmIdTSymbol, org::imm::ImmIdT<org::imm::ImmSymbol>> {
  using SharedPtrWrapBase<ImmIdTSymbol, org::imm::ImmIdT<org::imm::ImmSymbol>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmSymbol>::*)() const>(&org::imm::ImmIdT<org::imm::ImmSymbol>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmSymbol>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmSymbol>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmSymbol>::*)() const>(&org::imm::ImmIdT<org::imm::ImmSymbol>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmSymbol>::*)() const>(&org::imm::ImmIdT<org::imm::ImmSymbol>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTSymbol", {InstanceMethod("getKind", &ImmIdTSymbol::getKind),
                                                                                                                       InstanceMethod("is", &ImmIdTSymbol::is),
                                                                                                                       InstanceMethod("getNodeIndex", &ImmIdTSymbol::getNodeIndex),
                                                                                                                       InstanceMethod("getReadableId", &ImmIdTSymbol::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTSymbol> {
  using type = org::imm::ImmIdT<org::imm::ImmSymbol>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmSymbol>> {
  using type = ImmIdTSymbol;
};

struct ImmIdTEscaped : public SharedPtrWrapBase<ImmIdTEscaped, org::imm::ImmIdT<org::imm::ImmEscaped>> {
  using SharedPtrWrapBase<ImmIdTEscaped, org::imm::ImmIdT<org::imm::ImmEscaped>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmEscaped>::*)() const>(&org::imm::ImmIdT<org::imm::ImmEscaped>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmEscaped>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmEscaped>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmEscaped>::*)() const>(&org::imm::ImmIdT<org::imm::ImmEscaped>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmEscaped>::*)() const>(&org::imm::ImmIdT<org::imm::ImmEscaped>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTEscaped", {InstanceMethod("getKind", &ImmIdTEscaped::getKind),
                                                                                                                        InstanceMethod("is", &ImmIdTEscaped::is),
                                                                                                                        InstanceMethod("getNodeIndex", &ImmIdTEscaped::getNodeIndex),
                                                                                                                        InstanceMethod("getReadableId", &ImmIdTEscaped::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTEscaped> {
  using type = org::imm::ImmIdT<org::imm::ImmEscaped>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmEscaped>> {
  using type = ImmIdTEscaped;
};

struct ImmIdTNewline : public SharedPtrWrapBase<ImmIdTNewline, org::imm::ImmIdT<org::imm::ImmNewline>> {
  using SharedPtrWrapBase<ImmIdTNewline, org::imm::ImmIdT<org::imm::ImmNewline>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmNewline>::*)() const>(&org::imm::ImmIdT<org::imm::ImmNewline>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmNewline>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmNewline>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmNewline>::*)() const>(&org::imm::ImmIdT<org::imm::ImmNewline>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmNewline>::*)() const>(&org::imm::ImmIdT<org::imm::ImmNewline>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTNewline", {InstanceMethod("getKind", &ImmIdTNewline::getKind),
                                                                                                                        InstanceMethod("is", &ImmIdTNewline::is),
                                                                                                                        InstanceMethod("getNodeIndex", &ImmIdTNewline::getNodeIndex),
                                                                                                                        InstanceMethod("getReadableId", &ImmIdTNewline::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTNewline> {
  using type = org::imm::ImmIdT<org::imm::ImmNewline>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmNewline>> {
  using type = ImmIdTNewline;
};

struct ImmIdTSpace : public SharedPtrWrapBase<ImmIdTSpace, org::imm::ImmIdT<org::imm::ImmSpace>> {
  using SharedPtrWrapBase<ImmIdTSpace, org::imm::ImmIdT<org::imm::ImmSpace>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmSpace>::*)() const>(&org::imm::ImmIdT<org::imm::ImmSpace>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmSpace>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmSpace>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmSpace>::*)() const>(&org::imm::ImmIdT<org::imm::ImmSpace>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmSpace>::*)() const>(&org::imm::ImmIdT<org::imm::ImmSpace>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTSpace", {InstanceMethod("getKind", &ImmIdTSpace::getKind),
                                                                                                                      InstanceMethod("is", &ImmIdTSpace::is),
                                                                                                                      InstanceMethod("getNodeIndex", &ImmIdTSpace::getNodeIndex),
                                                                                                                      InstanceMethod("getReadableId", &ImmIdTSpace::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTSpace> {
  using type = org::imm::ImmIdT<org::imm::ImmSpace>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmSpace>> {
  using type = ImmIdTSpace;
};

struct ImmIdTWord : public SharedPtrWrapBase<ImmIdTWord, org::imm::ImmIdT<org::imm::ImmWord>> {
  using SharedPtrWrapBase<ImmIdTWord, org::imm::ImmIdT<org::imm::ImmWord>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmWord>::*)() const>(&org::imm::ImmIdT<org::imm::ImmWord>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmWord>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmWord>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmWord>::*)() const>(&org::imm::ImmIdT<org::imm::ImmWord>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmWord>::*)() const>(&org::imm::ImmIdT<org::imm::ImmWord>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTWord", {InstanceMethod("getKind", &ImmIdTWord::getKind),
                                                                                                                     InstanceMethod("is", &ImmIdTWord::is),
                                                                                                                     InstanceMethod("getNodeIndex", &ImmIdTWord::getNodeIndex),
                                                                                                                     InstanceMethod("getReadableId", &ImmIdTWord::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTWord> {
  using type = org::imm::ImmIdT<org::imm::ImmWord>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmWord>> {
  using type = ImmIdTWord;
};

struct ImmIdTAtMention : public SharedPtrWrapBase<ImmIdTAtMention, org::imm::ImmIdT<org::imm::ImmAtMention>> {
  using SharedPtrWrapBase<ImmIdTAtMention, org::imm::ImmIdT<org::imm::ImmAtMention>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmAtMention>::*)() const>(&org::imm::ImmIdT<org::imm::ImmAtMention>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmAtMention>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmAtMention>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmAtMention>::*)() const>(&org::imm::ImmIdT<org::imm::ImmAtMention>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmAtMention>::*)() const>(&org::imm::ImmIdT<org::imm::ImmAtMention>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTAtMention", {InstanceMethod("getKind", &ImmIdTAtMention::getKind),
                                                                                                                          InstanceMethod("is", &ImmIdTAtMention::is),
                                                                                                                          InstanceMethod("getNodeIndex", &ImmIdTAtMention::getNodeIndex),
                                                                                                                          InstanceMethod("getReadableId", &ImmIdTAtMention::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTAtMention> {
  using type = org::imm::ImmIdT<org::imm::ImmAtMention>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmAtMention>> {
  using type = ImmIdTAtMention;
};

struct ImmIdTRawText : public SharedPtrWrapBase<ImmIdTRawText, org::imm::ImmIdT<org::imm::ImmRawText>> {
  using SharedPtrWrapBase<ImmIdTRawText, org::imm::ImmIdT<org::imm::ImmRawText>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmRawText>::*)() const>(&org::imm::ImmIdT<org::imm::ImmRawText>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmRawText>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmRawText>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmRawText>::*)() const>(&org::imm::ImmIdT<org::imm::ImmRawText>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmRawText>::*)() const>(&org::imm::ImmIdT<org::imm::ImmRawText>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTRawText", {InstanceMethod("getKind", &ImmIdTRawText::getKind),
                                                                                                                        InstanceMethod("is", &ImmIdTRawText::is),
                                                                                                                        InstanceMethod("getNodeIndex", &ImmIdTRawText::getNodeIndex),
                                                                                                                        InstanceMethod("getReadableId", &ImmIdTRawText::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTRawText> {
  using type = org::imm::ImmIdT<org::imm::ImmRawText>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmRawText>> {
  using type = ImmIdTRawText;
};

struct ImmIdTPunctuation : public SharedPtrWrapBase<ImmIdTPunctuation, org::imm::ImmIdT<org::imm::ImmPunctuation>> {
  using SharedPtrWrapBase<ImmIdTPunctuation, org::imm::ImmIdT<org::imm::ImmPunctuation>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmPunctuation>::*)() const>(&org::imm::ImmIdT<org::imm::ImmPunctuation>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmPunctuation>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmPunctuation>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmPunctuation>::*)() const>(&org::imm::ImmIdT<org::imm::ImmPunctuation>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmPunctuation>::*)() const>(&org::imm::ImmIdT<org::imm::ImmPunctuation>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTPunctuation", {InstanceMethod("getKind", &ImmIdTPunctuation::getKind),
                                                                                                                            InstanceMethod("is", &ImmIdTPunctuation::is),
                                                                                                                            InstanceMethod("getNodeIndex", &ImmIdTPunctuation::getNodeIndex),
                                                                                                                            InstanceMethod("getReadableId", &ImmIdTPunctuation::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTPunctuation> {
  using type = org::imm::ImmIdT<org::imm::ImmPunctuation>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmPunctuation>> {
  using type = ImmIdTPunctuation;
};

struct ImmIdTPlaceholder : public SharedPtrWrapBase<ImmIdTPlaceholder, org::imm::ImmIdT<org::imm::ImmPlaceholder>> {
  using SharedPtrWrapBase<ImmIdTPlaceholder, org::imm::ImmIdT<org::imm::ImmPlaceholder>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmPlaceholder>::*)() const>(&org::imm::ImmIdT<org::imm::ImmPlaceholder>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmPlaceholder>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmPlaceholder>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmPlaceholder>::*)() const>(&org::imm::ImmIdT<org::imm::ImmPlaceholder>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmPlaceholder>::*)() const>(&org::imm::ImmIdT<org::imm::ImmPlaceholder>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTPlaceholder", {InstanceMethod("getKind", &ImmIdTPlaceholder::getKind),
                                                                                                                            InstanceMethod("is", &ImmIdTPlaceholder::is),
                                                                                                                            InstanceMethod("getNodeIndex", &ImmIdTPlaceholder::getNodeIndex),
                                                                                                                            InstanceMethod("getReadableId", &ImmIdTPlaceholder::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTPlaceholder> {
  using type = org::imm::ImmIdT<org::imm::ImmPlaceholder>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmPlaceholder>> {
  using type = ImmIdTPlaceholder;
};

struct ImmIdTBigIdent : public SharedPtrWrapBase<ImmIdTBigIdent, org::imm::ImmIdT<org::imm::ImmBigIdent>> {
  using SharedPtrWrapBase<ImmIdTBigIdent, org::imm::ImmIdT<org::imm::ImmBigIdent>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmBigIdent>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBigIdent>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmBigIdent>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmBigIdent>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmBigIdent>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBigIdent>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmBigIdent>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBigIdent>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTBigIdent", {InstanceMethod("getKind", &ImmIdTBigIdent::getKind),
                                                                                                                         InstanceMethod("is", &ImmIdTBigIdent::is),
                                                                                                                         InstanceMethod("getNodeIndex", &ImmIdTBigIdent::getNodeIndex),
                                                                                                                         InstanceMethod("getReadableId", &ImmIdTBigIdent::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTBigIdent> {
  using type = org::imm::ImmIdT<org::imm::ImmBigIdent>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmBigIdent>> {
  using type = ImmIdTBigIdent;
};

struct ImmIdTTextTarget : public SharedPtrWrapBase<ImmIdTTextTarget, org::imm::ImmIdT<org::imm::ImmTextTarget>> {
  using SharedPtrWrapBase<ImmIdTTextTarget, org::imm::ImmIdT<org::imm::ImmTextTarget>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmTextTarget>::*)() const>(&org::imm::ImmIdT<org::imm::ImmTextTarget>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmTextTarget>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmTextTarget>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmTextTarget>::*)() const>(&org::imm::ImmIdT<org::imm::ImmTextTarget>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmTextTarget>::*)() const>(&org::imm::ImmIdT<org::imm::ImmTextTarget>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTTextTarget", {InstanceMethod("getKind", &ImmIdTTextTarget::getKind),
                                                                                                                           InstanceMethod("is", &ImmIdTTextTarget::is),
                                                                                                                           InstanceMethod("getNodeIndex", &ImmIdTTextTarget::getNodeIndex),
                                                                                                                           InstanceMethod("getReadableId", &ImmIdTTextTarget::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTTextTarget> {
  using type = org::imm::ImmIdT<org::imm::ImmTextTarget>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmTextTarget>> {
  using type = ImmIdTTextTarget;
};

struct ImmIdTMarkup : public SharedPtrWrapBase<ImmIdTMarkup, org::imm::ImmIdT<org::imm::ImmMarkup>> {
  using SharedPtrWrapBase<ImmIdTMarkup, org::imm::ImmIdT<org::imm::ImmMarkup>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmMarkup>::*)() const>(&org::imm::ImmIdT<org::imm::ImmMarkup>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmMarkup>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmMarkup>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmMarkup>::*)() const>(&org::imm::ImmIdT<org::imm::ImmMarkup>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmMarkup>::*)() const>(&org::imm::ImmIdT<org::imm::ImmMarkup>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTMarkup", {InstanceMethod("getKind", &ImmIdTMarkup::getKind),
                                                                                                                       InstanceMethod("is", &ImmIdTMarkup::is),
                                                                                                                       InstanceMethod("getNodeIndex", &ImmIdTMarkup::getNodeIndex),
                                                                                                                       InstanceMethod("getReadableId", &ImmIdTMarkup::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTMarkup> {
  using type = org::imm::ImmIdT<org::imm::ImmMarkup>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmMarkup>> {
  using type = ImmIdTMarkup;
};

struct ImmIdTBold : public SharedPtrWrapBase<ImmIdTBold, org::imm::ImmIdT<org::imm::ImmBold>> {
  using SharedPtrWrapBase<ImmIdTBold, org::imm::ImmIdT<org::imm::ImmBold>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmBold>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBold>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmBold>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmBold>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmBold>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBold>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmBold>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBold>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTBold", {InstanceMethod("getKind", &ImmIdTBold::getKind),
                                                                                                                     InstanceMethod("is", &ImmIdTBold::is),
                                                                                                                     InstanceMethod("getNodeIndex", &ImmIdTBold::getNodeIndex),
                                                                                                                     InstanceMethod("getReadableId", &ImmIdTBold::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTBold> {
  using type = org::imm::ImmIdT<org::imm::ImmBold>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmBold>> {
  using type = ImmIdTBold;
};

struct ImmIdTUnderline : public SharedPtrWrapBase<ImmIdTUnderline, org::imm::ImmIdT<org::imm::ImmUnderline>> {
  using SharedPtrWrapBase<ImmIdTUnderline, org::imm::ImmIdT<org::imm::ImmUnderline>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmUnderline>::*)() const>(&org::imm::ImmIdT<org::imm::ImmUnderline>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmUnderline>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmUnderline>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmUnderline>::*)() const>(&org::imm::ImmIdT<org::imm::ImmUnderline>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmUnderline>::*)() const>(&org::imm::ImmIdT<org::imm::ImmUnderline>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTUnderline", {InstanceMethod("getKind", &ImmIdTUnderline::getKind),
                                                                                                                          InstanceMethod("is", &ImmIdTUnderline::is),
                                                                                                                          InstanceMethod("getNodeIndex", &ImmIdTUnderline::getNodeIndex),
                                                                                                                          InstanceMethod("getReadableId", &ImmIdTUnderline::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTUnderline> {
  using type = org::imm::ImmIdT<org::imm::ImmUnderline>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmUnderline>> {
  using type = ImmIdTUnderline;
};

struct ImmIdTMonospace : public SharedPtrWrapBase<ImmIdTMonospace, org::imm::ImmIdT<org::imm::ImmMonospace>> {
  using SharedPtrWrapBase<ImmIdTMonospace, org::imm::ImmIdT<org::imm::ImmMonospace>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmMonospace>::*)() const>(&org::imm::ImmIdT<org::imm::ImmMonospace>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmMonospace>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmMonospace>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmMonospace>::*)() const>(&org::imm::ImmIdT<org::imm::ImmMonospace>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmMonospace>::*)() const>(&org::imm::ImmIdT<org::imm::ImmMonospace>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTMonospace", {InstanceMethod("getKind", &ImmIdTMonospace::getKind),
                                                                                                                          InstanceMethod("is", &ImmIdTMonospace::is),
                                                                                                                          InstanceMethod("getNodeIndex", &ImmIdTMonospace::getNodeIndex),
                                                                                                                          InstanceMethod("getReadableId", &ImmIdTMonospace::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTMonospace> {
  using type = org::imm::ImmIdT<org::imm::ImmMonospace>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmMonospace>> {
  using type = ImmIdTMonospace;
};

struct ImmIdTMarkQuote : public SharedPtrWrapBase<ImmIdTMarkQuote, org::imm::ImmIdT<org::imm::ImmMarkQuote>> {
  using SharedPtrWrapBase<ImmIdTMarkQuote, org::imm::ImmIdT<org::imm::ImmMarkQuote>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmMarkQuote>::*)() const>(&org::imm::ImmIdT<org::imm::ImmMarkQuote>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmMarkQuote>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmMarkQuote>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmMarkQuote>::*)() const>(&org::imm::ImmIdT<org::imm::ImmMarkQuote>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmMarkQuote>::*)() const>(&org::imm::ImmIdT<org::imm::ImmMarkQuote>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTMarkQuote", {InstanceMethod("getKind", &ImmIdTMarkQuote::getKind),
                                                                                                                          InstanceMethod("is", &ImmIdTMarkQuote::is),
                                                                                                                          InstanceMethod("getNodeIndex", &ImmIdTMarkQuote::getNodeIndex),
                                                                                                                          InstanceMethod("getReadableId", &ImmIdTMarkQuote::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTMarkQuote> {
  using type = org::imm::ImmIdT<org::imm::ImmMarkQuote>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmMarkQuote>> {
  using type = ImmIdTMarkQuote;
};

struct ImmIdTVerbatim : public SharedPtrWrapBase<ImmIdTVerbatim, org::imm::ImmIdT<org::imm::ImmVerbatim>> {
  using SharedPtrWrapBase<ImmIdTVerbatim, org::imm::ImmIdT<org::imm::ImmVerbatim>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmVerbatim>::*)() const>(&org::imm::ImmIdT<org::imm::ImmVerbatim>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmVerbatim>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmVerbatim>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmVerbatim>::*)() const>(&org::imm::ImmIdT<org::imm::ImmVerbatim>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmVerbatim>::*)() const>(&org::imm::ImmIdT<org::imm::ImmVerbatim>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTVerbatim", {InstanceMethod("getKind", &ImmIdTVerbatim::getKind),
                                                                                                                         InstanceMethod("is", &ImmIdTVerbatim::is),
                                                                                                                         InstanceMethod("getNodeIndex", &ImmIdTVerbatim::getNodeIndex),
                                                                                                                         InstanceMethod("getReadableId", &ImmIdTVerbatim::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTVerbatim> {
  using type = org::imm::ImmIdT<org::imm::ImmVerbatim>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmVerbatim>> {
  using type = ImmIdTVerbatim;
};

struct ImmIdTItalic : public SharedPtrWrapBase<ImmIdTItalic, org::imm::ImmIdT<org::imm::ImmItalic>> {
  using SharedPtrWrapBase<ImmIdTItalic, org::imm::ImmIdT<org::imm::ImmItalic>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmItalic>::*)() const>(&org::imm::ImmIdT<org::imm::ImmItalic>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmItalic>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmItalic>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmItalic>::*)() const>(&org::imm::ImmIdT<org::imm::ImmItalic>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmItalic>::*)() const>(&org::imm::ImmIdT<org::imm::ImmItalic>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTItalic", {InstanceMethod("getKind", &ImmIdTItalic::getKind),
                                                                                                                       InstanceMethod("is", &ImmIdTItalic::is),
                                                                                                                       InstanceMethod("getNodeIndex", &ImmIdTItalic::getNodeIndex),
                                                                                                                       InstanceMethod("getReadableId", &ImmIdTItalic::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTItalic> {
  using type = org::imm::ImmIdT<org::imm::ImmItalic>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmItalic>> {
  using type = ImmIdTItalic;
};

struct ImmIdTStrike : public SharedPtrWrapBase<ImmIdTStrike, org::imm::ImmIdT<org::imm::ImmStrike>> {
  using SharedPtrWrapBase<ImmIdTStrike, org::imm::ImmIdT<org::imm::ImmStrike>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmStrike>::*)() const>(&org::imm::ImmIdT<org::imm::ImmStrike>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmStrike>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmStrike>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmStrike>::*)() const>(&org::imm::ImmIdT<org::imm::ImmStrike>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmStrike>::*)() const>(&org::imm::ImmIdT<org::imm::ImmStrike>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTStrike", {InstanceMethod("getKind", &ImmIdTStrike::getKind),
                                                                                                                       InstanceMethod("is", &ImmIdTStrike::is),
                                                                                                                       InstanceMethod("getNodeIndex", &ImmIdTStrike::getNodeIndex),
                                                                                                                       InstanceMethod("getReadableId", &ImmIdTStrike::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTStrike> {
  using type = org::imm::ImmIdT<org::imm::ImmStrike>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmStrike>> {
  using type = ImmIdTStrike;
};

struct ImmIdTPar : public SharedPtrWrapBase<ImmIdTPar, org::imm::ImmIdT<org::imm::ImmPar>> {
  using SharedPtrWrapBase<ImmIdTPar, org::imm::ImmIdT<org::imm::ImmPar>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmPar>::*)() const>(&org::imm::ImmIdT<org::imm::ImmPar>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmPar>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmPar>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmPar>::*)() const>(&org::imm::ImmIdT<org::imm::ImmPar>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmPar>::*)() const>(&org::imm::ImmIdT<org::imm::ImmPar>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTPar", {InstanceMethod("getKind", &ImmIdTPar::getKind),
                                                                                                                    InstanceMethod("is", &ImmIdTPar::is),
                                                                                                                    InstanceMethod("getNodeIndex", &ImmIdTPar::getNodeIndex),
                                                                                                                    InstanceMethod("getReadableId", &ImmIdTPar::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTPar> {
  using type = org::imm::ImmIdT<org::imm::ImmPar>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmPar>> {
  using type = ImmIdTPar;
};

struct ImmIdTRadioTarget : public SharedPtrWrapBase<ImmIdTRadioTarget, org::imm::ImmIdT<org::imm::ImmRadioTarget>> {
  using SharedPtrWrapBase<ImmIdTRadioTarget, org::imm::ImmIdT<org::imm::ImmRadioTarget>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmRadioTarget>::*)() const>(&org::imm::ImmIdT<org::imm::ImmRadioTarget>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmRadioTarget>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmRadioTarget>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmRadioTarget>::*)() const>(&org::imm::ImmIdT<org::imm::ImmRadioTarget>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmRadioTarget>::*)() const>(&org::imm::ImmIdT<org::imm::ImmRadioTarget>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTRadioTarget", {InstanceMethod("getKind", &ImmIdTRadioTarget::getKind),
                                                                                                                            InstanceMethod("is", &ImmIdTRadioTarget::is),
                                                                                                                            InstanceMethod("getNodeIndex", &ImmIdTRadioTarget::getNodeIndex),
                                                                                                                            InstanceMethod("getReadableId", &ImmIdTRadioTarget::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTRadioTarget> {
  using type = org::imm::ImmIdT<org::imm::ImmRadioTarget>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmRadioTarget>> {
  using type = ImmIdTRadioTarget;
};

struct ImmIdTLatex : public SharedPtrWrapBase<ImmIdTLatex, org::imm::ImmIdT<org::imm::ImmLatex>> {
  using SharedPtrWrapBase<ImmIdTLatex, org::imm::ImmIdT<org::imm::ImmLatex>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmLatex>::*)() const>(&org::imm::ImmIdT<org::imm::ImmLatex>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmLatex>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmLatex>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmLatex>::*)() const>(&org::imm::ImmIdT<org::imm::ImmLatex>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmLatex>::*)() const>(&org::imm::ImmIdT<org::imm::ImmLatex>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTLatex", {InstanceMethod("getKind", &ImmIdTLatex::getKind),
                                                                                                                      InstanceMethod("is", &ImmIdTLatex::is),
                                                                                                                      InstanceMethod("getNodeIndex", &ImmIdTLatex::getNodeIndex),
                                                                                                                      InstanceMethod("getReadableId", &ImmIdTLatex::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTLatex> {
  using type = org::imm::ImmIdT<org::imm::ImmLatex>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmLatex>> {
  using type = ImmIdTLatex;
};

struct ImmIdTLink : public SharedPtrWrapBase<ImmIdTLink, org::imm::ImmIdT<org::imm::ImmLink>> {
  using SharedPtrWrapBase<ImmIdTLink, org::imm::ImmIdT<org::imm::ImmLink>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmLink>::*)() const>(&org::imm::ImmIdT<org::imm::ImmLink>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmLink>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmLink>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmLink>::*)() const>(&org::imm::ImmIdT<org::imm::ImmLink>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmLink>::*)() const>(&org::imm::ImmIdT<org::imm::ImmLink>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTLink", {InstanceMethod("getKind", &ImmIdTLink::getKind),
                                                                                                                     InstanceMethod("is", &ImmIdTLink::is),
                                                                                                                     InstanceMethod("getNodeIndex", &ImmIdTLink::getNodeIndex),
                                                                                                                     InstanceMethod("getReadableId", &ImmIdTLink::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTLink> {
  using type = org::imm::ImmIdT<org::imm::ImmLink>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmLink>> {
  using type = ImmIdTLink;
};

struct ImmIdTBlockCenter : public SharedPtrWrapBase<ImmIdTBlockCenter, org::imm::ImmIdT<org::imm::ImmBlockCenter>> {
  using SharedPtrWrapBase<ImmIdTBlockCenter, org::imm::ImmIdT<org::imm::ImmBlockCenter>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmBlockCenter>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockCenter>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmBlockCenter>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmBlockCenter>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmBlockCenter>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockCenter>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmBlockCenter>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockCenter>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTBlockCenter", {InstanceMethod("getKind", &ImmIdTBlockCenter::getKind),
                                                                                                                            InstanceMethod("is", &ImmIdTBlockCenter::is),
                                                                                                                            InstanceMethod("getNodeIndex", &ImmIdTBlockCenter::getNodeIndex),
                                                                                                                            InstanceMethod("getReadableId", &ImmIdTBlockCenter::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTBlockCenter> {
  using type = org::imm::ImmIdT<org::imm::ImmBlockCenter>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmBlockCenter>> {
  using type = ImmIdTBlockCenter;
};

struct ImmIdTBlockQuote : public SharedPtrWrapBase<ImmIdTBlockQuote, org::imm::ImmIdT<org::imm::ImmBlockQuote>> {
  using SharedPtrWrapBase<ImmIdTBlockQuote, org::imm::ImmIdT<org::imm::ImmBlockQuote>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmBlockQuote>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockQuote>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmBlockQuote>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmBlockQuote>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmBlockQuote>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockQuote>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmBlockQuote>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockQuote>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTBlockQuote", {InstanceMethod("getKind", &ImmIdTBlockQuote::getKind),
                                                                                                                           InstanceMethod("is", &ImmIdTBlockQuote::is),
                                                                                                                           InstanceMethod("getNodeIndex", &ImmIdTBlockQuote::getNodeIndex),
                                                                                                                           InstanceMethod("getReadableId", &ImmIdTBlockQuote::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTBlockQuote> {
  using type = org::imm::ImmIdT<org::imm::ImmBlockQuote>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmBlockQuote>> {
  using type = ImmIdTBlockQuote;
};

struct ImmIdTBlockComment : public SharedPtrWrapBase<ImmIdTBlockComment, org::imm::ImmIdT<org::imm::ImmBlockComment>> {
  using SharedPtrWrapBase<ImmIdTBlockComment, org::imm::ImmIdT<org::imm::ImmBlockComment>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmBlockComment>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockComment>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmBlockComment>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmBlockComment>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmBlockComment>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockComment>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmBlockComment>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockComment>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTBlockComment", {InstanceMethod("getKind", &ImmIdTBlockComment::getKind),
                                                                                                                             InstanceMethod("is", &ImmIdTBlockComment::is),
                                                                                                                             InstanceMethod("getNodeIndex", &ImmIdTBlockComment::getNodeIndex),
                                                                                                                             InstanceMethod("getReadableId", &ImmIdTBlockComment::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTBlockComment> {
  using type = org::imm::ImmIdT<org::imm::ImmBlockComment>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmBlockComment>> {
  using type = ImmIdTBlockComment;
};

struct ImmIdTBlockVerse : public SharedPtrWrapBase<ImmIdTBlockVerse, org::imm::ImmIdT<org::imm::ImmBlockVerse>> {
  using SharedPtrWrapBase<ImmIdTBlockVerse, org::imm::ImmIdT<org::imm::ImmBlockVerse>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmBlockVerse>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockVerse>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmBlockVerse>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmBlockVerse>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmBlockVerse>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockVerse>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmBlockVerse>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockVerse>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTBlockVerse", {InstanceMethod("getKind", &ImmIdTBlockVerse::getKind),
                                                                                                                           InstanceMethod("is", &ImmIdTBlockVerse::is),
                                                                                                                           InstanceMethod("getNodeIndex", &ImmIdTBlockVerse::getNodeIndex),
                                                                                                                           InstanceMethod("getReadableId", &ImmIdTBlockVerse::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTBlockVerse> {
  using type = org::imm::ImmIdT<org::imm::ImmBlockVerse>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmBlockVerse>> {
  using type = ImmIdTBlockVerse;
};

struct ImmIdTBlockDynamicFallback : public SharedPtrWrapBase<ImmIdTBlockDynamicFallback, org::imm::ImmIdT<org::imm::ImmBlockDynamicFallback>> {
  using SharedPtrWrapBase<ImmIdTBlockDynamicFallback, org::imm::ImmIdT<org::imm::ImmBlockDynamicFallback>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmBlockDynamicFallback>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockDynamicFallback>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmBlockDynamicFallback>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmBlockDynamicFallback>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmBlockDynamicFallback>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockDynamicFallback>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmBlockDynamicFallback>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockDynamicFallback>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTBlockDynamicFallback", {InstanceMethod("getKind", &ImmIdTBlockDynamicFallback::getKind),
                                                                                                                                     InstanceMethod("is", &ImmIdTBlockDynamicFallback::is),
                                                                                                                                     InstanceMethod("getNodeIndex", &ImmIdTBlockDynamicFallback::getNodeIndex),
                                                                                                                                     InstanceMethod("getReadableId", &ImmIdTBlockDynamicFallback::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTBlockDynamicFallback> {
  using type = org::imm::ImmIdT<org::imm::ImmBlockDynamicFallback>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmBlockDynamicFallback>> {
  using type = ImmIdTBlockDynamicFallback;
};

struct ImmIdTBlockExample : public SharedPtrWrapBase<ImmIdTBlockExample, org::imm::ImmIdT<org::imm::ImmBlockExample>> {
  using SharedPtrWrapBase<ImmIdTBlockExample, org::imm::ImmIdT<org::imm::ImmBlockExample>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmBlockExample>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockExample>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmBlockExample>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmBlockExample>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmBlockExample>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockExample>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmBlockExample>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockExample>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTBlockExample", {InstanceMethod("getKind", &ImmIdTBlockExample::getKind),
                                                                                                                             InstanceMethod("is", &ImmIdTBlockExample::is),
                                                                                                                             InstanceMethod("getNodeIndex", &ImmIdTBlockExample::getNodeIndex),
                                                                                                                             InstanceMethod("getReadableId", &ImmIdTBlockExample::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTBlockExample> {
  using type = org::imm::ImmIdT<org::imm::ImmBlockExample>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmBlockExample>> {
  using type = ImmIdTBlockExample;
};

struct ImmIdTBlockExport : public SharedPtrWrapBase<ImmIdTBlockExport, org::imm::ImmIdT<org::imm::ImmBlockExport>> {
  using SharedPtrWrapBase<ImmIdTBlockExport, org::imm::ImmIdT<org::imm::ImmBlockExport>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmBlockExport>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockExport>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmBlockExport>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmBlockExport>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmBlockExport>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockExport>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmBlockExport>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockExport>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTBlockExport", {InstanceMethod("getKind", &ImmIdTBlockExport::getKind),
                                                                                                                            InstanceMethod("is", &ImmIdTBlockExport::is),
                                                                                                                            InstanceMethod("getNodeIndex", &ImmIdTBlockExport::getNodeIndex),
                                                                                                                            InstanceMethod("getReadableId", &ImmIdTBlockExport::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTBlockExport> {
  using type = org::imm::ImmIdT<org::imm::ImmBlockExport>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmBlockExport>> {
  using type = ImmIdTBlockExport;
};

struct ImmIdTBlockAdmonition : public SharedPtrWrapBase<ImmIdTBlockAdmonition, org::imm::ImmIdT<org::imm::ImmBlockAdmonition>> {
  using SharedPtrWrapBase<ImmIdTBlockAdmonition, org::imm::ImmIdT<org::imm::ImmBlockAdmonition>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmBlockAdmonition>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockAdmonition>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmBlockAdmonition>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmBlockAdmonition>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmBlockAdmonition>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockAdmonition>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmBlockAdmonition>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockAdmonition>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTBlockAdmonition", {InstanceMethod("getKind", &ImmIdTBlockAdmonition::getKind),
                                                                                                                                InstanceMethod("is", &ImmIdTBlockAdmonition::is),
                                                                                                                                InstanceMethod("getNodeIndex", &ImmIdTBlockAdmonition::getNodeIndex),
                                                                                                                                InstanceMethod("getReadableId", &ImmIdTBlockAdmonition::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTBlockAdmonition> {
  using type = org::imm::ImmIdT<org::imm::ImmBlockAdmonition>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmBlockAdmonition>> {
  using type = ImmIdTBlockAdmonition;
};

struct ImmIdTBlockCodeEvalResult : public SharedPtrWrapBase<ImmIdTBlockCodeEvalResult, org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>> {
  using SharedPtrWrapBase<ImmIdTBlockCodeEvalResult, org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTBlockCodeEvalResult", {InstanceMethod("getKind", &ImmIdTBlockCodeEvalResult::getKind),
                                                                                                                                    InstanceMethod("is", &ImmIdTBlockCodeEvalResult::is),
                                                                                                                                    InstanceMethod("getNodeIndex", &ImmIdTBlockCodeEvalResult::getNodeIndex),
                                                                                                                                    InstanceMethod("getReadableId", &ImmIdTBlockCodeEvalResult::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTBlockCodeEvalResult> {
  using type = org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>> {
  using type = ImmIdTBlockCodeEvalResult;
};

struct ImmIdTBlockCode : public SharedPtrWrapBase<ImmIdTBlockCode, org::imm::ImmIdT<org::imm::ImmBlockCode>> {
  using SharedPtrWrapBase<ImmIdTBlockCode, org::imm::ImmIdT<org::imm::ImmBlockCode>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmBlockCode>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockCode>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmBlockCode>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmBlockCode>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmBlockCode>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockCode>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmBlockCode>::*)() const>(&org::imm::ImmIdT<org::imm::ImmBlockCode>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTBlockCode", {InstanceMethod("getKind", &ImmIdTBlockCode::getKind),
                                                                                                                          InstanceMethod("is", &ImmIdTBlockCode::is),
                                                                                                                          InstanceMethod("getNodeIndex", &ImmIdTBlockCode::getNodeIndex),
                                                                                                                          InstanceMethod("getReadableId", &ImmIdTBlockCode::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTBlockCode> {
  using type = org::imm::ImmIdT<org::imm::ImmBlockCode>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmBlockCode>> {
  using type = ImmIdTBlockCode;
};

struct ImmIdTSubtreeLog : public SharedPtrWrapBase<ImmIdTSubtreeLog, org::imm::ImmIdT<org::imm::ImmSubtreeLog>> {
  using SharedPtrWrapBase<ImmIdTSubtreeLog, org::imm::ImmIdT<org::imm::ImmSubtreeLog>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmSubtreeLog>::*)() const>(&org::imm::ImmIdT<org::imm::ImmSubtreeLog>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmSubtreeLog>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmSubtreeLog>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmSubtreeLog>::*)() const>(&org::imm::ImmIdT<org::imm::ImmSubtreeLog>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmSubtreeLog>::*)() const>(&org::imm::ImmIdT<org::imm::ImmSubtreeLog>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTSubtreeLog", {InstanceMethod("getKind", &ImmIdTSubtreeLog::getKind),
                                                                                                                           InstanceMethod("is", &ImmIdTSubtreeLog::is),
                                                                                                                           InstanceMethod("getNodeIndex", &ImmIdTSubtreeLog::getNodeIndex),
                                                                                                                           InstanceMethod("getReadableId", &ImmIdTSubtreeLog::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTSubtreeLog> {
  using type = org::imm::ImmIdT<org::imm::ImmSubtreeLog>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmSubtreeLog>> {
  using type = ImmIdTSubtreeLog;
};

struct ImmIdTSubtree : public SharedPtrWrapBase<ImmIdTSubtree, org::imm::ImmIdT<org::imm::ImmSubtree>> {
  using SharedPtrWrapBase<ImmIdTSubtree, org::imm::ImmIdT<org::imm::ImmSubtree>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmSubtree>::*)() const>(&org::imm::ImmIdT<org::imm::ImmSubtree>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmSubtree>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmSubtree>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmSubtree>::*)() const>(&org::imm::ImmIdT<org::imm::ImmSubtree>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmSubtree>::*)() const>(&org::imm::ImmIdT<org::imm::ImmSubtree>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTSubtree", {InstanceMethod("getKind", &ImmIdTSubtree::getKind),
                                                                                                                        InstanceMethod("is", &ImmIdTSubtree::is),
                                                                                                                        InstanceMethod("getNodeIndex", &ImmIdTSubtree::getNodeIndex),
                                                                                                                        InstanceMethod("getReadableId", &ImmIdTSubtree::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTSubtree> {
  using type = org::imm::ImmIdT<org::imm::ImmSubtree>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmSubtree>> {
  using type = ImmIdTSubtree;
};

struct ImmIdTCell : public SharedPtrWrapBase<ImmIdTCell, org::imm::ImmIdT<org::imm::ImmCell>> {
  using SharedPtrWrapBase<ImmIdTCell, org::imm::ImmIdT<org::imm::ImmCell>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmCell>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCell>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmCell>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmCell>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmCell>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCell>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmCell>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCell>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTCell", {InstanceMethod("getKind", &ImmIdTCell::getKind),
                                                                                                                     InstanceMethod("is", &ImmIdTCell::is),
                                                                                                                     InstanceMethod("getNodeIndex", &ImmIdTCell::getNodeIndex),
                                                                                                                     InstanceMethod("getReadableId", &ImmIdTCell::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTCell> {
  using type = org::imm::ImmIdT<org::imm::ImmCell>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmCell>> {
  using type = ImmIdTCell;
};

struct ImmIdTRow : public SharedPtrWrapBase<ImmIdTRow, org::imm::ImmIdT<org::imm::ImmRow>> {
  using SharedPtrWrapBase<ImmIdTRow, org::imm::ImmIdT<org::imm::ImmRow>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmRow>::*)() const>(&org::imm::ImmIdT<org::imm::ImmRow>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmRow>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmRow>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmRow>::*)() const>(&org::imm::ImmIdT<org::imm::ImmRow>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmRow>::*)() const>(&org::imm::ImmIdT<org::imm::ImmRow>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTRow", {InstanceMethod("getKind", &ImmIdTRow::getKind),
                                                                                                                    InstanceMethod("is", &ImmIdTRow::is),
                                                                                                                    InstanceMethod("getNodeIndex", &ImmIdTRow::getNodeIndex),
                                                                                                                    InstanceMethod("getReadableId", &ImmIdTRow::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTRow> {
  using type = org::imm::ImmIdT<org::imm::ImmRow>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmRow>> {
  using type = ImmIdTRow;
};

struct ImmIdTTable : public SharedPtrWrapBase<ImmIdTTable, org::imm::ImmIdT<org::imm::ImmTable>> {
  using SharedPtrWrapBase<ImmIdTTable, org::imm::ImmIdT<org::imm::ImmTable>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmTable>::*)() const>(&org::imm::ImmIdT<org::imm::ImmTable>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmTable>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmTable>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmTable>::*)() const>(&org::imm::ImmIdT<org::imm::ImmTable>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmTable>::*)() const>(&org::imm::ImmIdT<org::imm::ImmTable>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTTable", {InstanceMethod("getKind", &ImmIdTTable::getKind),
                                                                                                                      InstanceMethod("is", &ImmIdTTable::is),
                                                                                                                      InstanceMethod("getNodeIndex", &ImmIdTTable::getNodeIndex),
                                                                                                                      InstanceMethod("getReadableId", &ImmIdTTable::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTTable> {
  using type = org::imm::ImmIdT<org::imm::ImmTable>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmTable>> {
  using type = ImmIdTTable;
};

struct ImmIdTParagraph : public SharedPtrWrapBase<ImmIdTParagraph, org::imm::ImmIdT<org::imm::ImmParagraph>> {
  using SharedPtrWrapBase<ImmIdTParagraph, org::imm::ImmIdT<org::imm::ImmParagraph>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmParagraph>::*)() const>(&org::imm::ImmIdT<org::imm::ImmParagraph>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmParagraph>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmParagraph>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmParagraph>::*)() const>(&org::imm::ImmIdT<org::imm::ImmParagraph>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmParagraph>::*)() const>(&org::imm::ImmIdT<org::imm::ImmParagraph>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTParagraph", {InstanceMethod("getKind", &ImmIdTParagraph::getKind),
                                                                                                                          InstanceMethod("is", &ImmIdTParagraph::is),
                                                                                                                          InstanceMethod("getNodeIndex", &ImmIdTParagraph::getNodeIndex),
                                                                                                                          InstanceMethod("getReadableId", &ImmIdTParagraph::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTParagraph> {
  using type = org::imm::ImmIdT<org::imm::ImmParagraph>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmParagraph>> {
  using type = ImmIdTParagraph;
};

struct ImmIdTColonExample : public SharedPtrWrapBase<ImmIdTColonExample, org::imm::ImmIdT<org::imm::ImmColonExample>> {
  using SharedPtrWrapBase<ImmIdTColonExample, org::imm::ImmIdT<org::imm::ImmColonExample>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmColonExample>::*)() const>(&org::imm::ImmIdT<org::imm::ImmColonExample>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmColonExample>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmColonExample>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmColonExample>::*)() const>(&org::imm::ImmIdT<org::imm::ImmColonExample>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmColonExample>::*)() const>(&org::imm::ImmIdT<org::imm::ImmColonExample>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTColonExample", {InstanceMethod("getKind", &ImmIdTColonExample::getKind),
                                                                                                                             InstanceMethod("is", &ImmIdTColonExample::is),
                                                                                                                             InstanceMethod("getNodeIndex", &ImmIdTColonExample::getNodeIndex),
                                                                                                                             InstanceMethod("getReadableId", &ImmIdTColonExample::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTColonExample> {
  using type = org::imm::ImmIdT<org::imm::ImmColonExample>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmColonExample>> {
  using type = ImmIdTColonExample;
};

struct ImmIdTCmdAttr : public SharedPtrWrapBase<ImmIdTCmdAttr, org::imm::ImmIdT<org::imm::ImmCmdAttr>> {
  using SharedPtrWrapBase<ImmIdTCmdAttr, org::imm::ImmIdT<org::imm::ImmCmdAttr>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmCmdAttr>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdAttr>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmCmdAttr>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmCmdAttr>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmCmdAttr>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdAttr>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmCmdAttr>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdAttr>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTCmdAttr", {InstanceMethod("getKind", &ImmIdTCmdAttr::getKind),
                                                                                                                        InstanceMethod("is", &ImmIdTCmdAttr::is),
                                                                                                                        InstanceMethod("getNodeIndex", &ImmIdTCmdAttr::getNodeIndex),
                                                                                                                        InstanceMethod("getReadableId", &ImmIdTCmdAttr::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTCmdAttr> {
  using type = org::imm::ImmIdT<org::imm::ImmCmdAttr>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmCmdAttr>> {
  using type = ImmIdTCmdAttr;
};

struct ImmIdTCmdExport : public SharedPtrWrapBase<ImmIdTCmdExport, org::imm::ImmIdT<org::imm::ImmCmdExport>> {
  using SharedPtrWrapBase<ImmIdTCmdExport, org::imm::ImmIdT<org::imm::ImmCmdExport>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmCmdExport>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdExport>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmCmdExport>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmCmdExport>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmCmdExport>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdExport>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmCmdExport>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdExport>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTCmdExport", {InstanceMethod("getKind", &ImmIdTCmdExport::getKind),
                                                                                                                          InstanceMethod("is", &ImmIdTCmdExport::is),
                                                                                                                          InstanceMethod("getNodeIndex", &ImmIdTCmdExport::getNodeIndex),
                                                                                                                          InstanceMethod("getReadableId", &ImmIdTCmdExport::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTCmdExport> {
  using type = org::imm::ImmIdT<org::imm::ImmCmdExport>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmCmdExport>> {
  using type = ImmIdTCmdExport;
};

struct ImmIdTCall : public SharedPtrWrapBase<ImmIdTCall, org::imm::ImmIdT<org::imm::ImmCall>> {
  using SharedPtrWrapBase<ImmIdTCall, org::imm::ImmIdT<org::imm::ImmCall>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmCall>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCall>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmCall>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmCall>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmCall>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCall>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmCall>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCall>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTCall", {InstanceMethod("getKind", &ImmIdTCall::getKind),
                                                                                                                     InstanceMethod("is", &ImmIdTCall::is),
                                                                                                                     InstanceMethod("getNodeIndex", &ImmIdTCall::getNodeIndex),
                                                                                                                     InstanceMethod("getReadableId", &ImmIdTCall::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTCall> {
  using type = org::imm::ImmIdT<org::imm::ImmCall>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmCall>> {
  using type = ImmIdTCall;
};

struct ImmIdTList : public SharedPtrWrapBase<ImmIdTList, org::imm::ImmIdT<org::imm::ImmList>> {
  using SharedPtrWrapBase<ImmIdTList, org::imm::ImmIdT<org::imm::ImmList>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmList>::*)() const>(&org::imm::ImmIdT<org::imm::ImmList>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmList>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmList>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmList>::*)() const>(&org::imm::ImmIdT<org::imm::ImmList>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmList>::*)() const>(&org::imm::ImmIdT<org::imm::ImmList>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTList", {InstanceMethod("getKind", &ImmIdTList::getKind),
                                                                                                                     InstanceMethod("is", &ImmIdTList::is),
                                                                                                                     InstanceMethod("getNodeIndex", &ImmIdTList::getNodeIndex),
                                                                                                                     InstanceMethod("getReadableId", &ImmIdTList::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTList> {
  using type = org::imm::ImmIdT<org::imm::ImmList>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmList>> {
  using type = ImmIdTList;
};

struct ImmIdTListItem : public SharedPtrWrapBase<ImmIdTListItem, org::imm::ImmIdT<org::imm::ImmListItem>> {
  using SharedPtrWrapBase<ImmIdTListItem, org::imm::ImmIdT<org::imm::ImmListItem>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmListItem>::*)() const>(&org::imm::ImmIdT<org::imm::ImmListItem>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmListItem>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmListItem>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmListItem>::*)() const>(&org::imm::ImmIdT<org::imm::ImmListItem>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmListItem>::*)() const>(&org::imm::ImmIdT<org::imm::ImmListItem>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTListItem", {InstanceMethod("getKind", &ImmIdTListItem::getKind),
                                                                                                                         InstanceMethod("is", &ImmIdTListItem::is),
                                                                                                                         InstanceMethod("getNodeIndex", &ImmIdTListItem::getNodeIndex),
                                                                                                                         InstanceMethod("getReadableId", &ImmIdTListItem::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTListItem> {
  using type = org::imm::ImmIdT<org::imm::ImmListItem>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmListItem>> {
  using type = ImmIdTListItem;
};

struct ImmIdTDocumentOptions : public SharedPtrWrapBase<ImmIdTDocumentOptions, org::imm::ImmIdT<org::imm::ImmDocumentOptions>> {
  using SharedPtrWrapBase<ImmIdTDocumentOptions, org::imm::ImmIdT<org::imm::ImmDocumentOptions>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmDocumentOptions>::*)() const>(&org::imm::ImmIdT<org::imm::ImmDocumentOptions>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmDocumentOptions>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmDocumentOptions>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmDocumentOptions>::*)() const>(&org::imm::ImmIdT<org::imm::ImmDocumentOptions>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmDocumentOptions>::*)() const>(&org::imm::ImmIdT<org::imm::ImmDocumentOptions>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTDocumentOptions", {InstanceMethod("getKind", &ImmIdTDocumentOptions::getKind),
                                                                                                                                InstanceMethod("is", &ImmIdTDocumentOptions::is),
                                                                                                                                InstanceMethod("getNodeIndex", &ImmIdTDocumentOptions::getNodeIndex),
                                                                                                                                InstanceMethod("getReadableId", &ImmIdTDocumentOptions::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTDocumentOptions> {
  using type = org::imm::ImmIdT<org::imm::ImmDocumentOptions>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmDocumentOptions>> {
  using type = ImmIdTDocumentOptions;
};

struct ImmIdTDocumentFragment : public SharedPtrWrapBase<ImmIdTDocumentFragment, org::imm::ImmIdT<org::imm::ImmDocumentFragment>> {
  using SharedPtrWrapBase<ImmIdTDocumentFragment, org::imm::ImmIdT<org::imm::ImmDocumentFragment>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmDocumentFragment>::*)() const>(&org::imm::ImmIdT<org::imm::ImmDocumentFragment>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmDocumentFragment>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmDocumentFragment>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmDocumentFragment>::*)() const>(&org::imm::ImmIdT<org::imm::ImmDocumentFragment>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmDocumentFragment>::*)() const>(&org::imm::ImmIdT<org::imm::ImmDocumentFragment>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTDocumentFragment", {InstanceMethod("getKind", &ImmIdTDocumentFragment::getKind),
                                                                                                                                 InstanceMethod("is", &ImmIdTDocumentFragment::is),
                                                                                                                                 InstanceMethod("getNodeIndex", &ImmIdTDocumentFragment::getNodeIndex),
                                                                                                                                 InstanceMethod("getReadableId", &ImmIdTDocumentFragment::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTDocumentFragment> {
  using type = org::imm::ImmIdT<org::imm::ImmDocumentFragment>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmDocumentFragment>> {
  using type = ImmIdTDocumentFragment;
};

struct ImmIdTCriticMarkup : public SharedPtrWrapBase<ImmIdTCriticMarkup, org::imm::ImmIdT<org::imm::ImmCriticMarkup>> {
  using SharedPtrWrapBase<ImmIdTCriticMarkup, org::imm::ImmIdT<org::imm::ImmCriticMarkup>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmCriticMarkup>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCriticMarkup>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmCriticMarkup>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmCriticMarkup>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmCriticMarkup>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCriticMarkup>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmCriticMarkup>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCriticMarkup>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTCriticMarkup", {InstanceMethod("getKind", &ImmIdTCriticMarkup::getKind),
                                                                                                                             InstanceMethod("is", &ImmIdTCriticMarkup::is),
                                                                                                                             InstanceMethod("getNodeIndex", &ImmIdTCriticMarkup::getNodeIndex),
                                                                                                                             InstanceMethod("getReadableId", &ImmIdTCriticMarkup::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTCriticMarkup> {
  using type = org::imm::ImmIdT<org::imm::ImmCriticMarkup>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmCriticMarkup>> {
  using type = ImmIdTCriticMarkup;
};

struct ImmIdTDocument : public SharedPtrWrapBase<ImmIdTDocument, org::imm::ImmIdT<org::imm::ImmDocument>> {
  using SharedPtrWrapBase<ImmIdTDocument, org::imm::ImmIdT<org::imm::ImmDocument>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmDocument>::*)() const>(&org::imm::ImmIdT<org::imm::ImmDocument>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmDocument>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmDocument>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmDocument>::*)() const>(&org::imm::ImmIdT<org::imm::ImmDocument>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmDocument>::*)() const>(&org::imm::ImmIdT<org::imm::ImmDocument>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTDocument", {InstanceMethod("getKind", &ImmIdTDocument::getKind),
                                                                                                                         InstanceMethod("is", &ImmIdTDocument::is),
                                                                                                                         InstanceMethod("getNodeIndex", &ImmIdTDocument::getNodeIndex),
                                                                                                                         InstanceMethod("getReadableId", &ImmIdTDocument::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTDocument> {
  using type = org::imm::ImmIdT<org::imm::ImmDocument>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmDocument>> {
  using type = ImmIdTDocument;
};

struct ImmIdTFileTarget : public SharedPtrWrapBase<ImmIdTFileTarget, org::imm::ImmIdT<org::imm::ImmFileTarget>> {
  using SharedPtrWrapBase<ImmIdTFileTarget, org::imm::ImmIdT<org::imm::ImmFileTarget>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmFileTarget>::*)() const>(&org::imm::ImmIdT<org::imm::ImmFileTarget>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmFileTarget>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmFileTarget>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmFileTarget>::*)() const>(&org::imm::ImmIdT<org::imm::ImmFileTarget>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmFileTarget>::*)() const>(&org::imm::ImmIdT<org::imm::ImmFileTarget>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTFileTarget", {InstanceMethod("getKind", &ImmIdTFileTarget::getKind),
                                                                                                                           InstanceMethod("is", &ImmIdTFileTarget::is),
                                                                                                                           InstanceMethod("getNodeIndex", &ImmIdTFileTarget::getNodeIndex),
                                                                                                                           InstanceMethod("getReadableId", &ImmIdTFileTarget::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTFileTarget> {
  using type = org::imm::ImmIdT<org::imm::ImmFileTarget>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmFileTarget>> {
  using type = ImmIdTFileTarget;
};

struct ImmIdTTextSeparator : public SharedPtrWrapBase<ImmIdTTextSeparator, org::imm::ImmIdT<org::imm::ImmTextSeparator>> {
  using SharedPtrWrapBase<ImmIdTTextSeparator, org::imm::ImmIdT<org::imm::ImmTextSeparator>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmTextSeparator>::*)() const>(&org::imm::ImmIdT<org::imm::ImmTextSeparator>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmTextSeparator>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmTextSeparator>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmTextSeparator>::*)() const>(&org::imm::ImmIdT<org::imm::ImmTextSeparator>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmTextSeparator>::*)() const>(&org::imm::ImmIdT<org::imm::ImmTextSeparator>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTTextSeparator", {InstanceMethod("getKind", &ImmIdTTextSeparator::getKind),
                                                                                                                              InstanceMethod("is", &ImmIdTTextSeparator::is),
                                                                                                                              InstanceMethod("getNodeIndex", &ImmIdTTextSeparator::getNodeIndex),
                                                                                                                              InstanceMethod("getReadableId", &ImmIdTTextSeparator::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTTextSeparator> {
  using type = org::imm::ImmIdT<org::imm::ImmTextSeparator>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmTextSeparator>> {
  using type = ImmIdTTextSeparator;
};

struct ImmIdTDocumentGroup : public SharedPtrWrapBase<ImmIdTDocumentGroup, org::imm::ImmIdT<org::imm::ImmDocumentGroup>> {
  using SharedPtrWrapBase<ImmIdTDocumentGroup, org::imm::ImmIdT<org::imm::ImmDocumentGroup>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmDocumentGroup>::*)() const>(&org::imm::ImmIdT<org::imm::ImmDocumentGroup>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmDocumentGroup>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmDocumentGroup>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmDocumentGroup>::*)() const>(&org::imm::ImmIdT<org::imm::ImmDocumentGroup>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmDocumentGroup>::*)() const>(&org::imm::ImmIdT<org::imm::ImmDocumentGroup>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTDocumentGroup", {InstanceMethod("getKind", &ImmIdTDocumentGroup::getKind),
                                                                                                                              InstanceMethod("is", &ImmIdTDocumentGroup::is),
                                                                                                                              InstanceMethod("getNodeIndex", &ImmIdTDocumentGroup::getNodeIndex),
                                                                                                                              InstanceMethod("getReadableId", &ImmIdTDocumentGroup::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTDocumentGroup> {
  using type = org::imm::ImmIdT<org::imm::ImmDocumentGroup>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmDocumentGroup>> {
  using type = ImmIdTDocumentGroup;
};

struct ImmIdTFile : public SharedPtrWrapBase<ImmIdTFile, org::imm::ImmIdT<org::imm::ImmFile>> {
  using SharedPtrWrapBase<ImmIdTFile, org::imm::ImmIdT<org::imm::ImmFile>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmFile>::*)() const>(&org::imm::ImmIdT<org::imm::ImmFile>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmFile>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmFile>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmFile>::*)() const>(&org::imm::ImmIdT<org::imm::ImmFile>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmFile>::*)() const>(&org::imm::ImmIdT<org::imm::ImmFile>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTFile", {InstanceMethod("getKind", &ImmIdTFile::getKind),
                                                                                                                     InstanceMethod("is", &ImmIdTFile::is),
                                                                                                                     InstanceMethod("getNodeIndex", &ImmIdTFile::getNodeIndex),
                                                                                                                     InstanceMethod("getReadableId", &ImmIdTFile::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTFile> {
  using type = org::imm::ImmIdT<org::imm::ImmFile>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmFile>> {
  using type = ImmIdTFile;
};

struct ImmIdTDirectory : public SharedPtrWrapBase<ImmIdTDirectory, org::imm::ImmIdT<org::imm::ImmDirectory>> {
  using SharedPtrWrapBase<ImmIdTDirectory, org::imm::ImmIdT<org::imm::ImmDirectory>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmDirectory>::*)() const>(&org::imm::ImmIdT<org::imm::ImmDirectory>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmDirectory>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmDirectory>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmDirectory>::*)() const>(&org::imm::ImmIdT<org::imm::ImmDirectory>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmDirectory>::*)() const>(&org::imm::ImmIdT<org::imm::ImmDirectory>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTDirectory", {InstanceMethod("getKind", &ImmIdTDirectory::getKind),
                                                                                                                          InstanceMethod("is", &ImmIdTDirectory::is),
                                                                                                                          InstanceMethod("getNodeIndex", &ImmIdTDirectory::getNodeIndex),
                                                                                                                          InstanceMethod("getReadableId", &ImmIdTDirectory::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTDirectory> {
  using type = org::imm::ImmIdT<org::imm::ImmDirectory>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmDirectory>> {
  using type = ImmIdTDirectory;
};

struct ImmIdTSymlink : public SharedPtrWrapBase<ImmIdTSymlink, org::imm::ImmIdT<org::imm::ImmSymlink>> {
  using SharedPtrWrapBase<ImmIdTSymlink, org::imm::ImmIdT<org::imm::ImmSymlink>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmSymlink>::*)() const>(&org::imm::ImmIdT<org::imm::ImmSymlink>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmSymlink>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmSymlink>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmSymlink>::*)() const>(&org::imm::ImmIdT<org::imm::ImmSymlink>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmSymlink>::*)() const>(&org::imm::ImmIdT<org::imm::ImmSymlink>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTSymlink", {InstanceMethod("getKind", &ImmIdTSymlink::getKind),
                                                                                                                        InstanceMethod("is", &ImmIdTSymlink::is),
                                                                                                                        InstanceMethod("getNodeIndex", &ImmIdTSymlink::getNodeIndex),
                                                                                                                        InstanceMethod("getReadableId", &ImmIdTSymlink::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTSymlink> {
  using type = org::imm::ImmIdT<org::imm::ImmSymlink>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmSymlink>> {
  using type = ImmIdTSymlink;
};

struct ImmIdTCmdInclude : public SharedPtrWrapBase<ImmIdTCmdInclude, org::imm::ImmIdT<org::imm::ImmCmdInclude>> {
  using SharedPtrWrapBase<ImmIdTCmdInclude, org::imm::ImmIdT<org::imm::ImmCmdInclude>>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmIdT<org::imm::ImmCmdInclude>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdInclude>::getKind),
                                        std::make_tuple()));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmIdT<org::imm::ImmCmdInclude>::*)(OrgSemKind) const>(&org::imm::ImmIdT<org::imm::ImmCmdInclude>::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getNodeIndex(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmId::NodeIdxT(org::imm::ImmIdT<org::imm::ImmCmdInclude>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdInclude>::getNodeIndex),
                                        std::make_tuple()));
  }
  Napi::Value getReadableId(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::string(org::imm::ImmIdT<org::imm::ImmCmdInclude>::*)() const>(&org::imm::ImmIdT<org::imm::ImmCmdInclude>::getReadableId),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmIdTCmdInclude", {InstanceMethod("getKind", &ImmIdTCmdInclude::getKind),
                                                                                                                           InstanceMethod("is", &ImmIdTCmdInclude::is),
                                                                                                                           InstanceMethod("getNodeIndex", &ImmIdTCmdInclude::getNodeIndex),
                                                                                                                           InstanceMethod("getReadableId", &ImmIdTCmdInclude::getReadableId)}); }
};

template <>
struct js_to_org_type<ImmIdTCmdInclude> {
  using type = org::imm::ImmIdT<org::imm::ImmCmdInclude>;
};

template <>
struct org_to_js_type<org::imm::ImmIdT<org::imm::ImmCmdInclude>> {
  using type = ImmIdTCmdInclude;
};

struct ImmNoneValueJs : public SharedPtrWrapBase<ImmNoneValueJs, org::imm::ImmNoneValue> {
  using SharedPtrWrapBase<ImmNoneValueJs, org::imm::ImmNoneValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmNoneValueJs", {}); }
};

template <>
struct js_to_org_type<ImmNoneValueJs> {
  using type = org::imm::ImmNoneValue;
};

template <>
struct org_to_js_type<org::imm::ImmNoneValue> {
  using type = ImmNoneValueJs;
};

struct ImmErrorItemValueJs : public SharedPtrWrapBase<ImmErrorItemValueJs, org::imm::ImmErrorItemValue> {
  using SharedPtrWrapBase<ImmErrorItemValueJs, org::imm::ImmErrorItemValue>::SharedPtrWrapBase;
  Napi::Value getMessage(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmErrorItemValue::*)() const>(&org::imm::ImmErrorItemValue::getMessage),
                                        std::make_tuple()));
  }
  Napi::Value getFunction(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmErrorItemValue::*)() const>(&org::imm::ImmErrorItemValue::getFunction),
                                        std::make_tuple()));
  }
  Napi::Value getLine(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<int>> const&(org::imm::ImmErrorItemValue::*)() const>(&org::imm::ImmErrorItemValue::getLine),
                                        std::make_tuple()));
  }
  Napi::Value setMessage(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmErrorItemValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmErrorItemValue::setMessage),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setFunction(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmErrorItemValue::*)(immer::box<std::optional<hstd::Str>> const&)>(&org::imm::ImmErrorItemValue::setFunction),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::Str>>>{"value"})));
  }
  Napi::Value setLine(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmErrorItemValue::*)(immer::box<std::optional<int>> const&)>(&org::imm::ImmErrorItemValue::setLine),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<int>>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmErrorItemValueJs", {InstanceMethod("getMessage", &ImmErrorItemValueJs::getMessage),
                                                                                                                              InstanceMethod("getFunction", &ImmErrorItemValueJs::getFunction),
                                                                                                                              InstanceMethod("getLine", &ImmErrorItemValueJs::getLine),
                                                                                                                              InstanceMethod("setMessage", &ImmErrorItemValueJs::setMessage),
                                                                                                                              InstanceMethod("setFunction", &ImmErrorItemValueJs::setFunction),
                                                                                                                              InstanceMethod("setLine", &ImmErrorItemValueJs::setLine)}); }
};

template <>
struct js_to_org_type<ImmErrorItemValueJs> {
  using type = org::imm::ImmErrorItemValue;
};

template <>
struct org_to_js_type<org::imm::ImmErrorItemValue> {
  using type = ImmErrorItemValueJs;
};

struct ImmErrorGroupValueJs : public SharedPtrWrapBase<ImmErrorGroupValueJs, org::imm::ImmErrorGroupValue> {
  using SharedPtrWrapBase<ImmErrorGroupValueJs, org::imm::ImmErrorGroupValue>::SharedPtrWrapBase;
  Napi::Value getDiagnostics(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmErrorItem>> const&(org::imm::ImmErrorGroupValue::*)() const>(&org::imm::ImmErrorGroupValue::getDiagnostics),
                                        std::make_tuple()));
  }
  Napi::Value getFunction(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmErrorGroupValue::*)() const>(&org::imm::ImmErrorGroupValue::getFunction),
                                        std::make_tuple()));
  }
  Napi::Value getLine(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<int>> const&(org::imm::ImmErrorGroupValue::*)() const>(&org::imm::ImmErrorGroupValue::getLine),
                                        std::make_tuple()));
  }
  Napi::Value setDiagnostics(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmErrorGroupValue::*)(immer::flex_vector<org::imm::ImmIdT<org::imm::ImmErrorItem>> const&)>(&org::imm::ImmErrorGroupValue::setDiagnostics),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmErrorItem>>>{"value"})));
  }
  Napi::Value setFunction(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmErrorGroupValue::*)(immer::box<std::optional<hstd::Str>> const&)>(&org::imm::ImmErrorGroupValue::setFunction),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::Str>>>{"value"})));
  }
  Napi::Value setLine(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmErrorGroupValue::*)(immer::box<std::optional<int>> const&)>(&org::imm::ImmErrorGroupValue::setLine),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<int>>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmErrorGroupValueJs", {InstanceMethod("getDiagnostics", &ImmErrorGroupValueJs::getDiagnostics),
                                                                                                                               InstanceMethod("getFunction", &ImmErrorGroupValueJs::getFunction),
                                                                                                                               InstanceMethod("getLine", &ImmErrorGroupValueJs::getLine),
                                                                                                                               InstanceMethod("setDiagnostics", &ImmErrorGroupValueJs::setDiagnostics),
                                                                                                                               InstanceMethod("setFunction", &ImmErrorGroupValueJs::setFunction),
                                                                                                                               InstanceMethod("setLine", &ImmErrorGroupValueJs::setLine)}); }
};

template <>
struct js_to_org_type<ImmErrorGroupValueJs> {
  using type = org::imm::ImmErrorGroupValue;
};

template <>
struct org_to_js_type<org::imm::ImmErrorGroupValue> {
  using type = ImmErrorGroupValueJs;
};

struct ImmStmtListValueJs : public SharedPtrWrapBase<ImmStmtListValueJs, org::imm::ImmStmtListValue> {
  using SharedPtrWrapBase<ImmStmtListValueJs, org::imm::ImmStmtListValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmStmtListValueJs", {}); }
};

template <>
struct js_to_org_type<ImmStmtListValueJs> {
  using type = org::imm::ImmStmtListValue;
};

template <>
struct org_to_js_type<org::imm::ImmStmtListValue> {
  using type = ImmStmtListValueJs;
};

struct ImmEmptyValueJs : public SharedPtrWrapBase<ImmEmptyValueJs, org::imm::ImmEmptyValue> {
  using SharedPtrWrapBase<ImmEmptyValueJs, org::imm::ImmEmptyValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmEmptyValueJs", {}); }
};

template <>
struct js_to_org_type<ImmEmptyValueJs> {
  using type = org::imm::ImmEmptyValue;
};

template <>
struct org_to_js_type<org::imm::ImmEmptyValue> {
  using type = ImmEmptyValueJs;
};

struct ImmCmdCaptionValueJs : public SharedPtrWrapBase<ImmCmdCaptionValueJs, org::imm::ImmCmdCaptionValue> {
  using SharedPtrWrapBase<ImmCmdCaptionValueJs, org::imm::ImmCmdCaptionValue>::SharedPtrWrapBase;
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmIdT<org::imm::ImmParagraph> const&(org::imm::ImmCmdCaptionValue::*)() const>(&org::imm::ImmCmdCaptionValue::getText),
                                        std::make_tuple()));
  }
  Napi::Value setText(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdCaptionValue::*)(org::imm::ImmIdT<org::imm::ImmParagraph> const&)>(&org::imm::ImmCmdCaptionValue::setText),
                                   std::make_tuple(CxxArgSpec<org::imm::ImmIdT<org::imm::ImmParagraph>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdCaptionValueJs", {InstanceMethod("getText", &ImmCmdCaptionValueJs::getText),
                                                                                                                               InstanceMethod("setText", &ImmCmdCaptionValueJs::setText)}); }
};

template <>
struct js_to_org_type<ImmCmdCaptionValueJs> {
  using type = org::imm::ImmCmdCaptionValue;
};

template <>
struct org_to_js_type<org::imm::ImmCmdCaptionValue> {
  using type = ImmCmdCaptionValueJs;
};

struct ImmCmdColumnsValueJs : public SharedPtrWrapBase<ImmCmdColumnsValueJs, org::imm::ImmCmdColumnsValue> {
  using SharedPtrWrapBase<ImmCmdColumnsValueJs, org::imm::ImmCmdColumnsValue>::SharedPtrWrapBase;
  Napi::Value getView(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::ColumnView const&(org::imm::ImmCmdColumnsValue::*)() const>(&org::imm::ImmCmdColumnsValue::getView),
                                        std::make_tuple()));
  }
  Napi::Value setView(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdColumnsValue::*)(org::sem::ColumnView const&)>(&org::imm::ImmCmdColumnsValue::setView),
                                   std::make_tuple(CxxArgSpec<org::sem::ColumnView>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdColumnsValueJs", {InstanceMethod("getView", &ImmCmdColumnsValueJs::getView),
                                                                                                                               InstanceMethod("setView", &ImmCmdColumnsValueJs::setView)}); }
};

template <>
struct js_to_org_type<ImmCmdColumnsValueJs> {
  using type = org::imm::ImmCmdColumnsValue;
};

template <>
struct org_to_js_type<org::imm::ImmCmdColumnsValue> {
  using type = ImmCmdColumnsValueJs;
};

struct ImmCmdNameValueJs : public SharedPtrWrapBase<ImmCmdNameValueJs, org::imm::ImmCmdNameValue> {
  using SharedPtrWrapBase<ImmCmdNameValueJs, org::imm::ImmCmdNameValue>::SharedPtrWrapBase;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdNameValue::*)() const>(&org::imm::ImmCmdNameValue::getName),
                                        std::make_tuple()));
  }
  Napi::Value setName(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdNameValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmCmdNameValue::setName),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdNameValueJs", {InstanceMethod("getName", &ImmCmdNameValueJs::getName),
                                                                                                                            InstanceMethod("setName", &ImmCmdNameValueJs::setName)}); }
};

template <>
struct js_to_org_type<ImmCmdNameValueJs> {
  using type = org::imm::ImmCmdNameValue;
};

template <>
struct org_to_js_type<org::imm::ImmCmdNameValue> {
  using type = ImmCmdNameValueJs;
};

struct ImmCmdCustomArgsValueJs : public SharedPtrWrapBase<ImmCmdCustomArgsValueJs, org::imm::ImmCmdCustomArgsValue> {
  using SharedPtrWrapBase<ImmCmdCustomArgsValueJs, org::imm::ImmCmdCustomArgsValue>::SharedPtrWrapBase;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdCustomArgsValue::*)() const>(&org::imm::ImmCmdCustomArgsValue::getName),
                                        std::make_tuple()));
  }
  Napi::Value getIsattached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmCmdCustomArgsValue::*)() const>(&org::imm::ImmCmdCustomArgsValue::getIsattached),
                                        std::make_tuple()));
  }
  Napi::Value setName(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdCustomArgsValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmCmdCustomArgsValue::setName),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setIsattached(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdCustomArgsValue::*)(bool const&)>(&org::imm::ImmCmdCustomArgsValue::setIsattached),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdCustomArgsValueJs", {InstanceMethod("getName", &ImmCmdCustomArgsValueJs::getName),
                                                                                                                                  InstanceMethod("getIsattached", &ImmCmdCustomArgsValueJs::getIsattached),
                                                                                                                                  InstanceMethod("setName", &ImmCmdCustomArgsValueJs::setName),
                                                                                                                                  InstanceMethod("setIsattached", &ImmCmdCustomArgsValueJs::setIsattached)}); }
};

template <>
struct js_to_org_type<ImmCmdCustomArgsValueJs> {
  using type = org::imm::ImmCmdCustomArgsValue;
};

template <>
struct org_to_js_type<org::imm::ImmCmdCustomArgsValue> {
  using type = ImmCmdCustomArgsValueJs;
};

struct ImmCmdCustomRawValueJs : public SharedPtrWrapBase<ImmCmdCustomRawValueJs, org::imm::ImmCmdCustomRawValue> {
  using SharedPtrWrapBase<ImmCmdCustomRawValueJs, org::imm::ImmCmdCustomRawValue>::SharedPtrWrapBase;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdCustomRawValue::*)() const>(&org::imm::ImmCmdCustomRawValue::getName),
                                        std::make_tuple()));
  }
  Napi::Value getIsattached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmCmdCustomRawValue::*)() const>(&org::imm::ImmCmdCustomRawValue::getIsattached),
                                        std::make_tuple()));
  }
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdCustomRawValue::*)() const>(&org::imm::ImmCmdCustomRawValue::getText),
                                        std::make_tuple()));
  }
  Napi::Value setName(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdCustomRawValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmCmdCustomRawValue::setName),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setIsattached(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdCustomRawValue::*)(bool const&)>(&org::imm::ImmCmdCustomRawValue::setIsattached),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  Napi::Value setText(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdCustomRawValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmCmdCustomRawValue::setText),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdCustomRawValueJs", {InstanceMethod("getName", &ImmCmdCustomRawValueJs::getName),
                                                                                                                                 InstanceMethod("getIsattached", &ImmCmdCustomRawValueJs::getIsattached),
                                                                                                                                 InstanceMethod("getText", &ImmCmdCustomRawValueJs::getText),
                                                                                                                                 InstanceMethod("setName", &ImmCmdCustomRawValueJs::setName),
                                                                                                                                 InstanceMethod("setIsattached", &ImmCmdCustomRawValueJs::setIsattached),
                                                                                                                                 InstanceMethod("setText", &ImmCmdCustomRawValueJs::setText)}); }
};

template <>
struct js_to_org_type<ImmCmdCustomRawValueJs> {
  using type = org::imm::ImmCmdCustomRawValue;
};

template <>
struct org_to_js_type<org::imm::ImmCmdCustomRawValue> {
  using type = ImmCmdCustomRawValueJs;
};

struct ImmCmdCustomTextValueJs : public SharedPtrWrapBase<ImmCmdCustomTextValueJs, org::imm::ImmCmdCustomTextValue> {
  using SharedPtrWrapBase<ImmCmdCustomTextValueJs, org::imm::ImmCmdCustomTextValue>::SharedPtrWrapBase;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdCustomTextValue::*)() const>(&org::imm::ImmCmdCustomTextValue::getName),
                                        std::make_tuple()));
  }
  Napi::Value getIsattached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmCmdCustomTextValue::*)() const>(&org::imm::ImmCmdCustomTextValue::getIsattached),
                                        std::make_tuple()));
  }
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmIdT<org::imm::ImmParagraph> const&(org::imm::ImmCmdCustomTextValue::*)() const>(&org::imm::ImmCmdCustomTextValue::getText),
                                        std::make_tuple()));
  }
  Napi::Value setName(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdCustomTextValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmCmdCustomTextValue::setName),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setIsattached(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdCustomTextValue::*)(bool const&)>(&org::imm::ImmCmdCustomTextValue::setIsattached),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  Napi::Value setText(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdCustomTextValue::*)(org::imm::ImmIdT<org::imm::ImmParagraph> const&)>(&org::imm::ImmCmdCustomTextValue::setText),
                                   std::make_tuple(CxxArgSpec<org::imm::ImmIdT<org::imm::ImmParagraph>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdCustomTextValueJs", {InstanceMethod("getName", &ImmCmdCustomTextValueJs::getName),
                                                                                                                                  InstanceMethod("getIsattached", &ImmCmdCustomTextValueJs::getIsattached),
                                                                                                                                  InstanceMethod("getText", &ImmCmdCustomTextValueJs::getText),
                                                                                                                                  InstanceMethod("setName", &ImmCmdCustomTextValueJs::setName),
                                                                                                                                  InstanceMethod("setIsattached", &ImmCmdCustomTextValueJs::setIsattached),
                                                                                                                                  InstanceMethod("setText", &ImmCmdCustomTextValueJs::setText)}); }
};

template <>
struct js_to_org_type<ImmCmdCustomTextValueJs> {
  using type = org::imm::ImmCmdCustomTextValue;
};

template <>
struct org_to_js_type<org::imm::ImmCmdCustomTextValue> {
  using type = ImmCmdCustomTextValueJs;
};

struct ImmCmdCallValueJs : public SharedPtrWrapBase<ImmCmdCallValueJs, org::imm::ImmCmdCallValue> {
  using SharedPtrWrapBase<ImmCmdCallValueJs, org::imm::ImmCmdCallValue>::SharedPtrWrapBase;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdCallValue::*)() const>(&org::imm::ImmCmdCallValue::getName),
                                        std::make_tuple()));
  }
  Napi::Value getFilename(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmCmdCallValue::*)() const>(&org::imm::ImmCmdCallValue::getFilename),
                                        std::make_tuple()));
  }
  Napi::Value getInsideheaderattrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrGroup const&(org::imm::ImmCmdCallValue::*)() const>(&org::imm::ImmCmdCallValue::getInsideheaderattrs),
                                        std::make_tuple()));
  }
  Napi::Value getCallattrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrGroup const&(org::imm::ImmCmdCallValue::*)() const>(&org::imm::ImmCmdCallValue::getCallattrs),
                                        std::make_tuple()));
  }
  Napi::Value getEndheaderattrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrGroup const&(org::imm::ImmCmdCallValue::*)() const>(&org::imm::ImmCmdCallValue::getEndheaderattrs),
                                        std::make_tuple()));
  }
  Napi::Value getResult(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>> const&(org::imm::ImmCmdCallValue::*)() const>(&org::imm::ImmCmdCallValue::getResult),
                                        std::make_tuple()));
  }
  Napi::Value setName(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdCallValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmCmdCallValue::setName),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setFilename(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdCallValue::*)(immer::box<std::optional<hstd::Str>> const&)>(&org::imm::ImmCmdCallValue::setFilename),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::Str>>>{"value"})));
  }
  Napi::Value setInsideheaderattrs(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdCallValue::*)(org::sem::AttrGroup const&)>(&org::imm::ImmCmdCallValue::setInsideheaderattrs),
                                   std::make_tuple(CxxArgSpec<org::sem::AttrGroup>{"value"})));
  }
  Napi::Value setCallattrs(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdCallValue::*)(org::sem::AttrGroup const&)>(&org::imm::ImmCmdCallValue::setCallattrs),
                                   std::make_tuple(CxxArgSpec<org::sem::AttrGroup>{"value"})));
  }
  Napi::Value setEndheaderattrs(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdCallValue::*)(org::sem::AttrGroup const&)>(&org::imm::ImmCmdCallValue::setEndheaderattrs),
                                   std::make_tuple(CxxArgSpec<org::sem::AttrGroup>{"value"})));
  }
  Napi::Value setResult(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdCallValue::*)(immer::flex_vector<org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>> const&)>(&org::imm::ImmCmdCallValue::setResult),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdCallValueJs", {InstanceMethod("getName", &ImmCmdCallValueJs::getName),
                                                                                                                            InstanceMethod("getFilename", &ImmCmdCallValueJs::getFilename),
                                                                                                                            InstanceMethod("getInsideheaderattrs", &ImmCmdCallValueJs::getInsideheaderattrs),
                                                                                                                            InstanceMethod("getCallattrs", &ImmCmdCallValueJs::getCallattrs),
                                                                                                                            InstanceMethod("getEndheaderattrs", &ImmCmdCallValueJs::getEndheaderattrs),
                                                                                                                            InstanceMethod("getResult", &ImmCmdCallValueJs::getResult),
                                                                                                                            InstanceMethod("setName", &ImmCmdCallValueJs::setName),
                                                                                                                            InstanceMethod("setFilename", &ImmCmdCallValueJs::setFilename),
                                                                                                                            InstanceMethod("setInsideheaderattrs", &ImmCmdCallValueJs::setInsideheaderattrs),
                                                                                                                            InstanceMethod("setCallattrs", &ImmCmdCallValueJs::setCallattrs),
                                                                                                                            InstanceMethod("setEndheaderattrs", &ImmCmdCallValueJs::setEndheaderattrs),
                                                                                                                            InstanceMethod("setResult", &ImmCmdCallValueJs::setResult)}); }
};

template <>
struct js_to_org_type<ImmCmdCallValueJs> {
  using type = org::imm::ImmCmdCallValue;
};

template <>
struct org_to_js_type<org::imm::ImmCmdCallValue> {
  using type = ImmCmdCallValueJs;
};

struct ImmCmdTblfmValueJs : public SharedPtrWrapBase<ImmCmdTblfmValueJs, org::imm::ImmCmdTblfmValue> {
  using SharedPtrWrapBase<ImmCmdTblfmValueJs, org::imm::ImmCmdTblfmValue>::SharedPtrWrapBase;
  Napi::Value getExpr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::Tblfm const&(org::imm::ImmCmdTblfmValue::*)() const>(&org::imm::ImmCmdTblfmValue::getExpr),
                                        std::make_tuple()));
  }
  Napi::Value setExpr(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdTblfmValue::*)(org::sem::Tblfm const&)>(&org::imm::ImmCmdTblfmValue::setExpr),
                                   std::make_tuple(CxxArgSpec<org::sem::Tblfm>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdTblfmValueJs", {InstanceMethod("getExpr", &ImmCmdTblfmValueJs::getExpr),
                                                                                                                             InstanceMethod("setExpr", &ImmCmdTblfmValueJs::setExpr)}); }
};

template <>
struct js_to_org_type<ImmCmdTblfmValueJs> {
  using type = org::imm::ImmCmdTblfmValue;
};

template <>
struct org_to_js_type<org::imm::ImmCmdTblfmValue> {
  using type = ImmCmdTblfmValueJs;
};

struct ImmHashTagValueJs : public SharedPtrWrapBase<ImmHashTagValueJs, org::imm::ImmHashTagValue> {
  using SharedPtrWrapBase<ImmHashTagValueJs, org::imm::ImmHashTagValue>::SharedPtrWrapBase;
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::HashTagText const&(org::imm::ImmHashTagValue::*)() const>(&org::imm::ImmHashTagValue::getText),
                                        std::make_tuple()));
  }
  Napi::Value setText(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmHashTagValue::*)(org::sem::HashTagText const&)>(&org::imm::ImmHashTagValue::setText),
                                   std::make_tuple(CxxArgSpec<org::sem::HashTagText>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmHashTagValueJs", {InstanceMethod("getText", &ImmHashTagValueJs::getText),
                                                                                                                            InstanceMethod("setText", &ImmHashTagValueJs::setText)}); }
};

template <>
struct js_to_org_type<ImmHashTagValueJs> {
  using type = org::imm::ImmHashTagValue;
};

template <>
struct org_to_js_type<org::imm::ImmHashTagValue> {
  using type = ImmHashTagValueJs;
};

struct ImmInlineFootnoteValueJs : public SharedPtrWrapBase<ImmInlineFootnoteValueJs, org::imm::ImmInlineFootnoteValue> {
  using SharedPtrWrapBase<ImmInlineFootnoteValueJs, org::imm::ImmInlineFootnoteValue>::SharedPtrWrapBase;
  Napi::Value getTag(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmInlineFootnoteValue::*)() const>(&org::imm::ImmInlineFootnoteValue::getTag),
                                        std::make_tuple()));
  }
  Napi::Value getDefinition(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmOrg>>> const&(org::imm::ImmInlineFootnoteValue::*)() const>(&org::imm::ImmInlineFootnoteValue::getDefinition),
                                        std::make_tuple()));
  }
  Napi::Value setTag(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmInlineFootnoteValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmInlineFootnoteValue::setTag),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setDefinition(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmInlineFootnoteValue::*)(immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmOrg>>> const&)>(&org::imm::ImmInlineFootnoteValue::setDefinition),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmOrg>>>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmInlineFootnoteValueJs", {InstanceMethod("getTag", &ImmInlineFootnoteValueJs::getTag),
                                                                                                                                   InstanceMethod("getDefinition", &ImmInlineFootnoteValueJs::getDefinition),
                                                                                                                                   InstanceMethod("setTag", &ImmInlineFootnoteValueJs::setTag),
                                                                                                                                   InstanceMethod("setDefinition", &ImmInlineFootnoteValueJs::setDefinition)}); }
};

template <>
struct js_to_org_type<ImmInlineFootnoteValueJs> {
  using type = org::imm::ImmInlineFootnoteValue;
};

template <>
struct org_to_js_type<org::imm::ImmInlineFootnoteValue> {
  using type = ImmInlineFootnoteValueJs;
};

struct ImmInlineExportValueJs : public SharedPtrWrapBase<ImmInlineExportValueJs, org::imm::ImmInlineExportValue> {
  using SharedPtrWrapBase<ImmInlineExportValueJs, org::imm::ImmInlineExportValue>::SharedPtrWrapBase;
  Napi::Value getExporter(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmInlineExportValue::*)() const>(&org::imm::ImmInlineExportValue::getExporter),
                                        std::make_tuple()));
  }
  Napi::Value getContent(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmInlineExportValue::*)() const>(&org::imm::ImmInlineExportValue::getContent),
                                        std::make_tuple()));
  }
  Napi::Value setExporter(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmInlineExportValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmInlineExportValue::setExporter),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setContent(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmInlineExportValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmInlineExportValue::setContent),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmInlineExportValueJs", {InstanceMethod("getExporter", &ImmInlineExportValueJs::getExporter),
                                                                                                                                 InstanceMethod("getContent", &ImmInlineExportValueJs::getContent),
                                                                                                                                 InstanceMethod("setExporter", &ImmInlineExportValueJs::setExporter),
                                                                                                                                 InstanceMethod("setContent", &ImmInlineExportValueJs::setContent)}); }
};

template <>
struct js_to_org_type<ImmInlineExportValueJs> {
  using type = org::imm::ImmInlineExportValue;
};

template <>
struct org_to_js_type<org::imm::ImmInlineExportValue> {
  using type = ImmInlineExportValueJs;
};

struct ImmTimeValueJs : public SharedPtrWrapBase<ImmTimeValueJs, org::imm::ImmTimeValue> {
  using SharedPtrWrapBase<ImmTimeValueJs, org::imm::ImmTimeValue>::SharedPtrWrapBase;
  Napi::Value getIsactive(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmTimeValue::*)() const>(&org::imm::ImmTimeValue::getIsactive),
                                        std::make_tuple()));
  }
  Napi::Value getTime(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmTime::TimeVariant const&(org::imm::ImmTimeValue::*)() const>(&org::imm::ImmTimeValue::getTime),
                                        std::make_tuple()));
  }
  Napi::Value setIsactive(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmTimeValue::*)(bool const&)>(&org::imm::ImmTimeValue::setIsactive),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  Napi::Value setTime(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmTimeValue::*)(org::imm::ImmTime::TimeVariant const&)>(&org::imm::ImmTimeValue::setTime),
                                   std::make_tuple(CxxArgSpec<org::imm::ImmTime::TimeVariant>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmTimeValueJs", {InstanceMethod("getIsactive", &ImmTimeValueJs::getIsactive),
                                                                                                                         InstanceMethod("getTime", &ImmTimeValueJs::getTime),
                                                                                                                         InstanceMethod("setIsactive", &ImmTimeValueJs::setIsactive),
                                                                                                                         InstanceMethod("setTime", &ImmTimeValueJs::setTime)}); }
};

template <>
struct js_to_org_type<ImmTimeValueJs> {
  using type = org::imm::ImmTimeValue;
};

template <>
struct org_to_js_type<org::imm::ImmTimeValue> {
  using type = ImmTimeValueJs;
};

struct ImmTimeRangeValueJs : public SharedPtrWrapBase<ImmTimeRangeValueJs, org::imm::ImmTimeRangeValue> {
  using SharedPtrWrapBase<ImmTimeRangeValueJs, org::imm::ImmTimeRangeValue>::SharedPtrWrapBase;
  Napi::Value getFrom(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmIdT<org::imm::ImmTime> const&(org::imm::ImmTimeRangeValue::*)() const>(&org::imm::ImmTimeRangeValue::getFrom),
                                        std::make_tuple()));
  }
  Napi::Value getTo(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmIdT<org::imm::ImmTime> const&(org::imm::ImmTimeRangeValue::*)() const>(&org::imm::ImmTimeRangeValue::getTo),
                                        std::make_tuple()));
  }
  Napi::Value setFrom(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmTimeRangeValue::*)(org::imm::ImmIdT<org::imm::ImmTime> const&)>(&org::imm::ImmTimeRangeValue::setFrom),
                                   std::make_tuple(CxxArgSpec<org::imm::ImmIdT<org::imm::ImmTime>>{"value"})));
  }
  Napi::Value setTo(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmTimeRangeValue::*)(org::imm::ImmIdT<org::imm::ImmTime> const&)>(&org::imm::ImmTimeRangeValue::setTo),
                                   std::make_tuple(CxxArgSpec<org::imm::ImmIdT<org::imm::ImmTime>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmTimeRangeValueJs", {InstanceMethod("getFrom", &ImmTimeRangeValueJs::getFrom),
                                                                                                                              InstanceMethod("getTo", &ImmTimeRangeValueJs::getTo),
                                                                                                                              InstanceMethod("setFrom", &ImmTimeRangeValueJs::setFrom),
                                                                                                                              InstanceMethod("setTo", &ImmTimeRangeValueJs::setTo)}); }
};

template <>
struct js_to_org_type<ImmTimeRangeValueJs> {
  using type = org::imm::ImmTimeRangeValue;
};

template <>
struct org_to_js_type<org::imm::ImmTimeRangeValue> {
  using type = ImmTimeRangeValueJs;
};

struct ImmMacroValueJs : public SharedPtrWrapBase<ImmMacroValueJs, org::imm::ImmMacroValue> {
  using SharedPtrWrapBase<ImmMacroValueJs, org::imm::ImmMacroValue>::SharedPtrWrapBase;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmMacroValue::*)() const>(&org::imm::ImmMacroValue::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrGroup const&(org::imm::ImmMacroValue::*)() const>(&org::imm::ImmMacroValue::getAttrs),
                                        std::make_tuple()));
  }
  Napi::Value setName(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmMacroValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmMacroValue::setName),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setAttrs(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmMacroValue::*)(org::sem::AttrGroup const&)>(&org::imm::ImmMacroValue::setAttrs),
                                   std::make_tuple(CxxArgSpec<org::sem::AttrGroup>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmMacroValueJs", {InstanceMethod("getName", &ImmMacroValueJs::getName),
                                                                                                                          InstanceMethod("getAttrs", &ImmMacroValueJs::getAttrs),
                                                                                                                          InstanceMethod("setName", &ImmMacroValueJs::setName),
                                                                                                                          InstanceMethod("setAttrs", &ImmMacroValueJs::setAttrs)}); }
};

template <>
struct js_to_org_type<ImmMacroValueJs> {
  using type = org::imm::ImmMacroValue;
};

template <>
struct org_to_js_type<org::imm::ImmMacroValue> {
  using type = ImmMacroValueJs;
};

struct ImmSymbolValueJs : public SharedPtrWrapBase<ImmSymbolValueJs, org::imm::ImmSymbolValue> {
  using SharedPtrWrapBase<ImmSymbolValueJs, org::imm::ImmSymbolValue>::SharedPtrWrapBase;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmSymbolValue::*)() const>(&org::imm::ImmSymbolValue::getName),
                                        std::make_tuple()));
  }
  Napi::Value getParameters(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmSymbol::Param> const&(org::imm::ImmSymbolValue::*)() const>(&org::imm::ImmSymbolValue::getParameters),
                                        std::make_tuple()));
  }
  Napi::Value getPositional(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmOrg>> const&(org::imm::ImmSymbolValue::*)() const>(&org::imm::ImmSymbolValue::getPositional),
                                        std::make_tuple()));
  }
  Napi::Value setName(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSymbolValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmSymbolValue::setName),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setParameters(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSymbolValue::*)(immer::flex_vector<org::imm::ImmSymbol::Param> const&)>(&org::imm::ImmSymbolValue::setParameters),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<org::imm::ImmSymbol::Param>>{"value"})));
  }
  Napi::Value setPositional(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSymbolValue::*)(immer::flex_vector<org::imm::ImmIdT<org::imm::ImmOrg>> const&)>(&org::imm::ImmSymbolValue::setPositional),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmOrg>>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmSymbolValueJs", {InstanceMethod("getName", &ImmSymbolValueJs::getName),
                                                                                                                           InstanceMethod("getParameters", &ImmSymbolValueJs::getParameters),
                                                                                                                           InstanceMethod("getPositional", &ImmSymbolValueJs::getPositional),
                                                                                                                           InstanceMethod("setName", &ImmSymbolValueJs::setName),
                                                                                                                           InstanceMethod("setParameters", &ImmSymbolValueJs::setParameters),
                                                                                                                           InstanceMethod("setPositional", &ImmSymbolValueJs::setPositional)}); }
};

template <>
struct js_to_org_type<ImmSymbolValueJs> {
  using type = org::imm::ImmSymbolValue;
};

template <>
struct org_to_js_type<org::imm::ImmSymbolValue> {
  using type = ImmSymbolValueJs;
};

struct ImmEscapedValueJs : public SharedPtrWrapBase<ImmEscapedValueJs, org::imm::ImmEscapedValue> {
  using SharedPtrWrapBase<ImmEscapedValueJs, org::imm::ImmEscapedValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmEscapedValueJs", {}); }
};

template <>
struct js_to_org_type<ImmEscapedValueJs> {
  using type = org::imm::ImmEscapedValue;
};

template <>
struct org_to_js_type<org::imm::ImmEscapedValue> {
  using type = ImmEscapedValueJs;
};

struct ImmNewlineValueJs : public SharedPtrWrapBase<ImmNewlineValueJs, org::imm::ImmNewlineValue> {
  using SharedPtrWrapBase<ImmNewlineValueJs, org::imm::ImmNewlineValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmNewlineValueJs", {}); }
};

template <>
struct js_to_org_type<ImmNewlineValueJs> {
  using type = org::imm::ImmNewlineValue;
};

template <>
struct org_to_js_type<org::imm::ImmNewlineValue> {
  using type = ImmNewlineValueJs;
};

struct ImmSpaceValueJs : public SharedPtrWrapBase<ImmSpaceValueJs, org::imm::ImmSpaceValue> {
  using SharedPtrWrapBase<ImmSpaceValueJs, org::imm::ImmSpaceValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmSpaceValueJs", {}); }
};

template <>
struct js_to_org_type<ImmSpaceValueJs> {
  using type = org::imm::ImmSpaceValue;
};

template <>
struct org_to_js_type<org::imm::ImmSpaceValue> {
  using type = ImmSpaceValueJs;
};

struct ImmWordValueJs : public SharedPtrWrapBase<ImmWordValueJs, org::imm::ImmWordValue> {
  using SharedPtrWrapBase<ImmWordValueJs, org::imm::ImmWordValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmWordValueJs", {}); }
};

template <>
struct js_to_org_type<ImmWordValueJs> {
  using type = org::imm::ImmWordValue;
};

template <>
struct org_to_js_type<org::imm::ImmWordValue> {
  using type = ImmWordValueJs;
};

struct ImmAtMentionValueJs : public SharedPtrWrapBase<ImmAtMentionValueJs, org::imm::ImmAtMentionValue> {
  using SharedPtrWrapBase<ImmAtMentionValueJs, org::imm::ImmAtMentionValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmAtMentionValueJs", {}); }
};

template <>
struct js_to_org_type<ImmAtMentionValueJs> {
  using type = org::imm::ImmAtMentionValue;
};

template <>
struct org_to_js_type<org::imm::ImmAtMentionValue> {
  using type = ImmAtMentionValueJs;
};

struct ImmRawTextValueJs : public SharedPtrWrapBase<ImmRawTextValueJs, org::imm::ImmRawTextValue> {
  using SharedPtrWrapBase<ImmRawTextValueJs, org::imm::ImmRawTextValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmRawTextValueJs", {}); }
};

template <>
struct js_to_org_type<ImmRawTextValueJs> {
  using type = org::imm::ImmRawTextValue;
};

template <>
struct org_to_js_type<org::imm::ImmRawTextValue> {
  using type = ImmRawTextValueJs;
};

struct ImmPunctuationValueJs : public SharedPtrWrapBase<ImmPunctuationValueJs, org::imm::ImmPunctuationValue> {
  using SharedPtrWrapBase<ImmPunctuationValueJs, org::imm::ImmPunctuationValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmPunctuationValueJs", {}); }
};

template <>
struct js_to_org_type<ImmPunctuationValueJs> {
  using type = org::imm::ImmPunctuationValue;
};

template <>
struct org_to_js_type<org::imm::ImmPunctuationValue> {
  using type = ImmPunctuationValueJs;
};

struct ImmPlaceholderValueJs : public SharedPtrWrapBase<ImmPlaceholderValueJs, org::imm::ImmPlaceholderValue> {
  using SharedPtrWrapBase<ImmPlaceholderValueJs, org::imm::ImmPlaceholderValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmPlaceholderValueJs", {}); }
};

template <>
struct js_to_org_type<ImmPlaceholderValueJs> {
  using type = org::imm::ImmPlaceholderValue;
};

template <>
struct org_to_js_type<org::imm::ImmPlaceholderValue> {
  using type = ImmPlaceholderValueJs;
};

struct ImmBigIdentValueJs : public SharedPtrWrapBase<ImmBigIdentValueJs, org::imm::ImmBigIdentValue> {
  using SharedPtrWrapBase<ImmBigIdentValueJs, org::imm::ImmBigIdentValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBigIdentValueJs", {}); }
};

template <>
struct js_to_org_type<ImmBigIdentValueJs> {
  using type = org::imm::ImmBigIdentValue;
};

template <>
struct org_to_js_type<org::imm::ImmBigIdentValue> {
  using type = ImmBigIdentValueJs;
};

struct ImmTextTargetValueJs : public SharedPtrWrapBase<ImmTextTargetValueJs, org::imm::ImmTextTargetValue> {
  using SharedPtrWrapBase<ImmTextTargetValueJs, org::imm::ImmTextTargetValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmTextTargetValueJs", {}); }
};

template <>
struct js_to_org_type<ImmTextTargetValueJs> {
  using type = org::imm::ImmTextTargetValue;
};

template <>
struct org_to_js_type<org::imm::ImmTextTargetValue> {
  using type = ImmTextTargetValueJs;
};

struct ImmBoldValueJs : public SharedPtrWrapBase<ImmBoldValueJs, org::imm::ImmBoldValue> {
  using SharedPtrWrapBase<ImmBoldValueJs, org::imm::ImmBoldValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBoldValueJs", {}); }
};

template <>
struct js_to_org_type<ImmBoldValueJs> {
  using type = org::imm::ImmBoldValue;
};

template <>
struct org_to_js_type<org::imm::ImmBoldValue> {
  using type = ImmBoldValueJs;
};

struct ImmUnderlineValueJs : public SharedPtrWrapBase<ImmUnderlineValueJs, org::imm::ImmUnderlineValue> {
  using SharedPtrWrapBase<ImmUnderlineValueJs, org::imm::ImmUnderlineValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmUnderlineValueJs", {}); }
};

template <>
struct js_to_org_type<ImmUnderlineValueJs> {
  using type = org::imm::ImmUnderlineValue;
};

template <>
struct org_to_js_type<org::imm::ImmUnderlineValue> {
  using type = ImmUnderlineValueJs;
};

struct ImmMonospaceValueJs : public SharedPtrWrapBase<ImmMonospaceValueJs, org::imm::ImmMonospaceValue> {
  using SharedPtrWrapBase<ImmMonospaceValueJs, org::imm::ImmMonospaceValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmMonospaceValueJs", {}); }
};

template <>
struct js_to_org_type<ImmMonospaceValueJs> {
  using type = org::imm::ImmMonospaceValue;
};

template <>
struct org_to_js_type<org::imm::ImmMonospaceValue> {
  using type = ImmMonospaceValueJs;
};

struct ImmMarkQuoteValueJs : public SharedPtrWrapBase<ImmMarkQuoteValueJs, org::imm::ImmMarkQuoteValue> {
  using SharedPtrWrapBase<ImmMarkQuoteValueJs, org::imm::ImmMarkQuoteValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmMarkQuoteValueJs", {}); }
};

template <>
struct js_to_org_type<ImmMarkQuoteValueJs> {
  using type = org::imm::ImmMarkQuoteValue;
};

template <>
struct org_to_js_type<org::imm::ImmMarkQuoteValue> {
  using type = ImmMarkQuoteValueJs;
};

struct ImmVerbatimValueJs : public SharedPtrWrapBase<ImmVerbatimValueJs, org::imm::ImmVerbatimValue> {
  using SharedPtrWrapBase<ImmVerbatimValueJs, org::imm::ImmVerbatimValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmVerbatimValueJs", {}); }
};

template <>
struct js_to_org_type<ImmVerbatimValueJs> {
  using type = org::imm::ImmVerbatimValue;
};

template <>
struct org_to_js_type<org::imm::ImmVerbatimValue> {
  using type = ImmVerbatimValueJs;
};

struct ImmItalicValueJs : public SharedPtrWrapBase<ImmItalicValueJs, org::imm::ImmItalicValue> {
  using SharedPtrWrapBase<ImmItalicValueJs, org::imm::ImmItalicValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmItalicValueJs", {}); }
};

template <>
struct js_to_org_type<ImmItalicValueJs> {
  using type = org::imm::ImmItalicValue;
};

template <>
struct org_to_js_type<org::imm::ImmItalicValue> {
  using type = ImmItalicValueJs;
};

struct ImmStrikeValueJs : public SharedPtrWrapBase<ImmStrikeValueJs, org::imm::ImmStrikeValue> {
  using SharedPtrWrapBase<ImmStrikeValueJs, org::imm::ImmStrikeValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmStrikeValueJs", {}); }
};

template <>
struct js_to_org_type<ImmStrikeValueJs> {
  using type = org::imm::ImmStrikeValue;
};

template <>
struct org_to_js_type<org::imm::ImmStrikeValue> {
  using type = ImmStrikeValueJs;
};

struct ImmParValueJs : public SharedPtrWrapBase<ImmParValueJs, org::imm::ImmParValue> {
  using SharedPtrWrapBase<ImmParValueJs, org::imm::ImmParValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmParValueJs", {}); }
};

template <>
struct js_to_org_type<ImmParValueJs> {
  using type = org::imm::ImmParValue;
};

template <>
struct org_to_js_type<org::imm::ImmParValue> {
  using type = ImmParValueJs;
};

struct ImmRadioTargetValueJs : public SharedPtrWrapBase<ImmRadioTargetValueJs, org::imm::ImmRadioTargetValue> {
  using SharedPtrWrapBase<ImmRadioTargetValueJs, org::imm::ImmRadioTargetValue>::SharedPtrWrapBase;
  Napi::Value getWords(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<hstd::Str> const&(org::imm::ImmRadioTargetValue::*)() const>(&org::imm::ImmRadioTargetValue::getWords),
                                        std::make_tuple()));
  }
  Napi::Value setWords(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmRadioTargetValue::*)(immer::flex_vector<hstd::Str> const&)>(&org::imm::ImmRadioTargetValue::setWords),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<hstd::Str>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmRadioTargetValueJs", {InstanceMethod("getWords", &ImmRadioTargetValueJs::getWords),
                                                                                                                                InstanceMethod("setWords", &ImmRadioTargetValueJs::setWords)}); }
};

template <>
struct js_to_org_type<ImmRadioTargetValueJs> {
  using type = org::imm::ImmRadioTargetValue;
};

template <>
struct org_to_js_type<org::imm::ImmRadioTargetValue> {
  using type = ImmRadioTargetValueJs;
};

struct ImmLatexValueJs : public SharedPtrWrapBase<ImmLatexValueJs, org::imm::ImmLatexValue> {
  using SharedPtrWrapBase<ImmLatexValueJs, org::imm::ImmLatexValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmLatexValueJs", {}); }
};

template <>
struct js_to_org_type<ImmLatexValueJs> {
  using type = org::imm::ImmLatexValue;
};

template <>
struct org_to_js_type<org::imm::ImmLatexValue> {
  using type = ImmLatexValueJs;
};

struct ImmLinkValueJs : public SharedPtrWrapBase<ImmLinkValueJs, org::imm::ImmLinkValue> {
  using SharedPtrWrapBase<ImmLinkValueJs, org::imm::ImmLinkValue>::SharedPtrWrapBase;
  Napi::Value getDescription(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&(org::imm::ImmLinkValue::*)() const>(&org::imm::ImmLinkValue::getDescription),
                                        std::make_tuple()));
  }
  Napi::Value getTarget(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::LinkTarget const&(org::imm::ImmLinkValue::*)() const>(&org::imm::ImmLinkValue::getTarget),
                                        std::make_tuple()));
  }
  Napi::Value setDescription(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmLinkValue::*)(immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&)>(&org::imm::ImmLinkValue::setDescription),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>>>{"value"})));
  }
  Napi::Value setTarget(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmLinkValue::*)(org::sem::LinkTarget const&)>(&org::imm::ImmLinkValue::setTarget),
                                   std::make_tuple(CxxArgSpec<org::sem::LinkTarget>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmLinkValueJs", {InstanceMethod("getDescription", &ImmLinkValueJs::getDescription),
                                                                                                                         InstanceMethod("getTarget", &ImmLinkValueJs::getTarget),
                                                                                                                         InstanceMethod("setDescription", &ImmLinkValueJs::setDescription),
                                                                                                                         InstanceMethod("setTarget", &ImmLinkValueJs::setTarget)}); }
};

template <>
struct js_to_org_type<ImmLinkValueJs> {
  using type = org::imm::ImmLinkValue;
};

template <>
struct org_to_js_type<org::imm::ImmLinkValue> {
  using type = ImmLinkValueJs;
};

struct ImmBlockCenterValueJs : public SharedPtrWrapBase<ImmBlockCenterValueJs, org::imm::ImmBlockCenterValue> {
  using SharedPtrWrapBase<ImmBlockCenterValueJs, org::imm::ImmBlockCenterValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockCenterValueJs", {}); }
};

template <>
struct js_to_org_type<ImmBlockCenterValueJs> {
  using type = org::imm::ImmBlockCenterValue;
};

template <>
struct org_to_js_type<org::imm::ImmBlockCenterValue> {
  using type = ImmBlockCenterValueJs;
};

struct ImmBlockQuoteValueJs : public SharedPtrWrapBase<ImmBlockQuoteValueJs, org::imm::ImmBlockQuoteValue> {
  using SharedPtrWrapBase<ImmBlockQuoteValueJs, org::imm::ImmBlockQuoteValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockQuoteValueJs", {}); }
};

template <>
struct js_to_org_type<ImmBlockQuoteValueJs> {
  using type = org::imm::ImmBlockQuoteValue;
};

template <>
struct org_to_js_type<org::imm::ImmBlockQuoteValue> {
  using type = ImmBlockQuoteValueJs;
};

struct ImmBlockCommentValueJs : public SharedPtrWrapBase<ImmBlockCommentValueJs, org::imm::ImmBlockCommentValue> {
  using SharedPtrWrapBase<ImmBlockCommentValueJs, org::imm::ImmBlockCommentValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockCommentValueJs", {}); }
};

template <>
struct js_to_org_type<ImmBlockCommentValueJs> {
  using type = org::imm::ImmBlockCommentValue;
};

template <>
struct org_to_js_type<org::imm::ImmBlockCommentValue> {
  using type = ImmBlockCommentValueJs;
};

struct ImmBlockVerseValueJs : public SharedPtrWrapBase<ImmBlockVerseValueJs, org::imm::ImmBlockVerseValue> {
  using SharedPtrWrapBase<ImmBlockVerseValueJs, org::imm::ImmBlockVerseValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockVerseValueJs", {}); }
};

template <>
struct js_to_org_type<ImmBlockVerseValueJs> {
  using type = org::imm::ImmBlockVerseValue;
};

template <>
struct org_to_js_type<org::imm::ImmBlockVerseValue> {
  using type = ImmBlockVerseValueJs;
};

struct ImmBlockDynamicFallbackValueJs : public SharedPtrWrapBase<ImmBlockDynamicFallbackValueJs, org::imm::ImmBlockDynamicFallbackValue> {
  using SharedPtrWrapBase<ImmBlockDynamicFallbackValueJs, org::imm::ImmBlockDynamicFallbackValue>::SharedPtrWrapBase;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmBlockDynamicFallbackValue::*)() const>(&org::imm::ImmBlockDynamicFallbackValue::getName),
                                        std::make_tuple()));
  }
  Napi::Value setName(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmBlockDynamicFallbackValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmBlockDynamicFallbackValue::setName),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockDynamicFallbackValueJs", {InstanceMethod("getName", &ImmBlockDynamicFallbackValueJs::getName),
                                                                                                                                         InstanceMethod("setName", &ImmBlockDynamicFallbackValueJs::setName)}); }
};

template <>
struct js_to_org_type<ImmBlockDynamicFallbackValueJs> {
  using type = org::imm::ImmBlockDynamicFallbackValue;
};

template <>
struct org_to_js_type<org::imm::ImmBlockDynamicFallbackValue> {
  using type = ImmBlockDynamicFallbackValueJs;
};

struct ImmBlockExampleValueJs : public SharedPtrWrapBase<ImmBlockExampleValueJs, org::imm::ImmBlockExampleValue> {
  using SharedPtrWrapBase<ImmBlockExampleValueJs, org::imm::ImmBlockExampleValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockExampleValueJs", {}); }
};

template <>
struct js_to_org_type<ImmBlockExampleValueJs> {
  using type = org::imm::ImmBlockExampleValue;
};

template <>
struct org_to_js_type<org::imm::ImmBlockExampleValue> {
  using type = ImmBlockExampleValueJs;
};

struct ImmBlockExportValueJs : public SharedPtrWrapBase<ImmBlockExportValueJs, org::imm::ImmBlockExportValue> {
  using SharedPtrWrapBase<ImmBlockExportValueJs, org::imm::ImmBlockExportValue>::SharedPtrWrapBase;
  Napi::Value getExporter(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmBlockExportValue::*)() const>(&org::imm::ImmBlockExportValue::getExporter),
                                        std::make_tuple()));
  }
  Napi::Value getContent(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmBlockExportValue::*)() const>(&org::imm::ImmBlockExportValue::getContent),
                                        std::make_tuple()));
  }
  Napi::Value setExporter(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmBlockExportValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmBlockExportValue::setExporter),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setContent(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmBlockExportValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmBlockExportValue::setContent),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockExportValueJs", {InstanceMethod("getExporter", &ImmBlockExportValueJs::getExporter),
                                                                                                                                InstanceMethod("getContent", &ImmBlockExportValueJs::getContent),
                                                                                                                                InstanceMethod("setExporter", &ImmBlockExportValueJs::setExporter),
                                                                                                                                InstanceMethod("setContent", &ImmBlockExportValueJs::setContent)}); }
};

template <>
struct js_to_org_type<ImmBlockExportValueJs> {
  using type = org::imm::ImmBlockExportValue;
};

template <>
struct org_to_js_type<org::imm::ImmBlockExportValue> {
  using type = ImmBlockExportValueJs;
};

struct ImmBlockAdmonitionValueJs : public SharedPtrWrapBase<ImmBlockAdmonitionValueJs, org::imm::ImmBlockAdmonitionValue> {
  using SharedPtrWrapBase<ImmBlockAdmonitionValueJs, org::imm::ImmBlockAdmonitionValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockAdmonitionValueJs", {}); }
};

template <>
struct js_to_org_type<ImmBlockAdmonitionValueJs> {
  using type = org::imm::ImmBlockAdmonitionValue;
};

template <>
struct org_to_js_type<org::imm::ImmBlockAdmonitionValue> {
  using type = ImmBlockAdmonitionValueJs;
};

struct ImmBlockCodeEvalResultValueJs : public SharedPtrWrapBase<ImmBlockCodeEvalResultValueJs, org::imm::ImmBlockCodeEvalResultValue> {
  using SharedPtrWrapBase<ImmBlockCodeEvalResultValueJs, org::imm::ImmBlockCodeEvalResultValue>::SharedPtrWrapBase;
  Napi::Value getRaw(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::sem::OrgCodeEvalOutput> const&(org::imm::ImmBlockCodeEvalResultValue::*)() const>(&org::imm::ImmBlockCodeEvalResultValue::getRaw),
                                        std::make_tuple()));
  }
  Napi::Value getNode(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmIdT<org::imm::ImmOrg> const&(org::imm::ImmBlockCodeEvalResultValue::*)() const>(&org::imm::ImmBlockCodeEvalResultValue::getNode),
                                        std::make_tuple()));
  }
  Napi::Value setRaw(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmBlockCodeEvalResultValue::*)(immer::flex_vector<org::sem::OrgCodeEvalOutput> const&)>(&org::imm::ImmBlockCodeEvalResultValue::setRaw),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<org::sem::OrgCodeEvalOutput>>{"value"})));
  }
  Napi::Value setNode(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmBlockCodeEvalResultValue::*)(org::imm::ImmIdT<org::imm::ImmOrg> const&)>(&org::imm::ImmBlockCodeEvalResultValue::setNode),
                                   std::make_tuple(CxxArgSpec<org::imm::ImmIdT<org::imm::ImmOrg>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockCodeEvalResultValueJs", {InstanceMethod("getRaw", &ImmBlockCodeEvalResultValueJs::getRaw),
                                                                                                                                        InstanceMethod("getNode", &ImmBlockCodeEvalResultValueJs::getNode),
                                                                                                                                        InstanceMethod("setRaw", &ImmBlockCodeEvalResultValueJs::setRaw),
                                                                                                                                        InstanceMethod("setNode", &ImmBlockCodeEvalResultValueJs::setNode)}); }
};

template <>
struct js_to_org_type<ImmBlockCodeEvalResultValueJs> {
  using type = org::imm::ImmBlockCodeEvalResultValue;
};

template <>
struct org_to_js_type<org::imm::ImmBlockCodeEvalResultValue> {
  using type = ImmBlockCodeEvalResultValueJs;
};

struct ImmBlockCodeValueJs : public SharedPtrWrapBase<ImmBlockCodeValueJs, org::imm::ImmBlockCodeValue> {
  using SharedPtrWrapBase<ImmBlockCodeValueJs, org::imm::ImmBlockCodeValue>::SharedPtrWrapBase;
  Napi::Value getLang(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmBlockCodeValue::*)() const>(&org::imm::ImmBlockCodeValue::getLang),
                                        std::make_tuple()));
  }
  Napi::Value getExports(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<BlockCodeExports const&(org::imm::ImmBlockCodeValue::*)() const>(&org::imm::ImmBlockCodeValue::getExports),
                                        std::make_tuple()));
  }
  Napi::Value getResult(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>> const&(org::imm::ImmBlockCodeValue::*)() const>(&org::imm::ImmBlockCodeValue::getResult),
                                        std::make_tuple()));
  }
  Napi::Value getLines(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::sem::BlockCodeLine> const&(org::imm::ImmBlockCodeValue::*)() const>(&org::imm::ImmBlockCodeValue::getLines),
                                        std::make_tuple()));
  }
  Napi::Value getCache(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmBlockCodeValue::*)() const>(&org::imm::ImmBlockCodeValue::getCache),
                                        std::make_tuple()));
  }
  Napi::Value getEval(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmBlockCodeValue::*)() const>(&org::imm::ImmBlockCodeValue::getEval),
                                        std::make_tuple()));
  }
  Napi::Value getNoweb(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmBlockCodeValue::*)() const>(&org::imm::ImmBlockCodeValue::getNoweb),
                                        std::make_tuple()));
  }
  Napi::Value getHlines(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmBlockCodeValue::*)() const>(&org::imm::ImmBlockCodeValue::getHlines),
                                        std::make_tuple()));
  }
  Napi::Value getTangle(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmBlockCodeValue::*)() const>(&org::imm::ImmBlockCodeValue::getTangle),
                                        std::make_tuple()));
  }
  Napi::Value getSwitches(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrGroup const&(org::imm::ImmBlockCodeValue::*)() const>(&org::imm::ImmBlockCodeValue::getSwitches),
                                        std::make_tuple()));
  }
  Napi::Value setLang(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmBlockCodeValue::*)(immer::box<std::optional<hstd::Str>> const&)>(&org::imm::ImmBlockCodeValue::setLang),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::Str>>>{"value"})));
  }
  Napi::Value setExports(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmBlockCodeValue::*)(BlockCodeExports const&)>(&org::imm::ImmBlockCodeValue::setExports),
                                   std::make_tuple(CxxArgSpec<BlockCodeExports>{"value"})));
  }
  Napi::Value setResult(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmBlockCodeValue::*)(immer::flex_vector<org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>> const&)>(&org::imm::ImmBlockCodeValue::setResult),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>>>{"value"})));
  }
  Napi::Value setLines(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmBlockCodeValue::*)(immer::flex_vector<org::sem::BlockCodeLine> const&)>(&org::imm::ImmBlockCodeValue::setLines),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<org::sem::BlockCodeLine>>{"value"})));
  }
  Napi::Value setCache(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmBlockCodeValue::*)(bool const&)>(&org::imm::ImmBlockCodeValue::setCache),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  Napi::Value setEval(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmBlockCodeValue::*)(bool const&)>(&org::imm::ImmBlockCodeValue::setEval),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  Napi::Value setNoweb(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmBlockCodeValue::*)(bool const&)>(&org::imm::ImmBlockCodeValue::setNoweb),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  Napi::Value setHlines(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmBlockCodeValue::*)(bool const&)>(&org::imm::ImmBlockCodeValue::setHlines),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  Napi::Value setTangle(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmBlockCodeValue::*)(bool const&)>(&org::imm::ImmBlockCodeValue::setTangle),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  Napi::Value setSwitches(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmBlockCodeValue::*)(org::sem::AttrGroup const&)>(&org::imm::ImmBlockCodeValue::setSwitches),
                                   std::make_tuple(CxxArgSpec<org::sem::AttrGroup>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockCodeValueJs", {InstanceMethod("getLang", &ImmBlockCodeValueJs::getLang),
                                                                                                                              InstanceMethod("getExports", &ImmBlockCodeValueJs::getExports),
                                                                                                                              InstanceMethod("getResult", &ImmBlockCodeValueJs::getResult),
                                                                                                                              InstanceMethod("getLines", &ImmBlockCodeValueJs::getLines),
                                                                                                                              InstanceMethod("getCache", &ImmBlockCodeValueJs::getCache),
                                                                                                                              InstanceMethod("getEval", &ImmBlockCodeValueJs::getEval),
                                                                                                                              InstanceMethod("getNoweb", &ImmBlockCodeValueJs::getNoweb),
                                                                                                                              InstanceMethod("getHlines", &ImmBlockCodeValueJs::getHlines),
                                                                                                                              InstanceMethod("getTangle", &ImmBlockCodeValueJs::getTangle),
                                                                                                                              InstanceMethod("getSwitches", &ImmBlockCodeValueJs::getSwitches),
                                                                                                                              InstanceMethod("setLang", &ImmBlockCodeValueJs::setLang),
                                                                                                                              InstanceMethod("setExports", &ImmBlockCodeValueJs::setExports),
                                                                                                                              InstanceMethod("setResult", &ImmBlockCodeValueJs::setResult),
                                                                                                                              InstanceMethod("setLines", &ImmBlockCodeValueJs::setLines),
                                                                                                                              InstanceMethod("setCache", &ImmBlockCodeValueJs::setCache),
                                                                                                                              InstanceMethod("setEval", &ImmBlockCodeValueJs::setEval),
                                                                                                                              InstanceMethod("setNoweb", &ImmBlockCodeValueJs::setNoweb),
                                                                                                                              InstanceMethod("setHlines", &ImmBlockCodeValueJs::setHlines),
                                                                                                                              InstanceMethod("setTangle", &ImmBlockCodeValueJs::setTangle),
                                                                                                                              InstanceMethod("setSwitches", &ImmBlockCodeValueJs::setSwitches)}); }
};

template <>
struct js_to_org_type<ImmBlockCodeValueJs> {
  using type = org::imm::ImmBlockCodeValue;
};

template <>
struct org_to_js_type<org::imm::ImmBlockCodeValue> {
  using type = ImmBlockCodeValueJs;
};

struct ImmSubtreeLogValueJs : public SharedPtrWrapBase<ImmSubtreeLogValueJs, org::imm::ImmSubtreeLogValue> {
  using SharedPtrWrapBase<ImmSubtreeLogValueJs, org::imm::ImmSubtreeLogValue>::SharedPtrWrapBase;
  Napi::Value getHead(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SubtreeLogHead const&(org::imm::ImmSubtreeLogValue::*)() const>(&org::imm::ImmSubtreeLogValue::getHead),
                                        std::make_tuple()));
  }
  Napi::Value getDesc(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmStmtList>>> const&(org::imm::ImmSubtreeLogValue::*)() const>(&org::imm::ImmSubtreeLogValue::getDesc),
                                        std::make_tuple()));
  }
  Napi::Value setHead(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeLogValue::*)(org::sem::SubtreeLogHead const&)>(&org::imm::ImmSubtreeLogValue::setHead),
                                   std::make_tuple(CxxArgSpec<org::sem::SubtreeLogHead>{"value"})));
  }
  Napi::Value setDesc(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeLogValue::*)(immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmStmtList>>> const&)>(&org::imm::ImmSubtreeLogValue::setDesc),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmStmtList>>>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmSubtreeLogValueJs", {InstanceMethod("getHead", &ImmSubtreeLogValueJs::getHead),
                                                                                                                               InstanceMethod("getDesc", &ImmSubtreeLogValueJs::getDesc),
                                                                                                                               InstanceMethod("setHead", &ImmSubtreeLogValueJs::setHead),
                                                                                                                               InstanceMethod("setDesc", &ImmSubtreeLogValueJs::setDesc)}); }
};

template <>
struct js_to_org_type<ImmSubtreeLogValueJs> {
  using type = org::imm::ImmSubtreeLogValue;
};

template <>
struct org_to_js_type<org::imm::ImmSubtreeLogValue> {
  using type = ImmSubtreeLogValueJs;
};

struct ImmSubtreeValueJs : public SharedPtrWrapBase<ImmSubtreeValueJs, org::imm::ImmSubtreeValue> {
  using SharedPtrWrapBase<ImmSubtreeValueJs, org::imm::ImmSubtreeValue>::SharedPtrWrapBase;
  Napi::Value getLevel(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int const&(org::imm::ImmSubtreeValue::*)() const>(&org::imm::ImmSubtreeValue::getLevel),
                                        std::make_tuple()));
  }
  Napi::Value getTreeid(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmSubtreeValue::*)() const>(&org::imm::ImmSubtreeValue::getTreeid),
                                        std::make_tuple()));
  }
  Napi::Value getTodo(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmSubtreeValue::*)() const>(&org::imm::ImmSubtreeValue::getTodo),
                                        std::make_tuple()));
  }
  Napi::Value getCompletion(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::sem::SubtreeCompletion>> const&(org::imm::ImmSubtreeValue::*)() const>(&org::imm::ImmSubtreeValue::getCompletion),
                                        std::make_tuple()));
  }
  Napi::Value getDescription(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&(org::imm::ImmSubtreeValue::*)() const>(&org::imm::ImmSubtreeValue::getDescription),
                                        std::make_tuple()));
  }
  Napi::Value getTags(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmHashTag>> const&(org::imm::ImmSubtreeValue::*)() const>(&org::imm::ImmSubtreeValue::getTags),
                                        std::make_tuple()));
  }
  Napi::Value getTitle(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmIdT<org::imm::ImmParagraph> const&(org::imm::ImmSubtreeValue::*)() const>(&org::imm::ImmSubtreeValue::getTitle),
                                        std::make_tuple()));
  }
  Napi::Value getLogbook(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmSubtreeLog>> const&(org::imm::ImmSubtreeValue::*)() const>(&org::imm::ImmSubtreeValue::getLogbook),
                                        std::make_tuple()));
  }
  Napi::Value getProperties(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::sem::NamedProperty> const&(org::imm::ImmSubtreeValue::*)() const>(&org::imm::ImmSubtreeValue::getProperties),
                                        std::make_tuple()));
  }
  Napi::Value getClosed(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::UserTime>> const&(org::imm::ImmSubtreeValue::*)() const>(&org::imm::ImmSubtreeValue::getClosed),
                                        std::make_tuple()));
  }
  Napi::Value getDeadline(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::UserTime>> const&(org::imm::ImmSubtreeValue::*)() const>(&org::imm::ImmSubtreeValue::getDeadline),
                                        std::make_tuple()));
  }
  Napi::Value getScheduled(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::UserTime>> const&(org::imm::ImmSubtreeValue::*)() const>(&org::imm::ImmSubtreeValue::getScheduled),
                                        std::make_tuple()));
  }
  Napi::Value getIscomment(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmSubtreeValue::*)() const>(&org::imm::ImmSubtreeValue::getIscomment),
                                        std::make_tuple()));
  }
  Napi::Value getIsarchived(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmSubtreeValue::*)() const>(&org::imm::ImmSubtreeValue::getIsarchived),
                                        std::make_tuple()));
  }
  Napi::Value getPriority(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmSubtreeValue::*)() const>(&org::imm::ImmSubtreeValue::getPriority),
                                        std::make_tuple()));
  }
  Napi::Value setLevel(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeValue::*)(int const&)>(&org::imm::ImmSubtreeValue::setLevel),
                                   std::make_tuple(CxxArgSpec<int>{"value"})));
  }
  Napi::Value setTreeid(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeValue::*)(immer::box<std::optional<hstd::Str>> const&)>(&org::imm::ImmSubtreeValue::setTreeid),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::Str>>>{"value"})));
  }
  Napi::Value setTodo(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeValue::*)(immer::box<std::optional<hstd::Str>> const&)>(&org::imm::ImmSubtreeValue::setTodo),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::Str>>>{"value"})));
  }
  Napi::Value setCompletion(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeValue::*)(immer::box<std::optional<org::sem::SubtreeCompletion>> const&)>(&org::imm::ImmSubtreeValue::setCompletion),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<org::sem::SubtreeCompletion>>>{"value"})));
  }
  Napi::Value setDescription(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeValue::*)(immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&)>(&org::imm::ImmSubtreeValue::setDescription),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>>>{"value"})));
  }
  Napi::Value setTags(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeValue::*)(immer::flex_vector<org::imm::ImmIdT<org::imm::ImmHashTag>> const&)>(&org::imm::ImmSubtreeValue::setTags),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmHashTag>>>{"value"})));
  }
  Napi::Value setTitle(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeValue::*)(org::imm::ImmIdT<org::imm::ImmParagraph> const&)>(&org::imm::ImmSubtreeValue::setTitle),
                                   std::make_tuple(CxxArgSpec<org::imm::ImmIdT<org::imm::ImmParagraph>>{"value"})));
  }
  Napi::Value setLogbook(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeValue::*)(immer::flex_vector<org::imm::ImmIdT<org::imm::ImmSubtreeLog>> const&)>(&org::imm::ImmSubtreeValue::setLogbook),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmSubtreeLog>>>{"value"})));
  }
  Napi::Value setProperties(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeValue::*)(immer::flex_vector<org::sem::NamedProperty> const&)>(&org::imm::ImmSubtreeValue::setProperties),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<org::sem::NamedProperty>>{"value"})));
  }
  Napi::Value setClosed(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeValue::*)(immer::box<std::optional<hstd::UserTime>> const&)>(&org::imm::ImmSubtreeValue::setClosed),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::UserTime>>>{"value"})));
  }
  Napi::Value setDeadline(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeValue::*)(immer::box<std::optional<hstd::UserTime>> const&)>(&org::imm::ImmSubtreeValue::setDeadline),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::UserTime>>>{"value"})));
  }
  Napi::Value setScheduled(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeValue::*)(immer::box<std::optional<hstd::UserTime>> const&)>(&org::imm::ImmSubtreeValue::setScheduled),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::UserTime>>>{"value"})));
  }
  Napi::Value setIscomment(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeValue::*)(bool const&)>(&org::imm::ImmSubtreeValue::setIscomment),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  Napi::Value setIsarchived(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeValue::*)(bool const&)>(&org::imm::ImmSubtreeValue::setIsarchived),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  Napi::Value setPriority(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSubtreeValue::*)(immer::box<std::optional<hstd::Str>> const&)>(&org::imm::ImmSubtreeValue::setPriority),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::Str>>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmSubtreeValueJs", {InstanceMethod("getLevel", &ImmSubtreeValueJs::getLevel),
                                                                                                                            InstanceMethod("getTreeid", &ImmSubtreeValueJs::getTreeid),
                                                                                                                            InstanceMethod("getTodo", &ImmSubtreeValueJs::getTodo),
                                                                                                                            InstanceMethod("getCompletion", &ImmSubtreeValueJs::getCompletion),
                                                                                                                            InstanceMethod("getDescription", &ImmSubtreeValueJs::getDescription),
                                                                                                                            InstanceMethod("getTags", &ImmSubtreeValueJs::getTags),
                                                                                                                            InstanceMethod("getTitle", &ImmSubtreeValueJs::getTitle),
                                                                                                                            InstanceMethod("getLogbook", &ImmSubtreeValueJs::getLogbook),
                                                                                                                            InstanceMethod("getProperties", &ImmSubtreeValueJs::getProperties),
                                                                                                                            InstanceMethod("getClosed", &ImmSubtreeValueJs::getClosed),
                                                                                                                            InstanceMethod("getDeadline", &ImmSubtreeValueJs::getDeadline),
                                                                                                                            InstanceMethod("getScheduled", &ImmSubtreeValueJs::getScheduled),
                                                                                                                            InstanceMethod("getIscomment", &ImmSubtreeValueJs::getIscomment),
                                                                                                                            InstanceMethod("getIsarchived", &ImmSubtreeValueJs::getIsarchived),
                                                                                                                            InstanceMethod("getPriority", &ImmSubtreeValueJs::getPriority),
                                                                                                                            InstanceMethod("setLevel", &ImmSubtreeValueJs::setLevel),
                                                                                                                            InstanceMethod("setTreeid", &ImmSubtreeValueJs::setTreeid),
                                                                                                                            InstanceMethod("setTodo", &ImmSubtreeValueJs::setTodo),
                                                                                                                            InstanceMethod("setCompletion", &ImmSubtreeValueJs::setCompletion),
                                                                                                                            InstanceMethod("setDescription", &ImmSubtreeValueJs::setDescription),
                                                                                                                            InstanceMethod("setTags", &ImmSubtreeValueJs::setTags),
                                                                                                                            InstanceMethod("setTitle", &ImmSubtreeValueJs::setTitle),
                                                                                                                            InstanceMethod("setLogbook", &ImmSubtreeValueJs::setLogbook),
                                                                                                                            InstanceMethod("setProperties", &ImmSubtreeValueJs::setProperties),
                                                                                                                            InstanceMethod("setClosed", &ImmSubtreeValueJs::setClosed),
                                                                                                                            InstanceMethod("setDeadline", &ImmSubtreeValueJs::setDeadline),
                                                                                                                            InstanceMethod("setScheduled", &ImmSubtreeValueJs::setScheduled),
                                                                                                                            InstanceMethod("setIscomment", &ImmSubtreeValueJs::setIscomment),
                                                                                                                            InstanceMethod("setIsarchived", &ImmSubtreeValueJs::setIsarchived),
                                                                                                                            InstanceMethod("setPriority", &ImmSubtreeValueJs::setPriority)}); }
};

template <>
struct js_to_org_type<ImmSubtreeValueJs> {
  using type = org::imm::ImmSubtreeValue;
};

template <>
struct org_to_js_type<org::imm::ImmSubtreeValue> {
  using type = ImmSubtreeValueJs;
};

struct ImmCellValueJs : public SharedPtrWrapBase<ImmCellValueJs, org::imm::ImmCellValue> {
  using SharedPtrWrapBase<ImmCellValueJs, org::imm::ImmCellValue>::SharedPtrWrapBase;
  Napi::Value getIsblock(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmCellValue::*)() const>(&org::imm::ImmCellValue::getIsblock),
                                        std::make_tuple()));
  }
  Napi::Value setIsblock(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCellValue::*)(bool const&)>(&org::imm::ImmCellValue::setIsblock),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCellValueJs", {InstanceMethod("getIsblock", &ImmCellValueJs::getIsblock),
                                                                                                                         InstanceMethod("setIsblock", &ImmCellValueJs::setIsblock)}); }
};

template <>
struct js_to_org_type<ImmCellValueJs> {
  using type = org::imm::ImmCellValue;
};

template <>
struct org_to_js_type<org::imm::ImmCellValue> {
  using type = ImmCellValueJs;
};

struct ImmRowValueJs : public SharedPtrWrapBase<ImmRowValueJs, org::imm::ImmRowValue> {
  using SharedPtrWrapBase<ImmRowValueJs, org::imm::ImmRowValue>::SharedPtrWrapBase;
  Napi::Value getCells(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmCell>> const&(org::imm::ImmRowValue::*)() const>(&org::imm::ImmRowValue::getCells),
                                        std::make_tuple()));
  }
  Napi::Value getIsblock(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmRowValue::*)() const>(&org::imm::ImmRowValue::getIsblock),
                                        std::make_tuple()));
  }
  Napi::Value setCells(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmRowValue::*)(immer::flex_vector<org::imm::ImmIdT<org::imm::ImmCell>> const&)>(&org::imm::ImmRowValue::setCells),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmCell>>>{"value"})));
  }
  Napi::Value setIsblock(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmRowValue::*)(bool const&)>(&org::imm::ImmRowValue::setIsblock),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmRowValueJs", {InstanceMethod("getCells", &ImmRowValueJs::getCells),
                                                                                                                        InstanceMethod("getIsblock", &ImmRowValueJs::getIsblock),
                                                                                                                        InstanceMethod("setCells", &ImmRowValueJs::setCells),
                                                                                                                        InstanceMethod("setIsblock", &ImmRowValueJs::setIsblock)}); }
};

template <>
struct js_to_org_type<ImmRowValueJs> {
  using type = org::imm::ImmRowValue;
};

template <>
struct org_to_js_type<org::imm::ImmRowValue> {
  using type = ImmRowValueJs;
};

struct ImmTableValueJs : public SharedPtrWrapBase<ImmTableValueJs, org::imm::ImmTableValue> {
  using SharedPtrWrapBase<ImmTableValueJs, org::imm::ImmTableValue>::SharedPtrWrapBase;
  Napi::Value getRows(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmRow>> const&(org::imm::ImmTableValue::*)() const>(&org::imm::ImmTableValue::getRows),
                                        std::make_tuple()));
  }
  Napi::Value getIsblock(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmTableValue::*)() const>(&org::imm::ImmTableValue::getIsblock),
                                        std::make_tuple()));
  }
  Napi::Value setRows(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmTableValue::*)(immer::flex_vector<org::imm::ImmIdT<org::imm::ImmRow>> const&)>(&org::imm::ImmTableValue::setRows),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmRow>>>{"value"})));
  }
  Napi::Value setIsblock(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmTableValue::*)(bool const&)>(&org::imm::ImmTableValue::setIsblock),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmTableValueJs", {InstanceMethod("getRows", &ImmTableValueJs::getRows),
                                                                                                                          InstanceMethod("getIsblock", &ImmTableValueJs::getIsblock),
                                                                                                                          InstanceMethod("setRows", &ImmTableValueJs::setRows),
                                                                                                                          InstanceMethod("setIsblock", &ImmTableValueJs::setIsblock)}); }
};

template <>
struct js_to_org_type<ImmTableValueJs> {
  using type = org::imm::ImmTableValue;
};

template <>
struct org_to_js_type<org::imm::ImmTableValue> {
  using type = ImmTableValueJs;
};

struct ImmParagraphValueJs : public SharedPtrWrapBase<ImmParagraphValueJs, org::imm::ImmParagraphValue> {
  using SharedPtrWrapBase<ImmParagraphValueJs, org::imm::ImmParagraphValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmParagraphValueJs", {}); }
};

template <>
struct js_to_org_type<ImmParagraphValueJs> {
  using type = org::imm::ImmParagraphValue;
};

template <>
struct org_to_js_type<org::imm::ImmParagraphValue> {
  using type = ImmParagraphValueJs;
};

struct ImmColonExampleValueJs : public SharedPtrWrapBase<ImmColonExampleValueJs, org::imm::ImmColonExampleValue> {
  using SharedPtrWrapBase<ImmColonExampleValueJs, org::imm::ImmColonExampleValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmColonExampleValueJs", {}); }
};

template <>
struct js_to_org_type<ImmColonExampleValueJs> {
  using type = org::imm::ImmColonExampleValue;
};

template <>
struct org_to_js_type<org::imm::ImmColonExampleValue> {
  using type = ImmColonExampleValueJs;
};

struct ImmCmdAttrValueJs : public SharedPtrWrapBase<ImmCmdAttrValueJs, org::imm::ImmCmdAttrValue> {
  using SharedPtrWrapBase<ImmCmdAttrValueJs, org::imm::ImmCmdAttrValue>::SharedPtrWrapBase;
  Napi::Value getTarget(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdAttrValue::*)() const>(&org::imm::ImmCmdAttrValue::getTarget),
                                        std::make_tuple()));
  }
  Napi::Value setTarget(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdAttrValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmCmdAttrValue::setTarget),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdAttrValueJs", {InstanceMethod("getTarget", &ImmCmdAttrValueJs::getTarget),
                                                                                                                            InstanceMethod("setTarget", &ImmCmdAttrValueJs::setTarget)}); }
};

template <>
struct js_to_org_type<ImmCmdAttrValueJs> {
  using type = org::imm::ImmCmdAttrValue;
};

template <>
struct org_to_js_type<org::imm::ImmCmdAttrValue> {
  using type = ImmCmdAttrValueJs;
};

struct ImmCmdExportValueJs : public SharedPtrWrapBase<ImmCmdExportValueJs, org::imm::ImmCmdExportValue> {
  using SharedPtrWrapBase<ImmCmdExportValueJs, org::imm::ImmCmdExportValue>::SharedPtrWrapBase;
  Napi::Value getExporter(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdExportValue::*)() const>(&org::imm::ImmCmdExportValue::getExporter),
                                        std::make_tuple()));
  }
  Napi::Value getContent(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdExportValue::*)() const>(&org::imm::ImmCmdExportValue::getContent),
                                        std::make_tuple()));
  }
  Napi::Value setExporter(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdExportValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmCmdExportValue::setExporter),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setContent(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdExportValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmCmdExportValue::setContent),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdExportValueJs", {InstanceMethod("getExporter", &ImmCmdExportValueJs::getExporter),
                                                                                                                              InstanceMethod("getContent", &ImmCmdExportValueJs::getContent),
                                                                                                                              InstanceMethod("setExporter", &ImmCmdExportValueJs::setExporter),
                                                                                                                              InstanceMethod("setContent", &ImmCmdExportValueJs::setContent)}); }
};

template <>
struct js_to_org_type<ImmCmdExportValueJs> {
  using type = org::imm::ImmCmdExportValue;
};

template <>
struct org_to_js_type<org::imm::ImmCmdExportValue> {
  using type = ImmCmdExportValueJs;
};

struct ImmCallValueJs : public SharedPtrWrapBase<ImmCallValueJs, org::imm::ImmCallValue> {
  using SharedPtrWrapBase<ImmCallValueJs, org::imm::ImmCallValue>::SharedPtrWrapBase;
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCallValue::*)() const>(&org::imm::ImmCallValue::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::AttrGroup const&(org::imm::ImmCallValue::*)() const>(&org::imm::ImmCallValue::getAttrs),
                                        std::make_tuple()));
  }
  Napi::Value getIscommand(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmCallValue::*)() const>(&org::imm::ImmCallValue::getIscommand),
                                        std::make_tuple()));
  }
  Napi::Value setName(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCallValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmCallValue::setName),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setAttrs(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCallValue::*)(org::sem::AttrGroup const&)>(&org::imm::ImmCallValue::setAttrs),
                                   std::make_tuple(CxxArgSpec<org::sem::AttrGroup>{"value"})));
  }
  Napi::Value setIscommand(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCallValue::*)(bool const&)>(&org::imm::ImmCallValue::setIscommand),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCallValueJs", {InstanceMethod("getName", &ImmCallValueJs::getName),
                                                                                                                         InstanceMethod("getAttrs", &ImmCallValueJs::getAttrs),
                                                                                                                         InstanceMethod("getIscommand", &ImmCallValueJs::getIscommand),
                                                                                                                         InstanceMethod("setName", &ImmCallValueJs::setName),
                                                                                                                         InstanceMethod("setAttrs", &ImmCallValueJs::setAttrs),
                                                                                                                         InstanceMethod("setIscommand", &ImmCallValueJs::setIscommand)}); }
};

template <>
struct js_to_org_type<ImmCallValueJs> {
  using type = org::imm::ImmCallValue;
};

template <>
struct org_to_js_type<org::imm::ImmCallValue> {
  using type = ImmCallValueJs;
};

struct ImmListValueJs : public SharedPtrWrapBase<ImmListValueJs, org::imm::ImmListValue> {
  using SharedPtrWrapBase<ImmListValueJs, org::imm::ImmListValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmListValueJs", {}); }
};

template <>
struct js_to_org_type<ImmListValueJs> {
  using type = org::imm::ImmListValue;
};

template <>
struct org_to_js_type<org::imm::ImmListValue> {
  using type = ImmListValueJs;
};

struct ImmListItemValueJs : public SharedPtrWrapBase<ImmListItemValueJs, org::imm::ImmListItemValue> {
  using SharedPtrWrapBase<ImmListItemValueJs, org::imm::ImmListItemValue>::SharedPtrWrapBase;
  Napi::Value getCheckbox(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmListItem::Checkbox const&(org::imm::ImmListItemValue::*)() const>(&org::imm::ImmListItemValue::getCheckbox),
                                        std::make_tuple()));
  }
  Napi::Value getHeader(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&(org::imm::ImmListItemValue::*)() const>(&org::imm::ImmListItemValue::getHeader),
                                        std::make_tuple()));
  }
  Napi::Value getBullet(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmListItemValue::*)() const>(&org::imm::ImmListItemValue::getBullet),
                                        std::make_tuple()));
  }
  Napi::Value setCheckbox(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmListItemValue::*)(org::imm::ImmListItem::Checkbox const&)>(&org::imm::ImmListItemValue::setCheckbox),
                                   std::make_tuple(CxxArgSpec<org::imm::ImmListItem::Checkbox>{"value"})));
  }
  Napi::Value setHeader(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmListItemValue::*)(immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&)>(&org::imm::ImmListItemValue::setHeader),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>>>{"value"})));
  }
  Napi::Value setBullet(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmListItemValue::*)(immer::box<std::optional<hstd::Str>> const&)>(&org::imm::ImmListItemValue::setBullet),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::Str>>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmListItemValueJs", {InstanceMethod("getCheckbox", &ImmListItemValueJs::getCheckbox),
                                                                                                                             InstanceMethod("getHeader", &ImmListItemValueJs::getHeader),
                                                                                                                             InstanceMethod("getBullet", &ImmListItemValueJs::getBullet),
                                                                                                                             InstanceMethod("setCheckbox", &ImmListItemValueJs::setCheckbox),
                                                                                                                             InstanceMethod("setHeader", &ImmListItemValueJs::setHeader),
                                                                                                                             InstanceMethod("setBullet", &ImmListItemValueJs::setBullet)}); }
};

template <>
struct js_to_org_type<ImmListItemValueJs> {
  using type = org::imm::ImmListItemValue;
};

template <>
struct org_to_js_type<org::imm::ImmListItemValue> {
  using type = ImmListItemValueJs;
};

struct ImmDocumentOptionsValueJs : public SharedPtrWrapBase<ImmDocumentOptionsValueJs, org::imm::ImmDocumentOptionsValue> {
  using SharedPtrWrapBase<ImmDocumentOptionsValueJs, org::imm::ImmDocumentOptionsValue>::SharedPtrWrapBase;
  Napi::Value getInitialvisibility(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<InitialSubtreeVisibility const&(org::imm::ImmDocumentOptionsValue::*)() const>(&org::imm::ImmDocumentOptionsValue::getInitialvisibility),
                                        std::make_tuple()));
  }
  Napi::Value getProperties(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::sem::NamedProperty> const&(org::imm::ImmDocumentOptionsValue::*)() const>(&org::imm::ImmDocumentOptionsValue::getProperties),
                                        std::make_tuple()));
  }
  Napi::Value getExportconfig(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::DocumentExportConfig const&(org::imm::ImmDocumentOptionsValue::*)() const>(&org::imm::ImmDocumentOptionsValue::getExportconfig),
                                        std::make_tuple()));
  }
  Napi::Value getFixedwidthsections(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<bool>> const&(org::imm::ImmDocumentOptionsValue::*)() const>(&org::imm::ImmDocumentOptionsValue::getFixedwidthsections),
                                        std::make_tuple()));
  }
  Napi::Value getStartupindented(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<bool>> const&(org::imm::ImmDocumentOptionsValue::*)() const>(&org::imm::ImmDocumentOptionsValue::getStartupindented),
                                        std::make_tuple()));
  }
  Napi::Value getCategory(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmDocumentOptionsValue::*)() const>(&org::imm::ImmDocumentOptionsValue::getCategory),
                                        std::make_tuple()));
  }
  Napi::Value getSetupfile(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmDocumentOptionsValue::*)() const>(&org::imm::ImmDocumentOptionsValue::getSetupfile),
                                        std::make_tuple()));
  }
  Napi::Value getMaxsubtreelevelexport(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<int>> const&(org::imm::ImmDocumentOptionsValue::*)() const>(&org::imm::ImmDocumentOptionsValue::getMaxsubtreelevelexport),
                                        std::make_tuple()));
  }
  Napi::Value getColumns(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::sem::ColumnView>> const&(org::imm::ImmDocumentOptionsValue::*)() const>(&org::imm::ImmDocumentOptionsValue::getColumns),
                                        std::make_tuple()));
  }
  Napi::Value setInitialvisibility(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentOptionsValue::*)(InitialSubtreeVisibility const&)>(&org::imm::ImmDocumentOptionsValue::setInitialvisibility),
                                   std::make_tuple(CxxArgSpec<InitialSubtreeVisibility>{"value"})));
  }
  Napi::Value setProperties(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentOptionsValue::*)(immer::flex_vector<org::sem::NamedProperty> const&)>(&org::imm::ImmDocumentOptionsValue::setProperties),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<org::sem::NamedProperty>>{"value"})));
  }
  Napi::Value setExportconfig(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentOptionsValue::*)(org::sem::DocumentExportConfig const&)>(&org::imm::ImmDocumentOptionsValue::setExportconfig),
                                   std::make_tuple(CxxArgSpec<org::sem::DocumentExportConfig>{"value"})));
  }
  Napi::Value setFixedwidthsections(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentOptionsValue::*)(immer::box<std::optional<bool>> const&)>(&org::imm::ImmDocumentOptionsValue::setFixedwidthsections),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<bool>>>{"value"})));
  }
  Napi::Value setStartupindented(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentOptionsValue::*)(immer::box<std::optional<bool>> const&)>(&org::imm::ImmDocumentOptionsValue::setStartupindented),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<bool>>>{"value"})));
  }
  Napi::Value setCategory(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentOptionsValue::*)(immer::box<std::optional<hstd::Str>> const&)>(&org::imm::ImmDocumentOptionsValue::setCategory),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::Str>>>{"value"})));
  }
  Napi::Value setSetupfile(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentOptionsValue::*)(immer::box<std::optional<hstd::Str>> const&)>(&org::imm::ImmDocumentOptionsValue::setSetupfile),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::Str>>>{"value"})));
  }
  Napi::Value setMaxsubtreelevelexport(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentOptionsValue::*)(immer::box<std::optional<int>> const&)>(&org::imm::ImmDocumentOptionsValue::setMaxsubtreelevelexport),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<int>>>{"value"})));
  }
  Napi::Value setColumns(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentOptionsValue::*)(immer::box<std::optional<org::sem::ColumnView>> const&)>(&org::imm::ImmDocumentOptionsValue::setColumns),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<org::sem::ColumnView>>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmDocumentOptionsValueJs", {InstanceMethod("getInitialvisibility", &ImmDocumentOptionsValueJs::getInitialvisibility),
                                                                                                                                    InstanceMethod("getProperties", &ImmDocumentOptionsValueJs::getProperties),
                                                                                                                                    InstanceMethod("getExportconfig", &ImmDocumentOptionsValueJs::getExportconfig),
                                                                                                                                    InstanceMethod("getFixedwidthsections", &ImmDocumentOptionsValueJs::getFixedwidthsections),
                                                                                                                                    InstanceMethod("getStartupindented", &ImmDocumentOptionsValueJs::getStartupindented),
                                                                                                                                    InstanceMethod("getCategory", &ImmDocumentOptionsValueJs::getCategory),
                                                                                                                                    InstanceMethod("getSetupfile", &ImmDocumentOptionsValueJs::getSetupfile),
                                                                                                                                    InstanceMethod("getMaxsubtreelevelexport", &ImmDocumentOptionsValueJs::getMaxsubtreelevelexport),
                                                                                                                                    InstanceMethod("getColumns", &ImmDocumentOptionsValueJs::getColumns),
                                                                                                                                    InstanceMethod("setInitialvisibility", &ImmDocumentOptionsValueJs::setInitialvisibility),
                                                                                                                                    InstanceMethod("setProperties", &ImmDocumentOptionsValueJs::setProperties),
                                                                                                                                    InstanceMethod("setExportconfig", &ImmDocumentOptionsValueJs::setExportconfig),
                                                                                                                                    InstanceMethod("setFixedwidthsections", &ImmDocumentOptionsValueJs::setFixedwidthsections),
                                                                                                                                    InstanceMethod("setStartupindented", &ImmDocumentOptionsValueJs::setStartupindented),
                                                                                                                                    InstanceMethod("setCategory", &ImmDocumentOptionsValueJs::setCategory),
                                                                                                                                    InstanceMethod("setSetupfile", &ImmDocumentOptionsValueJs::setSetupfile),
                                                                                                                                    InstanceMethod("setMaxsubtreelevelexport", &ImmDocumentOptionsValueJs::setMaxsubtreelevelexport),
                                                                                                                                    InstanceMethod("setColumns", &ImmDocumentOptionsValueJs::setColumns)}); }
};

template <>
struct js_to_org_type<ImmDocumentOptionsValueJs> {
  using type = org::imm::ImmDocumentOptionsValue;
};

template <>
struct org_to_js_type<org::imm::ImmDocumentOptionsValue> {
  using type = ImmDocumentOptionsValueJs;
};

struct ImmDocumentFragmentValueJs : public SharedPtrWrapBase<ImmDocumentFragmentValueJs, org::imm::ImmDocumentFragmentValue> {
  using SharedPtrWrapBase<ImmDocumentFragmentValueJs, org::imm::ImmDocumentFragmentValue>::SharedPtrWrapBase;
  Napi::Value getBaseline(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int const&(org::imm::ImmDocumentFragmentValue::*)() const>(&org::imm::ImmDocumentFragmentValue::getBaseline),
                                        std::make_tuple()));
  }
  Napi::Value getBasecol(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int const&(org::imm::ImmDocumentFragmentValue::*)() const>(&org::imm::ImmDocumentFragmentValue::getBasecol),
                                        std::make_tuple()));
  }
  Napi::Value setBaseline(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentFragmentValue::*)(int const&)>(&org::imm::ImmDocumentFragmentValue::setBaseline),
                                   std::make_tuple(CxxArgSpec<int>{"value"})));
  }
  Napi::Value setBasecol(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentFragmentValue::*)(int const&)>(&org::imm::ImmDocumentFragmentValue::setBasecol),
                                   std::make_tuple(CxxArgSpec<int>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmDocumentFragmentValueJs", {InstanceMethod("getBaseline", &ImmDocumentFragmentValueJs::getBaseline),
                                                                                                                                     InstanceMethod("getBasecol", &ImmDocumentFragmentValueJs::getBasecol),
                                                                                                                                     InstanceMethod("setBaseline", &ImmDocumentFragmentValueJs::setBaseline),
                                                                                                                                     InstanceMethod("setBasecol", &ImmDocumentFragmentValueJs::setBasecol)}); }
};

template <>
struct js_to_org_type<ImmDocumentFragmentValueJs> {
  using type = org::imm::ImmDocumentFragmentValue;
};

template <>
struct org_to_js_type<org::imm::ImmDocumentFragmentValue> {
  using type = ImmDocumentFragmentValueJs;
};

struct ImmCriticMarkupValueJs : public SharedPtrWrapBase<ImmCriticMarkupValueJs, org::imm::ImmCriticMarkupValue> {
  using SharedPtrWrapBase<ImmCriticMarkupValueJs, org::imm::ImmCriticMarkupValue>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCriticMarkup::Kind const&(org::imm::ImmCriticMarkupValue::*)() const>(&org::imm::ImmCriticMarkupValue::getKind),
                                        std::make_tuple()));
  }
  Napi::Value setKind(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCriticMarkupValue::*)(org::imm::ImmCriticMarkup::Kind const&)>(&org::imm::ImmCriticMarkupValue::setKind),
                                   std::make_tuple(CxxArgSpec<org::imm::ImmCriticMarkup::Kind>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCriticMarkupValueJs", {InstanceMethod("getKind", &ImmCriticMarkupValueJs::getKind),
                                                                                                                                 InstanceMethod("setKind", &ImmCriticMarkupValueJs::setKind)}); }
};

template <>
struct js_to_org_type<ImmCriticMarkupValueJs> {
  using type = org::imm::ImmCriticMarkupValue;
};

template <>
struct org_to_js_type<org::imm::ImmCriticMarkupValue> {
  using type = ImmCriticMarkupValueJs;
};

struct ImmDocumentValueJs : public SharedPtrWrapBase<ImmDocumentValueJs, org::imm::ImmDocumentValue> {
  using SharedPtrWrapBase<ImmDocumentValueJs, org::imm::ImmDocumentValue>::SharedPtrWrapBase;
  Napi::Value getTitle(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&(org::imm::ImmDocumentValue::*)() const>(&org::imm::ImmDocumentValue::getTitle),
                                        std::make_tuple()));
  }
  Napi::Value getAuthor(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&(org::imm::ImmDocumentValue::*)() const>(&org::imm::ImmDocumentValue::getAuthor),
                                        std::make_tuple()));
  }
  Napi::Value getCreator(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&(org::imm::ImmDocumentValue::*)() const>(&org::imm::ImmDocumentValue::getCreator),
                                        std::make_tuple()));
  }
  Napi::Value getFiletags(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmHashTag>> const&(org::imm::ImmDocumentValue::*)() const>(&org::imm::ImmDocumentValue::getFiletags),
                                        std::make_tuple()));
  }
  Napi::Value getEmail(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmRawText>>> const&(org::imm::ImmDocumentValue::*)() const>(&org::imm::ImmDocumentValue::getEmail),
                                        std::make_tuple()));
  }
  Napi::Value getLanguage(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::flex_vector<hstd::Str> const&(org::imm::ImmDocumentValue::*)() const>(&org::imm::ImmDocumentValue::getLanguage),
                                        std::make_tuple()));
  }
  Napi::Value getOptions(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmIdT<org::imm::ImmDocumentOptions> const&(org::imm::ImmDocumentValue::*)() const>(&org::imm::ImmDocumentValue::getOptions),
                                        std::make_tuple()));
  }
  Napi::Value getExportfilename(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmDocumentValue::*)() const>(&org::imm::ImmDocumentValue::getExportfilename),
                                        std::make_tuple()));
  }
  Napi::Value setTitle(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentValue::*)(immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&)>(&org::imm::ImmDocumentValue::setTitle),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>>>{"value"})));
  }
  Napi::Value setAuthor(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentValue::*)(immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&)>(&org::imm::ImmDocumentValue::setAuthor),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>>>{"value"})));
  }
  Napi::Value setCreator(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentValue::*)(immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>> const&)>(&org::imm::ImmDocumentValue::setCreator),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>>>{"value"})));
  }
  Napi::Value setFiletags(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentValue::*)(immer::flex_vector<org::imm::ImmIdT<org::imm::ImmHashTag>> const&)>(&org::imm::ImmDocumentValue::setFiletags),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<org::imm::ImmIdT<org::imm::ImmHashTag>>>{"value"})));
  }
  Napi::Value setEmail(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentValue::*)(immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmRawText>>> const&)>(&org::imm::ImmDocumentValue::setEmail),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<org::imm::ImmIdT<org::imm::ImmRawText>>>>{"value"})));
  }
  Napi::Value setLanguage(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentValue::*)(immer::flex_vector<hstd::Str> const&)>(&org::imm::ImmDocumentValue::setLanguage),
                                   std::make_tuple(CxxArgSpec<immer::flex_vector<hstd::Str>>{"value"})));
  }
  Napi::Value setOptions(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentValue::*)(org::imm::ImmIdT<org::imm::ImmDocumentOptions> const&)>(&org::imm::ImmDocumentValue::setOptions),
                                   std::make_tuple(CxxArgSpec<org::imm::ImmIdT<org::imm::ImmDocumentOptions>>{"value"})));
  }
  Napi::Value setExportfilename(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDocumentValue::*)(immer::box<std::optional<hstd::Str>> const&)>(&org::imm::ImmDocumentValue::setExportfilename),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::Str>>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmDocumentValueJs", {InstanceMethod("getTitle", &ImmDocumentValueJs::getTitle),
                                                                                                                             InstanceMethod("getAuthor", &ImmDocumentValueJs::getAuthor),
                                                                                                                             InstanceMethod("getCreator", &ImmDocumentValueJs::getCreator),
                                                                                                                             InstanceMethod("getFiletags", &ImmDocumentValueJs::getFiletags),
                                                                                                                             InstanceMethod("getEmail", &ImmDocumentValueJs::getEmail),
                                                                                                                             InstanceMethod("getLanguage", &ImmDocumentValueJs::getLanguage),
                                                                                                                             InstanceMethod("getOptions", &ImmDocumentValueJs::getOptions),
                                                                                                                             InstanceMethod("getExportfilename", &ImmDocumentValueJs::getExportfilename),
                                                                                                                             InstanceMethod("setTitle", &ImmDocumentValueJs::setTitle),
                                                                                                                             InstanceMethod("setAuthor", &ImmDocumentValueJs::setAuthor),
                                                                                                                             InstanceMethod("setCreator", &ImmDocumentValueJs::setCreator),
                                                                                                                             InstanceMethod("setFiletags", &ImmDocumentValueJs::setFiletags),
                                                                                                                             InstanceMethod("setEmail", &ImmDocumentValueJs::setEmail),
                                                                                                                             InstanceMethod("setLanguage", &ImmDocumentValueJs::setLanguage),
                                                                                                                             InstanceMethod("setOptions", &ImmDocumentValueJs::setOptions),
                                                                                                                             InstanceMethod("setExportfilename", &ImmDocumentValueJs::setExportfilename)}); }
};

template <>
struct js_to_org_type<ImmDocumentValueJs> {
  using type = org::imm::ImmDocumentValue;
};

template <>
struct org_to_js_type<org::imm::ImmDocumentValue> {
  using type = ImmDocumentValueJs;
};

struct ImmFileTargetValueJs : public SharedPtrWrapBase<ImmFileTargetValueJs, org::imm::ImmFileTargetValue> {
  using SharedPtrWrapBase<ImmFileTargetValueJs, org::imm::ImmFileTargetValue>::SharedPtrWrapBase;
  Napi::Value getPath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmFileTargetValue::*)() const>(&org::imm::ImmFileTargetValue::getPath),
                                        std::make_tuple()));
  }
  Napi::Value getLine(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<int>> const&(org::imm::ImmFileTargetValue::*)() const>(&org::imm::ImmFileTargetValue::getLine),
                                        std::make_tuple()));
  }
  Napi::Value getSearchtarget(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmFileTargetValue::*)() const>(&org::imm::ImmFileTargetValue::getSearchtarget),
                                        std::make_tuple()));
  }
  Napi::Value getRestricttoheadlines(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmFileTargetValue::*)() const>(&org::imm::ImmFileTargetValue::getRestricttoheadlines),
                                        std::make_tuple()));
  }
  Napi::Value getTargetid(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmFileTargetValue::*)() const>(&org::imm::ImmFileTargetValue::getTargetid),
                                        std::make_tuple()));
  }
  Napi::Value getRegexp(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<hstd::Str>> const&(org::imm::ImmFileTargetValue::*)() const>(&org::imm::ImmFileTargetValue::getRegexp),
                                        std::make_tuple()));
  }
  Napi::Value setPath(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmFileTargetValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmFileTargetValue::setPath),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setLine(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmFileTargetValue::*)(immer::box<std::optional<int>> const&)>(&org::imm::ImmFileTargetValue::setLine),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<int>>>{"value"})));
  }
  Napi::Value setSearchtarget(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmFileTargetValue::*)(immer::box<std::optional<hstd::Str>> const&)>(&org::imm::ImmFileTargetValue::setSearchtarget),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::Str>>>{"value"})));
  }
  Napi::Value setRestricttoheadlines(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmFileTargetValue::*)(bool const&)>(&org::imm::ImmFileTargetValue::setRestricttoheadlines),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  Napi::Value setTargetid(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmFileTargetValue::*)(immer::box<std::optional<hstd::Str>> const&)>(&org::imm::ImmFileTargetValue::setTargetid),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::Str>>>{"value"})));
  }
  Napi::Value setRegexp(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmFileTargetValue::*)(immer::box<std::optional<hstd::Str>> const&)>(&org::imm::ImmFileTargetValue::setRegexp),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<hstd::Str>>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmFileTargetValueJs", {InstanceMethod("getPath", &ImmFileTargetValueJs::getPath),
                                                                                                                               InstanceMethod("getLine", &ImmFileTargetValueJs::getLine),
                                                                                                                               InstanceMethod("getSearchtarget", &ImmFileTargetValueJs::getSearchtarget),
                                                                                                                               InstanceMethod("getRestricttoheadlines", &ImmFileTargetValueJs::getRestricttoheadlines),
                                                                                                                               InstanceMethod("getTargetid", &ImmFileTargetValueJs::getTargetid),
                                                                                                                               InstanceMethod("getRegexp", &ImmFileTargetValueJs::getRegexp),
                                                                                                                               InstanceMethod("setPath", &ImmFileTargetValueJs::setPath),
                                                                                                                               InstanceMethod("setLine", &ImmFileTargetValueJs::setLine),
                                                                                                                               InstanceMethod("setSearchtarget", &ImmFileTargetValueJs::setSearchtarget),
                                                                                                                               InstanceMethod("setRestricttoheadlines", &ImmFileTargetValueJs::setRestricttoheadlines),
                                                                                                                               InstanceMethod("setTargetid", &ImmFileTargetValueJs::setTargetid),
                                                                                                                               InstanceMethod("setRegexp", &ImmFileTargetValueJs::setRegexp)}); }
};

template <>
struct js_to_org_type<ImmFileTargetValueJs> {
  using type = org::imm::ImmFileTargetValue;
};

template <>
struct org_to_js_type<org::imm::ImmFileTargetValue> {
  using type = ImmFileTargetValueJs;
};

struct ImmTextSeparatorValueJs : public SharedPtrWrapBase<ImmTextSeparatorValueJs, org::imm::ImmTextSeparatorValue> {
  using SharedPtrWrapBase<ImmTextSeparatorValueJs, org::imm::ImmTextSeparatorValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmTextSeparatorValueJs", {}); }
};

template <>
struct js_to_org_type<ImmTextSeparatorValueJs> {
  using type = org::imm::ImmTextSeparatorValue;
};

template <>
struct org_to_js_type<org::imm::ImmTextSeparatorValue> {
  using type = ImmTextSeparatorValueJs;
};

struct ImmDocumentGroupValueJs : public SharedPtrWrapBase<ImmDocumentGroupValueJs, org::imm::ImmDocumentGroupValue> {
  using SharedPtrWrapBase<ImmDocumentGroupValueJs, org::imm::ImmDocumentGroupValue>::SharedPtrWrapBase;
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmDocumentGroupValueJs", {}); }
};

template <>
struct js_to_org_type<ImmDocumentGroupValueJs> {
  using type = org::imm::ImmDocumentGroupValue;
};

template <>
struct org_to_js_type<org::imm::ImmDocumentGroupValue> {
  using type = ImmDocumentGroupValueJs;
};

struct ImmFileValueJs : public SharedPtrWrapBase<ImmFileValueJs, org::imm::ImmFileValue> {
  using SharedPtrWrapBase<ImmFileValueJs, org::imm::ImmFileValue>::SharedPtrWrapBase;
  Napi::Value getRelpath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmFileValue::*)() const>(&org::imm::ImmFileValue::getRelpath),
                                        std::make_tuple()));
  }
  Napi::Value getAbspath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmFileValue::*)() const>(&org::imm::ImmFileValue::getAbspath),
                                        std::make_tuple()));
  }
  Napi::Value getData(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmFile::Data const&(org::imm::ImmFileValue::*)() const>(&org::imm::ImmFileValue::getData),
                                        std::make_tuple()));
  }
  Napi::Value setRelpath(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmFileValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmFileValue::setRelpath),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setAbspath(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmFileValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmFileValue::setAbspath),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setData(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmFileValue::*)(org::imm::ImmFile::Data const&)>(&org::imm::ImmFileValue::setData),
                                   std::make_tuple(CxxArgSpec<org::imm::ImmFile::Data>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmFileValueJs", {InstanceMethod("getRelpath", &ImmFileValueJs::getRelpath),
                                                                                                                         InstanceMethod("getAbspath", &ImmFileValueJs::getAbspath),
                                                                                                                         InstanceMethod("getData", &ImmFileValueJs::getData),
                                                                                                                         InstanceMethod("setRelpath", &ImmFileValueJs::setRelpath),
                                                                                                                         InstanceMethod("setAbspath", &ImmFileValueJs::setAbspath),
                                                                                                                         InstanceMethod("setData", &ImmFileValueJs::setData)}); }
};

template <>
struct js_to_org_type<ImmFileValueJs> {
  using type = org::imm::ImmFileValue;
};

template <>
struct org_to_js_type<org::imm::ImmFileValue> {
  using type = ImmFileValueJs;
};

struct ImmDirectoryValueJs : public SharedPtrWrapBase<ImmDirectoryValueJs, org::imm::ImmDirectoryValue> {
  using SharedPtrWrapBase<ImmDirectoryValueJs, org::imm::ImmDirectoryValue>::SharedPtrWrapBase;
  Napi::Value getRelpath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmDirectoryValue::*)() const>(&org::imm::ImmDirectoryValue::getRelpath),
                                        std::make_tuple()));
  }
  Napi::Value getAbspath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmDirectoryValue::*)() const>(&org::imm::ImmDirectoryValue::getAbspath),
                                        std::make_tuple()));
  }
  Napi::Value setRelpath(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDirectoryValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmDirectoryValue::setRelpath),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setAbspath(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmDirectoryValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmDirectoryValue::setAbspath),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmDirectoryValueJs", {InstanceMethod("getRelpath", &ImmDirectoryValueJs::getRelpath),
                                                                                                                              InstanceMethod("getAbspath", &ImmDirectoryValueJs::getAbspath),
                                                                                                                              InstanceMethod("setRelpath", &ImmDirectoryValueJs::setRelpath),
                                                                                                                              InstanceMethod("setAbspath", &ImmDirectoryValueJs::setAbspath)}); }
};

template <>
struct js_to_org_type<ImmDirectoryValueJs> {
  using type = org::imm::ImmDirectoryValue;
};

template <>
struct org_to_js_type<org::imm::ImmDirectoryValue> {
  using type = ImmDirectoryValueJs;
};

struct ImmSymlinkValueJs : public SharedPtrWrapBase<ImmSymlinkValueJs, org::imm::ImmSymlinkValue> {
  using SharedPtrWrapBase<ImmSymlinkValueJs, org::imm::ImmSymlinkValue>::SharedPtrWrapBase;
  Napi::Value getIsdirectory(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool const&(org::imm::ImmSymlinkValue::*)() const>(&org::imm::ImmSymlinkValue::getIsdirectory),
                                        std::make_tuple()));
  }
  Napi::Value getAbspath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmSymlinkValue::*)() const>(&org::imm::ImmSymlinkValue::getAbspath),
                                        std::make_tuple()));
  }
  Napi::Value setIsdirectory(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSymlinkValue::*)(bool const&)>(&org::imm::ImmSymlinkValue::setIsdirectory),
                                   std::make_tuple(CxxArgSpec<bool>{"value"})));
  }
  Napi::Value setAbspath(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmSymlinkValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmSymlinkValue::setAbspath),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmSymlinkValueJs", {InstanceMethod("getIsdirectory", &ImmSymlinkValueJs::getIsdirectory),
                                                                                                                            InstanceMethod("getAbspath", &ImmSymlinkValueJs::getAbspath),
                                                                                                                            InstanceMethod("setIsdirectory", &ImmSymlinkValueJs::setIsdirectory),
                                                                                                                            InstanceMethod("setAbspath", &ImmSymlinkValueJs::setAbspath)}); }
};

template <>
struct js_to_org_type<ImmSymlinkValueJs> {
  using type = org::imm::ImmSymlinkValue;
};

template <>
struct org_to_js_type<org::imm::ImmSymlinkValue> {
  using type = ImmSymlinkValueJs;
};

struct ImmCmdIncludeValueJs : public SharedPtrWrapBase<ImmCmdIncludeValueJs, org::imm::ImmCmdIncludeValue> {
  using SharedPtrWrapBase<ImmCmdIncludeValueJs, org::imm::ImmCmdIncludeValue>::SharedPtrWrapBase;
  Napi::Value getPath(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<hstd::Str> const&(org::imm::ImmCmdIncludeValue::*)() const>(&org::imm::ImmCmdIncludeValue::getPath),
                                        std::make_tuple()));
  }
  Napi::Value getFirstline(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<int>> const&(org::imm::ImmCmdIncludeValue::*)() const>(&org::imm::ImmCmdIncludeValue::getFirstline),
                                        std::make_tuple()));
  }
  Napi::Value getLastline(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<immer::box<std::optional<int>> const&(org::imm::ImmCmdIncludeValue::*)() const>(&org::imm::ImmCmdIncludeValue::getLastline),
                                        std::make_tuple()));
  }
  Napi::Value getData(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCmdInclude::Data const&(org::imm::ImmCmdIncludeValue::*)() const>(&org::imm::ImmCmdIncludeValue::getData),
                                        std::make_tuple()));
  }
  Napi::Value setPath(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdIncludeValue::*)(immer::box<hstd::Str> const&)>(&org::imm::ImmCmdIncludeValue::setPath),
                                   std::make_tuple(CxxArgSpec<immer::box<hstd::Str>>{"value"})));
  }
  Napi::Value setFirstline(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdIncludeValue::*)(immer::box<std::optional<int>> const&)>(&org::imm::ImmCmdIncludeValue::setFirstline),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<int>>>{"value"})));
  }
  Napi::Value setLastline(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdIncludeValue::*)(immer::box<std::optional<int>> const&)>(&org::imm::ImmCmdIncludeValue::setLastline),
                                   std::make_tuple(CxxArgSpec<immer::box<std::optional<int>>>{"value"})));
  }
  Napi::Value setData(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::imm::ImmCmdIncludeValue::*)(org::imm::ImmCmdInclude::Data const&)>(&org::imm::ImmCmdIncludeValue::setData),
                                   std::make_tuple(CxxArgSpec<org::imm::ImmCmdInclude::Data>{"value"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdIncludeValueJs", {InstanceMethod("getPath", &ImmCmdIncludeValueJs::getPath),
                                                                                                                               InstanceMethod("getFirstline", &ImmCmdIncludeValueJs::getFirstline),
                                                                                                                               InstanceMethod("getLastline", &ImmCmdIncludeValueJs::getLastline),
                                                                                                                               InstanceMethod("getData", &ImmCmdIncludeValueJs::getData),
                                                                                                                               InstanceMethod("setPath", &ImmCmdIncludeValueJs::setPath),
                                                                                                                               InstanceMethod("setFirstline", &ImmCmdIncludeValueJs::setFirstline),
                                                                                                                               InstanceMethod("setLastline", &ImmCmdIncludeValueJs::setLastline),
                                                                                                                               InstanceMethod("setData", &ImmCmdIncludeValueJs::setData)}); }
};

template <>
struct js_to_org_type<ImmCmdIncludeValueJs> {
  using type = org::imm::ImmCmdIncludeValue;
};

template <>
struct org_to_js_type<org::imm::ImmCmdIncludeValue> {
  using type = ImmCmdIncludeValueJs;
};

struct ImmCmdCustomRawJs : public SharedPtrWrapBase<ImmCmdCustomRawJs, org::imm::ImmCmdCustomRaw> {
  using SharedPtrWrapBase<ImmCmdCustomRawJs, org::imm::ImmCmdCustomRaw>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmCmdCustomRaw::*)(org::imm::ImmCmdCustomRaw const&) const>(&org::imm::ImmCmdCustomRaw::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmCmdCustomRaw>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmCmdCustomRaw::*)() const>(&org::imm::ImmCmdCustomRaw::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdCustomRawJs", {InstanceMethod("operator==", &ImmCmdCustomRawJs::operator==),
                                                                                                                            InstanceMethod("getKind", &ImmCmdCustomRawJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmCmdCustomRawJs> {
  using type = org::imm::ImmCmdCustomRaw;
};

template <>
struct org_to_js_type<org::imm::ImmCmdCustomRaw> {
  using type = ImmCmdCustomRawJs;
};

struct ImmCmdCustomTextJs : public SharedPtrWrapBase<ImmCmdCustomTextJs, org::imm::ImmCmdCustomText> {
  using SharedPtrWrapBase<ImmCmdCustomTextJs, org::imm::ImmCmdCustomText>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmCmdCustomText::*)(org::imm::ImmCmdCustomText const&) const>(&org::imm::ImmCmdCustomText::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmCmdCustomText>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmCmdCustomText::*)() const>(&org::imm::ImmCmdCustomText::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdCustomTextJs", {InstanceMethod("operator==", &ImmCmdCustomTextJs::operator==),
                                                                                                                             InstanceMethod("getKind", &ImmCmdCustomTextJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmCmdCustomTextJs> {
  using type = org::imm::ImmCmdCustomText;
};

template <>
struct org_to_js_type<org::imm::ImmCmdCustomText> {
  using type = ImmCmdCustomTextJs;
};

struct ImmLinkJs : public SharedPtrWrapBase<ImmLinkJs, org::imm::ImmLink> {
  using SharedPtrWrapBase<ImmLinkJs, org::imm::ImmLink>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmLink::*)(org::imm::ImmLink const&) const>(&org::imm::ImmLink::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmLink>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmLink::*)() const>(&org::imm::ImmLink::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmLinkJs", {InstanceMethod("operator==", &ImmLinkJs::operator==),
                                                                                                                    InstanceMethod("getKind", &ImmLinkJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmLinkJs> {
  using type = org::imm::ImmLink;
};

template <>
struct org_to_js_type<org::imm::ImmLink> {
  using type = ImmLinkJs;
};

struct ImmBlockCommentJs : public SharedPtrWrapBase<ImmBlockCommentJs, org::imm::ImmBlockComment> {
  using SharedPtrWrapBase<ImmBlockCommentJs, org::imm::ImmBlockComment>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmBlockComment::*)(org::imm::ImmBlockComment const&) const>(&org::imm::ImmBlockComment::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmBlockComment>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmBlockComment::*)() const>(&org::imm::ImmBlockComment::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockCommentJs", {InstanceMethod("operator==", &ImmBlockCommentJs::operator==),
                                                                                                                            InstanceMethod("getKind", &ImmBlockCommentJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmBlockCommentJs> {
  using type = org::imm::ImmBlockComment;
};

template <>
struct org_to_js_type<org::imm::ImmBlockComment> {
  using type = ImmBlockCommentJs;
};

struct ImmParagraphJs : public SharedPtrWrapBase<ImmParagraphJs, org::imm::ImmParagraph> {
  using SharedPtrWrapBase<ImmParagraphJs, org::imm::ImmParagraph>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmParagraph::*)(org::imm::ImmParagraph const&) const>(&org::imm::ImmParagraph::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmParagraph>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmParagraph::*)() const>(&org::imm::ImmParagraph::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmParagraphJs", {InstanceMethod("operator==", &ImmParagraphJs::operator==),
                                                                                                                         InstanceMethod("getKind", &ImmParagraphJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmParagraphJs> {
  using type = org::imm::ImmParagraph;
};

template <>
struct org_to_js_type<org::imm::ImmParagraph> {
  using type = ImmParagraphJs;
};

struct ImmListJs : public SharedPtrWrapBase<ImmListJs, org::imm::ImmList> {
  using SharedPtrWrapBase<ImmListJs, org::imm::ImmList>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmList::*)(org::imm::ImmList const&) const>(&org::imm::ImmList::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmList>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmList::*)() const>(&org::imm::ImmList::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmListJs", {InstanceMethod("operator==", &ImmListJs::operator==),
                                                                                                                    InstanceMethod("getKind", &ImmListJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmListJs> {
  using type = org::imm::ImmList;
};

template <>
struct org_to_js_type<org::imm::ImmList> {
  using type = ImmListJs;
};

struct ImmHashTagJs : public SharedPtrWrapBase<ImmHashTagJs, org::imm::ImmHashTag> {
  using SharedPtrWrapBase<ImmHashTagJs, org::imm::ImmHashTag>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmHashTag::*)(org::imm::ImmHashTag const&) const>(&org::imm::ImmHashTag::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmHashTag>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmHashTag::*)() const>(&org::imm::ImmHashTag::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmHashTagJs", {InstanceMethod("operator==", &ImmHashTagJs::operator==),
                                                                                                                       InstanceMethod("getKind", &ImmHashTagJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmHashTagJs> {
  using type = org::imm::ImmHashTag;
};

template <>
struct org_to_js_type<org::imm::ImmHashTag> {
  using type = ImmHashTagJs;
};

struct ImmInlineFootnoteJs : public SharedPtrWrapBase<ImmInlineFootnoteJs, org::imm::ImmInlineFootnote> {
  using SharedPtrWrapBase<ImmInlineFootnoteJs, org::imm::ImmInlineFootnote>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmInlineFootnote::*)(org::imm::ImmInlineFootnote const&) const>(&org::imm::ImmInlineFootnote::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmInlineFootnote>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmInlineFootnote::*)() const>(&org::imm::ImmInlineFootnote::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmInlineFootnoteJs", {InstanceMethod("operator==", &ImmInlineFootnoteJs::operator==),
                                                                                                                              InstanceMethod("getKind", &ImmInlineFootnoteJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmInlineFootnoteJs> {
  using type = org::imm::ImmInlineFootnote;
};

template <>
struct org_to_js_type<org::imm::ImmInlineFootnote> {
  using type = ImmInlineFootnoteJs;
};

struct ImmInlineExportJs : public SharedPtrWrapBase<ImmInlineExportJs, org::imm::ImmInlineExport> {
  using SharedPtrWrapBase<ImmInlineExportJs, org::imm::ImmInlineExport>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmInlineExport::*)(org::imm::ImmInlineExport const&) const>(&org::imm::ImmInlineExport::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmInlineExport>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmInlineExport::*)() const>(&org::imm::ImmInlineExport::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmInlineExportJs", {InstanceMethod("operator==", &ImmInlineExportJs::operator==),
                                                                                                                            InstanceMethod("getKind", &ImmInlineExportJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmInlineExportJs> {
  using type = org::imm::ImmInlineExport;
};

template <>
struct org_to_js_type<org::imm::ImmInlineExport> {
  using type = ImmInlineExportJs;
};

struct ImmEscapedJs : public SharedPtrWrapBase<ImmEscapedJs, org::imm::ImmEscaped> {
  using SharedPtrWrapBase<ImmEscapedJs, org::imm::ImmEscaped>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmEscaped::*)(org::imm::ImmEscaped const&) const>(&org::imm::ImmEscaped::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmEscaped>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmEscaped::*)() const>(&org::imm::ImmEscaped::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmEscapedJs", {InstanceMethod("operator==", &ImmEscapedJs::operator==),
                                                                                                                       InstanceMethod("getKind", &ImmEscapedJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmEscapedJs> {
  using type = org::imm::ImmEscaped;
};

template <>
struct org_to_js_type<org::imm::ImmEscaped> {
  using type = ImmEscapedJs;
};

struct ImmNewlineJs : public SharedPtrWrapBase<ImmNewlineJs, org::imm::ImmNewline> {
  using SharedPtrWrapBase<ImmNewlineJs, org::imm::ImmNewline>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmNewline::*)(org::imm::ImmNewline const&) const>(&org::imm::ImmNewline::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmNewline>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmNewline::*)() const>(&org::imm::ImmNewline::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmNewlineJs", {InstanceMethod("operator==", &ImmNewlineJs::operator==),
                                                                                                                       InstanceMethod("getKind", &ImmNewlineJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmNewlineJs> {
  using type = org::imm::ImmNewline;
};

template <>
struct org_to_js_type<org::imm::ImmNewline> {
  using type = ImmNewlineJs;
};

struct ImmSpaceJs : public SharedPtrWrapBase<ImmSpaceJs, org::imm::ImmSpace> {
  using SharedPtrWrapBase<ImmSpaceJs, org::imm::ImmSpace>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmSpace::*)(org::imm::ImmSpace const&) const>(&org::imm::ImmSpace::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmSpace>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmSpace::*)() const>(&org::imm::ImmSpace::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmSpaceJs", {InstanceMethod("operator==", &ImmSpaceJs::operator==),
                                                                                                                     InstanceMethod("getKind", &ImmSpaceJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmSpaceJs> {
  using type = org::imm::ImmSpace;
};

template <>
struct org_to_js_type<org::imm::ImmSpace> {
  using type = ImmSpaceJs;
};

struct ImmWordJs : public SharedPtrWrapBase<ImmWordJs, org::imm::ImmWord> {
  using SharedPtrWrapBase<ImmWordJs, org::imm::ImmWord>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmWord::*)(org::imm::ImmWord const&) const>(&org::imm::ImmWord::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmWord>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmWord::*)() const>(&org::imm::ImmWord::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmWordJs", {InstanceMethod("operator==", &ImmWordJs::operator==),
                                                                                                                    InstanceMethod("getKind", &ImmWordJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmWordJs> {
  using type = org::imm::ImmWord;
};

template <>
struct org_to_js_type<org::imm::ImmWord> {
  using type = ImmWordJs;
};

struct ImmAtMentionJs : public SharedPtrWrapBase<ImmAtMentionJs, org::imm::ImmAtMention> {
  using SharedPtrWrapBase<ImmAtMentionJs, org::imm::ImmAtMention>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmAtMention::*)(org::imm::ImmAtMention const&) const>(&org::imm::ImmAtMention::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmAtMention>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmAtMention::*)() const>(&org::imm::ImmAtMention::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmAtMentionJs", {InstanceMethod("operator==", &ImmAtMentionJs::operator==),
                                                                                                                         InstanceMethod("getKind", &ImmAtMentionJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmAtMentionJs> {
  using type = org::imm::ImmAtMention;
};

template <>
struct org_to_js_type<org::imm::ImmAtMention> {
  using type = ImmAtMentionJs;
};

struct ImmRawTextJs : public SharedPtrWrapBase<ImmRawTextJs, org::imm::ImmRawText> {
  using SharedPtrWrapBase<ImmRawTextJs, org::imm::ImmRawText>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmRawText::*)(org::imm::ImmRawText const&) const>(&org::imm::ImmRawText::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmRawText>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmRawText::*)() const>(&org::imm::ImmRawText::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmRawTextJs", {InstanceMethod("operator==", &ImmRawTextJs::operator==),
                                                                                                                       InstanceMethod("getKind", &ImmRawTextJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmRawTextJs> {
  using type = org::imm::ImmRawText;
};

template <>
struct org_to_js_type<org::imm::ImmRawText> {
  using type = ImmRawTextJs;
};

struct ImmPunctuationJs : public SharedPtrWrapBase<ImmPunctuationJs, org::imm::ImmPunctuation> {
  using SharedPtrWrapBase<ImmPunctuationJs, org::imm::ImmPunctuation>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmPunctuation::*)(org::imm::ImmPunctuation const&) const>(&org::imm::ImmPunctuation::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmPunctuation>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmPunctuation::*)() const>(&org::imm::ImmPunctuation::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmPunctuationJs", {InstanceMethod("operator==", &ImmPunctuationJs::operator==),
                                                                                                                           InstanceMethod("getKind", &ImmPunctuationJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmPunctuationJs> {
  using type = org::imm::ImmPunctuation;
};

template <>
struct org_to_js_type<org::imm::ImmPunctuation> {
  using type = ImmPunctuationJs;
};

struct ImmPlaceholderJs : public SharedPtrWrapBase<ImmPlaceholderJs, org::imm::ImmPlaceholder> {
  using SharedPtrWrapBase<ImmPlaceholderJs, org::imm::ImmPlaceholder>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmPlaceholder::*)(org::imm::ImmPlaceholder const&) const>(&org::imm::ImmPlaceholder::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmPlaceholder>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmPlaceholder::*)() const>(&org::imm::ImmPlaceholder::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmPlaceholderJs", {InstanceMethod("operator==", &ImmPlaceholderJs::operator==),
                                                                                                                           InstanceMethod("getKind", &ImmPlaceholderJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmPlaceholderJs> {
  using type = org::imm::ImmPlaceholder;
};

template <>
struct org_to_js_type<org::imm::ImmPlaceholder> {
  using type = ImmPlaceholderJs;
};

struct ImmBigIdentJs : public SharedPtrWrapBase<ImmBigIdentJs, org::imm::ImmBigIdent> {
  using SharedPtrWrapBase<ImmBigIdentJs, org::imm::ImmBigIdent>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmBigIdent::*)(org::imm::ImmBigIdent const&) const>(&org::imm::ImmBigIdent::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmBigIdent>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmBigIdent::*)() const>(&org::imm::ImmBigIdent::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBigIdentJs", {InstanceMethod("operator==", &ImmBigIdentJs::operator==),
                                                                                                                        InstanceMethod("getKind", &ImmBigIdentJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmBigIdentJs> {
  using type = org::imm::ImmBigIdent;
};

template <>
struct org_to_js_type<org::imm::ImmBigIdent> {
  using type = ImmBigIdentJs;
};

struct ImmTextTargetJs : public SharedPtrWrapBase<ImmTextTargetJs, org::imm::ImmTextTarget> {
  using SharedPtrWrapBase<ImmTextTargetJs, org::imm::ImmTextTarget>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmTextTarget::*)(org::imm::ImmTextTarget const&) const>(&org::imm::ImmTextTarget::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmTextTarget>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmTextTarget::*)() const>(&org::imm::ImmTextTarget::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmTextTargetJs", {InstanceMethod("operator==", &ImmTextTargetJs::operator==),
                                                                                                                          InstanceMethod("getKind", &ImmTextTargetJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmTextTargetJs> {
  using type = org::imm::ImmTextTarget;
};

template <>
struct org_to_js_type<org::imm::ImmTextTarget> {
  using type = ImmTextTargetJs;
};

struct ImmBoldJs : public SharedPtrWrapBase<ImmBoldJs, org::imm::ImmBold> {
  using SharedPtrWrapBase<ImmBoldJs, org::imm::ImmBold>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmBold::*)(org::imm::ImmBold const&) const>(&org::imm::ImmBold::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmBold>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmBold::*)() const>(&org::imm::ImmBold::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBoldJs", {InstanceMethod("operator==", &ImmBoldJs::operator==),
                                                                                                                    InstanceMethod("getKind", &ImmBoldJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmBoldJs> {
  using type = org::imm::ImmBold;
};

template <>
struct org_to_js_type<org::imm::ImmBold> {
  using type = ImmBoldJs;
};

struct ImmUnderlineJs : public SharedPtrWrapBase<ImmUnderlineJs, org::imm::ImmUnderline> {
  using SharedPtrWrapBase<ImmUnderlineJs, org::imm::ImmUnderline>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmUnderline::*)(org::imm::ImmUnderline const&) const>(&org::imm::ImmUnderline::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmUnderline>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmUnderline::*)() const>(&org::imm::ImmUnderline::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmUnderlineJs", {InstanceMethod("operator==", &ImmUnderlineJs::operator==),
                                                                                                                         InstanceMethod("getKind", &ImmUnderlineJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmUnderlineJs> {
  using type = org::imm::ImmUnderline;
};

template <>
struct org_to_js_type<org::imm::ImmUnderline> {
  using type = ImmUnderlineJs;
};

struct ImmMonospaceJs : public SharedPtrWrapBase<ImmMonospaceJs, org::imm::ImmMonospace> {
  using SharedPtrWrapBase<ImmMonospaceJs, org::imm::ImmMonospace>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmMonospace::*)(org::imm::ImmMonospace const&) const>(&org::imm::ImmMonospace::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmMonospace>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmMonospace::*)() const>(&org::imm::ImmMonospace::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmMonospaceJs", {InstanceMethod("operator==", &ImmMonospaceJs::operator==),
                                                                                                                         InstanceMethod("getKind", &ImmMonospaceJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmMonospaceJs> {
  using type = org::imm::ImmMonospace;
};

template <>
struct org_to_js_type<org::imm::ImmMonospace> {
  using type = ImmMonospaceJs;
};

struct ImmMarkQuoteJs : public SharedPtrWrapBase<ImmMarkQuoteJs, org::imm::ImmMarkQuote> {
  using SharedPtrWrapBase<ImmMarkQuoteJs, org::imm::ImmMarkQuote>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmMarkQuote::*)(org::imm::ImmMarkQuote const&) const>(&org::imm::ImmMarkQuote::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmMarkQuote>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmMarkQuote::*)() const>(&org::imm::ImmMarkQuote::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmMarkQuoteJs", {InstanceMethod("operator==", &ImmMarkQuoteJs::operator==),
                                                                                                                         InstanceMethod("getKind", &ImmMarkQuoteJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmMarkQuoteJs> {
  using type = org::imm::ImmMarkQuote;
};

template <>
struct org_to_js_type<org::imm::ImmMarkQuote> {
  using type = ImmMarkQuoteJs;
};

struct ImmVerbatimJs : public SharedPtrWrapBase<ImmVerbatimJs, org::imm::ImmVerbatim> {
  using SharedPtrWrapBase<ImmVerbatimJs, org::imm::ImmVerbatim>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmVerbatim::*)(org::imm::ImmVerbatim const&) const>(&org::imm::ImmVerbatim::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmVerbatim>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmVerbatim::*)() const>(&org::imm::ImmVerbatim::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmVerbatimJs", {InstanceMethod("operator==", &ImmVerbatimJs::operator==),
                                                                                                                        InstanceMethod("getKind", &ImmVerbatimJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmVerbatimJs> {
  using type = org::imm::ImmVerbatim;
};

template <>
struct org_to_js_type<org::imm::ImmVerbatim> {
  using type = ImmVerbatimJs;
};

struct ImmItalicJs : public SharedPtrWrapBase<ImmItalicJs, org::imm::ImmItalic> {
  using SharedPtrWrapBase<ImmItalicJs, org::imm::ImmItalic>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmItalic::*)(org::imm::ImmItalic const&) const>(&org::imm::ImmItalic::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmItalic>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmItalic::*)() const>(&org::imm::ImmItalic::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmItalicJs", {InstanceMethod("operator==", &ImmItalicJs::operator==),
                                                                                                                      InstanceMethod("getKind", &ImmItalicJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmItalicJs> {
  using type = org::imm::ImmItalic;
};

template <>
struct org_to_js_type<org::imm::ImmItalic> {
  using type = ImmItalicJs;
};

struct ImmStrikeJs : public SharedPtrWrapBase<ImmStrikeJs, org::imm::ImmStrike> {
  using SharedPtrWrapBase<ImmStrikeJs, org::imm::ImmStrike>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmStrike::*)(org::imm::ImmStrike const&) const>(&org::imm::ImmStrike::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmStrike>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmStrike::*)() const>(&org::imm::ImmStrike::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmStrikeJs", {InstanceMethod("operator==", &ImmStrikeJs::operator==),
                                                                                                                      InstanceMethod("getKind", &ImmStrikeJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmStrikeJs> {
  using type = org::imm::ImmStrike;
};

template <>
struct org_to_js_type<org::imm::ImmStrike> {
  using type = ImmStrikeJs;
};

struct ImmParJs : public SharedPtrWrapBase<ImmParJs, org::imm::ImmPar> {
  using SharedPtrWrapBase<ImmParJs, org::imm::ImmPar>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmPar::*)(org::imm::ImmPar const&) const>(&org::imm::ImmPar::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmPar>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmPar::*)() const>(&org::imm::ImmPar::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmParJs", {InstanceMethod("operator==", &ImmParJs::operator==),
                                                                                                                   InstanceMethod("getKind", &ImmParJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmParJs> {
  using type = org::imm::ImmPar;
};

template <>
struct org_to_js_type<org::imm::ImmPar> {
  using type = ImmParJs;
};

struct CmdCustomRawJs : public SharedPtrWrapBase<CmdCustomRawJs, org::sem::CmdCustomRaw> {
  using SharedPtrWrapBase<CmdCustomRawJs, org::sem::CmdCustomRaw>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::CmdCustomRaw::*)() const>(&org::sem::CmdCustomRaw::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdCustomRaw::*)() const>(&org::sem::CmdCustomRaw::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdCustomRaw::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::CmdCustomRaw::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::CmdCustomRaw::*)() const>(&org::sem::CmdCustomRaw::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdCustomRaw::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::CmdCustomRaw::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::CmdCustomRaw::*)(int) const>(&org::sem::CmdCustomRaw::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdCustomRaw::*)(OrgSemKind) const>(&org::sem::CmdCustomRaw::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdCustomRaw::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdCustomRaw::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdCustomRaw::*)() const>(&org::sem::CmdCustomRaw::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::CmdCustomRaw::*)() const>(&org::sem::CmdCustomRaw::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::CmdCustomRaw::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdCustomRaw::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::CmdCustomRaw::*)(hstd::Str const&) const>(&org::sem::CmdCustomRaw::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "CmdCustomRawJs", {InstanceMethod("getKind", &CmdCustomRawJs::getKind),
                                                                                                                         InstanceMethod("isGenerated", &CmdCustomRawJs::isGenerated),
                                                                                                                         InstanceMethod("push_back", &CmdCustomRawJs::push_back),
                                                                                                                         InstanceMethod("size", &CmdCustomRawJs::size),
                                                                                                                         InstanceMethod("insert", &CmdCustomRawJs::insert),
                                                                                                                         InstanceMethod("at", &CmdCustomRawJs::at),
                                                                                                                         InstanceMethod("is", &CmdCustomRawJs::is),
                                                                                                                         InstanceMethod("getAttached", &CmdCustomRawJs::getAttached),
                                                                                                                         InstanceMethod("getCaption", &CmdCustomRawJs::getCaption),
                                                                                                                         InstanceMethod("getName", &CmdCustomRawJs::getName),
                                                                                                                         InstanceMethod("getAttrs", &CmdCustomRawJs::getAttrs),
                                                                                                                         InstanceMethod("getFirstAttr", &CmdCustomRawJs::getFirstAttr)}); }
};

template <>
struct js_to_org_type<CmdCustomRawJs> {
  using type = org::sem::CmdCustomRaw;
};

template <>
struct org_to_js_type<org::sem::CmdCustomRaw> {
  using type = CmdCustomRawJs;
};

struct CmdCustomTextJs : public SharedPtrWrapBase<CmdCustomTextJs, org::sem::CmdCustomText> {
  using SharedPtrWrapBase<CmdCustomTextJs, org::sem::CmdCustomText>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::CmdCustomText::*)() const>(&org::sem::CmdCustomText::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdCustomText::*)() const>(&org::sem::CmdCustomText::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdCustomText::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::CmdCustomText::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::CmdCustomText::*)() const>(&org::sem::CmdCustomText::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdCustomText::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::CmdCustomText::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::CmdCustomText::*)(int) const>(&org::sem::CmdCustomText::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdCustomText::*)(OrgSemKind) const>(&org::sem::CmdCustomText::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdCustomText::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdCustomText::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdCustomText::*)() const>(&org::sem::CmdCustomText::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::CmdCustomText::*)() const>(&org::sem::CmdCustomText::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::CmdCustomText::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdCustomText::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::CmdCustomText::*)(hstd::Str const&) const>(&org::sem::CmdCustomText::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "CmdCustomTextJs", {InstanceMethod("getKind", &CmdCustomTextJs::getKind),
                                                                                                                          InstanceMethod("isGenerated", &CmdCustomTextJs::isGenerated),
                                                                                                                          InstanceMethod("push_back", &CmdCustomTextJs::push_back),
                                                                                                                          InstanceMethod("size", &CmdCustomTextJs::size),
                                                                                                                          InstanceMethod("insert", &CmdCustomTextJs::insert),
                                                                                                                          InstanceMethod("at", &CmdCustomTextJs::at),
                                                                                                                          InstanceMethod("is", &CmdCustomTextJs::is),
                                                                                                                          InstanceMethod("getAttached", &CmdCustomTextJs::getAttached),
                                                                                                                          InstanceMethod("getCaption", &CmdCustomTextJs::getCaption),
                                                                                                                          InstanceMethod("getName", &CmdCustomTextJs::getName),
                                                                                                                          InstanceMethod("getAttrs", &CmdCustomTextJs::getAttrs),
                                                                                                                          InstanceMethod("getFirstAttr", &CmdCustomTextJs::getFirstAttr)}); }
};

template <>
struct js_to_org_type<CmdCustomTextJs> {
  using type = org::sem::CmdCustomText;
};

template <>
struct org_to_js_type<org::sem::CmdCustomText> {
  using type = CmdCustomTextJs;
};

struct LinkJs : public SharedPtrWrapBase<LinkJs, org::sem::Link> {
  using SharedPtrWrapBase<LinkJs, org::sem::Link>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Link::*)() const>(&org::sem::Link::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Link::*)() const>(&org::sem::Link::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Link::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Link::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::Link::*)() const>(&org::sem::Link::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Link::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Link::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Link::*)(int) const>(&org::sem::Link::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Link::*)(OrgSemKind) const>(&org::sem::Link::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::Link::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::Link::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::Link::*)() const>(&org::sem::Link::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::Link::*)() const>(&org::sem::Link::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::Link::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::Link::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::Link::*)(hstd::Str const&) const>(&org::sem::Link::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "LinkJs", {InstanceMethod("getKind", &LinkJs::getKind),
                                                                                                                 InstanceMethod("isGenerated", &LinkJs::isGenerated),
                                                                                                                 InstanceMethod("push_back", &LinkJs::push_back),
                                                                                                                 InstanceMethod("size", &LinkJs::size),
                                                                                                                 InstanceMethod("insert", &LinkJs::insert),
                                                                                                                 InstanceMethod("at", &LinkJs::at),
                                                                                                                 InstanceMethod("is", &LinkJs::is),
                                                                                                                 InstanceMethod("getAttached", &LinkJs::getAttached),
                                                                                                                 InstanceMethod("getCaption", &LinkJs::getCaption),
                                                                                                                 InstanceMethod("getName", &LinkJs::getName),
                                                                                                                 InstanceMethod("getAttrs", &LinkJs::getAttrs),
                                                                                                                 InstanceMethod("getFirstAttr", &LinkJs::getFirstAttr)}); }
};

template <>
struct js_to_org_type<LinkJs> {
  using type = org::sem::Link;
};

template <>
struct org_to_js_type<org::sem::Link> {
  using type = LinkJs;
};

struct BlockCommentJs : public SharedPtrWrapBase<BlockCommentJs, org::sem::BlockComment> {
  using SharedPtrWrapBase<BlockCommentJs, org::sem::BlockComment>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::BlockComment::*)() const>(&org::sem::BlockComment::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockComment::*)() const>(&org::sem::BlockComment::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockComment::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::BlockComment::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::BlockComment::*)() const>(&org::sem::BlockComment::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockComment::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::BlockComment::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::BlockComment::*)(int) const>(&org::sem::BlockComment::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockComment::*)(OrgSemKind) const>(&org::sem::BlockComment::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockComment::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockComment::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockComment::*)() const>(&org::sem::BlockComment::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::BlockComment::*)() const>(&org::sem::BlockComment::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::BlockComment::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockComment::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::BlockComment::*)(hstd::Str const&) const>(&org::sem::BlockComment::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "BlockCommentJs", {InstanceMethod("getKind", &BlockCommentJs::getKind),
                                                                                                                         InstanceMethod("isGenerated", &BlockCommentJs::isGenerated),
                                                                                                                         InstanceMethod("push_back", &BlockCommentJs::push_back),
                                                                                                                         InstanceMethod("size", &BlockCommentJs::size),
                                                                                                                         InstanceMethod("insert", &BlockCommentJs::insert),
                                                                                                                         InstanceMethod("at", &BlockCommentJs::at),
                                                                                                                         InstanceMethod("is", &BlockCommentJs::is),
                                                                                                                         InstanceMethod("getAttached", &BlockCommentJs::getAttached),
                                                                                                                         InstanceMethod("getCaption", &BlockCommentJs::getCaption),
                                                                                                                         InstanceMethod("getName", &BlockCommentJs::getName),
                                                                                                                         InstanceMethod("getAttrs", &BlockCommentJs::getAttrs),
                                                                                                                         InstanceMethod("getFirstAttr", &BlockCommentJs::getFirstAttr)}); }
};

template <>
struct js_to_org_type<BlockCommentJs> {
  using type = org::sem::BlockComment;
};

template <>
struct org_to_js_type<org::sem::BlockComment> {
  using type = BlockCommentJs;
};

struct ParagraphJs : public SharedPtrWrapBase<ParagraphJs, org::sem::Paragraph> {
  using SharedPtrWrapBase<ParagraphJs, org::sem::Paragraph>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Paragraph::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Paragraph::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Paragraph::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Paragraph::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Paragraph::*)(int) const>(&org::sem::Paragraph::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Paragraph::*)(OrgSemKind) const>(&org::sem::Paragraph::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::Paragraph::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::Paragraph::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::Paragraph::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::Paragraph::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::Paragraph::*)(hstd::Str const&) const>(&org::sem::Paragraph::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  Napi::Value isFootnoteDefinition(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::isFootnoteDefinition),
                                        std::make_tuple()));
  }
  Napi::Value getFootnoteName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<hstd::Str>(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::getFootnoteName),
                                        std::make_tuple()));
  }
  Napi::Value hasAdmonition(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::hasAdmonition),
                                        std::make_tuple()));
  }
  Napi::Value getAdmonitions(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::getAdmonitions),
                                        std::make_tuple()));
  }
  Napi::Value getAdmonitionNodes(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::BigIdent>>(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::getAdmonitionNodes),
                                        std::make_tuple()));
  }
  Napi::Value hasTimestamp(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::hasTimestamp),
                                        std::make_tuple()));
  }
  Napi::Value getTimestamps(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::UserTime>(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::getTimestamps),
                                        std::make_tuple()));
  }
  Napi::Value getTimestampNodes(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Time>>(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::getTimestampNodes),
                                        std::make_tuple()));
  }
  Napi::Value hasLeadHashtags(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::hasLeadHashtags),
                                        std::make_tuple()));
  }
  Napi::Value getLeadHashtags(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::HashTag>>(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::getLeadHashtags),
                                        std::make_tuple()));
  }
  Napi::Value getBody(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::Paragraph::*)() const>(&org::sem::Paragraph::getBody),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ParagraphJs", {InstanceMethod("getKind", &ParagraphJs::getKind),
                                                                                                                      InstanceMethod("isGenerated", &ParagraphJs::isGenerated),
                                                                                                                      InstanceMethod("push_back", &ParagraphJs::push_back),
                                                                                                                      InstanceMethod("size", &ParagraphJs::size),
                                                                                                                      InstanceMethod("insert", &ParagraphJs::insert),
                                                                                                                      InstanceMethod("at", &ParagraphJs::at),
                                                                                                                      InstanceMethod("is", &ParagraphJs::is),
                                                                                                                      InstanceMethod("getAttached", &ParagraphJs::getAttached),
                                                                                                                      InstanceMethod("getCaption", &ParagraphJs::getCaption),
                                                                                                                      InstanceMethod("getName", &ParagraphJs::getName),
                                                                                                                      InstanceMethod("getAttrs", &ParagraphJs::getAttrs),
                                                                                                                      InstanceMethod("getFirstAttr", &ParagraphJs::getFirstAttr),
                                                                                                                      InstanceMethod("isFootnoteDefinition", &ParagraphJs::isFootnoteDefinition),
                                                                                                                      InstanceMethod("getFootnoteName", &ParagraphJs::getFootnoteName),
                                                                                                                      InstanceMethod("hasAdmonition", &ParagraphJs::hasAdmonition),
                                                                                                                      InstanceMethod("getAdmonitions", &ParagraphJs::getAdmonitions),
                                                                                                                      InstanceMethod("getAdmonitionNodes", &ParagraphJs::getAdmonitionNodes),
                                                                                                                      InstanceMethod("hasTimestamp", &ParagraphJs::hasTimestamp),
                                                                                                                      InstanceMethod("getTimestamps", &ParagraphJs::getTimestamps),
                                                                                                                      InstanceMethod("getTimestampNodes", &ParagraphJs::getTimestampNodes),
                                                                                                                      InstanceMethod("hasLeadHashtags", &ParagraphJs::hasLeadHashtags),
                                                                                                                      InstanceMethod("getLeadHashtags", &ParagraphJs::getLeadHashtags),
                                                                                                                      InstanceMethod("getBody", &ParagraphJs::getBody)}); }
};

template <>
struct js_to_org_type<ParagraphJs> {
  using type = org::sem::Paragraph;
};

template <>
struct org_to_js_type<org::sem::Paragraph> {
  using type = ParagraphJs;
};

struct ListJs : public SharedPtrWrapBase<ListJs, org::sem::List> {
  using SharedPtrWrapBase<ListJs, org::sem::List>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::List::*)() const>(&org::sem::List::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::List::*)() const>(&org::sem::List::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::List::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::List::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::List::*)() const>(&org::sem::List::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::List::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::List::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::List::*)(int) const>(&org::sem::List::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::List::*)(OrgSemKind) const>(&org::sem::List::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::List::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::List::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::List::*)() const>(&org::sem::List::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::List::*)() const>(&org::sem::List::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::List::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::List::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::List::*)(hstd::Str const&) const>(&org::sem::List::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  Napi::Value getListAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::List::*)(hstd::Str const&) const>(&org::sem::List::getListAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"key"})));
  }
  Napi::Value getListFormattingMode(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<ListFormattingMode(org::sem::List::*)() const>(&org::sem::List::getListFormattingMode),
                                        std::make_tuple()));
  }
  Napi::Value isDescriptionList(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::List::*)() const>(&org::sem::List::isDescriptionList),
                                        std::make_tuple()));
  }
  Napi::Value isNumberedList(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::List::*)() const>(&org::sem::List::isNumberedList),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ListJs", {InstanceMethod("getKind", &ListJs::getKind),
                                                                                                                 InstanceMethod("isGenerated", &ListJs::isGenerated),
                                                                                                                 InstanceMethod("push_back", &ListJs::push_back),
                                                                                                                 InstanceMethod("size", &ListJs::size),
                                                                                                                 InstanceMethod("insert", &ListJs::insert),
                                                                                                                 InstanceMethod("at", &ListJs::at),
                                                                                                                 InstanceMethod("is", &ListJs::is),
                                                                                                                 InstanceMethod("getAttached", &ListJs::getAttached),
                                                                                                                 InstanceMethod("getCaption", &ListJs::getCaption),
                                                                                                                 InstanceMethod("getName", &ListJs::getName),
                                                                                                                 InstanceMethod("getAttrs", &ListJs::getAttrs),
                                                                                                                 InstanceMethod("getFirstAttr", &ListJs::getFirstAttr),
                                                                                                                 InstanceMethod("getListAttrs", &ListJs::getListAttrs),
                                                                                                                 InstanceMethod("getListFormattingMode", &ListJs::getListFormattingMode),
                                                                                                                 InstanceMethod("isDescriptionList", &ListJs::isDescriptionList),
                                                                                                                 InstanceMethod("isNumberedList", &ListJs::isNumberedList)}); }
};

template <>
struct js_to_org_type<ListJs> {
  using type = org::sem::List;
};

template <>
struct org_to_js_type<org::sem::List> {
  using type = ListJs;
};

struct HashTagJs : public SharedPtrWrapBase<HashTagJs, org::sem::HashTag> {
  using SharedPtrWrapBase<HashTagJs, org::sem::HashTag>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::HashTag::*)() const>(&org::sem::HashTag::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::HashTag::*)() const>(&org::sem::HashTag::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::HashTag::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::HashTag::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::HashTag::*)() const>(&org::sem::HashTag::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::HashTag::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::HashTag::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::HashTag::*)(int) const>(&org::sem::HashTag::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::HashTag::*)(OrgSemKind) const>(&org::sem::HashTag::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "HashTagJs", {InstanceMethod("getKind", &HashTagJs::getKind),
                                                                                                                    InstanceMethod("isGenerated", &HashTagJs::isGenerated),
                                                                                                                    InstanceMethod("push_back", &HashTagJs::push_back),
                                                                                                                    InstanceMethod("size", &HashTagJs::size),
                                                                                                                    InstanceMethod("insert", &HashTagJs::insert),
                                                                                                                    InstanceMethod("at", &HashTagJs::at),
                                                                                                                    InstanceMethod("is", &HashTagJs::is)}); }
};

template <>
struct js_to_org_type<HashTagJs> {
  using type = org::sem::HashTag;
};

template <>
struct org_to_js_type<org::sem::HashTag> {
  using type = HashTagJs;
};

struct InlineFootnoteJs : public SharedPtrWrapBase<InlineFootnoteJs, org::sem::InlineFootnote> {
  using SharedPtrWrapBase<InlineFootnoteJs, org::sem::InlineFootnote>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::InlineFootnote::*)() const>(&org::sem::InlineFootnote::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::InlineFootnote::*)() const>(&org::sem::InlineFootnote::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::InlineFootnote::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::InlineFootnote::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::InlineFootnote::*)() const>(&org::sem::InlineFootnote::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::InlineFootnote::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::InlineFootnote::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::InlineFootnote::*)(int) const>(&org::sem::InlineFootnote::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::InlineFootnote::*)(OrgSemKind) const>(&org::sem::InlineFootnote::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "InlineFootnoteJs", {InstanceMethod("getKind", &InlineFootnoteJs::getKind),
                                                                                                                           InstanceMethod("isGenerated", &InlineFootnoteJs::isGenerated),
                                                                                                                           InstanceMethod("push_back", &InlineFootnoteJs::push_back),
                                                                                                                           InstanceMethod("size", &InlineFootnoteJs::size),
                                                                                                                           InstanceMethod("insert", &InlineFootnoteJs::insert),
                                                                                                                           InstanceMethod("at", &InlineFootnoteJs::at),
                                                                                                                           InstanceMethod("is", &InlineFootnoteJs::is)}); }
};

template <>
struct js_to_org_type<InlineFootnoteJs> {
  using type = org::sem::InlineFootnote;
};

template <>
struct org_to_js_type<org::sem::InlineFootnote> {
  using type = InlineFootnoteJs;
};

struct InlineExportJs : public SharedPtrWrapBase<InlineExportJs, org::sem::InlineExport> {
  using SharedPtrWrapBase<InlineExportJs, org::sem::InlineExport>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::InlineExport::*)() const>(&org::sem::InlineExport::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::InlineExport::*)() const>(&org::sem::InlineExport::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::InlineExport::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::InlineExport::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::InlineExport::*)() const>(&org::sem::InlineExport::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::InlineExport::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::InlineExport::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::InlineExport::*)(int) const>(&org::sem::InlineExport::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::InlineExport::*)(OrgSemKind) const>(&org::sem::InlineExport::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "InlineExportJs", {InstanceMethod("getKind", &InlineExportJs::getKind),
                                                                                                                         InstanceMethod("isGenerated", &InlineExportJs::isGenerated),
                                                                                                                         InstanceMethod("push_back", &InlineExportJs::push_back),
                                                                                                                         InstanceMethod("size", &InlineExportJs::size),
                                                                                                                         InstanceMethod("insert", &InlineExportJs::insert),
                                                                                                                         InstanceMethod("at", &InlineExportJs::at),
                                                                                                                         InstanceMethod("is", &InlineExportJs::is)}); }
};

template <>
struct js_to_org_type<InlineExportJs> {
  using type = org::sem::InlineExport;
};

template <>
struct org_to_js_type<org::sem::InlineExport> {
  using type = InlineExportJs;
};

struct EscapedJs : public SharedPtrWrapBase<EscapedJs, org::sem::Escaped> {
  using SharedPtrWrapBase<EscapedJs, org::sem::Escaped>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Escaped::*)() const>(&org::sem::Escaped::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Escaped::*)() const>(&org::sem::Escaped::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Escaped::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Escaped::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::Escaped::*)() const>(&org::sem::Escaped::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Escaped::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Escaped::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Escaped::*)(int) const>(&org::sem::Escaped::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Escaped::*)(OrgSemKind) const>(&org::sem::Escaped::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Str(org::sem::Escaped::*)() const>(&org::sem::Escaped::getText),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "EscapedJs", {InstanceMethod("getKind", &EscapedJs::getKind),
                                                                                                                    InstanceMethod("isGenerated", &EscapedJs::isGenerated),
                                                                                                                    InstanceMethod("push_back", &EscapedJs::push_back),
                                                                                                                    InstanceMethod("size", &EscapedJs::size),
                                                                                                                    InstanceMethod("insert", &EscapedJs::insert),
                                                                                                                    InstanceMethod("at", &EscapedJs::at),
                                                                                                                    InstanceMethod("is", &EscapedJs::is),
                                                                                                                    InstanceMethod("getText", &EscapedJs::getText)}); }
};

template <>
struct js_to_org_type<EscapedJs> {
  using type = org::sem::Escaped;
};

template <>
struct org_to_js_type<org::sem::Escaped> {
  using type = EscapedJs;
};

struct NewlineJs : public SharedPtrWrapBase<NewlineJs, org::sem::Newline> {
  using SharedPtrWrapBase<NewlineJs, org::sem::Newline>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Newline::*)() const>(&org::sem::Newline::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Newline::*)() const>(&org::sem::Newline::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Newline::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Newline::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::Newline::*)() const>(&org::sem::Newline::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Newline::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Newline::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Newline::*)(int) const>(&org::sem::Newline::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Newline::*)(OrgSemKind) const>(&org::sem::Newline::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Str(org::sem::Newline::*)() const>(&org::sem::Newline::getText),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "NewlineJs", {InstanceMethod("getKind", &NewlineJs::getKind),
                                                                                                                    InstanceMethod("isGenerated", &NewlineJs::isGenerated),
                                                                                                                    InstanceMethod("push_back", &NewlineJs::push_back),
                                                                                                                    InstanceMethod("size", &NewlineJs::size),
                                                                                                                    InstanceMethod("insert", &NewlineJs::insert),
                                                                                                                    InstanceMethod("at", &NewlineJs::at),
                                                                                                                    InstanceMethod("is", &NewlineJs::is),
                                                                                                                    InstanceMethod("getText", &NewlineJs::getText)}); }
};

template <>
struct js_to_org_type<NewlineJs> {
  using type = org::sem::Newline;
};

template <>
struct org_to_js_type<org::sem::Newline> {
  using type = NewlineJs;
};

struct SpaceJs : public SharedPtrWrapBase<SpaceJs, org::sem::Space> {
  using SharedPtrWrapBase<SpaceJs, org::sem::Space>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Space::*)() const>(&org::sem::Space::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Space::*)() const>(&org::sem::Space::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Space::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Space::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::Space::*)() const>(&org::sem::Space::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Space::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Space::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Space::*)(int) const>(&org::sem::Space::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Space::*)(OrgSemKind) const>(&org::sem::Space::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Str(org::sem::Space::*)() const>(&org::sem::Space::getText),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "SpaceJs", {InstanceMethod("getKind", &SpaceJs::getKind),
                                                                                                                  InstanceMethod("isGenerated", &SpaceJs::isGenerated),
                                                                                                                  InstanceMethod("push_back", &SpaceJs::push_back),
                                                                                                                  InstanceMethod("size", &SpaceJs::size),
                                                                                                                  InstanceMethod("insert", &SpaceJs::insert),
                                                                                                                  InstanceMethod("at", &SpaceJs::at),
                                                                                                                  InstanceMethod("is", &SpaceJs::is),
                                                                                                                  InstanceMethod("getText", &SpaceJs::getText)}); }
};

template <>
struct js_to_org_type<SpaceJs> {
  using type = org::sem::Space;
};

template <>
struct org_to_js_type<org::sem::Space> {
  using type = SpaceJs;
};

struct WordJs : public SharedPtrWrapBase<WordJs, org::sem::Word> {
  using SharedPtrWrapBase<WordJs, org::sem::Word>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Word::*)() const>(&org::sem::Word::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Word::*)() const>(&org::sem::Word::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Word::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Word::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::Word::*)() const>(&org::sem::Word::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Word::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Word::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Word::*)(int) const>(&org::sem::Word::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Word::*)(OrgSemKind) const>(&org::sem::Word::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Str(org::sem::Word::*)() const>(&org::sem::Word::getText),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "WordJs", {InstanceMethod("getKind", &WordJs::getKind),
                                                                                                                 InstanceMethod("isGenerated", &WordJs::isGenerated),
                                                                                                                 InstanceMethod("push_back", &WordJs::push_back),
                                                                                                                 InstanceMethod("size", &WordJs::size),
                                                                                                                 InstanceMethod("insert", &WordJs::insert),
                                                                                                                 InstanceMethod("at", &WordJs::at),
                                                                                                                 InstanceMethod("is", &WordJs::is),
                                                                                                                 InstanceMethod("getText", &WordJs::getText)}); }
};

template <>
struct js_to_org_type<WordJs> {
  using type = org::sem::Word;
};

template <>
struct org_to_js_type<org::sem::Word> {
  using type = WordJs;
};

struct AtMentionJs : public SharedPtrWrapBase<AtMentionJs, org::sem::AtMention> {
  using SharedPtrWrapBase<AtMentionJs, org::sem::AtMention>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::AtMention::*)() const>(&org::sem::AtMention::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::AtMention::*)() const>(&org::sem::AtMention::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::AtMention::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::AtMention::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::AtMention::*)() const>(&org::sem::AtMention::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::AtMention::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::AtMention::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::AtMention::*)(int) const>(&org::sem::AtMention::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::AtMention::*)(OrgSemKind) const>(&org::sem::AtMention::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Str(org::sem::AtMention::*)() const>(&org::sem::AtMention::getText),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "AtMentionJs", {InstanceMethod("getKind", &AtMentionJs::getKind),
                                                                                                                      InstanceMethod("isGenerated", &AtMentionJs::isGenerated),
                                                                                                                      InstanceMethod("push_back", &AtMentionJs::push_back),
                                                                                                                      InstanceMethod("size", &AtMentionJs::size),
                                                                                                                      InstanceMethod("insert", &AtMentionJs::insert),
                                                                                                                      InstanceMethod("at", &AtMentionJs::at),
                                                                                                                      InstanceMethod("is", &AtMentionJs::is),
                                                                                                                      InstanceMethod("getText", &AtMentionJs::getText)}); }
};

template <>
struct js_to_org_type<AtMentionJs> {
  using type = org::sem::AtMention;
};

template <>
struct org_to_js_type<org::sem::AtMention> {
  using type = AtMentionJs;
};

struct RawTextJs : public SharedPtrWrapBase<RawTextJs, org::sem::RawText> {
  using SharedPtrWrapBase<RawTextJs, org::sem::RawText>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::RawText::*)() const>(&org::sem::RawText::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::RawText::*)() const>(&org::sem::RawText::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::RawText::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::RawText::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::RawText::*)() const>(&org::sem::RawText::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::RawText::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::RawText::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::RawText::*)(int) const>(&org::sem::RawText::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::RawText::*)(OrgSemKind) const>(&org::sem::RawText::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Str(org::sem::RawText::*)() const>(&org::sem::RawText::getText),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "RawTextJs", {InstanceMethod("getKind", &RawTextJs::getKind),
                                                                                                                    InstanceMethod("isGenerated", &RawTextJs::isGenerated),
                                                                                                                    InstanceMethod("push_back", &RawTextJs::push_back),
                                                                                                                    InstanceMethod("size", &RawTextJs::size),
                                                                                                                    InstanceMethod("insert", &RawTextJs::insert),
                                                                                                                    InstanceMethod("at", &RawTextJs::at),
                                                                                                                    InstanceMethod("is", &RawTextJs::is),
                                                                                                                    InstanceMethod("getText", &RawTextJs::getText)}); }
};

template <>
struct js_to_org_type<RawTextJs> {
  using type = org::sem::RawText;
};

template <>
struct org_to_js_type<org::sem::RawText> {
  using type = RawTextJs;
};

struct PunctuationJs : public SharedPtrWrapBase<PunctuationJs, org::sem::Punctuation> {
  using SharedPtrWrapBase<PunctuationJs, org::sem::Punctuation>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Punctuation::*)() const>(&org::sem::Punctuation::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Punctuation::*)() const>(&org::sem::Punctuation::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Punctuation::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Punctuation::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::Punctuation::*)() const>(&org::sem::Punctuation::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Punctuation::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Punctuation::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Punctuation::*)(int) const>(&org::sem::Punctuation::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Punctuation::*)(OrgSemKind) const>(&org::sem::Punctuation::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Str(org::sem::Punctuation::*)() const>(&org::sem::Punctuation::getText),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "PunctuationJs", {InstanceMethod("getKind", &PunctuationJs::getKind),
                                                                                                                        InstanceMethod("isGenerated", &PunctuationJs::isGenerated),
                                                                                                                        InstanceMethod("push_back", &PunctuationJs::push_back),
                                                                                                                        InstanceMethod("size", &PunctuationJs::size),
                                                                                                                        InstanceMethod("insert", &PunctuationJs::insert),
                                                                                                                        InstanceMethod("at", &PunctuationJs::at),
                                                                                                                        InstanceMethod("is", &PunctuationJs::is),
                                                                                                                        InstanceMethod("getText", &PunctuationJs::getText)}); }
};

template <>
struct js_to_org_type<PunctuationJs> {
  using type = org::sem::Punctuation;
};

template <>
struct org_to_js_type<org::sem::Punctuation> {
  using type = PunctuationJs;
};

struct PlaceholderJs : public SharedPtrWrapBase<PlaceholderJs, org::sem::Placeholder> {
  using SharedPtrWrapBase<PlaceholderJs, org::sem::Placeholder>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Placeholder::*)() const>(&org::sem::Placeholder::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Placeholder::*)() const>(&org::sem::Placeholder::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Placeholder::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Placeholder::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::Placeholder::*)() const>(&org::sem::Placeholder::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Placeholder::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Placeholder::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Placeholder::*)(int) const>(&org::sem::Placeholder::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Placeholder::*)(OrgSemKind) const>(&org::sem::Placeholder::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Str(org::sem::Placeholder::*)() const>(&org::sem::Placeholder::getText),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "PlaceholderJs", {InstanceMethod("getKind", &PlaceholderJs::getKind),
                                                                                                                        InstanceMethod("isGenerated", &PlaceholderJs::isGenerated),
                                                                                                                        InstanceMethod("push_back", &PlaceholderJs::push_back),
                                                                                                                        InstanceMethod("size", &PlaceholderJs::size),
                                                                                                                        InstanceMethod("insert", &PlaceholderJs::insert),
                                                                                                                        InstanceMethod("at", &PlaceholderJs::at),
                                                                                                                        InstanceMethod("is", &PlaceholderJs::is),
                                                                                                                        InstanceMethod("getText", &PlaceholderJs::getText)}); }
};

template <>
struct js_to_org_type<PlaceholderJs> {
  using type = org::sem::Placeholder;
};

template <>
struct org_to_js_type<org::sem::Placeholder> {
  using type = PlaceholderJs;
};

struct BigIdentJs : public SharedPtrWrapBase<BigIdentJs, org::sem::BigIdent> {
  using SharedPtrWrapBase<BigIdentJs, org::sem::BigIdent>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::BigIdent::*)() const>(&org::sem::BigIdent::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BigIdent::*)() const>(&org::sem::BigIdent::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BigIdent::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::BigIdent::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::BigIdent::*)() const>(&org::sem::BigIdent::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BigIdent::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::BigIdent::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::BigIdent::*)(int) const>(&org::sem::BigIdent::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BigIdent::*)(OrgSemKind) const>(&org::sem::BigIdent::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Str(org::sem::BigIdent::*)() const>(&org::sem::BigIdent::getText),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "BigIdentJs", {InstanceMethod("getKind", &BigIdentJs::getKind),
                                                                                                                     InstanceMethod("isGenerated", &BigIdentJs::isGenerated),
                                                                                                                     InstanceMethod("push_back", &BigIdentJs::push_back),
                                                                                                                     InstanceMethod("size", &BigIdentJs::size),
                                                                                                                     InstanceMethod("insert", &BigIdentJs::insert),
                                                                                                                     InstanceMethod("at", &BigIdentJs::at),
                                                                                                                     InstanceMethod("is", &BigIdentJs::is),
                                                                                                                     InstanceMethod("getText", &BigIdentJs::getText)}); }
};

template <>
struct js_to_org_type<BigIdentJs> {
  using type = org::sem::BigIdent;
};

template <>
struct org_to_js_type<org::sem::BigIdent> {
  using type = BigIdentJs;
};

struct TextTargetJs : public SharedPtrWrapBase<TextTargetJs, org::sem::TextTarget> {
  using SharedPtrWrapBase<TextTargetJs, org::sem::TextTarget>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::TextTarget::*)() const>(&org::sem::TextTarget::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::TextTarget::*)() const>(&org::sem::TextTarget::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::TextTarget::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::TextTarget::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::TextTarget::*)() const>(&org::sem::TextTarget::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::TextTarget::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::TextTarget::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::TextTarget::*)(int) const>(&org::sem::TextTarget::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::TextTarget::*)(OrgSemKind) const>(&org::sem::TextTarget::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getText(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Str(org::sem::TextTarget::*)() const>(&org::sem::TextTarget::getText),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "TextTargetJs", {InstanceMethod("getKind", &TextTargetJs::getKind),
                                                                                                                       InstanceMethod("isGenerated", &TextTargetJs::isGenerated),
                                                                                                                       InstanceMethod("push_back", &TextTargetJs::push_back),
                                                                                                                       InstanceMethod("size", &TextTargetJs::size),
                                                                                                                       InstanceMethod("insert", &TextTargetJs::insert),
                                                                                                                       InstanceMethod("at", &TextTargetJs::at),
                                                                                                                       InstanceMethod("is", &TextTargetJs::is),
                                                                                                                       InstanceMethod("getText", &TextTargetJs::getText)}); }
};

template <>
struct js_to_org_type<TextTargetJs> {
  using type = org::sem::TextTarget;
};

template <>
struct org_to_js_type<org::sem::TextTarget> {
  using type = TextTargetJs;
};

struct BoldJs : public SharedPtrWrapBase<BoldJs, org::sem::Bold> {
  using SharedPtrWrapBase<BoldJs, org::sem::Bold>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Bold::*)() const>(&org::sem::Bold::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Bold::*)() const>(&org::sem::Bold::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Bold::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Bold::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::Bold::*)() const>(&org::sem::Bold::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Bold::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Bold::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Bold::*)(int) const>(&org::sem::Bold::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Bold::*)(OrgSemKind) const>(&org::sem::Bold::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "BoldJs", {InstanceMethod("getKind", &BoldJs::getKind),
                                                                                                                 InstanceMethod("isGenerated", &BoldJs::isGenerated),
                                                                                                                 InstanceMethod("push_back", &BoldJs::push_back),
                                                                                                                 InstanceMethod("size", &BoldJs::size),
                                                                                                                 InstanceMethod("insert", &BoldJs::insert),
                                                                                                                 InstanceMethod("at", &BoldJs::at),
                                                                                                                 InstanceMethod("is", &BoldJs::is)}); }
};

template <>
struct js_to_org_type<BoldJs> {
  using type = org::sem::Bold;
};

template <>
struct org_to_js_type<org::sem::Bold> {
  using type = BoldJs;
};

struct UnderlineJs : public SharedPtrWrapBase<UnderlineJs, org::sem::Underline> {
  using SharedPtrWrapBase<UnderlineJs, org::sem::Underline>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Underline::*)() const>(&org::sem::Underline::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Underline::*)() const>(&org::sem::Underline::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Underline::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Underline::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::Underline::*)() const>(&org::sem::Underline::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Underline::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Underline::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Underline::*)(int) const>(&org::sem::Underline::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Underline::*)(OrgSemKind) const>(&org::sem::Underline::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "UnderlineJs", {InstanceMethod("getKind", &UnderlineJs::getKind),
                                                                                                                      InstanceMethod("isGenerated", &UnderlineJs::isGenerated),
                                                                                                                      InstanceMethod("push_back", &UnderlineJs::push_back),
                                                                                                                      InstanceMethod("size", &UnderlineJs::size),
                                                                                                                      InstanceMethod("insert", &UnderlineJs::insert),
                                                                                                                      InstanceMethod("at", &UnderlineJs::at),
                                                                                                                      InstanceMethod("is", &UnderlineJs::is)}); }
};

template <>
struct js_to_org_type<UnderlineJs> {
  using type = org::sem::Underline;
};

template <>
struct org_to_js_type<org::sem::Underline> {
  using type = UnderlineJs;
};

struct MonospaceJs : public SharedPtrWrapBase<MonospaceJs, org::sem::Monospace> {
  using SharedPtrWrapBase<MonospaceJs, org::sem::Monospace>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Monospace::*)() const>(&org::sem::Monospace::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Monospace::*)() const>(&org::sem::Monospace::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Monospace::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Monospace::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::Monospace::*)() const>(&org::sem::Monospace::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Monospace::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Monospace::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Monospace::*)(int) const>(&org::sem::Monospace::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Monospace::*)(OrgSemKind) const>(&org::sem::Monospace::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "MonospaceJs", {InstanceMethod("getKind", &MonospaceJs::getKind),
                                                                                                                      InstanceMethod("isGenerated", &MonospaceJs::isGenerated),
                                                                                                                      InstanceMethod("push_back", &MonospaceJs::push_back),
                                                                                                                      InstanceMethod("size", &MonospaceJs::size),
                                                                                                                      InstanceMethod("insert", &MonospaceJs::insert),
                                                                                                                      InstanceMethod("at", &MonospaceJs::at),
                                                                                                                      InstanceMethod("is", &MonospaceJs::is)}); }
};

template <>
struct js_to_org_type<MonospaceJs> {
  using type = org::sem::Monospace;
};

template <>
struct org_to_js_type<org::sem::Monospace> {
  using type = MonospaceJs;
};

struct MarkQuoteJs : public SharedPtrWrapBase<MarkQuoteJs, org::sem::MarkQuote> {
  using SharedPtrWrapBase<MarkQuoteJs, org::sem::MarkQuote>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::MarkQuote::*)() const>(&org::sem::MarkQuote::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::MarkQuote::*)() const>(&org::sem::MarkQuote::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::MarkQuote::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::MarkQuote::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::MarkQuote::*)() const>(&org::sem::MarkQuote::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::MarkQuote::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::MarkQuote::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::MarkQuote::*)(int) const>(&org::sem::MarkQuote::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::MarkQuote::*)(OrgSemKind) const>(&org::sem::MarkQuote::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "MarkQuoteJs", {InstanceMethod("getKind", &MarkQuoteJs::getKind),
                                                                                                                      InstanceMethod("isGenerated", &MarkQuoteJs::isGenerated),
                                                                                                                      InstanceMethod("push_back", &MarkQuoteJs::push_back),
                                                                                                                      InstanceMethod("size", &MarkQuoteJs::size),
                                                                                                                      InstanceMethod("insert", &MarkQuoteJs::insert),
                                                                                                                      InstanceMethod("at", &MarkQuoteJs::at),
                                                                                                                      InstanceMethod("is", &MarkQuoteJs::is)}); }
};

template <>
struct js_to_org_type<MarkQuoteJs> {
  using type = org::sem::MarkQuote;
};

template <>
struct org_to_js_type<org::sem::MarkQuote> {
  using type = MarkQuoteJs;
};

struct VerbatimJs : public SharedPtrWrapBase<VerbatimJs, org::sem::Verbatim> {
  using SharedPtrWrapBase<VerbatimJs, org::sem::Verbatim>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Verbatim::*)() const>(&org::sem::Verbatim::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Verbatim::*)() const>(&org::sem::Verbatim::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Verbatim::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Verbatim::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::Verbatim::*)() const>(&org::sem::Verbatim::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Verbatim::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Verbatim::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Verbatim::*)(int) const>(&org::sem::Verbatim::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Verbatim::*)(OrgSemKind) const>(&org::sem::Verbatim::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "VerbatimJs", {InstanceMethod("getKind", &VerbatimJs::getKind),
                                                                                                                     InstanceMethod("isGenerated", &VerbatimJs::isGenerated),
                                                                                                                     InstanceMethod("push_back", &VerbatimJs::push_back),
                                                                                                                     InstanceMethod("size", &VerbatimJs::size),
                                                                                                                     InstanceMethod("insert", &VerbatimJs::insert),
                                                                                                                     InstanceMethod("at", &VerbatimJs::at),
                                                                                                                     InstanceMethod("is", &VerbatimJs::is)}); }
};

template <>
struct js_to_org_type<VerbatimJs> {
  using type = org::sem::Verbatim;
};

template <>
struct org_to_js_type<org::sem::Verbatim> {
  using type = VerbatimJs;
};

struct ItalicJs : public SharedPtrWrapBase<ItalicJs, org::sem::Italic> {
  using SharedPtrWrapBase<ItalicJs, org::sem::Italic>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Italic::*)() const>(&org::sem::Italic::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Italic::*)() const>(&org::sem::Italic::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Italic::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Italic::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::Italic::*)() const>(&org::sem::Italic::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Italic::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Italic::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Italic::*)(int) const>(&org::sem::Italic::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Italic::*)(OrgSemKind) const>(&org::sem::Italic::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ItalicJs", {InstanceMethod("getKind", &ItalicJs::getKind),
                                                                                                                   InstanceMethod("isGenerated", &ItalicJs::isGenerated),
                                                                                                                   InstanceMethod("push_back", &ItalicJs::push_back),
                                                                                                                   InstanceMethod("size", &ItalicJs::size),
                                                                                                                   InstanceMethod("insert", &ItalicJs::insert),
                                                                                                                   InstanceMethod("at", &ItalicJs::at),
                                                                                                                   InstanceMethod("is", &ItalicJs::is)}); }
};

template <>
struct js_to_org_type<ItalicJs> {
  using type = org::sem::Italic;
};

template <>
struct org_to_js_type<org::sem::Italic> {
  using type = ItalicJs;
};

struct StrikeJs : public SharedPtrWrapBase<StrikeJs, org::sem::Strike> {
  using SharedPtrWrapBase<StrikeJs, org::sem::Strike>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Strike::*)() const>(&org::sem::Strike::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Strike::*)() const>(&org::sem::Strike::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Strike::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Strike::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::Strike::*)() const>(&org::sem::Strike::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Strike::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Strike::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Strike::*)(int) const>(&org::sem::Strike::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Strike::*)(OrgSemKind) const>(&org::sem::Strike::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "StrikeJs", {InstanceMethod("getKind", &StrikeJs::getKind),
                                                                                                                   InstanceMethod("isGenerated", &StrikeJs::isGenerated),
                                                                                                                   InstanceMethod("push_back", &StrikeJs::push_back),
                                                                                                                   InstanceMethod("size", &StrikeJs::size),
                                                                                                                   InstanceMethod("insert", &StrikeJs::insert),
                                                                                                                   InstanceMethod("at", &StrikeJs::at),
                                                                                                                   InstanceMethod("is", &StrikeJs::is)}); }
};

template <>
struct js_to_org_type<StrikeJs> {
  using type = org::sem::Strike;
};

template <>
struct org_to_js_type<org::sem::Strike> {
  using type = StrikeJs;
};

struct ParJs : public SharedPtrWrapBase<ParJs, org::sem::Par> {
  using SharedPtrWrapBase<ParJs, org::sem::Par>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Par::*)() const>(&org::sem::Par::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Par::*)() const>(&org::sem::Par::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Par::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Par::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::Par::*)() const>(&org::sem::Par::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Par::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Par::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Par::*)(int) const>(&org::sem::Par::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Par::*)(OrgSemKind) const>(&org::sem::Par::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ParJs", {InstanceMethod("getKind", &ParJs::getKind),
                                                                                                                InstanceMethod("isGenerated", &ParJs::isGenerated),
                                                                                                                InstanceMethod("push_back", &ParJs::push_back),
                                                                                                                InstanceMethod("size", &ParJs::size),
                                                                                                                InstanceMethod("insert", &ParJs::insert),
                                                                                                                InstanceMethod("at", &ParJs::at),
                                                                                                                InstanceMethod("is", &ParJs::is)}); }
};

template <>
struct js_to_org_type<ParJs> {
  using type = org::sem::Par;
};

template <>
struct org_to_js_type<org::sem::Par> {
  using type = ParJs;
};

struct ImmCmdCustomArgsJs : public SharedPtrWrapBase<ImmCmdCustomArgsJs, org::imm::ImmCmdCustomArgs> {
  using SharedPtrWrapBase<ImmCmdCustomArgsJs, org::imm::ImmCmdCustomArgs>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmCmdCustomArgs::*)(org::imm::ImmCmdCustomArgs const&) const>(&org::imm::ImmCmdCustomArgs::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmCmdCustomArgs>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmCmdCustomArgs::*)() const>(&org::imm::ImmCmdCustomArgs::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdCustomArgsJs", {InstanceMethod("operator==", &ImmCmdCustomArgsJs::operator==),
                                                                                                                             InstanceMethod("getKind", &ImmCmdCustomArgsJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmCmdCustomArgsJs> {
  using type = org::imm::ImmCmdCustomArgs;
};

template <>
struct org_to_js_type<org::imm::ImmCmdCustomArgs> {
  using type = ImmCmdCustomArgsJs;
};

struct ImmCmdTblfmJs : public SharedPtrWrapBase<ImmCmdTblfmJs, org::imm::ImmCmdTblfm> {
  using SharedPtrWrapBase<ImmCmdTblfmJs, org::imm::ImmCmdTblfm>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmCmdTblfm::*)(org::imm::ImmCmdTblfm const&) const>(&org::imm::ImmCmdTblfm::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmCmdTblfm>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmCmdTblfm::*)() const>(&org::imm::ImmCmdTblfm::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdTblfmJs", {InstanceMethod("operator==", &ImmCmdTblfmJs::operator==),
                                                                                                                        InstanceMethod("getKind", &ImmCmdTblfmJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmCmdTblfmJs> {
  using type = org::imm::ImmCmdTblfm;
};

template <>
struct org_to_js_type<org::imm::ImmCmdTblfm> {
  using type = ImmCmdTblfmJs;
};

struct ImmCellJs : public SharedPtrWrapBase<ImmCellJs, org::imm::ImmCell> {
  using SharedPtrWrapBase<ImmCellJs, org::imm::ImmCell>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmCell::*)(org::imm::ImmCell const&) const>(&org::imm::ImmCell::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmCell>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmCell::*)() const>(&org::imm::ImmCell::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCellJs", {InstanceMethod("operator==", &ImmCellJs::operator==),
                                                                                                                    InstanceMethod("getKind", &ImmCellJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmCellJs> {
  using type = org::imm::ImmCell;
};

template <>
struct org_to_js_type<org::imm::ImmCell> {
  using type = ImmCellJs;
};

struct ImmRowJs : public SharedPtrWrapBase<ImmRowJs, org::imm::ImmRow> {
  using SharedPtrWrapBase<ImmRowJs, org::imm::ImmRow>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmRow::*)(org::imm::ImmRow const&) const>(&org::imm::ImmRow::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmRow>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmRow::*)() const>(&org::imm::ImmRow::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmRowJs", {InstanceMethod("operator==", &ImmRowJs::operator==),
                                                                                                                   InstanceMethod("getKind", &ImmRowJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmRowJs> {
  using type = org::imm::ImmRow;
};

template <>
struct org_to_js_type<org::imm::ImmRow> {
  using type = ImmRowJs;
};

struct CmdCustomArgsJs : public SharedPtrWrapBase<CmdCustomArgsJs, org::sem::CmdCustomArgs> {
  using SharedPtrWrapBase<CmdCustomArgsJs, org::sem::CmdCustomArgs>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::CmdCustomArgs::*)() const>(&org::sem::CmdCustomArgs::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdCustomArgs::*)() const>(&org::sem::CmdCustomArgs::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdCustomArgs::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::CmdCustomArgs::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::CmdCustomArgs::*)() const>(&org::sem::CmdCustomArgs::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdCustomArgs::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::CmdCustomArgs::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::CmdCustomArgs::*)(int) const>(&org::sem::CmdCustomArgs::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdCustomArgs::*)(OrgSemKind) const>(&org::sem::CmdCustomArgs::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdCustomArgs::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdCustomArgs::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdCustomArgs::*)() const>(&org::sem::CmdCustomArgs::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::CmdCustomArgs::*)() const>(&org::sem::CmdCustomArgs::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::CmdCustomArgs::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdCustomArgs::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::CmdCustomArgs::*)(hstd::Str const&) const>(&org::sem::CmdCustomArgs::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "CmdCustomArgsJs", {InstanceMethod("getKind", &CmdCustomArgsJs::getKind),
                                                                                                                          InstanceMethod("isGenerated", &CmdCustomArgsJs::isGenerated),
                                                                                                                          InstanceMethod("push_back", &CmdCustomArgsJs::push_back),
                                                                                                                          InstanceMethod("size", &CmdCustomArgsJs::size),
                                                                                                                          InstanceMethod("insert", &CmdCustomArgsJs::insert),
                                                                                                                          InstanceMethod("at", &CmdCustomArgsJs::at),
                                                                                                                          InstanceMethod("is", &CmdCustomArgsJs::is),
                                                                                                                          InstanceMethod("getAttached", &CmdCustomArgsJs::getAttached),
                                                                                                                          InstanceMethod("getCaption", &CmdCustomArgsJs::getCaption),
                                                                                                                          InstanceMethod("getName", &CmdCustomArgsJs::getName),
                                                                                                                          InstanceMethod("getAttrs", &CmdCustomArgsJs::getAttrs),
                                                                                                                          InstanceMethod("getFirstAttr", &CmdCustomArgsJs::getFirstAttr)}); }
};

template <>
struct js_to_org_type<CmdCustomArgsJs> {
  using type = org::sem::CmdCustomArgs;
};

template <>
struct org_to_js_type<org::sem::CmdCustomArgs> {
  using type = CmdCustomArgsJs;
};

struct CmdTblfmJs : public SharedPtrWrapBase<CmdTblfmJs, org::sem::CmdTblfm> {
  using SharedPtrWrapBase<CmdTblfmJs, org::sem::CmdTblfm>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::CmdTblfm::*)() const>(&org::sem::CmdTblfm::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdTblfm::*)() const>(&org::sem::CmdTblfm::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdTblfm::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::CmdTblfm::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::CmdTblfm::*)() const>(&org::sem::CmdTblfm::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdTblfm::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::CmdTblfm::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::CmdTblfm::*)(int) const>(&org::sem::CmdTblfm::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdTblfm::*)(OrgSemKind) const>(&org::sem::CmdTblfm::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdTblfm::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdTblfm::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdTblfm::*)() const>(&org::sem::CmdTblfm::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::CmdTblfm::*)() const>(&org::sem::CmdTblfm::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::CmdTblfm::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdTblfm::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::CmdTblfm::*)(hstd::Str const&) const>(&org::sem::CmdTblfm::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "CmdTblfmJs", {InstanceMethod("getKind", &CmdTblfmJs::getKind),
                                                                                                                     InstanceMethod("isGenerated", &CmdTblfmJs::isGenerated),
                                                                                                                     InstanceMethod("push_back", &CmdTblfmJs::push_back),
                                                                                                                     InstanceMethod("size", &CmdTblfmJs::size),
                                                                                                                     InstanceMethod("insert", &CmdTblfmJs::insert),
                                                                                                                     InstanceMethod("at", &CmdTblfmJs::at),
                                                                                                                     InstanceMethod("is", &CmdTblfmJs::is),
                                                                                                                     InstanceMethod("getAttached", &CmdTblfmJs::getAttached),
                                                                                                                     InstanceMethod("getCaption", &CmdTblfmJs::getCaption),
                                                                                                                     InstanceMethod("getName", &CmdTblfmJs::getName),
                                                                                                                     InstanceMethod("getAttrs", &CmdTblfmJs::getAttrs),
                                                                                                                     InstanceMethod("getFirstAttr", &CmdTblfmJs::getFirstAttr)}); }
};

template <>
struct js_to_org_type<CmdTblfmJs> {
  using type = org::sem::CmdTblfm;
};

template <>
struct org_to_js_type<org::sem::CmdTblfm> {
  using type = CmdTblfmJs;
};

struct CellJs : public SharedPtrWrapBase<CellJs, org::sem::Cell> {
  using SharedPtrWrapBase<CellJs, org::sem::Cell>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Cell::*)() const>(&org::sem::Cell::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Cell::*)() const>(&org::sem::Cell::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Cell::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Cell::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::Cell::*)() const>(&org::sem::Cell::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Cell::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Cell::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Cell::*)(int) const>(&org::sem::Cell::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Cell::*)(OrgSemKind) const>(&org::sem::Cell::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::Cell::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::Cell::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::Cell::*)() const>(&org::sem::Cell::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::Cell::*)() const>(&org::sem::Cell::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::Cell::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::Cell::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::Cell::*)(hstd::Str const&) const>(&org::sem::Cell::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "CellJs", {InstanceMethod("getKind", &CellJs::getKind),
                                                                                                                 InstanceMethod("isGenerated", &CellJs::isGenerated),
                                                                                                                 InstanceMethod("push_back", &CellJs::push_back),
                                                                                                                 InstanceMethod("size", &CellJs::size),
                                                                                                                 InstanceMethod("insert", &CellJs::insert),
                                                                                                                 InstanceMethod("at", &CellJs::at),
                                                                                                                 InstanceMethod("is", &CellJs::is),
                                                                                                                 InstanceMethod("getAttached", &CellJs::getAttached),
                                                                                                                 InstanceMethod("getCaption", &CellJs::getCaption),
                                                                                                                 InstanceMethod("getName", &CellJs::getName),
                                                                                                                 InstanceMethod("getAttrs", &CellJs::getAttrs),
                                                                                                                 InstanceMethod("getFirstAttr", &CellJs::getFirstAttr)}); }
};

template <>
struct js_to_org_type<CellJs> {
  using type = org::sem::Cell;
};

template <>
struct org_to_js_type<org::sem::Cell> {
  using type = CellJs;
};

struct RowJs : public SharedPtrWrapBase<RowJs, org::sem::Row> {
  using SharedPtrWrapBase<RowJs, org::sem::Row>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Row::*)() const>(&org::sem::Row::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Row::*)() const>(&org::sem::Row::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Row::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Row::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::Row::*)() const>(&org::sem::Row::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Row::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Row::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Row::*)(int) const>(&org::sem::Row::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Row::*)(OrgSemKind) const>(&org::sem::Row::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::Row::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::Row::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::Row::*)() const>(&org::sem::Row::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::Row::*)() const>(&org::sem::Row::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::Row::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::Row::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::Row::*)(hstd::Str const&) const>(&org::sem::Row::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "RowJs", {InstanceMethod("getKind", &RowJs::getKind),
                                                                                                                InstanceMethod("isGenerated", &RowJs::isGenerated),
                                                                                                                InstanceMethod("push_back", &RowJs::push_back),
                                                                                                                InstanceMethod("size", &RowJs::size),
                                                                                                                InstanceMethod("insert", &RowJs::insert),
                                                                                                                InstanceMethod("at", &RowJs::at),
                                                                                                                InstanceMethod("is", &RowJs::is),
                                                                                                                InstanceMethod("getAttached", &RowJs::getAttached),
                                                                                                                InstanceMethod("getCaption", &RowJs::getCaption),
                                                                                                                InstanceMethod("getName", &RowJs::getName),
                                                                                                                InstanceMethod("getAttrs", &RowJs::getAttrs),
                                                                                                                InstanceMethod("getFirstAttr", &RowJs::getFirstAttr)}); }
};

template <>
struct js_to_org_type<RowJs> {
  using type = org::sem::Row;
};

template <>
struct org_to_js_type<org::sem::Row> {
  using type = RowJs;
};

struct ImmSubtreeAdapter : public SharedPtrWrapBase<ImmSubtreeAdapter, org::imm::ImmAdapterT<org::imm::ImmSubtree>> {
  using SharedPtrWrapBase<ImmSubtreeAdapter, org::imm::ImmAdapterT<org::imm::ImmSubtree>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmSubtreeValueRead(org::imm::ImmAdapterT<org::imm::ImmSubtree>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmSubtree>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmSubtreeAdapter", {InstanceMethod("getValue", &ImmSubtreeAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmSubtreeAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmSubtree>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmSubtree>> {
  using type = ImmSubtreeAdapter;
};

struct ImmNoneAdapter : public SharedPtrWrapBase<ImmNoneAdapter, org::imm::ImmAdapterT<org::imm::ImmNone>> {
  using SharedPtrWrapBase<ImmNoneAdapter, org::imm::ImmAdapterT<org::imm::ImmNone>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmNoneValueRead(org::imm::ImmAdapterT<org::imm::ImmNone>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmNone>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmNoneAdapter", {InstanceMethod("getValue", &ImmNoneAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmNoneAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmNone>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmNone>> {
  using type = ImmNoneAdapter;
};

struct ImmErrorItemAdapter : public SharedPtrWrapBase<ImmErrorItemAdapter, org::imm::ImmAdapterT<org::imm::ImmErrorItem>> {
  using SharedPtrWrapBase<ImmErrorItemAdapter, org::imm::ImmAdapterT<org::imm::ImmErrorItem>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmErrorItemValueRead(org::imm::ImmAdapterT<org::imm::ImmErrorItem>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmErrorItem>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmErrorItemAdapter", {InstanceMethod("getValue", &ImmErrorItemAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmErrorItemAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmErrorItem>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmErrorItem>> {
  using type = ImmErrorItemAdapter;
};

struct ImmErrorGroupAdapter : public SharedPtrWrapBase<ImmErrorGroupAdapter, org::imm::ImmAdapterT<org::imm::ImmErrorGroup>> {
  using SharedPtrWrapBase<ImmErrorGroupAdapter, org::imm::ImmAdapterT<org::imm::ImmErrorGroup>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmErrorGroupValueRead(org::imm::ImmAdapterT<org::imm::ImmErrorGroup>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmErrorGroup>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmErrorGroupAdapter", {InstanceMethod("getValue", &ImmErrorGroupAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmErrorGroupAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmErrorGroup>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmErrorGroup>> {
  using type = ImmErrorGroupAdapter;
};

struct ImmStmtListAdapter : public SharedPtrWrapBase<ImmStmtListAdapter, org::imm::ImmAdapterT<org::imm::ImmStmtList>> {
  using SharedPtrWrapBase<ImmStmtListAdapter, org::imm::ImmAdapterT<org::imm::ImmStmtList>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmStmtListValueRead(org::imm::ImmAdapterT<org::imm::ImmStmtList>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmStmtList>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmStmtListAdapter", {InstanceMethod("getValue", &ImmStmtListAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmStmtListAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmStmtList>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmStmtList>> {
  using type = ImmStmtListAdapter;
};

struct ImmEmptyAdapter : public SharedPtrWrapBase<ImmEmptyAdapter, org::imm::ImmAdapterT<org::imm::ImmEmpty>> {
  using SharedPtrWrapBase<ImmEmptyAdapter, org::imm::ImmAdapterT<org::imm::ImmEmpty>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmEmptyValueRead(org::imm::ImmAdapterT<org::imm::ImmEmpty>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmEmpty>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmEmptyAdapter", {InstanceMethod("getValue", &ImmEmptyAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmEmptyAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmEmpty>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmEmpty>> {
  using type = ImmEmptyAdapter;
};

struct ImmTimeAdapter : public SharedPtrWrapBase<ImmTimeAdapter, org::imm::ImmAdapterT<org::imm::ImmTime>> {
  using SharedPtrWrapBase<ImmTimeAdapter, org::imm::ImmAdapterT<org::imm::ImmTime>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmTimeValueRead(org::imm::ImmAdapterT<org::imm::ImmTime>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmTime>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmTimeAdapter", {InstanceMethod("getValue", &ImmTimeAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmTimeAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmTime>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmTime>> {
  using type = ImmTimeAdapter;
};

struct ImmTimeRangeAdapter : public SharedPtrWrapBase<ImmTimeRangeAdapter, org::imm::ImmAdapterT<org::imm::ImmTimeRange>> {
  using SharedPtrWrapBase<ImmTimeRangeAdapter, org::imm::ImmAdapterT<org::imm::ImmTimeRange>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmTimeRangeValueRead(org::imm::ImmAdapterT<org::imm::ImmTimeRange>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmTimeRange>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmTimeRangeAdapter", {InstanceMethod("getValue", &ImmTimeRangeAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmTimeRangeAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmTimeRange>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmTimeRange>> {
  using type = ImmTimeRangeAdapter;
};

struct ImmMacroAdapter : public SharedPtrWrapBase<ImmMacroAdapter, org::imm::ImmAdapterT<org::imm::ImmMacro>> {
  using SharedPtrWrapBase<ImmMacroAdapter, org::imm::ImmAdapterT<org::imm::ImmMacro>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmMacroValueRead(org::imm::ImmAdapterT<org::imm::ImmMacro>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmMacro>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmMacroAdapter", {InstanceMethod("getValue", &ImmMacroAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmMacroAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmMacro>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmMacro>> {
  using type = ImmMacroAdapter;
};

struct ImmSymbolAdapter : public SharedPtrWrapBase<ImmSymbolAdapter, org::imm::ImmAdapterT<org::imm::ImmSymbol>> {
  using SharedPtrWrapBase<ImmSymbolAdapter, org::imm::ImmAdapterT<org::imm::ImmSymbol>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmSymbolValueRead(org::imm::ImmAdapterT<org::imm::ImmSymbol>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmSymbol>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmSymbolAdapter", {InstanceMethod("getValue", &ImmSymbolAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmSymbolAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmSymbol>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmSymbol>> {
  using type = ImmSymbolAdapter;
};

struct ImmLatexAdapter : public SharedPtrWrapBase<ImmLatexAdapter, org::imm::ImmAdapterT<org::imm::ImmLatex>> {
  using SharedPtrWrapBase<ImmLatexAdapter, org::imm::ImmAdapterT<org::imm::ImmLatex>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmLatexValueRead(org::imm::ImmAdapterT<org::imm::ImmLatex>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmLatex>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmLatexAdapter", {InstanceMethod("getValue", &ImmLatexAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmLatexAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmLatex>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmLatex>> {
  using type = ImmLatexAdapter;
};

struct ImmSubtreeLogAdapter : public SharedPtrWrapBase<ImmSubtreeLogAdapter, org::imm::ImmAdapterT<org::imm::ImmSubtreeLog>> {
  using SharedPtrWrapBase<ImmSubtreeLogAdapter, org::imm::ImmAdapterT<org::imm::ImmSubtreeLog>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmSubtreeLogValueRead(org::imm::ImmAdapterT<org::imm::ImmSubtreeLog>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmSubtreeLog>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmSubtreeLogAdapter", {InstanceMethod("getValue", &ImmSubtreeLogAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmSubtreeLogAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmSubtreeLog>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmSubtreeLog>> {
  using type = ImmSubtreeLogAdapter;
};

struct ImmColonExampleAdapter : public SharedPtrWrapBase<ImmColonExampleAdapter, org::imm::ImmAdapterT<org::imm::ImmColonExample>> {
  using SharedPtrWrapBase<ImmColonExampleAdapter, org::imm::ImmAdapterT<org::imm::ImmColonExample>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmColonExampleValueRead(org::imm::ImmAdapterT<org::imm::ImmColonExample>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmColonExample>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmColonExampleAdapter", {InstanceMethod("getValue", &ImmColonExampleAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmColonExampleAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmColonExample>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmColonExample>> {
  using type = ImmColonExampleAdapter;
};

struct ImmCallAdapter : public SharedPtrWrapBase<ImmCallAdapter, org::imm::ImmAdapterT<org::imm::ImmCall>> {
  using SharedPtrWrapBase<ImmCallAdapter, org::imm::ImmAdapterT<org::imm::ImmCall>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCallValueRead(org::imm::ImmAdapterT<org::imm::ImmCall>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmCall>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCallAdapter", {InstanceMethod("getValue", &ImmCallAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmCallAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmCall>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmCall>> {
  using type = ImmCallAdapter;
};

struct ImmFileAdapter : public SharedPtrWrapBase<ImmFileAdapter, org::imm::ImmAdapterT<org::imm::ImmFile>> {
  using SharedPtrWrapBase<ImmFileAdapter, org::imm::ImmAdapterT<org::imm::ImmFile>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmFileValueRead(org::imm::ImmAdapterT<org::imm::ImmFile>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmFile>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmFileAdapter", {InstanceMethod("getValue", &ImmFileAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmFileAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmFile>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmFile>> {
  using type = ImmFileAdapter;
};

struct ImmDirectoryAdapter : public SharedPtrWrapBase<ImmDirectoryAdapter, org::imm::ImmAdapterT<org::imm::ImmDirectory>> {
  using SharedPtrWrapBase<ImmDirectoryAdapter, org::imm::ImmAdapterT<org::imm::ImmDirectory>>::SharedPtrWrapBase;
  Napi::Value getFsSubnode(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<std::optional<org::imm::ImmAdapter>(org::imm::ImmAdapterT<org::imm::ImmDirectory>::*)(hstd::Str const&, bool) const>(&org::imm::ImmAdapterT<org::imm::ImmDirectory>::getFsSubnode),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"name"},
                                                        CxxArgSpec<bool>{"withPath", 1})));
  }
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmDirectoryValueRead(org::imm::ImmAdapterT<org::imm::ImmDirectory>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmDirectory>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmDirectoryAdapter", {InstanceMethod("getFsSubnode", &ImmDirectoryAdapter::getFsSubnode),
                                                                                                                              InstanceMethod("getValue", &ImmDirectoryAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmDirectoryAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmDirectory>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmDirectory>> {
  using type = ImmDirectoryAdapter;
};

struct ImmSymlinkAdapter : public SharedPtrWrapBase<ImmSymlinkAdapter, org::imm::ImmAdapterT<org::imm::ImmSymlink>> {
  using SharedPtrWrapBase<ImmSymlinkAdapter, org::imm::ImmAdapterT<org::imm::ImmSymlink>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmSymlinkValueRead(org::imm::ImmAdapterT<org::imm::ImmSymlink>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmSymlink>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmSymlinkAdapter", {InstanceMethod("getValue", &ImmSymlinkAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmSymlinkAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmSymlink>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmSymlink>> {
  using type = ImmSymlinkAdapter;
};

struct ImmDocumentFragmentAdapter : public SharedPtrWrapBase<ImmDocumentFragmentAdapter, org::imm::ImmAdapterT<org::imm::ImmDocumentFragment>> {
  using SharedPtrWrapBase<ImmDocumentFragmentAdapter, org::imm::ImmAdapterT<org::imm::ImmDocumentFragment>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmDocumentFragmentValueRead(org::imm::ImmAdapterT<org::imm::ImmDocumentFragment>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmDocumentFragment>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmDocumentFragmentAdapter", {InstanceMethod("getValue", &ImmDocumentFragmentAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmDocumentFragmentAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmDocumentFragment>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmDocumentFragment>> {
  using type = ImmDocumentFragmentAdapter;
};

struct ImmCriticMarkupAdapter : public SharedPtrWrapBase<ImmCriticMarkupAdapter, org::imm::ImmAdapterT<org::imm::ImmCriticMarkup>> {
  using SharedPtrWrapBase<ImmCriticMarkupAdapter, org::imm::ImmAdapterT<org::imm::ImmCriticMarkup>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCriticMarkupValueRead(org::imm::ImmAdapterT<org::imm::ImmCriticMarkup>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmCriticMarkup>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCriticMarkupAdapter", {InstanceMethod("getValue", &ImmCriticMarkupAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmCriticMarkupAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmCriticMarkup>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmCriticMarkup>> {
  using type = ImmCriticMarkupAdapter;
};

struct ImmListItemAdapter : public SharedPtrWrapBase<ImmListItemAdapter, org::imm::ImmAdapterT<org::imm::ImmListItem>> {
  using SharedPtrWrapBase<ImmListItemAdapter, org::imm::ImmAdapterT<org::imm::ImmListItem>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmListItemValueRead(org::imm::ImmAdapterT<org::imm::ImmListItem>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmListItem>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmListItemAdapter", {InstanceMethod("getValue", &ImmListItemAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmListItemAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmListItem>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmListItem>> {
  using type = ImmListItemAdapter;
};

struct ImmDocumentOptionsAdapter : public SharedPtrWrapBase<ImmDocumentOptionsAdapter, org::imm::ImmAdapterT<org::imm::ImmDocumentOptions>> {
  using SharedPtrWrapBase<ImmDocumentOptionsAdapter, org::imm::ImmAdapterT<org::imm::ImmDocumentOptions>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmDocumentOptionsValueRead(org::imm::ImmAdapterT<org::imm::ImmDocumentOptions>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmDocumentOptions>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmDocumentOptionsAdapter", {InstanceMethod("getValue", &ImmDocumentOptionsAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmDocumentOptionsAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmDocumentOptions>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmDocumentOptions>> {
  using type = ImmDocumentOptionsAdapter;
};

struct ImmDocumentAdapter : public SharedPtrWrapBase<ImmDocumentAdapter, org::imm::ImmAdapterT<org::imm::ImmDocument>> {
  using SharedPtrWrapBase<ImmDocumentAdapter, org::imm::ImmAdapterT<org::imm::ImmDocument>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmDocumentValueRead(org::imm::ImmAdapterT<org::imm::ImmDocument>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmDocument>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmDocumentAdapter", {InstanceMethod("getValue", &ImmDocumentAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmDocumentAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmDocument>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmDocument>> {
  using type = ImmDocumentAdapter;
};

struct ImmFileTargetAdapter : public SharedPtrWrapBase<ImmFileTargetAdapter, org::imm::ImmAdapterT<org::imm::ImmFileTarget>> {
  using SharedPtrWrapBase<ImmFileTargetAdapter, org::imm::ImmAdapterT<org::imm::ImmFileTarget>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmFileTargetValueRead(org::imm::ImmAdapterT<org::imm::ImmFileTarget>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmFileTarget>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmFileTargetAdapter", {InstanceMethod("getValue", &ImmFileTargetAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmFileTargetAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmFileTarget>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmFileTarget>> {
  using type = ImmFileTargetAdapter;
};

struct ImmTextSeparatorAdapter : public SharedPtrWrapBase<ImmTextSeparatorAdapter, org::imm::ImmAdapterT<org::imm::ImmTextSeparator>> {
  using SharedPtrWrapBase<ImmTextSeparatorAdapter, org::imm::ImmAdapterT<org::imm::ImmTextSeparator>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmTextSeparatorValueRead(org::imm::ImmAdapterT<org::imm::ImmTextSeparator>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmTextSeparator>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmTextSeparatorAdapter", {InstanceMethod("getValue", &ImmTextSeparatorAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmTextSeparatorAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmTextSeparator>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmTextSeparator>> {
  using type = ImmTextSeparatorAdapter;
};

struct ImmCmdIncludeAdapter : public SharedPtrWrapBase<ImmCmdIncludeAdapter, org::imm::ImmAdapterT<org::imm::ImmCmdInclude>> {
  using SharedPtrWrapBase<ImmCmdIncludeAdapter, org::imm::ImmAdapterT<org::imm::ImmCmdInclude>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCmdIncludeValueRead(org::imm::ImmAdapterT<org::imm::ImmCmdInclude>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmCmdInclude>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdIncludeAdapter", {InstanceMethod("getValue", &ImmCmdIncludeAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmCmdIncludeAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmCmdInclude>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmCmdInclude>> {
  using type = ImmCmdIncludeAdapter;
};

struct ImmDocumentGroupAdapter : public SharedPtrWrapBase<ImmDocumentGroupAdapter, org::imm::ImmAdapterT<org::imm::ImmDocumentGroup>> {
  using SharedPtrWrapBase<ImmDocumentGroupAdapter, org::imm::ImmAdapterT<org::imm::ImmDocumentGroup>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmDocumentGroupValueRead(org::imm::ImmAdapterT<org::imm::ImmDocumentGroup>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmDocumentGroup>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmDocumentGroupAdapter", {InstanceMethod("getValue", &ImmDocumentGroupAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmDocumentGroupAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmDocumentGroup>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmDocumentGroup>> {
  using type = ImmDocumentGroupAdapter;
};

struct ImmBlockCenterJs : public SharedPtrWrapBase<ImmBlockCenterJs, org::imm::ImmBlockCenter> {
  using SharedPtrWrapBase<ImmBlockCenterJs, org::imm::ImmBlockCenter>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmBlockCenter::*)(org::imm::ImmBlockCenter const&) const>(&org::imm::ImmBlockCenter::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmBlockCenter>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmBlockCenter::*)() const>(&org::imm::ImmBlockCenter::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockCenterJs", {InstanceMethod("operator==", &ImmBlockCenterJs::operator==),
                                                                                                                           InstanceMethod("getKind", &ImmBlockCenterJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmBlockCenterJs> {
  using type = org::imm::ImmBlockCenter;
};

template <>
struct org_to_js_type<org::imm::ImmBlockCenter> {
  using type = ImmBlockCenterJs;
};

struct ImmBlockQuoteJs : public SharedPtrWrapBase<ImmBlockQuoteJs, org::imm::ImmBlockQuote> {
  using SharedPtrWrapBase<ImmBlockQuoteJs, org::imm::ImmBlockQuote>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmBlockQuote::*)(org::imm::ImmBlockQuote const&) const>(&org::imm::ImmBlockQuote::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmBlockQuote>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmBlockQuote::*)() const>(&org::imm::ImmBlockQuote::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockQuoteJs", {InstanceMethod("operator==", &ImmBlockQuoteJs::operator==),
                                                                                                                          InstanceMethod("getKind", &ImmBlockQuoteJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmBlockQuoteJs> {
  using type = org::imm::ImmBlockQuote;
};

template <>
struct org_to_js_type<org::imm::ImmBlockQuote> {
  using type = ImmBlockQuoteJs;
};

struct ImmBlockVerseJs : public SharedPtrWrapBase<ImmBlockVerseJs, org::imm::ImmBlockVerse> {
  using SharedPtrWrapBase<ImmBlockVerseJs, org::imm::ImmBlockVerse>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmBlockVerse::*)(org::imm::ImmBlockVerse const&) const>(&org::imm::ImmBlockVerse::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmBlockVerse>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmBlockVerse::*)() const>(&org::imm::ImmBlockVerse::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockVerseJs", {InstanceMethod("operator==", &ImmBlockVerseJs::operator==),
                                                                                                                          InstanceMethod("getKind", &ImmBlockVerseJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmBlockVerseJs> {
  using type = org::imm::ImmBlockVerse;
};

template <>
struct org_to_js_type<org::imm::ImmBlockVerse> {
  using type = ImmBlockVerseJs;
};

struct ImmBlockDynamicFallbackJs : public SharedPtrWrapBase<ImmBlockDynamicFallbackJs, org::imm::ImmBlockDynamicFallback> {
  using SharedPtrWrapBase<ImmBlockDynamicFallbackJs, org::imm::ImmBlockDynamicFallback>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmBlockDynamicFallback::*)(org::imm::ImmBlockDynamicFallback const&) const>(&org::imm::ImmBlockDynamicFallback::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmBlockDynamicFallback>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmBlockDynamicFallback::*)() const>(&org::imm::ImmBlockDynamicFallback::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockDynamicFallbackJs", {InstanceMethod("operator==", &ImmBlockDynamicFallbackJs::operator==),
                                                                                                                                    InstanceMethod("getKind", &ImmBlockDynamicFallbackJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmBlockDynamicFallbackJs> {
  using type = org::imm::ImmBlockDynamicFallback;
};

template <>
struct org_to_js_type<org::imm::ImmBlockDynamicFallback> {
  using type = ImmBlockDynamicFallbackJs;
};

struct ImmBlockExampleJs : public SharedPtrWrapBase<ImmBlockExampleJs, org::imm::ImmBlockExample> {
  using SharedPtrWrapBase<ImmBlockExampleJs, org::imm::ImmBlockExample>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmBlockExample::*)(org::imm::ImmBlockExample const&) const>(&org::imm::ImmBlockExample::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmBlockExample>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmBlockExample::*)() const>(&org::imm::ImmBlockExample::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockExampleJs", {InstanceMethod("operator==", &ImmBlockExampleJs::operator==),
                                                                                                                            InstanceMethod("getKind", &ImmBlockExampleJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmBlockExampleJs> {
  using type = org::imm::ImmBlockExample;
};

template <>
struct org_to_js_type<org::imm::ImmBlockExample> {
  using type = ImmBlockExampleJs;
};

struct ImmBlockExportJs : public SharedPtrWrapBase<ImmBlockExportJs, org::imm::ImmBlockExport> {
  using SharedPtrWrapBase<ImmBlockExportJs, org::imm::ImmBlockExport>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmBlockExport::*)(org::imm::ImmBlockExport const&) const>(&org::imm::ImmBlockExport::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmBlockExport>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmBlockExport::*)() const>(&org::imm::ImmBlockExport::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockExportJs", {InstanceMethod("operator==", &ImmBlockExportJs::operator==),
                                                                                                                           InstanceMethod("getKind", &ImmBlockExportJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmBlockExportJs> {
  using type = org::imm::ImmBlockExport;
};

template <>
struct org_to_js_type<org::imm::ImmBlockExport> {
  using type = ImmBlockExportJs;
};

struct ImmBlockAdmonitionJs : public SharedPtrWrapBase<ImmBlockAdmonitionJs, org::imm::ImmBlockAdmonition> {
  using SharedPtrWrapBase<ImmBlockAdmonitionJs, org::imm::ImmBlockAdmonition>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmBlockAdmonition::*)(org::imm::ImmBlockAdmonition const&) const>(&org::imm::ImmBlockAdmonition::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmBlockAdmonition>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmBlockAdmonition::*)() const>(&org::imm::ImmBlockAdmonition::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockAdmonitionJs", {InstanceMethod("operator==", &ImmBlockAdmonitionJs::operator==),
                                                                                                                               InstanceMethod("getKind", &ImmBlockAdmonitionJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmBlockAdmonitionJs> {
  using type = org::imm::ImmBlockAdmonition;
};

template <>
struct org_to_js_type<org::imm::ImmBlockAdmonition> {
  using type = ImmBlockAdmonitionJs;
};

struct ImmBlockCodeEvalResultJs : public SharedPtrWrapBase<ImmBlockCodeEvalResultJs, org::imm::ImmBlockCodeEvalResult> {
  using SharedPtrWrapBase<ImmBlockCodeEvalResultJs, org::imm::ImmBlockCodeEvalResult>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmBlockCodeEvalResult::*)(org::imm::ImmBlockCodeEvalResult const&) const>(&org::imm::ImmBlockCodeEvalResult::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmBlockCodeEvalResult>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmBlockCodeEvalResult::*)() const>(&org::imm::ImmBlockCodeEvalResult::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockCodeEvalResultJs", {InstanceMethod("operator==", &ImmBlockCodeEvalResultJs::operator==),
                                                                                                                                   InstanceMethod("getKind", &ImmBlockCodeEvalResultJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmBlockCodeEvalResultJs> {
  using type = org::imm::ImmBlockCodeEvalResult;
};

template <>
struct org_to_js_type<org::imm::ImmBlockCodeEvalResult> {
  using type = ImmBlockCodeEvalResultJs;
};

struct ImmBlockCodeJs : public SharedPtrWrapBase<ImmBlockCodeJs, org::imm::ImmBlockCode> {
  using SharedPtrWrapBase<ImmBlockCodeJs, org::imm::ImmBlockCode>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmBlockCode::*)(org::imm::ImmBlockCode const&) const>(&org::imm::ImmBlockCode::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmBlockCode>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmBlockCode::*)() const>(&org::imm::ImmBlockCode::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockCodeJs", {InstanceMethod("operator==", &ImmBlockCodeJs::operator==),
                                                                                                                         InstanceMethod("getKind", &ImmBlockCodeJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmBlockCodeJs> {
  using type = org::imm::ImmBlockCode;
};

template <>
struct org_to_js_type<org::imm::ImmBlockCode> {
  using type = ImmBlockCodeJs;
};

struct ImmTableJs : public SharedPtrWrapBase<ImmTableJs, org::imm::ImmTable> {
  using SharedPtrWrapBase<ImmTableJs, org::imm::ImmTable>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmTable::*)(org::imm::ImmTable const&) const>(&org::imm::ImmTable::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmTable>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmTable::*)() const>(&org::imm::ImmTable::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmTableJs", {InstanceMethod("operator==", &ImmTableJs::operator==),
                                                                                                                     InstanceMethod("getKind", &ImmTableJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmTableJs> {
  using type = org::imm::ImmTable;
};

template <>
struct org_to_js_type<org::imm::ImmTable> {
  using type = ImmTableJs;
};

struct BlockCenterJs : public SharedPtrWrapBase<BlockCenterJs, org::sem::BlockCenter> {
  using SharedPtrWrapBase<BlockCenterJs, org::sem::BlockCenter>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::BlockCenter::*)() const>(&org::sem::BlockCenter::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockCenter::*)() const>(&org::sem::BlockCenter::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockCenter::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::BlockCenter::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::BlockCenter::*)() const>(&org::sem::BlockCenter::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockCenter::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::BlockCenter::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::BlockCenter::*)(int) const>(&org::sem::BlockCenter::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockCenter::*)(OrgSemKind) const>(&org::sem::BlockCenter::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockCenter::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockCenter::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockCenter::*)() const>(&org::sem::BlockCenter::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::BlockCenter::*)() const>(&org::sem::BlockCenter::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::BlockCenter::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockCenter::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::BlockCenter::*)(hstd::Str const&) const>(&org::sem::BlockCenter::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "BlockCenterJs", {InstanceMethod("getKind", &BlockCenterJs::getKind),
                                                                                                                        InstanceMethod("isGenerated", &BlockCenterJs::isGenerated),
                                                                                                                        InstanceMethod("push_back", &BlockCenterJs::push_back),
                                                                                                                        InstanceMethod("size", &BlockCenterJs::size),
                                                                                                                        InstanceMethod("insert", &BlockCenterJs::insert),
                                                                                                                        InstanceMethod("at", &BlockCenterJs::at),
                                                                                                                        InstanceMethod("is", &BlockCenterJs::is),
                                                                                                                        InstanceMethod("getAttached", &BlockCenterJs::getAttached),
                                                                                                                        InstanceMethod("getCaption", &BlockCenterJs::getCaption),
                                                                                                                        InstanceMethod("getName", &BlockCenterJs::getName),
                                                                                                                        InstanceMethod("getAttrs", &BlockCenterJs::getAttrs),
                                                                                                                        InstanceMethod("getFirstAttr", &BlockCenterJs::getFirstAttr)}); }
};

template <>
struct js_to_org_type<BlockCenterJs> {
  using type = org::sem::BlockCenter;
};

template <>
struct org_to_js_type<org::sem::BlockCenter> {
  using type = BlockCenterJs;
};

struct BlockQuoteJs : public SharedPtrWrapBase<BlockQuoteJs, org::sem::BlockQuote> {
  using SharedPtrWrapBase<BlockQuoteJs, org::sem::BlockQuote>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::BlockQuote::*)() const>(&org::sem::BlockQuote::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockQuote::*)() const>(&org::sem::BlockQuote::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockQuote::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::BlockQuote::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::BlockQuote::*)() const>(&org::sem::BlockQuote::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockQuote::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::BlockQuote::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::BlockQuote::*)(int) const>(&org::sem::BlockQuote::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockQuote::*)(OrgSemKind) const>(&org::sem::BlockQuote::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockQuote::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockQuote::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockQuote::*)() const>(&org::sem::BlockQuote::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::BlockQuote::*)() const>(&org::sem::BlockQuote::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::BlockQuote::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockQuote::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::BlockQuote::*)(hstd::Str const&) const>(&org::sem::BlockQuote::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "BlockQuoteJs", {InstanceMethod("getKind", &BlockQuoteJs::getKind),
                                                                                                                       InstanceMethod("isGenerated", &BlockQuoteJs::isGenerated),
                                                                                                                       InstanceMethod("push_back", &BlockQuoteJs::push_back),
                                                                                                                       InstanceMethod("size", &BlockQuoteJs::size),
                                                                                                                       InstanceMethod("insert", &BlockQuoteJs::insert),
                                                                                                                       InstanceMethod("at", &BlockQuoteJs::at),
                                                                                                                       InstanceMethod("is", &BlockQuoteJs::is),
                                                                                                                       InstanceMethod("getAttached", &BlockQuoteJs::getAttached),
                                                                                                                       InstanceMethod("getCaption", &BlockQuoteJs::getCaption),
                                                                                                                       InstanceMethod("getName", &BlockQuoteJs::getName),
                                                                                                                       InstanceMethod("getAttrs", &BlockQuoteJs::getAttrs),
                                                                                                                       InstanceMethod("getFirstAttr", &BlockQuoteJs::getFirstAttr)}); }
};

template <>
struct js_to_org_type<BlockQuoteJs> {
  using type = org::sem::BlockQuote;
};

template <>
struct org_to_js_type<org::sem::BlockQuote> {
  using type = BlockQuoteJs;
};

struct BlockVerseJs : public SharedPtrWrapBase<BlockVerseJs, org::sem::BlockVerse> {
  using SharedPtrWrapBase<BlockVerseJs, org::sem::BlockVerse>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::BlockVerse::*)() const>(&org::sem::BlockVerse::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockVerse::*)() const>(&org::sem::BlockVerse::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockVerse::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::BlockVerse::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::BlockVerse::*)() const>(&org::sem::BlockVerse::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockVerse::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::BlockVerse::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::BlockVerse::*)(int) const>(&org::sem::BlockVerse::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockVerse::*)(OrgSemKind) const>(&org::sem::BlockVerse::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockVerse::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockVerse::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockVerse::*)() const>(&org::sem::BlockVerse::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::BlockVerse::*)() const>(&org::sem::BlockVerse::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::BlockVerse::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockVerse::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::BlockVerse::*)(hstd::Str const&) const>(&org::sem::BlockVerse::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "BlockVerseJs", {InstanceMethod("getKind", &BlockVerseJs::getKind),
                                                                                                                       InstanceMethod("isGenerated", &BlockVerseJs::isGenerated),
                                                                                                                       InstanceMethod("push_back", &BlockVerseJs::push_back),
                                                                                                                       InstanceMethod("size", &BlockVerseJs::size),
                                                                                                                       InstanceMethod("insert", &BlockVerseJs::insert),
                                                                                                                       InstanceMethod("at", &BlockVerseJs::at),
                                                                                                                       InstanceMethod("is", &BlockVerseJs::is),
                                                                                                                       InstanceMethod("getAttached", &BlockVerseJs::getAttached),
                                                                                                                       InstanceMethod("getCaption", &BlockVerseJs::getCaption),
                                                                                                                       InstanceMethod("getName", &BlockVerseJs::getName),
                                                                                                                       InstanceMethod("getAttrs", &BlockVerseJs::getAttrs),
                                                                                                                       InstanceMethod("getFirstAttr", &BlockVerseJs::getFirstAttr)}); }
};

template <>
struct js_to_org_type<BlockVerseJs> {
  using type = org::sem::BlockVerse;
};

template <>
struct org_to_js_type<org::sem::BlockVerse> {
  using type = BlockVerseJs;
};

struct BlockDynamicFallbackJs : public SharedPtrWrapBase<BlockDynamicFallbackJs, org::sem::BlockDynamicFallback> {
  using SharedPtrWrapBase<BlockDynamicFallbackJs, org::sem::BlockDynamicFallback>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::BlockDynamicFallback::*)() const>(&org::sem::BlockDynamicFallback::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockDynamicFallback::*)() const>(&org::sem::BlockDynamicFallback::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockDynamicFallback::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::BlockDynamicFallback::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::BlockDynamicFallback::*)() const>(&org::sem::BlockDynamicFallback::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockDynamicFallback::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::BlockDynamicFallback::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::BlockDynamicFallback::*)(int) const>(&org::sem::BlockDynamicFallback::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockDynamicFallback::*)(OrgSemKind) const>(&org::sem::BlockDynamicFallback::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockDynamicFallback::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockDynamicFallback::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockDynamicFallback::*)() const>(&org::sem::BlockDynamicFallback::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::BlockDynamicFallback::*)() const>(&org::sem::BlockDynamicFallback::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::BlockDynamicFallback::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockDynamicFallback::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::BlockDynamicFallback::*)(hstd::Str const&) const>(&org::sem::BlockDynamicFallback::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "BlockDynamicFallbackJs", {InstanceMethod("getKind", &BlockDynamicFallbackJs::getKind),
                                                                                                                                 InstanceMethod("isGenerated", &BlockDynamicFallbackJs::isGenerated),
                                                                                                                                 InstanceMethod("push_back", &BlockDynamicFallbackJs::push_back),
                                                                                                                                 InstanceMethod("size", &BlockDynamicFallbackJs::size),
                                                                                                                                 InstanceMethod("insert", &BlockDynamicFallbackJs::insert),
                                                                                                                                 InstanceMethod("at", &BlockDynamicFallbackJs::at),
                                                                                                                                 InstanceMethod("is", &BlockDynamicFallbackJs::is),
                                                                                                                                 InstanceMethod("getAttached", &BlockDynamicFallbackJs::getAttached),
                                                                                                                                 InstanceMethod("getCaption", &BlockDynamicFallbackJs::getCaption),
                                                                                                                                 InstanceMethod("getName", &BlockDynamicFallbackJs::getName),
                                                                                                                                 InstanceMethod("getAttrs", &BlockDynamicFallbackJs::getAttrs),
                                                                                                                                 InstanceMethod("getFirstAttr", &BlockDynamicFallbackJs::getFirstAttr)}); }
};

template <>
struct js_to_org_type<BlockDynamicFallbackJs> {
  using type = org::sem::BlockDynamicFallback;
};

template <>
struct org_to_js_type<org::sem::BlockDynamicFallback> {
  using type = BlockDynamicFallbackJs;
};

struct BlockExampleJs : public SharedPtrWrapBase<BlockExampleJs, org::sem::BlockExample> {
  using SharedPtrWrapBase<BlockExampleJs, org::sem::BlockExample>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::BlockExample::*)() const>(&org::sem::BlockExample::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockExample::*)() const>(&org::sem::BlockExample::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockExample::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::BlockExample::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::BlockExample::*)() const>(&org::sem::BlockExample::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockExample::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::BlockExample::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::BlockExample::*)(int) const>(&org::sem::BlockExample::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockExample::*)(OrgSemKind) const>(&org::sem::BlockExample::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockExample::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockExample::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockExample::*)() const>(&org::sem::BlockExample::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::BlockExample::*)() const>(&org::sem::BlockExample::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::BlockExample::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockExample::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::BlockExample::*)(hstd::Str const&) const>(&org::sem::BlockExample::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "BlockExampleJs", {InstanceMethod("getKind", &BlockExampleJs::getKind),
                                                                                                                         InstanceMethod("isGenerated", &BlockExampleJs::isGenerated),
                                                                                                                         InstanceMethod("push_back", &BlockExampleJs::push_back),
                                                                                                                         InstanceMethod("size", &BlockExampleJs::size),
                                                                                                                         InstanceMethod("insert", &BlockExampleJs::insert),
                                                                                                                         InstanceMethod("at", &BlockExampleJs::at),
                                                                                                                         InstanceMethod("is", &BlockExampleJs::is),
                                                                                                                         InstanceMethod("getAttached", &BlockExampleJs::getAttached),
                                                                                                                         InstanceMethod("getCaption", &BlockExampleJs::getCaption),
                                                                                                                         InstanceMethod("getName", &BlockExampleJs::getName),
                                                                                                                         InstanceMethod("getAttrs", &BlockExampleJs::getAttrs),
                                                                                                                         InstanceMethod("getFirstAttr", &BlockExampleJs::getFirstAttr)}); }
};

template <>
struct js_to_org_type<BlockExampleJs> {
  using type = org::sem::BlockExample;
};

template <>
struct org_to_js_type<org::sem::BlockExample> {
  using type = BlockExampleJs;
};

struct BlockExportJs : public SharedPtrWrapBase<BlockExportJs, org::sem::BlockExport> {
  using SharedPtrWrapBase<BlockExportJs, org::sem::BlockExport>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::BlockExport::*)() const>(&org::sem::BlockExport::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockExport::*)() const>(&org::sem::BlockExport::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockExport::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::BlockExport::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::BlockExport::*)() const>(&org::sem::BlockExport::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockExport::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::BlockExport::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::BlockExport::*)(int) const>(&org::sem::BlockExport::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockExport::*)(OrgSemKind) const>(&org::sem::BlockExport::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockExport::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockExport::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockExport::*)() const>(&org::sem::BlockExport::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::BlockExport::*)() const>(&org::sem::BlockExport::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::BlockExport::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockExport::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::BlockExport::*)(hstd::Str const&) const>(&org::sem::BlockExport::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  Napi::Value getPlacement(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<hstd::Str>(org::sem::BlockExport::*)() const>(&org::sem::BlockExport::getPlacement),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "BlockExportJs", {InstanceMethod("getKind", &BlockExportJs::getKind),
                                                                                                                        InstanceMethod("isGenerated", &BlockExportJs::isGenerated),
                                                                                                                        InstanceMethod("push_back", &BlockExportJs::push_back),
                                                                                                                        InstanceMethod("size", &BlockExportJs::size),
                                                                                                                        InstanceMethod("insert", &BlockExportJs::insert),
                                                                                                                        InstanceMethod("at", &BlockExportJs::at),
                                                                                                                        InstanceMethod("is", &BlockExportJs::is),
                                                                                                                        InstanceMethod("getAttached", &BlockExportJs::getAttached),
                                                                                                                        InstanceMethod("getCaption", &BlockExportJs::getCaption),
                                                                                                                        InstanceMethod("getName", &BlockExportJs::getName),
                                                                                                                        InstanceMethod("getAttrs", &BlockExportJs::getAttrs),
                                                                                                                        InstanceMethod("getFirstAttr", &BlockExportJs::getFirstAttr),
                                                                                                                        InstanceMethod("getPlacement", &BlockExportJs::getPlacement)}); }
};

template <>
struct js_to_org_type<BlockExportJs> {
  using type = org::sem::BlockExport;
};

template <>
struct org_to_js_type<org::sem::BlockExport> {
  using type = BlockExportJs;
};

struct BlockAdmonitionJs : public SharedPtrWrapBase<BlockAdmonitionJs, org::sem::BlockAdmonition> {
  using SharedPtrWrapBase<BlockAdmonitionJs, org::sem::BlockAdmonition>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::BlockAdmonition::*)() const>(&org::sem::BlockAdmonition::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockAdmonition::*)() const>(&org::sem::BlockAdmonition::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockAdmonition::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::BlockAdmonition::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::BlockAdmonition::*)() const>(&org::sem::BlockAdmonition::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockAdmonition::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::BlockAdmonition::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::BlockAdmonition::*)(int) const>(&org::sem::BlockAdmonition::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockAdmonition::*)(OrgSemKind) const>(&org::sem::BlockAdmonition::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockAdmonition::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockAdmonition::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockAdmonition::*)() const>(&org::sem::BlockAdmonition::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::BlockAdmonition::*)() const>(&org::sem::BlockAdmonition::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::BlockAdmonition::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockAdmonition::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::BlockAdmonition::*)(hstd::Str const&) const>(&org::sem::BlockAdmonition::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "BlockAdmonitionJs", {InstanceMethod("getKind", &BlockAdmonitionJs::getKind),
                                                                                                                            InstanceMethod("isGenerated", &BlockAdmonitionJs::isGenerated),
                                                                                                                            InstanceMethod("push_back", &BlockAdmonitionJs::push_back),
                                                                                                                            InstanceMethod("size", &BlockAdmonitionJs::size),
                                                                                                                            InstanceMethod("insert", &BlockAdmonitionJs::insert),
                                                                                                                            InstanceMethod("at", &BlockAdmonitionJs::at),
                                                                                                                            InstanceMethod("is", &BlockAdmonitionJs::is),
                                                                                                                            InstanceMethod("getAttached", &BlockAdmonitionJs::getAttached),
                                                                                                                            InstanceMethod("getCaption", &BlockAdmonitionJs::getCaption),
                                                                                                                            InstanceMethod("getName", &BlockAdmonitionJs::getName),
                                                                                                                            InstanceMethod("getAttrs", &BlockAdmonitionJs::getAttrs),
                                                                                                                            InstanceMethod("getFirstAttr", &BlockAdmonitionJs::getFirstAttr)}); }
};

template <>
struct js_to_org_type<BlockAdmonitionJs> {
  using type = org::sem::BlockAdmonition;
};

template <>
struct org_to_js_type<org::sem::BlockAdmonition> {
  using type = BlockAdmonitionJs;
};

struct BlockCodeEvalResultJs : public SharedPtrWrapBase<BlockCodeEvalResultJs, org::sem::BlockCodeEvalResult> {
  using SharedPtrWrapBase<BlockCodeEvalResultJs, org::sem::BlockCodeEvalResult>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::BlockCodeEvalResult::*)() const>(&org::sem::BlockCodeEvalResult::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockCodeEvalResult::*)() const>(&org::sem::BlockCodeEvalResult::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockCodeEvalResult::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::BlockCodeEvalResult::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::BlockCodeEvalResult::*)() const>(&org::sem::BlockCodeEvalResult::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockCodeEvalResult::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::BlockCodeEvalResult::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::BlockCodeEvalResult::*)(int) const>(&org::sem::BlockCodeEvalResult::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockCodeEvalResult::*)(OrgSemKind) const>(&org::sem::BlockCodeEvalResult::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockCodeEvalResult::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockCodeEvalResult::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockCodeEvalResult::*)() const>(&org::sem::BlockCodeEvalResult::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::BlockCodeEvalResult::*)() const>(&org::sem::BlockCodeEvalResult::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::BlockCodeEvalResult::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockCodeEvalResult::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::BlockCodeEvalResult::*)(hstd::Str const&) const>(&org::sem::BlockCodeEvalResult::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "BlockCodeEvalResultJs", {InstanceMethod("getKind", &BlockCodeEvalResultJs::getKind),
                                                                                                                                InstanceMethod("isGenerated", &BlockCodeEvalResultJs::isGenerated),
                                                                                                                                InstanceMethod("push_back", &BlockCodeEvalResultJs::push_back),
                                                                                                                                InstanceMethod("size", &BlockCodeEvalResultJs::size),
                                                                                                                                InstanceMethod("insert", &BlockCodeEvalResultJs::insert),
                                                                                                                                InstanceMethod("at", &BlockCodeEvalResultJs::at),
                                                                                                                                InstanceMethod("is", &BlockCodeEvalResultJs::is),
                                                                                                                                InstanceMethod("getAttached", &BlockCodeEvalResultJs::getAttached),
                                                                                                                                InstanceMethod("getCaption", &BlockCodeEvalResultJs::getCaption),
                                                                                                                                InstanceMethod("getName", &BlockCodeEvalResultJs::getName),
                                                                                                                                InstanceMethod("getAttrs", &BlockCodeEvalResultJs::getAttrs),
                                                                                                                                InstanceMethod("getFirstAttr", &BlockCodeEvalResultJs::getFirstAttr)}); }
};

template <>
struct js_to_org_type<BlockCodeEvalResultJs> {
  using type = org::sem::BlockCodeEvalResult;
};

template <>
struct org_to_js_type<org::sem::BlockCodeEvalResult> {
  using type = BlockCodeEvalResultJs;
};

struct BlockCodeJs : public SharedPtrWrapBase<BlockCodeJs, org::sem::BlockCode> {
  using SharedPtrWrapBase<BlockCodeJs, org::sem::BlockCode>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::BlockCode::*)() const>(&org::sem::BlockCode::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockCode::*)() const>(&org::sem::BlockCode::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockCode::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::BlockCode::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::BlockCode::*)() const>(&org::sem::BlockCode::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::BlockCode::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::BlockCode::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::BlockCode::*)(int) const>(&org::sem::BlockCode::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::BlockCode::*)(OrgSemKind) const>(&org::sem::BlockCode::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockCode::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockCode::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::BlockCode::*)() const>(&org::sem::BlockCode::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::BlockCode::*)() const>(&org::sem::BlockCode::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::BlockCode::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::BlockCode::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::BlockCode::*)(hstd::Str const&) const>(&org::sem::BlockCode::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  Napi::Value getVariable(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::BlockCode::*)(hstd::Str const&) const>(&org::sem::BlockCode::getVariable),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"varname"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "BlockCodeJs", {InstanceMethod("getKind", &BlockCodeJs::getKind),
                                                                                                                      InstanceMethod("isGenerated", &BlockCodeJs::isGenerated),
                                                                                                                      InstanceMethod("push_back", &BlockCodeJs::push_back),
                                                                                                                      InstanceMethod("size", &BlockCodeJs::size),
                                                                                                                      InstanceMethod("insert", &BlockCodeJs::insert),
                                                                                                                      InstanceMethod("at", &BlockCodeJs::at),
                                                                                                                      InstanceMethod("is", &BlockCodeJs::is),
                                                                                                                      InstanceMethod("getAttached", &BlockCodeJs::getAttached),
                                                                                                                      InstanceMethod("getCaption", &BlockCodeJs::getCaption),
                                                                                                                      InstanceMethod("getName", &BlockCodeJs::getName),
                                                                                                                      InstanceMethod("getAttrs", &BlockCodeJs::getAttrs),
                                                                                                                      InstanceMethod("getFirstAttr", &BlockCodeJs::getFirstAttr),
                                                                                                                      InstanceMethod("getVariable", &BlockCodeJs::getVariable)}); }
};

template <>
struct js_to_org_type<BlockCodeJs> {
  using type = org::sem::BlockCode;
};

template <>
struct org_to_js_type<org::sem::BlockCode> {
  using type = BlockCodeJs;
};

struct TableJs : public SharedPtrWrapBase<TableJs, org::sem::Table> {
  using SharedPtrWrapBase<TableJs, org::sem::Table>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::Table::*)() const>(&org::sem::Table::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Table::*)() const>(&org::sem::Table::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Table::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::Table::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::Table::*)() const>(&org::sem::Table::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::Table::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::Table::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::Table::*)(int) const>(&org::sem::Table::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::Table::*)(OrgSemKind) const>(&org::sem::Table::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::Table::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::Table::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::Table::*)() const>(&org::sem::Table::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::Table::*)() const>(&org::sem::Table::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::Table::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::Table::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::Table::*)(hstd::Str const&) const>(&org::sem::Table::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "TableJs", {InstanceMethod("getKind", &TableJs::getKind),
                                                                                                                  InstanceMethod("isGenerated", &TableJs::isGenerated),
                                                                                                                  InstanceMethod("push_back", &TableJs::push_back),
                                                                                                                  InstanceMethod("size", &TableJs::size),
                                                                                                                  InstanceMethod("insert", &TableJs::insert),
                                                                                                                  InstanceMethod("at", &TableJs::at),
                                                                                                                  InstanceMethod("is", &TableJs::is),
                                                                                                                  InstanceMethod("getAttached", &TableJs::getAttached),
                                                                                                                  InstanceMethod("getCaption", &TableJs::getCaption),
                                                                                                                  InstanceMethod("getName", &TableJs::getName),
                                                                                                                  InstanceMethod("getAttrs", &TableJs::getAttrs),
                                                                                                                  InstanceMethod("getFirstAttr", &TableJs::getFirstAttr)}); }
};

template <>
struct js_to_org_type<TableJs> {
  using type = org::sem::Table;
};

template <>
struct org_to_js_type<org::sem::Table> {
  using type = TableJs;
};

struct ImmCmdCustomRawAdapter : public SharedPtrWrapBase<ImmCmdCustomRawAdapter, org::imm::ImmAdapterT<org::imm::ImmCmdCustomRaw>> {
  using SharedPtrWrapBase<ImmCmdCustomRawAdapter, org::imm::ImmAdapterT<org::imm::ImmCmdCustomRaw>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCmdCustomRawValueRead(org::imm::ImmAdapterT<org::imm::ImmCmdCustomRaw>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmCmdCustomRaw>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdCustomRawAdapter", {InstanceMethod("getValue", &ImmCmdCustomRawAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmCmdCustomRawAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmCmdCustomRaw>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmCmdCustomRaw>> {
  using type = ImmCmdCustomRawAdapter;
};

struct ImmCmdCustomTextAdapter : public SharedPtrWrapBase<ImmCmdCustomTextAdapter, org::imm::ImmAdapterT<org::imm::ImmCmdCustomText>> {
  using SharedPtrWrapBase<ImmCmdCustomTextAdapter, org::imm::ImmAdapterT<org::imm::ImmCmdCustomText>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCmdCustomTextValueRead(org::imm::ImmAdapterT<org::imm::ImmCmdCustomText>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmCmdCustomText>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdCustomTextAdapter", {InstanceMethod("getValue", &ImmCmdCustomTextAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmCmdCustomTextAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmCmdCustomText>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmCmdCustomText>> {
  using type = ImmCmdCustomTextAdapter;
};

struct ImmLinkAdapter : public SharedPtrWrapBase<ImmLinkAdapter, org::imm::ImmAdapterT<org::imm::ImmLink>> {
  using SharedPtrWrapBase<ImmLinkAdapter, org::imm::ImmAdapterT<org::imm::ImmLink>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmLinkValueRead(org::imm::ImmAdapterT<org::imm::ImmLink>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmLink>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmLinkAdapter", {InstanceMethod("getValue", &ImmLinkAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmLinkAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmLink>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmLink>> {
  using type = ImmLinkAdapter;
};

struct ImmBlockCommentAdapter : public SharedPtrWrapBase<ImmBlockCommentAdapter, org::imm::ImmAdapterT<org::imm::ImmBlockComment>> {
  using SharedPtrWrapBase<ImmBlockCommentAdapter, org::imm::ImmAdapterT<org::imm::ImmBlockComment>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmBlockCommentValueRead(org::imm::ImmAdapterT<org::imm::ImmBlockComment>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmBlockComment>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockCommentAdapter", {InstanceMethod("getValue", &ImmBlockCommentAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmBlockCommentAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmBlockComment>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmBlockComment>> {
  using type = ImmBlockCommentAdapter;
};

struct ImmParagraphAdapter : public SharedPtrWrapBase<ImmParagraphAdapter, org::imm::ImmAdapterT<org::imm::ImmParagraph>> {
  using SharedPtrWrapBase<ImmParagraphAdapter, org::imm::ImmAdapterT<org::imm::ImmParagraph>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmParagraphValueRead(org::imm::ImmAdapterT<org::imm::ImmParagraph>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmParagraph>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmParagraphAdapter", {InstanceMethod("getValue", &ImmParagraphAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmParagraphAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmParagraph>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmParagraph>> {
  using type = ImmParagraphAdapter;
};

struct ImmListAdapter : public SharedPtrWrapBase<ImmListAdapter, org::imm::ImmAdapterT<org::imm::ImmList>> {
  using SharedPtrWrapBase<ImmListAdapter, org::imm::ImmAdapterT<org::imm::ImmList>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmListValueRead(org::imm::ImmAdapterT<org::imm::ImmList>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmList>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmListAdapter", {InstanceMethod("getValue", &ImmListAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmListAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmList>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmList>> {
  using type = ImmListAdapter;
};

struct ImmHashTagAdapter : public SharedPtrWrapBase<ImmHashTagAdapter, org::imm::ImmAdapterT<org::imm::ImmHashTag>> {
  using SharedPtrWrapBase<ImmHashTagAdapter, org::imm::ImmAdapterT<org::imm::ImmHashTag>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmHashTagValueRead(org::imm::ImmAdapterT<org::imm::ImmHashTag>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmHashTag>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmHashTagAdapter", {InstanceMethod("getValue", &ImmHashTagAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmHashTagAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmHashTag>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmHashTag>> {
  using type = ImmHashTagAdapter;
};

struct ImmInlineFootnoteAdapter : public SharedPtrWrapBase<ImmInlineFootnoteAdapter, org::imm::ImmAdapterT<org::imm::ImmInlineFootnote>> {
  using SharedPtrWrapBase<ImmInlineFootnoteAdapter, org::imm::ImmAdapterT<org::imm::ImmInlineFootnote>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmInlineFootnoteValueRead(org::imm::ImmAdapterT<org::imm::ImmInlineFootnote>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmInlineFootnote>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmInlineFootnoteAdapter", {InstanceMethod("getValue", &ImmInlineFootnoteAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmInlineFootnoteAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmInlineFootnote>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmInlineFootnote>> {
  using type = ImmInlineFootnoteAdapter;
};

struct ImmEscapedAdapter : public SharedPtrWrapBase<ImmEscapedAdapter, org::imm::ImmAdapterT<org::imm::ImmEscaped>> {
  using SharedPtrWrapBase<ImmEscapedAdapter, org::imm::ImmAdapterT<org::imm::ImmEscaped>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmEscapedValueRead(org::imm::ImmAdapterT<org::imm::ImmEscaped>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmEscaped>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmEscapedAdapter", {InstanceMethod("getValue", &ImmEscapedAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmEscapedAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmEscaped>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmEscaped>> {
  using type = ImmEscapedAdapter;
};

struct ImmNewlineAdapter : public SharedPtrWrapBase<ImmNewlineAdapter, org::imm::ImmAdapterT<org::imm::ImmNewline>> {
  using SharedPtrWrapBase<ImmNewlineAdapter, org::imm::ImmAdapterT<org::imm::ImmNewline>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmNewlineValueRead(org::imm::ImmAdapterT<org::imm::ImmNewline>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmNewline>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmNewlineAdapter", {InstanceMethod("getValue", &ImmNewlineAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmNewlineAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmNewline>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmNewline>> {
  using type = ImmNewlineAdapter;
};

struct ImmSpaceAdapter : public SharedPtrWrapBase<ImmSpaceAdapter, org::imm::ImmAdapterT<org::imm::ImmSpace>> {
  using SharedPtrWrapBase<ImmSpaceAdapter, org::imm::ImmAdapterT<org::imm::ImmSpace>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmSpaceValueRead(org::imm::ImmAdapterT<org::imm::ImmSpace>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmSpace>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmSpaceAdapter", {InstanceMethod("getValue", &ImmSpaceAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmSpaceAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmSpace>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmSpace>> {
  using type = ImmSpaceAdapter;
};

struct ImmWordAdapter : public SharedPtrWrapBase<ImmWordAdapter, org::imm::ImmAdapterT<org::imm::ImmWord>> {
  using SharedPtrWrapBase<ImmWordAdapter, org::imm::ImmAdapterT<org::imm::ImmWord>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmWordValueRead(org::imm::ImmAdapterT<org::imm::ImmWord>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmWord>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmWordAdapter", {InstanceMethod("getValue", &ImmWordAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmWordAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmWord>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmWord>> {
  using type = ImmWordAdapter;
};

struct ImmAtMentionAdapter : public SharedPtrWrapBase<ImmAtMentionAdapter, org::imm::ImmAdapterT<org::imm::ImmAtMention>> {
  using SharedPtrWrapBase<ImmAtMentionAdapter, org::imm::ImmAdapterT<org::imm::ImmAtMention>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmAtMentionValueRead(org::imm::ImmAdapterT<org::imm::ImmAtMention>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmAtMention>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmAtMentionAdapter", {InstanceMethod("getValue", &ImmAtMentionAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmAtMentionAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmAtMention>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmAtMention>> {
  using type = ImmAtMentionAdapter;
};

struct ImmRawTextAdapter : public SharedPtrWrapBase<ImmRawTextAdapter, org::imm::ImmAdapterT<org::imm::ImmRawText>> {
  using SharedPtrWrapBase<ImmRawTextAdapter, org::imm::ImmAdapterT<org::imm::ImmRawText>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmRawTextValueRead(org::imm::ImmAdapterT<org::imm::ImmRawText>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmRawText>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmRawTextAdapter", {InstanceMethod("getValue", &ImmRawTextAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmRawTextAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmRawText>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmRawText>> {
  using type = ImmRawTextAdapter;
};

struct ImmPunctuationAdapter : public SharedPtrWrapBase<ImmPunctuationAdapter, org::imm::ImmAdapterT<org::imm::ImmPunctuation>> {
  using SharedPtrWrapBase<ImmPunctuationAdapter, org::imm::ImmAdapterT<org::imm::ImmPunctuation>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmPunctuationValueRead(org::imm::ImmAdapterT<org::imm::ImmPunctuation>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmPunctuation>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmPunctuationAdapter", {InstanceMethod("getValue", &ImmPunctuationAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmPunctuationAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmPunctuation>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmPunctuation>> {
  using type = ImmPunctuationAdapter;
};

struct ImmPlaceholderAdapter : public SharedPtrWrapBase<ImmPlaceholderAdapter, org::imm::ImmAdapterT<org::imm::ImmPlaceholder>> {
  using SharedPtrWrapBase<ImmPlaceholderAdapter, org::imm::ImmAdapterT<org::imm::ImmPlaceholder>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmPlaceholderValueRead(org::imm::ImmAdapterT<org::imm::ImmPlaceholder>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmPlaceholder>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmPlaceholderAdapter", {InstanceMethod("getValue", &ImmPlaceholderAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmPlaceholderAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmPlaceholder>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmPlaceholder>> {
  using type = ImmPlaceholderAdapter;
};

struct ImmBigIdentAdapter : public SharedPtrWrapBase<ImmBigIdentAdapter, org::imm::ImmAdapterT<org::imm::ImmBigIdent>> {
  using SharedPtrWrapBase<ImmBigIdentAdapter, org::imm::ImmAdapterT<org::imm::ImmBigIdent>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmBigIdentValueRead(org::imm::ImmAdapterT<org::imm::ImmBigIdent>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmBigIdent>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBigIdentAdapter", {InstanceMethod("getValue", &ImmBigIdentAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmBigIdentAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmBigIdent>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmBigIdent>> {
  using type = ImmBigIdentAdapter;
};

struct ImmTextTargetAdapter : public SharedPtrWrapBase<ImmTextTargetAdapter, org::imm::ImmAdapterT<org::imm::ImmTextTarget>> {
  using SharedPtrWrapBase<ImmTextTargetAdapter, org::imm::ImmAdapterT<org::imm::ImmTextTarget>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmTextTargetValueRead(org::imm::ImmAdapterT<org::imm::ImmTextTarget>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmTextTarget>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmTextTargetAdapter", {InstanceMethod("getValue", &ImmTextTargetAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmTextTargetAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmTextTarget>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmTextTarget>> {
  using type = ImmTextTargetAdapter;
};

struct ImmBoldAdapter : public SharedPtrWrapBase<ImmBoldAdapter, org::imm::ImmAdapterT<org::imm::ImmBold>> {
  using SharedPtrWrapBase<ImmBoldAdapter, org::imm::ImmAdapterT<org::imm::ImmBold>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmBoldValueRead(org::imm::ImmAdapterT<org::imm::ImmBold>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmBold>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBoldAdapter", {InstanceMethod("getValue", &ImmBoldAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmBoldAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmBold>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmBold>> {
  using type = ImmBoldAdapter;
};

struct ImmUnderlineAdapter : public SharedPtrWrapBase<ImmUnderlineAdapter, org::imm::ImmAdapterT<org::imm::ImmUnderline>> {
  using SharedPtrWrapBase<ImmUnderlineAdapter, org::imm::ImmAdapterT<org::imm::ImmUnderline>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmUnderlineValueRead(org::imm::ImmAdapterT<org::imm::ImmUnderline>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmUnderline>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmUnderlineAdapter", {InstanceMethod("getValue", &ImmUnderlineAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmUnderlineAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmUnderline>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmUnderline>> {
  using type = ImmUnderlineAdapter;
};

struct ImmMonospaceAdapter : public SharedPtrWrapBase<ImmMonospaceAdapter, org::imm::ImmAdapterT<org::imm::ImmMonospace>> {
  using SharedPtrWrapBase<ImmMonospaceAdapter, org::imm::ImmAdapterT<org::imm::ImmMonospace>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmMonospaceValueRead(org::imm::ImmAdapterT<org::imm::ImmMonospace>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmMonospace>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmMonospaceAdapter", {InstanceMethod("getValue", &ImmMonospaceAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmMonospaceAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmMonospace>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmMonospace>> {
  using type = ImmMonospaceAdapter;
};

struct ImmMarkQuoteAdapter : public SharedPtrWrapBase<ImmMarkQuoteAdapter, org::imm::ImmAdapterT<org::imm::ImmMarkQuote>> {
  using SharedPtrWrapBase<ImmMarkQuoteAdapter, org::imm::ImmAdapterT<org::imm::ImmMarkQuote>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmMarkQuoteValueRead(org::imm::ImmAdapterT<org::imm::ImmMarkQuote>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmMarkQuote>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmMarkQuoteAdapter", {InstanceMethod("getValue", &ImmMarkQuoteAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmMarkQuoteAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmMarkQuote>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmMarkQuote>> {
  using type = ImmMarkQuoteAdapter;
};

struct ImmRadioTargetAdapter : public SharedPtrWrapBase<ImmRadioTargetAdapter, org::imm::ImmAdapterT<org::imm::ImmRadioTarget>> {
  using SharedPtrWrapBase<ImmRadioTargetAdapter, org::imm::ImmAdapterT<org::imm::ImmRadioTarget>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmRadioTargetValueRead(org::imm::ImmAdapterT<org::imm::ImmRadioTarget>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmRadioTarget>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmRadioTargetAdapter", {InstanceMethod("getValue", &ImmRadioTargetAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmRadioTargetAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmRadioTarget>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmRadioTarget>> {
  using type = ImmRadioTargetAdapter;
};

struct ImmVerbatimAdapter : public SharedPtrWrapBase<ImmVerbatimAdapter, org::imm::ImmAdapterT<org::imm::ImmVerbatim>> {
  using SharedPtrWrapBase<ImmVerbatimAdapter, org::imm::ImmAdapterT<org::imm::ImmVerbatim>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmVerbatimValueRead(org::imm::ImmAdapterT<org::imm::ImmVerbatim>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmVerbatim>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmVerbatimAdapter", {InstanceMethod("getValue", &ImmVerbatimAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmVerbatimAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmVerbatim>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmVerbatim>> {
  using type = ImmVerbatimAdapter;
};

struct ImmItalicAdapter : public SharedPtrWrapBase<ImmItalicAdapter, org::imm::ImmAdapterT<org::imm::ImmItalic>> {
  using SharedPtrWrapBase<ImmItalicAdapter, org::imm::ImmAdapterT<org::imm::ImmItalic>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmItalicValueRead(org::imm::ImmAdapterT<org::imm::ImmItalic>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmItalic>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmItalicAdapter", {InstanceMethod("getValue", &ImmItalicAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmItalicAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmItalic>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmItalic>> {
  using type = ImmItalicAdapter;
};

struct ImmStrikeAdapter : public SharedPtrWrapBase<ImmStrikeAdapter, org::imm::ImmAdapterT<org::imm::ImmStrike>> {
  using SharedPtrWrapBase<ImmStrikeAdapter, org::imm::ImmAdapterT<org::imm::ImmStrike>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmStrikeValueRead(org::imm::ImmAdapterT<org::imm::ImmStrike>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmStrike>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmStrikeAdapter", {InstanceMethod("getValue", &ImmStrikeAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmStrikeAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmStrike>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmStrike>> {
  using type = ImmStrikeAdapter;
};

struct ImmParAdapter : public SharedPtrWrapBase<ImmParAdapter, org::imm::ImmAdapterT<org::imm::ImmPar>> {
  using SharedPtrWrapBase<ImmParAdapter, org::imm::ImmAdapterT<org::imm::ImmPar>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmParValueRead(org::imm::ImmAdapterT<org::imm::ImmPar>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmPar>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmParAdapter", {InstanceMethod("getValue", &ImmParAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmParAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmPar>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmPar>> {
  using type = ImmParAdapter;
};

struct ImmCmdCaptionJs : public SharedPtrWrapBase<ImmCmdCaptionJs, org::imm::ImmCmdCaption> {
  using SharedPtrWrapBase<ImmCmdCaptionJs, org::imm::ImmCmdCaption>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmCmdCaption::*)(org::imm::ImmCmdCaption const&) const>(&org::imm::ImmCmdCaption::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmCmdCaption>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmCmdCaption::*)() const>(&org::imm::ImmCmdCaption::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdCaptionJs", {InstanceMethod("operator==", &ImmCmdCaptionJs::operator==),
                                                                                                                          InstanceMethod("getKind", &ImmCmdCaptionJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmCmdCaptionJs> {
  using type = org::imm::ImmCmdCaption;
};

template <>
struct org_to_js_type<org::imm::ImmCmdCaption> {
  using type = ImmCmdCaptionJs;
};

struct ImmCmdColumnsJs : public SharedPtrWrapBase<ImmCmdColumnsJs, org::imm::ImmCmdColumns> {
  using SharedPtrWrapBase<ImmCmdColumnsJs, org::imm::ImmCmdColumns>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmCmdColumns::*)(org::imm::ImmCmdColumns const&) const>(&org::imm::ImmCmdColumns::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmCmdColumns>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmCmdColumns::*)() const>(&org::imm::ImmCmdColumns::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdColumnsJs", {InstanceMethod("operator==", &ImmCmdColumnsJs::operator==),
                                                                                                                          InstanceMethod("getKind", &ImmCmdColumnsJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmCmdColumnsJs> {
  using type = org::imm::ImmCmdColumns;
};

template <>
struct org_to_js_type<org::imm::ImmCmdColumns> {
  using type = ImmCmdColumnsJs;
};

struct ImmCmdNameJs : public SharedPtrWrapBase<ImmCmdNameJs, org::imm::ImmCmdName> {
  using SharedPtrWrapBase<ImmCmdNameJs, org::imm::ImmCmdName>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmCmdName::*)(org::imm::ImmCmdName const&) const>(&org::imm::ImmCmdName::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmCmdName>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmCmdName::*)() const>(&org::imm::ImmCmdName::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdNameJs", {InstanceMethod("operator==", &ImmCmdNameJs::operator==),
                                                                                                                       InstanceMethod("getKind", &ImmCmdNameJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmCmdNameJs> {
  using type = org::imm::ImmCmdName;
};

template <>
struct org_to_js_type<org::imm::ImmCmdName> {
  using type = ImmCmdNameJs;
};

struct ImmCmdCallJs : public SharedPtrWrapBase<ImmCmdCallJs, org::imm::ImmCmdCall> {
  using SharedPtrWrapBase<ImmCmdCallJs, org::imm::ImmCmdCall>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmCmdCall::*)(org::imm::ImmCmdCall const&) const>(&org::imm::ImmCmdCall::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmCmdCall>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmCmdCall::*)() const>(&org::imm::ImmCmdCall::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdCallJs", {InstanceMethod("operator==", &ImmCmdCallJs::operator==),
                                                                                                                       InstanceMethod("getKind", &ImmCmdCallJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmCmdCallJs> {
  using type = org::imm::ImmCmdCall;
};

template <>
struct org_to_js_type<org::imm::ImmCmdCall> {
  using type = ImmCmdCallJs;
};

struct ImmCmdAttrJs : public SharedPtrWrapBase<ImmCmdAttrJs, org::imm::ImmCmdAttr> {
  using SharedPtrWrapBase<ImmCmdAttrJs, org::imm::ImmCmdAttr>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmCmdAttr::*)(org::imm::ImmCmdAttr const&) const>(&org::imm::ImmCmdAttr::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmCmdAttr>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmCmdAttr::*)() const>(&org::imm::ImmCmdAttr::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdAttrJs", {InstanceMethod("operator==", &ImmCmdAttrJs::operator==),
                                                                                                                       InstanceMethod("getKind", &ImmCmdAttrJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmCmdAttrJs> {
  using type = org::imm::ImmCmdAttr;
};

template <>
struct org_to_js_type<org::imm::ImmCmdAttr> {
  using type = ImmCmdAttrJs;
};

struct ImmCmdExportJs : public SharedPtrWrapBase<ImmCmdExportJs, org::imm::ImmCmdExport> {
  using SharedPtrWrapBase<ImmCmdExportJs, org::imm::ImmCmdExport>::SharedPtrWrapBase;
  Napi::Value operator==(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::imm::ImmCmdExport::*)(org::imm::ImmCmdExport const&) const>(&org::imm::ImmCmdExport::operator==),
                                        std::make_tuple(CxxArgSpec<org::imm::ImmCmdExport>{"other"})));
  }
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::imm::ImmCmdExport::*)() const>(&org::imm::ImmCmdExport::getKind),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdExportJs", {InstanceMethod("operator==", &ImmCmdExportJs::operator==),
                                                                                                                         InstanceMethod("getKind", &ImmCmdExportJs::getKind)}); }
};

template <>
struct js_to_org_type<ImmCmdExportJs> {
  using type = org::imm::ImmCmdExport;
};

template <>
struct org_to_js_type<org::imm::ImmCmdExport> {
  using type = ImmCmdExportJs;
};

struct CmdCaptionJs : public SharedPtrWrapBase<CmdCaptionJs, org::sem::CmdCaption> {
  using SharedPtrWrapBase<CmdCaptionJs, org::sem::CmdCaption>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::CmdCaption::*)() const>(&org::sem::CmdCaption::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdCaption::*)() const>(&org::sem::CmdCaption::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdCaption::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::CmdCaption::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::CmdCaption::*)() const>(&org::sem::CmdCaption::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdCaption::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::CmdCaption::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::CmdCaption::*)(int) const>(&org::sem::CmdCaption::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdCaption::*)(OrgSemKind) const>(&org::sem::CmdCaption::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdCaption::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdCaption::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdCaption::*)() const>(&org::sem::CmdCaption::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::CmdCaption::*)() const>(&org::sem::CmdCaption::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::CmdCaption::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdCaption::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::CmdCaption::*)(hstd::Str const&) const>(&org::sem::CmdCaption::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "CmdCaptionJs", {InstanceMethod("getKind", &CmdCaptionJs::getKind),
                                                                                                                       InstanceMethod("isGenerated", &CmdCaptionJs::isGenerated),
                                                                                                                       InstanceMethod("push_back", &CmdCaptionJs::push_back),
                                                                                                                       InstanceMethod("size", &CmdCaptionJs::size),
                                                                                                                       InstanceMethod("insert", &CmdCaptionJs::insert),
                                                                                                                       InstanceMethod("at", &CmdCaptionJs::at),
                                                                                                                       InstanceMethod("is", &CmdCaptionJs::is),
                                                                                                                       InstanceMethod("getAttached", &CmdCaptionJs::getAttached),
                                                                                                                       InstanceMethod("getCaption", &CmdCaptionJs::getCaption),
                                                                                                                       InstanceMethod("getName", &CmdCaptionJs::getName),
                                                                                                                       InstanceMethod("getAttrs", &CmdCaptionJs::getAttrs),
                                                                                                                       InstanceMethod("getFirstAttr", &CmdCaptionJs::getFirstAttr)}); }
};

template <>
struct js_to_org_type<CmdCaptionJs> {
  using type = org::sem::CmdCaption;
};

template <>
struct org_to_js_type<org::sem::CmdCaption> {
  using type = CmdCaptionJs;
};

struct CmdColumnsJs : public SharedPtrWrapBase<CmdColumnsJs, org::sem::CmdColumns> {
  using SharedPtrWrapBase<CmdColumnsJs, org::sem::CmdColumns>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::CmdColumns::*)() const>(&org::sem::CmdColumns::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdColumns::*)() const>(&org::sem::CmdColumns::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdColumns::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::CmdColumns::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::CmdColumns::*)() const>(&org::sem::CmdColumns::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdColumns::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::CmdColumns::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::CmdColumns::*)(int) const>(&org::sem::CmdColumns::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdColumns::*)(OrgSemKind) const>(&org::sem::CmdColumns::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdColumns::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdColumns::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdColumns::*)() const>(&org::sem::CmdColumns::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::CmdColumns::*)() const>(&org::sem::CmdColumns::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::CmdColumns::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdColumns::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::CmdColumns::*)(hstd::Str const&) const>(&org::sem::CmdColumns::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "CmdColumnsJs", {InstanceMethod("getKind", &CmdColumnsJs::getKind),
                                                                                                                       InstanceMethod("isGenerated", &CmdColumnsJs::isGenerated),
                                                                                                                       InstanceMethod("push_back", &CmdColumnsJs::push_back),
                                                                                                                       InstanceMethod("size", &CmdColumnsJs::size),
                                                                                                                       InstanceMethod("insert", &CmdColumnsJs::insert),
                                                                                                                       InstanceMethod("at", &CmdColumnsJs::at),
                                                                                                                       InstanceMethod("is", &CmdColumnsJs::is),
                                                                                                                       InstanceMethod("getAttached", &CmdColumnsJs::getAttached),
                                                                                                                       InstanceMethod("getCaption", &CmdColumnsJs::getCaption),
                                                                                                                       InstanceMethod("getName", &CmdColumnsJs::getName),
                                                                                                                       InstanceMethod("getAttrs", &CmdColumnsJs::getAttrs),
                                                                                                                       InstanceMethod("getFirstAttr", &CmdColumnsJs::getFirstAttr)}); }
};

template <>
struct js_to_org_type<CmdColumnsJs> {
  using type = org::sem::CmdColumns;
};

template <>
struct org_to_js_type<org::sem::CmdColumns> {
  using type = CmdColumnsJs;
};

struct CmdNameJs : public SharedPtrWrapBase<CmdNameJs, org::sem::CmdName> {
  using SharedPtrWrapBase<CmdNameJs, org::sem::CmdName>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::CmdName::*)() const>(&org::sem::CmdName::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdName::*)() const>(&org::sem::CmdName::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdName::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::CmdName::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::CmdName::*)() const>(&org::sem::CmdName::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdName::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::CmdName::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::CmdName::*)(int) const>(&org::sem::CmdName::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdName::*)(OrgSemKind) const>(&org::sem::CmdName::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdName::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdName::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdName::*)() const>(&org::sem::CmdName::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::CmdName::*)() const>(&org::sem::CmdName::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::CmdName::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdName::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::CmdName::*)(hstd::Str const&) const>(&org::sem::CmdName::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "CmdNameJs", {InstanceMethod("getKind", &CmdNameJs::getKind),
                                                                                                                    InstanceMethod("isGenerated", &CmdNameJs::isGenerated),
                                                                                                                    InstanceMethod("push_back", &CmdNameJs::push_back),
                                                                                                                    InstanceMethod("size", &CmdNameJs::size),
                                                                                                                    InstanceMethod("insert", &CmdNameJs::insert),
                                                                                                                    InstanceMethod("at", &CmdNameJs::at),
                                                                                                                    InstanceMethod("is", &CmdNameJs::is),
                                                                                                                    InstanceMethod("getAttached", &CmdNameJs::getAttached),
                                                                                                                    InstanceMethod("getCaption", &CmdNameJs::getCaption),
                                                                                                                    InstanceMethod("getName", &CmdNameJs::getName),
                                                                                                                    InstanceMethod("getAttrs", &CmdNameJs::getAttrs),
                                                                                                                    InstanceMethod("getFirstAttr", &CmdNameJs::getFirstAttr)}); }
};

template <>
struct js_to_org_type<CmdNameJs> {
  using type = org::sem::CmdName;
};

template <>
struct org_to_js_type<org::sem::CmdName> {
  using type = CmdNameJs;
};

struct CmdCallJs : public SharedPtrWrapBase<CmdCallJs, org::sem::CmdCall> {
  using SharedPtrWrapBase<CmdCallJs, org::sem::CmdCall>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::CmdCall::*)() const>(&org::sem::CmdCall::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdCall::*)() const>(&org::sem::CmdCall::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdCall::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::CmdCall::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::CmdCall::*)() const>(&org::sem::CmdCall::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdCall::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::CmdCall::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::CmdCall::*)(int) const>(&org::sem::CmdCall::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdCall::*)(OrgSemKind) const>(&org::sem::CmdCall::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdCall::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdCall::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdCall::*)() const>(&org::sem::CmdCall::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::CmdCall::*)() const>(&org::sem::CmdCall::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::CmdCall::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdCall::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::CmdCall::*)(hstd::Str const&) const>(&org::sem::CmdCall::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "CmdCallJs", {InstanceMethod("getKind", &CmdCallJs::getKind),
                                                                                                                    InstanceMethod("isGenerated", &CmdCallJs::isGenerated),
                                                                                                                    InstanceMethod("push_back", &CmdCallJs::push_back),
                                                                                                                    InstanceMethod("size", &CmdCallJs::size),
                                                                                                                    InstanceMethod("insert", &CmdCallJs::insert),
                                                                                                                    InstanceMethod("at", &CmdCallJs::at),
                                                                                                                    InstanceMethod("is", &CmdCallJs::is),
                                                                                                                    InstanceMethod("getAttached", &CmdCallJs::getAttached),
                                                                                                                    InstanceMethod("getCaption", &CmdCallJs::getCaption),
                                                                                                                    InstanceMethod("getName", &CmdCallJs::getName),
                                                                                                                    InstanceMethod("getAttrs", &CmdCallJs::getAttrs),
                                                                                                                    InstanceMethod("getFirstAttr", &CmdCallJs::getFirstAttr)}); }
};

template <>
struct js_to_org_type<CmdCallJs> {
  using type = org::sem::CmdCall;
};

template <>
struct org_to_js_type<org::sem::CmdCall> {
  using type = CmdCallJs;
};

struct CmdAttrJs : public SharedPtrWrapBase<CmdAttrJs, org::sem::CmdAttr> {
  using SharedPtrWrapBase<CmdAttrJs, org::sem::CmdAttr>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::CmdAttr::*)() const>(&org::sem::CmdAttr::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdAttr::*)() const>(&org::sem::CmdAttr::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdAttr::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::CmdAttr::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::CmdAttr::*)() const>(&org::sem::CmdAttr::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdAttr::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::CmdAttr::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::CmdAttr::*)(int) const>(&org::sem::CmdAttr::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdAttr::*)(OrgSemKind) const>(&org::sem::CmdAttr::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdAttr::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdAttr::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdAttr::*)() const>(&org::sem::CmdAttr::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::CmdAttr::*)() const>(&org::sem::CmdAttr::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::CmdAttr::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdAttr::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::CmdAttr::*)(hstd::Str const&) const>(&org::sem::CmdAttr::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "CmdAttrJs", {InstanceMethod("getKind", &CmdAttrJs::getKind),
                                                                                                                    InstanceMethod("isGenerated", &CmdAttrJs::isGenerated),
                                                                                                                    InstanceMethod("push_back", &CmdAttrJs::push_back),
                                                                                                                    InstanceMethod("size", &CmdAttrJs::size),
                                                                                                                    InstanceMethod("insert", &CmdAttrJs::insert),
                                                                                                                    InstanceMethod("at", &CmdAttrJs::at),
                                                                                                                    InstanceMethod("is", &CmdAttrJs::is),
                                                                                                                    InstanceMethod("getAttached", &CmdAttrJs::getAttached),
                                                                                                                    InstanceMethod("getCaption", &CmdAttrJs::getCaption),
                                                                                                                    InstanceMethod("getName", &CmdAttrJs::getName),
                                                                                                                    InstanceMethod("getAttrs", &CmdAttrJs::getAttrs),
                                                                                                                    InstanceMethod("getFirstAttr", &CmdAttrJs::getFirstAttr)}); }
};

template <>
struct js_to_org_type<CmdAttrJs> {
  using type = org::sem::CmdAttr;
};

template <>
struct org_to_js_type<org::sem::CmdAttr> {
  using type = CmdAttrJs;
};

struct CmdExportJs : public SharedPtrWrapBase<CmdExportJs, org::sem::CmdExport> {
  using SharedPtrWrapBase<CmdExportJs, org::sem::CmdExport>::SharedPtrWrapBase;
  Napi::Value getKind(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<OrgSemKind(org::sem::CmdExport::*)() const>(&org::sem::CmdExport::getKind),
                                        std::make_tuple()));
  }
  Napi::Value isGenerated(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdExport::*)() const>(&org::sem::CmdExport::isGenerated),
                                        std::make_tuple()));
  }
  Napi::Value push_back(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdExport::*)(org::sem::SemId<org::sem::Org>)>(&org::sem::CmdExport::push_back),
                                   std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"sub"})));
  }
  Napi::Value size(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<int(org::sem::CmdExport::*)() const>(&org::sem::CmdExport::size),
                                        std::make_tuple()));
  }
  Napi::Value insert(Napi::CallbackInfo const& info) {
    return WrapMethod(info,
                      getPtr(),
                      makeCallable(static_cast<void(org::sem::CmdExport::*)(int, org::sem::SemId<org::sem::Org>)>(&org::sem::CmdExport::insert),
                                   std::make_tuple(CxxArgSpec<int>{"pos"},
                                                   CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"})));
  }
  Napi::Value at(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::sem::SemId<org::sem::Org>(org::sem::CmdExport::*)(int) const>(&org::sem::CmdExport::at),
                                        std::make_tuple(CxxArgSpec<int>{"idx"})));
  }
  Napi::Value is(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<bool(org::sem::CmdExport::*)(OrgSemKind) const>(&org::sem::CmdExport::is),
                                        std::make_tuple(CxxArgSpec<OrgSemKind>{"kind"})));
  }
  Napi::Value getAttached(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdExport::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdExport::getAttached),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"kind", std::nullopt})));
  }
  Napi::Value getCaption(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::SemId<org::sem::Org>>(org::sem::CmdExport::*)() const>(&org::sem::CmdExport::getCaption),
                                        std::make_tuple()));
  }
  Napi::Value getName(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<hstd::Str>(org::sem::CmdExport::*)() const>(&org::sem::CmdExport::getName),
                                        std::make_tuple()));
  }
  Napi::Value getAttrs(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Vec<org::sem::AttrValue>(org::sem::CmdExport::*)(hstd::Opt<hstd::Str> const&) const>(&org::sem::CmdExport::getAttrs),
                                        std::make_tuple(CxxArgSpec<hstd::Opt<hstd::Str>>{"key", std::nullopt})));
  }
  Napi::Value getFirstAttr(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<hstd::Opt<org::sem::AttrValue>(org::sem::CmdExport::*)(hstd::Str const&) const>(&org::sem::CmdExport::getFirstAttr),
                                        std::make_tuple(CxxArgSpec<hstd::Str>{"kind"})));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "CmdExportJs", {InstanceMethod("getKind", &CmdExportJs::getKind),
                                                                                                                      InstanceMethod("isGenerated", &CmdExportJs::isGenerated),
                                                                                                                      InstanceMethod("push_back", &CmdExportJs::push_back),
                                                                                                                      InstanceMethod("size", &CmdExportJs::size),
                                                                                                                      InstanceMethod("insert", &CmdExportJs::insert),
                                                                                                                      InstanceMethod("at", &CmdExportJs::at),
                                                                                                                      InstanceMethod("is", &CmdExportJs::is),
                                                                                                                      InstanceMethod("getAttached", &CmdExportJs::getAttached),
                                                                                                                      InstanceMethod("getCaption", &CmdExportJs::getCaption),
                                                                                                                      InstanceMethod("getName", &CmdExportJs::getName),
                                                                                                                      InstanceMethod("getAttrs", &CmdExportJs::getAttrs),
                                                                                                                      InstanceMethod("getFirstAttr", &CmdExportJs::getFirstAttr)}); }
};

template <>
struct js_to_org_type<CmdExportJs> {
  using type = org::sem::CmdExport;
};

template <>
struct org_to_js_type<org::sem::CmdExport> {
  using type = CmdExportJs;
};

struct ImmCmdCustomArgsAdapter : public SharedPtrWrapBase<ImmCmdCustomArgsAdapter, org::imm::ImmAdapterT<org::imm::ImmCmdCustomArgs>> {
  using SharedPtrWrapBase<ImmCmdCustomArgsAdapter, org::imm::ImmAdapterT<org::imm::ImmCmdCustomArgs>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCmdCustomArgsValueRead(org::imm::ImmAdapterT<org::imm::ImmCmdCustomArgs>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmCmdCustomArgs>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdCustomArgsAdapter", {InstanceMethod("getValue", &ImmCmdCustomArgsAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmCmdCustomArgsAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmCmdCustomArgs>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmCmdCustomArgs>> {
  using type = ImmCmdCustomArgsAdapter;
};

struct ImmCmdTblfmAdapter : public SharedPtrWrapBase<ImmCmdTblfmAdapter, org::imm::ImmAdapterT<org::imm::ImmCmdTblfm>> {
  using SharedPtrWrapBase<ImmCmdTblfmAdapter, org::imm::ImmAdapterT<org::imm::ImmCmdTblfm>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCmdTblfmValueRead(org::imm::ImmAdapterT<org::imm::ImmCmdTblfm>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmCmdTblfm>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdTblfmAdapter", {InstanceMethod("getValue", &ImmCmdTblfmAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmCmdTblfmAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmCmdTblfm>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmCmdTblfm>> {
  using type = ImmCmdTblfmAdapter;
};

struct ImmCellAdapter : public SharedPtrWrapBase<ImmCellAdapter, org::imm::ImmAdapterT<org::imm::ImmCell>> {
  using SharedPtrWrapBase<ImmCellAdapter, org::imm::ImmAdapterT<org::imm::ImmCell>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCellValueRead(org::imm::ImmAdapterT<org::imm::ImmCell>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmCell>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCellAdapter", {InstanceMethod("getValue", &ImmCellAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmCellAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmCell>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmCell>> {
  using type = ImmCellAdapter;
};

struct ImmRowAdapter : public SharedPtrWrapBase<ImmRowAdapter, org::imm::ImmAdapterT<org::imm::ImmRow>> {
  using SharedPtrWrapBase<ImmRowAdapter, org::imm::ImmAdapterT<org::imm::ImmRow>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmRowValueRead(org::imm::ImmAdapterT<org::imm::ImmRow>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmRow>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmRowAdapter", {InstanceMethod("getValue", &ImmRowAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmRowAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmRow>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmRow>> {
  using type = ImmRowAdapter;
};

struct ImmBlockCenterAdapter : public SharedPtrWrapBase<ImmBlockCenterAdapter, org::imm::ImmAdapterT<org::imm::ImmBlockCenter>> {
  using SharedPtrWrapBase<ImmBlockCenterAdapter, org::imm::ImmAdapterT<org::imm::ImmBlockCenter>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmBlockCenterValueRead(org::imm::ImmAdapterT<org::imm::ImmBlockCenter>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmBlockCenter>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockCenterAdapter", {InstanceMethod("getValue", &ImmBlockCenterAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmBlockCenterAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmBlockCenter>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmBlockCenter>> {
  using type = ImmBlockCenterAdapter;
};

struct ImmBlockQuoteAdapter : public SharedPtrWrapBase<ImmBlockQuoteAdapter, org::imm::ImmAdapterT<org::imm::ImmBlockQuote>> {
  using SharedPtrWrapBase<ImmBlockQuoteAdapter, org::imm::ImmAdapterT<org::imm::ImmBlockQuote>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmBlockQuoteValueRead(org::imm::ImmAdapterT<org::imm::ImmBlockQuote>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmBlockQuote>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockQuoteAdapter", {InstanceMethod("getValue", &ImmBlockQuoteAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmBlockQuoteAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmBlockQuote>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmBlockQuote>> {
  using type = ImmBlockQuoteAdapter;
};

struct ImmBlockVerseAdapter : public SharedPtrWrapBase<ImmBlockVerseAdapter, org::imm::ImmAdapterT<org::imm::ImmBlockVerse>> {
  using SharedPtrWrapBase<ImmBlockVerseAdapter, org::imm::ImmAdapterT<org::imm::ImmBlockVerse>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmBlockVerseValueRead(org::imm::ImmAdapterT<org::imm::ImmBlockVerse>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmBlockVerse>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockVerseAdapter", {InstanceMethod("getValue", &ImmBlockVerseAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmBlockVerseAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmBlockVerse>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmBlockVerse>> {
  using type = ImmBlockVerseAdapter;
};

struct ImmBlockExampleAdapter : public SharedPtrWrapBase<ImmBlockExampleAdapter, org::imm::ImmAdapterT<org::imm::ImmBlockExample>> {
  using SharedPtrWrapBase<ImmBlockExampleAdapter, org::imm::ImmAdapterT<org::imm::ImmBlockExample>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmBlockExampleValueRead(org::imm::ImmAdapterT<org::imm::ImmBlockExample>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmBlockExample>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockExampleAdapter", {InstanceMethod("getValue", &ImmBlockExampleAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmBlockExampleAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmBlockExample>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmBlockExample>> {
  using type = ImmBlockExampleAdapter;
};

struct ImmInlineExportAdapter : public SharedPtrWrapBase<ImmInlineExportAdapter, org::imm::ImmAdapterT<org::imm::ImmInlineExport>> {
  using SharedPtrWrapBase<ImmInlineExportAdapter, org::imm::ImmAdapterT<org::imm::ImmInlineExport>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmInlineExportValueRead(org::imm::ImmAdapterT<org::imm::ImmInlineExport>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmInlineExport>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmInlineExportAdapter", {InstanceMethod("getValue", &ImmInlineExportAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmInlineExportAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmInlineExport>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmInlineExport>> {
  using type = ImmInlineExportAdapter;
};

struct ImmCmdExportAdapter : public SharedPtrWrapBase<ImmCmdExportAdapter, org::imm::ImmAdapterT<org::imm::ImmCmdExport>> {
  using SharedPtrWrapBase<ImmCmdExportAdapter, org::imm::ImmAdapterT<org::imm::ImmCmdExport>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCmdExportValueRead(org::imm::ImmAdapterT<org::imm::ImmCmdExport>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmCmdExport>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdExportAdapter", {InstanceMethod("getValue", &ImmCmdExportAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmCmdExportAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmCmdExport>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmCmdExport>> {
  using type = ImmCmdExportAdapter;
};

struct ImmBlockExportAdapter : public SharedPtrWrapBase<ImmBlockExportAdapter, org::imm::ImmAdapterT<org::imm::ImmBlockExport>> {
  using SharedPtrWrapBase<ImmBlockExportAdapter, org::imm::ImmAdapterT<org::imm::ImmBlockExport>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmBlockExportValueRead(org::imm::ImmAdapterT<org::imm::ImmBlockExport>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmBlockExport>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockExportAdapter", {InstanceMethod("getValue", &ImmBlockExportAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmBlockExportAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmBlockExport>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmBlockExport>> {
  using type = ImmBlockExportAdapter;
};

struct ImmBlockDynamicFallbackAdapter : public SharedPtrWrapBase<ImmBlockDynamicFallbackAdapter, org::imm::ImmAdapterT<org::imm::ImmBlockDynamicFallback>> {
  using SharedPtrWrapBase<ImmBlockDynamicFallbackAdapter, org::imm::ImmAdapterT<org::imm::ImmBlockDynamicFallback>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmBlockDynamicFallbackValueRead(org::imm::ImmAdapterT<org::imm::ImmBlockDynamicFallback>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmBlockDynamicFallback>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockDynamicFallbackAdapter", {InstanceMethod("getValue", &ImmBlockDynamicFallbackAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmBlockDynamicFallbackAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmBlockDynamicFallback>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmBlockDynamicFallback>> {
  using type = ImmBlockDynamicFallbackAdapter;
};

struct ImmBlockAdmonitionAdapter : public SharedPtrWrapBase<ImmBlockAdmonitionAdapter, org::imm::ImmAdapterT<org::imm::ImmBlockAdmonition>> {
  using SharedPtrWrapBase<ImmBlockAdmonitionAdapter, org::imm::ImmAdapterT<org::imm::ImmBlockAdmonition>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmBlockAdmonitionValueRead(org::imm::ImmAdapterT<org::imm::ImmBlockAdmonition>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmBlockAdmonition>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockAdmonitionAdapter", {InstanceMethod("getValue", &ImmBlockAdmonitionAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmBlockAdmonitionAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmBlockAdmonition>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmBlockAdmonition>> {
  using type = ImmBlockAdmonitionAdapter;
};

struct ImmBlockCodeEvalResultAdapter : public SharedPtrWrapBase<ImmBlockCodeEvalResultAdapter, org::imm::ImmAdapterT<org::imm::ImmBlockCodeEvalResult>> {
  using SharedPtrWrapBase<ImmBlockCodeEvalResultAdapter, org::imm::ImmAdapterT<org::imm::ImmBlockCodeEvalResult>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmBlockCodeEvalResultValueRead(org::imm::ImmAdapterT<org::imm::ImmBlockCodeEvalResult>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmBlockCodeEvalResult>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockCodeEvalResultAdapter", {InstanceMethod("getValue", &ImmBlockCodeEvalResultAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmBlockCodeEvalResultAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmBlockCodeEvalResult>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmBlockCodeEvalResult>> {
  using type = ImmBlockCodeEvalResultAdapter;
};

struct ImmBlockCodeAdapter : public SharedPtrWrapBase<ImmBlockCodeAdapter, org::imm::ImmAdapterT<org::imm::ImmBlockCode>> {
  using SharedPtrWrapBase<ImmBlockCodeAdapter, org::imm::ImmAdapterT<org::imm::ImmBlockCode>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmBlockCodeValueRead(org::imm::ImmAdapterT<org::imm::ImmBlockCode>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmBlockCode>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmBlockCodeAdapter", {InstanceMethod("getValue", &ImmBlockCodeAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmBlockCodeAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmBlockCode>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmBlockCode>> {
  using type = ImmBlockCodeAdapter;
};

struct ImmTableAdapter : public SharedPtrWrapBase<ImmTableAdapter, org::imm::ImmAdapterT<org::imm::ImmTable>> {
  using SharedPtrWrapBase<ImmTableAdapter, org::imm::ImmAdapterT<org::imm::ImmTable>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmTableValueRead(org::imm::ImmAdapterT<org::imm::ImmTable>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmTable>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmTableAdapter", {InstanceMethod("getValue", &ImmTableAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmTableAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmTable>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmTable>> {
  using type = ImmTableAdapter;
};

struct ImmCmdCaptionAdapter : public SharedPtrWrapBase<ImmCmdCaptionAdapter, org::imm::ImmAdapterT<org::imm::ImmCmdCaption>> {
  using SharedPtrWrapBase<ImmCmdCaptionAdapter, org::imm::ImmAdapterT<org::imm::ImmCmdCaption>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCmdCaptionValueRead(org::imm::ImmAdapterT<org::imm::ImmCmdCaption>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmCmdCaption>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdCaptionAdapter", {InstanceMethod("getValue", &ImmCmdCaptionAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmCmdCaptionAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmCmdCaption>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmCmdCaption>> {
  using type = ImmCmdCaptionAdapter;
};

struct ImmCmdColumnsAdapter : public SharedPtrWrapBase<ImmCmdColumnsAdapter, org::imm::ImmAdapterT<org::imm::ImmCmdColumns>> {
  using SharedPtrWrapBase<ImmCmdColumnsAdapter, org::imm::ImmAdapterT<org::imm::ImmCmdColumns>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCmdColumnsValueRead(org::imm::ImmAdapterT<org::imm::ImmCmdColumns>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmCmdColumns>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdColumnsAdapter", {InstanceMethod("getValue", &ImmCmdColumnsAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmCmdColumnsAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmCmdColumns>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmCmdColumns>> {
  using type = ImmCmdColumnsAdapter;
};

struct ImmCmdNameAdapter : public SharedPtrWrapBase<ImmCmdNameAdapter, org::imm::ImmAdapterT<org::imm::ImmCmdName>> {
  using SharedPtrWrapBase<ImmCmdNameAdapter, org::imm::ImmAdapterT<org::imm::ImmCmdName>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCmdNameValueRead(org::imm::ImmAdapterT<org::imm::ImmCmdName>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmCmdName>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdNameAdapter", {InstanceMethod("getValue", &ImmCmdNameAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmCmdNameAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmCmdName>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmCmdName>> {
  using type = ImmCmdNameAdapter;
};

struct ImmCmdCallAdapter : public SharedPtrWrapBase<ImmCmdCallAdapter, org::imm::ImmAdapterT<org::imm::ImmCmdCall>> {
  using SharedPtrWrapBase<ImmCmdCallAdapter, org::imm::ImmAdapterT<org::imm::ImmCmdCall>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCmdCallValueRead(org::imm::ImmAdapterT<org::imm::ImmCmdCall>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmCmdCall>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdCallAdapter", {InstanceMethod("getValue", &ImmCmdCallAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmCmdCallAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmCmdCall>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmCmdCall>> {
  using type = ImmCmdCallAdapter;
};

struct ImmCmdAttrAdapter : public SharedPtrWrapBase<ImmCmdAttrAdapter, org::imm::ImmAdapterT<org::imm::ImmCmdAttr>> {
  using SharedPtrWrapBase<ImmCmdAttrAdapter, org::imm::ImmAdapterT<org::imm::ImmCmdAttr>>::SharedPtrWrapBase;
  Napi::Value getValue(Napi::CallbackInfo const& info) {
    return WrapConstMethod(info,
                           getPtr(),
                           makeCallable(static_cast<org::imm::ImmCmdAttrValueRead(org::imm::ImmAdapterT<org::imm::ImmCmdAttr>::*)() const>(&org::imm::ImmAdapterT<org::imm::ImmCmdAttr>::getValue),
                                        std::make_tuple()));
  }
  static Napi::Object Init(Napi::Env env, Napi::Object exports) { return InitSharedWrap(env, exports, "ImmCmdAttrAdapter", {InstanceMethod("getValue", &ImmCmdAttrAdapter::getValue)}); }
};

template <>
struct js_to_org_type<ImmCmdAttrAdapter> {
  using type = org::imm::ImmAdapterT<org::imm::ImmCmdAttr>;
};

template <>
struct org_to_js_type<org::imm::ImmAdapterT<org::imm::ImmCmdAttr>> {
  using type = ImmCmdAttrAdapter;
};

Napi::Object InitModule(Napi::Env env, Napi::Object exports) {
  hstdVec_bind<org::sem::OrgJson>::Init(env, exports, "VecOfOrgJson");
  hstdVec_bind<org::sem::SemId<org::sem::Org>>::Init(env, exports, "VecOfSemIdOfOrg");
  immerbox_bind<hstd::Str>::Init(env, exports, "ImmBoxOfStr");
  immerbox_bind<std::optional<hstd::Str>>::Init(env, exports, "ImmBoxOfOptionalStdOfStr");
  immerbox_bind<std::optional<int>>::Init(env, exports, "ImmBoxOfOptionalStdOfInt");
  immerflex_vector_bind<org::imm::ImmIdT<org::imm::ImmErrorItem>>::Init(env, exports, "ImmFlexVectorOfImmIdTOfImmErrorItem");
  immerflex_vector_bind<org::imm::ImmIdT<org::imm::ImmBlockCodeEvalResult>>::Init(env, exports, "ImmFlexVectorOfImmIdTOfImmBlockCodeEvalResult");
  immerbox_bind<std::optional<org::imm::ImmIdT<org::imm::ImmOrg>>>::Init(env, exports, "ImmBoxOfOptionalStdOfImmIdTOfImmOrg");
  immerflex_vector_bind<org::imm::ImmSymbol::Param>::Init(env, exports, "ImmFlexVectorOfParamImmSymbol");
  immerflex_vector_bind<org::imm::ImmIdT<org::imm::ImmOrg>>::Init(env, exports, "ImmFlexVectorOfImmIdTOfImmOrg");
  immerflex_vector_bind<hstd::Str>::Init(env, exports, "ImmFlexVectorOfStr");
  immerbox_bind<std::optional<org::imm::ImmIdT<org::imm::ImmParagraph>>>::Init(env, exports, "ImmBoxOfOptionalStdOfImmIdTOfImmParagraph");
  immerflex_vector_bind<org::sem::OrgCodeEvalOutput>::Init(env, exports, "ImmFlexVectorOfOrgCodeEvalOutput");
  immerflex_vector_bind<org::sem::BlockCodeLine>::Init(env, exports, "ImmFlexVectorOfBlockCodeLine");
  immerbox_bind<std::optional<org::imm::ImmIdT<org::imm::ImmStmtList>>>::Init(env, exports, "ImmBoxOfOptionalStdOfImmIdTOfImmStmtList");
  immerbox_bind<std::optional<org::sem::SubtreeCompletion>>::Init(env, exports, "ImmBoxOfOptionalStdOfSubtreeCompletion");
  immerflex_vector_bind<org::imm::ImmIdT<org::imm::ImmHashTag>>::Init(env, exports, "ImmFlexVectorOfImmIdTOfImmHashTag");
  immerflex_vector_bind<org::imm::ImmIdT<org::imm::ImmSubtreeLog>>::Init(env, exports, "ImmFlexVectorOfImmIdTOfImmSubtreeLog");
  immerflex_vector_bind<org::sem::NamedProperty>::Init(env, exports, "ImmFlexVectorOfNamedProperty");
  immerbox_bind<std::optional<hstd::UserTime>>::Init(env, exports, "ImmBoxOfOptionalStdOfUserTime");
  immerflex_vector_bind<org::imm::ImmIdT<org::imm::ImmCell>>::Init(env, exports, "ImmFlexVectorOfImmIdTOfImmCell");
  immerflex_vector_bind<org::imm::ImmIdT<org::imm::ImmRow>>::Init(env, exports, "ImmFlexVectorOfImmIdTOfImmRow");
  immerbox_bind<std::optional<bool>>::Init(env, exports, "ImmBoxOfOptionalStdOfBool");
  immerbox_bind<std::optional<org::sem::ColumnView>>::Init(env, exports, "ImmBoxOfOptionalStdOfColumnView");
  immerbox_bind<std::optional<org::imm::ImmIdT<org::imm::ImmRawText>>>::Init(env, exports, "ImmBoxOfOptionalStdOfImmIdTOfImmRawText");
  hstdVec_bind<int>::Init(env, exports, "VecOfInt");
  hstdVec_bind<org::imm::ImmAdapter>::Init(env, exports, "VecOfImmAdapter");
  hstdUnorderedMap_bind<org::sem::HashTagFlat, org::AstTrackingPath>::Init(env, exports, "UnorderedMapOfHashTagFlatAstTrackingPath");
  hstdUnorderedMap_bind<hstd::Str, org::AstTrackingAlternatives>::Init(env, exports, "UnorderedMapOfStrAstTrackingAlternatives");
  hstdUnorderedMap_bind<org::sem::HashTagFlat, org::AstTrackingAlternatives>::Init(env, exports, "UnorderedMapOfHashTagFlatAstTrackingAlternatives");
  hstdVec_bind<hstd::SequenceSegment>::Init(env, exports, "VecOfSequenceSegment");
  hstdVec_bind<hstd::SequenceAnnotationTag>::Init(env, exports, "VecOfSequenceAnnotationTag");
  hstdVec_bind<org::graph::MapLink>::Init(env, exports, "VecOfMapLinkGraph");
  hstdUnorderedMap_bind<org::graph::MapNode, org::graph::MapNodeProp>::Init(env, exports, "UnorderedMapOfMapNodeGraphMapNodePropGraph");
  hstdUnorderedMap_bind<org::graph::MapEdge, org::graph::MapEdgeProp>::Init(env, exports, "UnorderedMapOfMapEdgeGraphMapEdgePropGraph");
  hstdUnorderedMap_bind<org::graph::MapNode, org::graph::AdjNodesList>::Init(env, exports, "UnorderedMapOfMapNodeGraphAdjNodesListGraph");
  hstdVec_bind<org::graph::MapNode>::Init(env, exports, "VecOfMapNodeGraph");
  hstdVec_bind<org::graph::MapEdge>::Init(env, exports, "VecOfMapEdgeGraph");
  hstdVec_bind<org::sem::LispCode>::Init(env, exports, "VecOfLispCode");
  hstdVec_bind<org::sem::Tblfm::Assign>::Init(env, exports, "VecOfAssignTblfm");
  hstdVec_bind<org::sem::Tblfm::Expr>::Init(env, exports, "VecOfExprTblfm");
  hstdVec_bind<org::sem::Tblfm::Assign::Flag>::Init(env, exports, "VecOfFlagTblfmAssign");
  hstdVec_bind<org::sem::AttrValue::DimensionSpan>::Init(env, exports, "VecOfDimensionSpanAttrValue");
  hstdVec_bind<hstd::Str>::Init(env, exports, "VecOfStr");
  hstdVec_bind<org::sem::HashTagText>::Init(env, exports, "VecOfHashTagText");
  hstdVec_bind<org::sem::HashTagFlat>::Init(env, exports, "VecOfHashTagFlat");
  hstdVec_bind<org::sem::AttrValue>::Init(env, exports, "VecOfAttrValue");
  hstdUnorderedMap_bind<hstd::Str, org::sem::AttrList>::Init(env, exports, "UnorderedMapOfStrAttrList");
  hstdVec_bind<org::sem::OrgCodeEvalInput::Var>::Init(env, exports, "VecOfVarOrgCodeEvalInput");
  hstdVec_bind<org::sem::ColumnView::Column>::Init(env, exports, "VecOfColumnColumnView");
  hstdVec_bind<org::sem::BlockCodeLine::Part>::Init(env, exports, "VecOfPartBlockCodeLine");
  hstdUnorderedMap_bind<hstd::Str, hstd::Str>::Init(env, exports, "UnorderedMapOfStrStr");
  hstdVec_bind<org::sem::SemId<org::sem::ErrorItem>>::Init(env, exports, "VecOfSemIdOfErrorItem");
  hstdVec_bind<org::sem::Symbol::Param>::Init(env, exports, "VecOfParamSymbol");
  hstdVec_bind<org::sem::SemId<org::sem::HashTag>>::Init(env, exports, "VecOfSemIdOfHashTag");
  hstdVec_bind<org::sem::SemId<org::sem::SubtreeLog>>::Init(env, exports, "VecOfSemIdOfSubtreeLog");
  hstdVec_bind<org::sem::NamedProperty>::Init(env, exports, "VecOfNamedProperty");
  hstdVec_bind<org::sem::SubtreePeriod>::Init(env, exports, "VecOfSubtreePeriod");
  hstdIntSet_bind<org::sem::SubtreePeriod::Kind>::Init(env, exports, "IntSetOfKindSubtreePeriod");
  hstdVec_bind<org::sem::SemId<org::sem::BigIdent>>::Init(env, exports, "VecOfSemIdOfBigIdent");
  hstdVec_bind<hstd::UserTime>::Init(env, exports, "VecOfUserTime");
  hstdVec_bind<org::sem::SemId<org::sem::Time>>::Init(env, exports, "VecOfSemIdOfTime");
  hstdVec_bind<org::sem::SemId<org::sem::Cell>>::Init(env, exports, "VecOfSemIdOfCell");
  hstdVec_bind<org::sem::OrgCodeEvalOutput>::Init(env, exports, "VecOfOrgCodeEvalOutput");
  hstdVec_bind<org::sem::SemId<org::sem::BlockCodeEvalResult>>::Init(env, exports, "VecOfSemIdOfBlockCodeEvalResult");
  hstdVec_bind<org::sem::BlockCodeLine>::Init(env, exports, "VecOfBlockCodeLine");
  hstdVec_bind<org::sem::SemId<org::sem::Row>>::Init(env, exports, "VecOfSemIdOfRow");
  hstdVec_bind<org::AstTrackingGroup>::Init(env, exports, "VecOfAstTrackingGroup");
  hstdVec_bind<hstd::SequenceAnnotation>::Init(env, exports, "VecOfSequenceAnnotation");
  hstdVec_bind<hstd::SequenceSegmentGroup>::Init(env, exports, "VecOfSequenceSegmentGroup");
  UserTimeBreakdownJs::Init(env, exports);
  UserTimeJs::Init(env, exports);
  LineColParseJs::Init(env, exports);
  OrgJsonJs::Init(env, exports);
  OperationsTracerJs::Init(env, exports);
  ImmIdJs::Init(env, exports);
  ImmPathStepJs::Init(env, exports);
  ImmPathJs::Init(env, exports);
  ImmUniqIdJs::Init(env, exports);
  ImmNoneValueReadJs::Init(env, exports);
  ImmErrorItemValueReadJs::Init(env, exports);
  ImmErrorGroupValueReadJs::Init(env, exports);
  ImmStmtListValueReadJs::Init(env, exports);
  ImmEmptyValueReadJs::Init(env, exports);
  ImmCmdCaptionValueReadJs::Init(env, exports);
  ImmCmdColumnsValueReadJs::Init(env, exports);
  ImmCmdNameValueReadJs::Init(env, exports);
  ImmCmdCustomArgsValueReadJs::Init(env, exports);
  ImmCmdCustomRawValueReadJs::Init(env, exports);
  ImmCmdCustomTextValueReadJs::Init(env, exports);
  ImmCmdCallValueReadJs::Init(env, exports);
  ImmCmdTblfmValueReadJs::Init(env, exports);
  ImmHashTagValueReadJs::Init(env, exports);
  ImmInlineFootnoteValueReadJs::Init(env, exports);
  ImmInlineExportValueReadJs::Init(env, exports);
  ImmTimeValueReadJs::Init(env, exports);
  ImmTimeRangeValueReadJs::Init(env, exports);
  ImmMacroValueReadJs::Init(env, exports);
  ImmSymbolValueReadJs::Init(env, exports);
  ImmEscapedValueReadJs::Init(env, exports);
  ImmNewlineValueReadJs::Init(env, exports);
  ImmSpaceValueReadJs::Init(env, exports);
  ImmWordValueReadJs::Init(env, exports);
  ImmAtMentionValueReadJs::Init(env, exports);
  ImmRawTextValueReadJs::Init(env, exports);
  ImmPunctuationValueReadJs::Init(env, exports);
  ImmPlaceholderValueReadJs::Init(env, exports);
  ImmBigIdentValueReadJs::Init(env, exports);
  ImmTextTargetValueReadJs::Init(env, exports);
  ImmBoldValueReadJs::Init(env, exports);
  ImmUnderlineValueReadJs::Init(env, exports);
  ImmMonospaceValueReadJs::Init(env, exports);
  ImmMarkQuoteValueReadJs::Init(env, exports);
  ImmVerbatimValueReadJs::Init(env, exports);
  ImmItalicValueReadJs::Init(env, exports);
  ImmStrikeValueReadJs::Init(env, exports);
  ImmParValueReadJs::Init(env, exports);
  ImmRadioTargetValueReadJs::Init(env, exports);
  ImmLatexValueReadJs::Init(env, exports);
  ImmLinkValueReadJs::Init(env, exports);
  ImmBlockCenterValueReadJs::Init(env, exports);
  ImmBlockQuoteValueReadJs::Init(env, exports);
  ImmBlockCommentValueReadJs::Init(env, exports);
  ImmBlockVerseValueReadJs::Init(env, exports);
  ImmBlockDynamicFallbackValueReadJs::Init(env, exports);
  ImmBlockExampleValueReadJs::Init(env, exports);
  ImmBlockExportValueReadJs::Init(env, exports);
  ImmBlockAdmonitionValueReadJs::Init(env, exports);
  ImmBlockCodeEvalResultValueReadJs::Init(env, exports);
  ImmBlockCodeValueReadJs::Init(env, exports);
  ImmSubtreeLogValueReadJs::Init(env, exports);
  ImmSubtreeValueReadJs::Init(env, exports);
  ImmCellValueReadJs::Init(env, exports);
  ImmRowValueReadJs::Init(env, exports);
  ImmTableValueReadJs::Init(env, exports);
  ImmParagraphValueReadJs::Init(env, exports);
  ImmColonExampleValueReadJs::Init(env, exports);
  ImmCmdAttrValueReadJs::Init(env, exports);
  ImmCmdExportValueReadJs::Init(env, exports);
  ImmCallValueReadJs::Init(env, exports);
  ImmListValueReadJs::Init(env, exports);
  ImmListItemValueReadJs::Init(env, exports);
  ImmDocumentOptionsValueReadJs::Init(env, exports);
  ImmDocumentFragmentValueReadJs::Init(env, exports);
  ImmCriticMarkupValueReadJs::Init(env, exports);
  ImmDocumentValueReadJs::Init(env, exports);
  ImmFileTargetValueReadJs::Init(env, exports);
  ImmTextSeparatorValueReadJs::Init(env, exports);
  ImmDocumentGroupValueReadJs::Init(env, exports);
  ImmFileValueReadJs::Init(env, exports);
  ImmDirectoryValueReadJs::Init(env, exports);
  ImmSymlinkValueReadJs::Init(env, exports);
  ImmCmdIncludeValueReadJs::Init(env, exports);
  ImmAstContextJs::Init(env, exports);
  ImmAstVersionJs::Init(env, exports);
  ImmAdapterJs::Init(env, exports);
  TreeReprConfImmAdapterJs::Init(env, exports);
  OrgParseFragmentJs::Init(env, exports);
  OrgParseParametersJs::Init(env, exports);
  OrgDirectoryParseParametersJs::Init(env, exports);
  OrgYamlExportOptsJs::Init(env, exports);
  OrgTreeExportOptsJs::Init(env, exports);
  AstTrackingPathJs::Init(env, exports);
  AstTrackingAlternativesJs::Init(env, exports);
  AstTrackingGroupJs::Init(env, exports);
  RadioTargetAstTrackingGroupJs::Init(env, exports);
  SingleAstTrackingGroupJs::Init(env, exports);
  TrackedHashtagAstTrackingGroupJs::Init(env, exports);
  AstTrackingMapJs::Init(env, exports);
  SequenceSegmentJs::Init(env, exports);
  SequenceSegmentGroupJs::Init(env, exports);
  SequenceAnnotationTagJs::Init(env, exports);
  SequenceAnnotationJs::Init(env, exports);
  MapLinkGraphJs::Init(env, exports);
  LinkGraphMapLinkJs::Init(env, exports);
  RadioGraphMapLinkJs::Init(env, exports);
  MapNodePropGraphJs::Init(env, exports);
  MapEdgePropGraphJs::Init(env, exports);
  MapNodeGraphJs::Init(env, exports);
  MapEdgeGraphJs::Init(env, exports);
  MapGraphGraphJs::Init(env, exports);
  MapGraphStateGraphJs::Init(env, exports);
  LispCodeJs::Init(env, exports);
  CallLispCodeJs::Init(env, exports);
  ListLispCodeJs::Init(env, exports);
  KeyValueLispCodeJs::Init(env, exports);
  NumberLispCodeJs::Init(env, exports);
  TextLispCodeJs::Init(env, exports);
  IdentLispCodeJs::Init(env, exports);
  BooleanLispCodeJs::Init(env, exports);
  RealLispCodeJs::Init(env, exports);
  JsEnumWrapper<org::sem::LispCode::Kind>::Init(env, exports, "KindLispCode");
  TblfmJs::Init(env, exports);
  ExprTblfmJs::Init(env, exports);
  AxisRefTblfmExprJs::Init(env, exports);
  PositionTblfmExprAxisRefJs::Init(env, exports);
  IndexTblfmExprAxisRefPositionJs::Init(env, exports);
  NameTblfmExprAxisRefPositionJs::Init(env, exports);
  JsEnumWrapper<org::sem::Tblfm::Expr::AxisRef::Position::Kind>::Init(env, exports, "KindTblfmExprAxisRefPosition");
  AxisNameTblfmExprJs::Init(env, exports);
  IntLiteralTblfmExprJs::Init(env, exports);
  FloatLiteralTblfmExprJs::Init(env, exports);
  RangeRefTblfmExprJs::Init(env, exports);
  CallTblfmExprJs::Init(env, exports);
  ElispTblfmExprJs::Init(env, exports);
  JsEnumWrapper<org::sem::Tblfm::Expr::Kind>::Init(env, exports, "KindTblfmExpr");
  AssignTblfmJs::Init(env, exports);
  JsEnumWrapper<org::sem::Tblfm::Assign::Flag>::Init(env, exports, "FlagTblfmAssign");
  AttrValueJs::Init(env, exports);
  JsEnumWrapper<org::sem::AttrValue::Kind>::Init(env, exports, "KindAttrValue");
  DimensionSpanAttrValueJs::Init(env, exports);
  TextValueAttrValueJs::Init(env, exports);
  FileReferenceAttrValueJs::Init(env, exports);
  LispValueAttrValueJs::Init(env, exports);
  JsEnumWrapper<org::sem::AttrValue::DataKind>::Init(env, exports, "DataKindAttrValue");
  HashTagFlatJs::Init(env, exports);
  HashTagTextJs::Init(env, exports);
  SubtreePathJs::Init(env, exports);
  LinkTargetJs::Init(env, exports);
  RawLinkTargetJs::Init(env, exports);
  IdLinkTargetJs::Init(env, exports);
  CustomIdLinkTargetJs::Init(env, exports);
  SubtreeTitleLinkTargetJs::Init(env, exports);
  PersonLinkTargetJs::Init(env, exports);
  UserProtocolLinkTargetJs::Init(env, exports);
  InternalLinkTargetJs::Init(env, exports);
  FootnoteLinkTargetJs::Init(env, exports);
  FileLinkTargetJs::Init(env, exports);
  AttachmentLinkTargetJs::Init(env, exports);
  JsEnumWrapper<org::sem::LinkTarget::Kind>::Init(env, exports, "KindLinkTarget");
  SubtreeLogHeadJs::Init(env, exports);
  PrioritySubtreeLogHeadJs::Init(env, exports);
  JsEnumWrapper<org::sem::SubtreeLogHead::Priority::Action>::Init(env, exports, "ActionSubtreeLogHeadPriority");
  NoteSubtreeLogHeadJs::Init(env, exports);
  RefileSubtreeLogHeadJs::Init(env, exports);
  ClockSubtreeLogHeadJs::Init(env, exports);
  StateSubtreeLogHeadJs::Init(env, exports);
  DeadlineSubtreeLogHeadJs::Init(env, exports);
  ScheduleSubtreeLogHeadJs::Init(env, exports);
  TagSubtreeLogHeadJs::Init(env, exports);
  UnknownSubtreeLogHeadJs::Init(env, exports);
  JsEnumWrapper<org::sem::SubtreeLogHead::Kind>::Init(env, exports, "KindSubtreeLogHead");
  SubtreeCompletionJs::Init(env, exports);
  AttrListJs::Init(env, exports);
  AttrGroupJs::Init(env, exports);
  OrgCodeEvalInputJs::Init(env, exports);
  VarOrgCodeEvalInputJs::Init(env, exports);
  JsEnumWrapper<org::sem::OrgCodeEvalInput::ResultType>::Init(env, exports, "ResultTypeOrgCodeEvalInput");
  JsEnumWrapper<org::sem::OrgCodeEvalInput::ResultFormat>::Init(env, exports, "ResultFormatOrgCodeEvalInput");
  JsEnumWrapper<org::sem::OrgCodeEvalInput::ResultHandling>::Init(env, exports, "ResultHandlingOrgCodeEvalInput");
  OrgCodeEvalOutputJs::Init(env, exports);
  ColumnViewJs::Init(env, exports);
  SummaryColumnViewJs::Init(env, exports);
  CheckboxAggregateColumnViewSummaryJs::Init(env, exports);
  JsEnumWrapper<org::sem::ColumnView::Summary::CheckboxAggregate::Kind>::Init(env, exports, "KindColumnViewSummaryCheckboxAggregate");
  MathAggregateColumnViewSummaryJs::Init(env, exports);
  JsEnumWrapper<org::sem::ColumnView::Summary::MathAggregate::Kind>::Init(env, exports, "KindColumnViewSummaryMathAggregate");
  JsEnumWrapper<org::sem::ColumnView::Summary::Kind>::Init(env, exports, "KindColumnViewSummary");
  ColumnColumnViewJs::Init(env, exports);
  BlockCodeLineJs::Init(env, exports);
  PartBlockCodeLineJs::Init(env, exports);
  RawBlockCodeLinePartJs::Init(env, exports);
  CalloutBlockCodeLinePartJs::Init(env, exports);
  TangleBlockCodeLinePartJs::Init(env, exports);
  JsEnumWrapper<org::sem::BlockCodeLine::Part::Kind>::Init(env, exports, "KindBlockCodeLinePart");
  DocumentExportConfigJs::Init(env, exports);
  TaskExportDocumentExportConfigJs::Init(env, exports);
  JsEnumWrapper<org::sem::DocumentExportConfig::TagExport>::Init(env, exports, "TagExportDocumentExportConfig");
  JsEnumWrapper<org::sem::DocumentExportConfig::TaskFiltering>::Init(env, exports, "TaskFilteringDocumentExportConfig");
  JsEnumWrapper<org::sem::DocumentExportConfig::BrokenLinks>::Init(env, exports, "BrokenLinksDocumentExportConfig");
  DoExportDocumentExportConfigJs::Init(env, exports);
  ExportFixedDocumentExportConfigJs::Init(env, exports);
  JsEnumWrapper<org::sem::DocumentExportConfig::TocExportKind>::Init(env, exports, "TocExportKindDocumentExportConfig");
  SubtreePeriodJs::Init(env, exports);
  JsEnumWrapper<org::sem::SubtreePeriod::Kind>::Init(env, exports, "KindSubtreePeriod");
  NamedPropertyJs::Init(env, exports);
  NonblockingNamedPropertyJs::Init(env, exports);
  ArchiveTimeNamedPropertyJs::Init(env, exports);
  ArchiveFileNamedPropertyJs::Init(env, exports);
  ArchiveOlpathNamedPropertyJs::Init(env, exports);
  ArchiveTargetNamedPropertyJs::Init(env, exports);
  ArchiveCategoryNamedPropertyJs::Init(env, exports);
  ArchiveTodoNamedPropertyJs::Init(env, exports);
  TriggerNamedPropertyJs::Init(env, exports);
  ExportLatexClassNamedPropertyJs::Init(env, exports);
  CookieDataNamedPropertyJs::Init(env, exports);
  JsEnumWrapper<org::sem::NamedProperty::CookieData::TodoSource>::Init(env, exports, "TodoSourceNamedPropertyCookieData");
  ExportLatexClassOptionsNamedPropertyJs::Init(env, exports);
  ExportLatexHeaderNamedPropertyJs::Init(env, exports);
  ExportLatexCompilerNamedPropertyJs::Init(env, exports);
  OrderedNamedPropertyJs::Init(env, exports);
  EffortNamedPropertyJs::Init(env, exports);
  VisibilityNamedPropertyJs::Init(env, exports);
  JsEnumWrapper<org::sem::NamedProperty::Visibility::Level>::Init(env, exports, "LevelNamedPropertyVisibility");
  ExportOptionsNamedPropertyJs::Init(env, exports);
  BlockerNamedPropertyJs::Init(env, exports);
  UnnumberedNamedPropertyJs::Init(env, exports);
  CreatedNamedPropertyJs::Init(env, exports);
  RadioIdNamedPropertyJs::Init(env, exports);
  HashtagDefNamedPropertyJs::Init(env, exports);
  CustomArgsNamedPropertyJs::Init(env, exports);
  CustomRawNamedPropertyJs::Init(env, exports);
  CustomSubtreeJsonNamedPropertyJs::Init(env, exports);
  CustomSubtreeFlagsNamedPropertyJs::Init(env, exports);
  JsEnumWrapper<org::sem::NamedProperty::Kind>::Init(env, exports, "KindNamedProperty");
  ImmNoneJs::Init(env, exports);
  ImmErrorItemJs::Init(env, exports);
  ImmErrorGroupJs::Init(env, exports);
  ImmStmtListJs::Init(env, exports);
  ImmEmptyJs::Init(env, exports);
  ImmTimeJs::Init(env, exports);
  RepeatImmTimeJs::Init(env, exports);
  JsEnumWrapper<org::imm::ImmTime::Repeat::Mode>::Init(env, exports, "ModeImmTimeRepeat");
  JsEnumWrapper<org::imm::ImmTime::Repeat::Period>::Init(env, exports, "PeriodImmTimeRepeat");
  StaticImmTimeJs::Init(env, exports);
  DynamicImmTimeJs::Init(env, exports);
  JsEnumWrapper<org::imm::ImmTime::TimeKind>::Init(env, exports, "TimeKindImmTime");
  ImmTimeRangeJs::Init(env, exports);
  ImmMacroJs::Init(env, exports);
  ImmSymbolJs::Init(env, exports);
  ParamImmSymbolJs::Init(env, exports);
  ImmRadioTargetJs::Init(env, exports);
  ImmLatexJs::Init(env, exports);
  ImmSubtreeLogJs::Init(env, exports);
  ImmSubtreeJs::Init(env, exports);
  ImmColonExampleJs::Init(env, exports);
  ImmCallJs::Init(env, exports);
  ImmListItemJs::Init(env, exports);
  JsEnumWrapper<org::sem::ListItem::Checkbox>::Init(env, exports, "CheckboxListItem");
  ImmDocumentOptionsJs::Init(env, exports);
  ImmDocumentFragmentJs::Init(env, exports);
  ImmCriticMarkupJs::Init(env, exports);
  JsEnumWrapper<org::imm::ImmCriticMarkup::Kind>::Init(env, exports, "KindImmCriticMarkup");
  ImmDocumentJs::Init(env, exports);
  ImmFileTargetJs::Init(env, exports);
  ImmTextSeparatorJs::Init(env, exports);
  ImmDocumentGroupJs::Init(env, exports);
  ImmFileJs::Init(env, exports);
  DocumentImmFileJs::Init(env, exports);
  AttachmentImmFileJs::Init(env, exports);
  SourceImmFileJs::Init(env, exports);
  JsEnumWrapper<org::imm::ImmFile::Kind>::Init(env, exports, "KindImmFile");
  ImmDirectoryJs::Init(env, exports);
  ImmSymlinkJs::Init(env, exports);
  ImmCmdIncludeJs::Init(env, exports);
  IncludeBaseImmCmdIncludeJs::Init(env, exports);
  ExampleImmCmdIncludeJs::Init(env, exports);
  ExportImmCmdIncludeJs::Init(env, exports);
  CustomImmCmdIncludeJs::Init(env, exports);
  SrcImmCmdIncludeJs::Init(env, exports);
  OrgDocumentImmCmdIncludeJs::Init(env, exports);
  JsEnumWrapper<org::imm::ImmCmdInclude::Kind>::Init(env, exports, "KindImmCmdInclude");
  NoneJs::Init(env, exports);
  ErrorItemJs::Init(env, exports);
  ErrorGroupJs::Init(env, exports);
  StmtListJs::Init(env, exports);
  EmptyJs::Init(env, exports);
  TimeJs::Init(env, exports);
  RepeatTimeJs::Init(env, exports);
  JsEnumWrapper<org::sem::Time::Repeat::Mode>::Init(env, exports, "ModeTimeRepeat");
  JsEnumWrapper<org::sem::Time::Repeat::Period>::Init(env, exports, "PeriodTimeRepeat");
  StaticTimeJs::Init(env, exports);
  DynamicTimeJs::Init(env, exports);
  JsEnumWrapper<org::sem::Time::TimeKind>::Init(env, exports, "TimeKindTime");
  TimeRangeJs::Init(env, exports);
  MacroJs::Init(env, exports);
  SymbolJs::Init(env, exports);
  ParamSymbolJs::Init(env, exports);
  RadioTargetJs::Init(env, exports);
  LatexJs::Init(env, exports);
  SubtreeLogJs::Init(env, exports);
  SubtreeJs::Init(env, exports);
  ColonExampleJs::Init(env, exports);
  CallJs::Init(env, exports);
  ListItemJs::Init(env, exports);
  JsEnumWrapper<org::sem::ListItem::Checkbox>::Init(env, exports, "CheckboxListItem");
  DocumentOptionsJs::Init(env, exports);
  DocumentFragmentJs::Init(env, exports);
  CriticMarkupJs::Init(env, exports);
  JsEnumWrapper<org::sem::CriticMarkup::Kind>::Init(env, exports, "KindCriticMarkup");
  DocumentJs::Init(env, exports);
  FileTargetJs::Init(env, exports);
  TextSeparatorJs::Init(env, exports);
  DocumentGroupJs::Init(env, exports);
  FileJs::Init(env, exports);
  DocumentFileJs::Init(env, exports);
  AttachmentFileJs::Init(env, exports);
  SourceFileJs::Init(env, exports);
  JsEnumWrapper<org::sem::File::Kind>::Init(env, exports, "KindFile");
  DirectoryJs::Init(env, exports);
  SymlinkJs::Init(env, exports);
  CmdIncludeJs::Init(env, exports);
  IncludeBaseCmdIncludeJs::Init(env, exports);
  ExampleCmdIncludeJs::Init(env, exports);
  ExportCmdIncludeJs::Init(env, exports);
  CustomCmdIncludeJs::Init(env, exports);
  SrcCmdIncludeJs::Init(env, exports);
  OrgDocumentCmdIncludeJs::Init(env, exports);
  JsEnumWrapper<org::sem::CmdInclude::Kind>::Init(env, exports, "KindCmdInclude");
  MapConfigGraphJs::Init(env, exports);
  ImmIdTNone::Init(env, exports);
  ImmIdTErrorItem::Init(env, exports);
  ImmIdTErrorGroup::Init(env, exports);
  ImmIdTStmt::Init(env, exports);
  ImmIdTInline::Init(env, exports);
  ImmIdTStmtList::Init(env, exports);
  ImmIdTEmpty::Init(env, exports);
  ImmIdTCmd::Init(env, exports);
  ImmIdTBlock::Init(env, exports);
  ImmIdTLineCommand::Init(env, exports);
  ImmIdTAttached::Init(env, exports);
  ImmIdTLeaf::Init(env, exports);
  ImmIdTCmdCaption::Init(env, exports);
  ImmIdTCmdColumns::Init(env, exports);
  ImmIdTCmdName::Init(env, exports);
  ImmIdTCmdCustomArgs::Init(env, exports);
  ImmIdTCmdCustomRaw::Init(env, exports);
  ImmIdTCmdCustomText::Init(env, exports);
  ImmIdTCmdCall::Init(env, exports);
  ImmIdTCmdTblfm::Init(env, exports);
  ImmIdTHashTag::Init(env, exports);
  ImmIdTInlineFootnote::Init(env, exports);
  ImmIdTInlineExport::Init(env, exports);
  ImmIdTTime::Init(env, exports);
  ImmIdTTimeRange::Init(env, exports);
  ImmIdTMacro::Init(env, exports);
  ImmIdTSymbol::Init(env, exports);
  ImmIdTEscaped::Init(env, exports);
  ImmIdTNewline::Init(env, exports);
  ImmIdTSpace::Init(env, exports);
  ImmIdTWord::Init(env, exports);
  ImmIdTAtMention::Init(env, exports);
  ImmIdTRawText::Init(env, exports);
  ImmIdTPunctuation::Init(env, exports);
  ImmIdTPlaceholder::Init(env, exports);
  ImmIdTBigIdent::Init(env, exports);
  ImmIdTTextTarget::Init(env, exports);
  ImmIdTMarkup::Init(env, exports);
  ImmIdTBold::Init(env, exports);
  ImmIdTUnderline::Init(env, exports);
  ImmIdTMonospace::Init(env, exports);
  ImmIdTMarkQuote::Init(env, exports);
  ImmIdTVerbatim::Init(env, exports);
  ImmIdTItalic::Init(env, exports);
  ImmIdTStrike::Init(env, exports);
  ImmIdTPar::Init(env, exports);
  ImmIdTRadioTarget::Init(env, exports);
  ImmIdTLatex::Init(env, exports);
  ImmIdTLink::Init(env, exports);
  ImmIdTBlockCenter::Init(env, exports);
  ImmIdTBlockQuote::Init(env, exports);
  ImmIdTBlockComment::Init(env, exports);
  ImmIdTBlockVerse::Init(env, exports);
  ImmIdTBlockDynamicFallback::Init(env, exports);
  ImmIdTBlockExample::Init(env, exports);
  ImmIdTBlockExport::Init(env, exports);
  ImmIdTBlockAdmonition::Init(env, exports);
  ImmIdTBlockCodeEvalResult::Init(env, exports);
  ImmIdTBlockCode::Init(env, exports);
  ImmIdTSubtreeLog::Init(env, exports);
  ImmIdTSubtree::Init(env, exports);
  ImmIdTCell::Init(env, exports);
  ImmIdTRow::Init(env, exports);
  ImmIdTTable::Init(env, exports);
  ImmIdTParagraph::Init(env, exports);
  ImmIdTColonExample::Init(env, exports);
  ImmIdTCmdAttr::Init(env, exports);
  ImmIdTCmdExport::Init(env, exports);
  ImmIdTCall::Init(env, exports);
  ImmIdTList::Init(env, exports);
  ImmIdTListItem::Init(env, exports);
  ImmIdTDocumentOptions::Init(env, exports);
  ImmIdTDocumentFragment::Init(env, exports);
  ImmIdTCriticMarkup::Init(env, exports);
  ImmIdTDocument::Init(env, exports);
  ImmIdTFileTarget::Init(env, exports);
  ImmIdTTextSeparator::Init(env, exports);
  ImmIdTDocumentGroup::Init(env, exports);
  ImmIdTFile::Init(env, exports);
  ImmIdTDirectory::Init(env, exports);
  ImmIdTSymlink::Init(env, exports);
  ImmIdTCmdInclude::Init(env, exports);
  ImmNoneValueJs::Init(env, exports);
  ImmErrorItemValueJs::Init(env, exports);
  ImmErrorGroupValueJs::Init(env, exports);
  ImmStmtListValueJs::Init(env, exports);
  ImmEmptyValueJs::Init(env, exports);
  ImmCmdCaptionValueJs::Init(env, exports);
  ImmCmdColumnsValueJs::Init(env, exports);
  ImmCmdNameValueJs::Init(env, exports);
  ImmCmdCustomArgsValueJs::Init(env, exports);
  ImmCmdCustomRawValueJs::Init(env, exports);
  ImmCmdCustomTextValueJs::Init(env, exports);
  ImmCmdCallValueJs::Init(env, exports);
  ImmCmdTblfmValueJs::Init(env, exports);
  ImmHashTagValueJs::Init(env, exports);
  ImmInlineFootnoteValueJs::Init(env, exports);
  ImmInlineExportValueJs::Init(env, exports);
  ImmTimeValueJs::Init(env, exports);
  ImmTimeRangeValueJs::Init(env, exports);
  ImmMacroValueJs::Init(env, exports);
  ImmSymbolValueJs::Init(env, exports);
  ImmEscapedValueJs::Init(env, exports);
  ImmNewlineValueJs::Init(env, exports);
  ImmSpaceValueJs::Init(env, exports);
  ImmWordValueJs::Init(env, exports);
  ImmAtMentionValueJs::Init(env, exports);
  ImmRawTextValueJs::Init(env, exports);
  ImmPunctuationValueJs::Init(env, exports);
  ImmPlaceholderValueJs::Init(env, exports);
  ImmBigIdentValueJs::Init(env, exports);
  ImmTextTargetValueJs::Init(env, exports);
  ImmBoldValueJs::Init(env, exports);
  ImmUnderlineValueJs::Init(env, exports);
  ImmMonospaceValueJs::Init(env, exports);
  ImmMarkQuoteValueJs::Init(env, exports);
  ImmVerbatimValueJs::Init(env, exports);
  ImmItalicValueJs::Init(env, exports);
  ImmStrikeValueJs::Init(env, exports);
  ImmParValueJs::Init(env, exports);
  ImmRadioTargetValueJs::Init(env, exports);
  ImmLatexValueJs::Init(env, exports);
  ImmLinkValueJs::Init(env, exports);
  ImmBlockCenterValueJs::Init(env, exports);
  ImmBlockQuoteValueJs::Init(env, exports);
  ImmBlockCommentValueJs::Init(env, exports);
  ImmBlockVerseValueJs::Init(env, exports);
  ImmBlockDynamicFallbackValueJs::Init(env, exports);
  ImmBlockExampleValueJs::Init(env, exports);
  ImmBlockExportValueJs::Init(env, exports);
  ImmBlockAdmonitionValueJs::Init(env, exports);
  ImmBlockCodeEvalResultValueJs::Init(env, exports);
  ImmBlockCodeValueJs::Init(env, exports);
  ImmSubtreeLogValueJs::Init(env, exports);
  ImmSubtreeValueJs::Init(env, exports);
  ImmCellValueJs::Init(env, exports);
  ImmRowValueJs::Init(env, exports);
  ImmTableValueJs::Init(env, exports);
  ImmParagraphValueJs::Init(env, exports);
  ImmColonExampleValueJs::Init(env, exports);
  ImmCmdAttrValueJs::Init(env, exports);
  ImmCmdExportValueJs::Init(env, exports);
  ImmCallValueJs::Init(env, exports);
  ImmListValueJs::Init(env, exports);
  ImmListItemValueJs::Init(env, exports);
  ImmDocumentOptionsValueJs::Init(env, exports);
  ImmDocumentFragmentValueJs::Init(env, exports);
  ImmCriticMarkupValueJs::Init(env, exports);
  ImmDocumentValueJs::Init(env, exports);
  ImmFileTargetValueJs::Init(env, exports);
  ImmTextSeparatorValueJs::Init(env, exports);
  ImmDocumentGroupValueJs::Init(env, exports);
  ImmFileValueJs::Init(env, exports);
  ImmDirectoryValueJs::Init(env, exports);
  ImmSymlinkValueJs::Init(env, exports);
  ImmCmdIncludeValueJs::Init(env, exports);
  ImmCmdCustomRawJs::Init(env, exports);
  ImmCmdCustomTextJs::Init(env, exports);
  ImmLinkJs::Init(env, exports);
  ImmBlockCommentJs::Init(env, exports);
  ImmParagraphJs::Init(env, exports);
  ImmListJs::Init(env, exports);
  ImmHashTagJs::Init(env, exports);
  ImmInlineFootnoteJs::Init(env, exports);
  ImmInlineExportJs::Init(env, exports);
  ImmEscapedJs::Init(env, exports);
  ImmNewlineJs::Init(env, exports);
  ImmSpaceJs::Init(env, exports);
  ImmWordJs::Init(env, exports);
  ImmAtMentionJs::Init(env, exports);
  ImmRawTextJs::Init(env, exports);
  ImmPunctuationJs::Init(env, exports);
  ImmPlaceholderJs::Init(env, exports);
  ImmBigIdentJs::Init(env, exports);
  ImmTextTargetJs::Init(env, exports);
  ImmBoldJs::Init(env, exports);
  ImmUnderlineJs::Init(env, exports);
  ImmMonospaceJs::Init(env, exports);
  ImmMarkQuoteJs::Init(env, exports);
  ImmVerbatimJs::Init(env, exports);
  ImmItalicJs::Init(env, exports);
  ImmStrikeJs::Init(env, exports);
  ImmParJs::Init(env, exports);
  CmdCustomRawJs::Init(env, exports);
  CmdCustomTextJs::Init(env, exports);
  LinkJs::Init(env, exports);
  BlockCommentJs::Init(env, exports);
  ParagraphJs::Init(env, exports);
  ListJs::Init(env, exports);
  HashTagJs::Init(env, exports);
  InlineFootnoteJs::Init(env, exports);
  InlineExportJs::Init(env, exports);
  EscapedJs::Init(env, exports);
  NewlineJs::Init(env, exports);
  SpaceJs::Init(env, exports);
  WordJs::Init(env, exports);
  AtMentionJs::Init(env, exports);
  RawTextJs::Init(env, exports);
  PunctuationJs::Init(env, exports);
  PlaceholderJs::Init(env, exports);
  BigIdentJs::Init(env, exports);
  TextTargetJs::Init(env, exports);
  BoldJs::Init(env, exports);
  UnderlineJs::Init(env, exports);
  MonospaceJs::Init(env, exports);
  MarkQuoteJs::Init(env, exports);
  VerbatimJs::Init(env, exports);
  ItalicJs::Init(env, exports);
  StrikeJs::Init(env, exports);
  ParJs::Init(env, exports);
  ImmCmdCustomArgsJs::Init(env, exports);
  ImmCmdTblfmJs::Init(env, exports);
  ImmCellJs::Init(env, exports);
  ImmRowJs::Init(env, exports);
  CmdCustomArgsJs::Init(env, exports);
  CmdTblfmJs::Init(env, exports);
  CellJs::Init(env, exports);
  RowJs::Init(env, exports);
  ImmSubtreeAdapter::Init(env, exports);
  ImmNoneAdapter::Init(env, exports);
  ImmErrorItemAdapter::Init(env, exports);
  ImmErrorGroupAdapter::Init(env, exports);
  ImmStmtListAdapter::Init(env, exports);
  ImmEmptyAdapter::Init(env, exports);
  ImmTimeAdapter::Init(env, exports);
  ImmTimeRangeAdapter::Init(env, exports);
  ImmMacroAdapter::Init(env, exports);
  ImmSymbolAdapter::Init(env, exports);
  ImmLatexAdapter::Init(env, exports);
  ImmSubtreeLogAdapter::Init(env, exports);
  ImmColonExampleAdapter::Init(env, exports);
  ImmCallAdapter::Init(env, exports);
  ImmFileAdapter::Init(env, exports);
  ImmDirectoryAdapter::Init(env, exports);
  ImmSymlinkAdapter::Init(env, exports);
  ImmDocumentFragmentAdapter::Init(env, exports);
  ImmCriticMarkupAdapter::Init(env, exports);
  ImmListItemAdapter::Init(env, exports);
  ImmDocumentOptionsAdapter::Init(env, exports);
  ImmDocumentAdapter::Init(env, exports);
  ImmFileTargetAdapter::Init(env, exports);
  ImmTextSeparatorAdapter::Init(env, exports);
  ImmCmdIncludeAdapter::Init(env, exports);
  ImmDocumentGroupAdapter::Init(env, exports);
  ImmBlockCenterJs::Init(env, exports);
  ImmBlockQuoteJs::Init(env, exports);
  ImmBlockVerseJs::Init(env, exports);
  ImmBlockDynamicFallbackJs::Init(env, exports);
  ImmBlockExampleJs::Init(env, exports);
  ImmBlockExportJs::Init(env, exports);
  ImmBlockAdmonitionJs::Init(env, exports);
  ImmBlockCodeEvalResultJs::Init(env, exports);
  ImmBlockCodeJs::Init(env, exports);
  ImmTableJs::Init(env, exports);
  BlockCenterJs::Init(env, exports);
  BlockQuoteJs::Init(env, exports);
  BlockVerseJs::Init(env, exports);
  BlockDynamicFallbackJs::Init(env, exports);
  BlockExampleJs::Init(env, exports);
  BlockExportJs::Init(env, exports);
  BlockAdmonitionJs::Init(env, exports);
  BlockCodeEvalResultJs::Init(env, exports);
  BlockCodeJs::Init(env, exports);
  TableJs::Init(env, exports);
  ImmCmdCustomRawAdapter::Init(env, exports);
  ImmCmdCustomTextAdapter::Init(env, exports);
  ImmLinkAdapter::Init(env, exports);
  ImmBlockCommentAdapter::Init(env, exports);
  ImmParagraphAdapter::Init(env, exports);
  ImmListAdapter::Init(env, exports);
  ImmHashTagAdapter::Init(env, exports);
  ImmInlineFootnoteAdapter::Init(env, exports);
  ImmEscapedAdapter::Init(env, exports);
  ImmNewlineAdapter::Init(env, exports);
  ImmSpaceAdapter::Init(env, exports);
  ImmWordAdapter::Init(env, exports);
  ImmAtMentionAdapter::Init(env, exports);
  ImmRawTextAdapter::Init(env, exports);
  ImmPunctuationAdapter::Init(env, exports);
  ImmPlaceholderAdapter::Init(env, exports);
  ImmBigIdentAdapter::Init(env, exports);
  ImmTextTargetAdapter::Init(env, exports);
  ImmBoldAdapter::Init(env, exports);
  ImmUnderlineAdapter::Init(env, exports);
  ImmMonospaceAdapter::Init(env, exports);
  ImmMarkQuoteAdapter::Init(env, exports);
  ImmRadioTargetAdapter::Init(env, exports);
  ImmVerbatimAdapter::Init(env, exports);
  ImmItalicAdapter::Init(env, exports);
  ImmStrikeAdapter::Init(env, exports);
  ImmParAdapter::Init(env, exports);
  ImmCmdCaptionJs::Init(env, exports);
  ImmCmdColumnsJs::Init(env, exports);
  ImmCmdNameJs::Init(env, exports);
  ImmCmdCallJs::Init(env, exports);
  ImmCmdAttrJs::Init(env, exports);
  ImmCmdExportJs::Init(env, exports);
  CmdCaptionJs::Init(env, exports);
  CmdColumnsJs::Init(env, exports);
  CmdNameJs::Init(env, exports);
  CmdCallJs::Init(env, exports);
  CmdAttrJs::Init(env, exports);
  CmdExportJs::Init(env, exports);
  ImmCmdCustomArgsAdapter::Init(env, exports);
  ImmCmdTblfmAdapter::Init(env, exports);
  ImmCellAdapter::Init(env, exports);
  ImmRowAdapter::Init(env, exports);
  ImmBlockCenterAdapter::Init(env, exports);
  ImmBlockQuoteAdapter::Init(env, exports);
  ImmBlockVerseAdapter::Init(env, exports);
  ImmBlockExampleAdapter::Init(env, exports);
  ImmInlineExportAdapter::Init(env, exports);
  ImmCmdExportAdapter::Init(env, exports);
  ImmBlockExportAdapter::Init(env, exports);
  ImmBlockDynamicFallbackAdapter::Init(env, exports);
  ImmBlockAdmonitionAdapter::Init(env, exports);
  ImmBlockCodeEvalResultAdapter::Init(env, exports);
  ImmBlockCodeAdapter::Init(env, exports);
  ImmTableAdapter::Init(env, exports);
  ImmCmdCaptionAdapter::Init(env, exports);
  ImmCmdColumnsAdapter::Init(env, exports);
  ImmCmdNameAdapter::Init(env, exports);
  ImmCmdCallAdapter::Init(env, exports);
  ImmCmdAttrAdapter::Init(env, exports);
  JsEnumWrapper<ListFormattingMode>::Init(env, exports, "ListFormattingMode");
  JsEnumWrapper<InitialSubtreeVisibility>::Init(env, exports, "InitialSubtreeVisibility");
  JsEnumWrapper<BlockCodeResults>::Init(env, exports, "BlockCodeResults");
  JsEnumWrapper<BlockCodeExports>::Init(env, exports, "BlockCodeExports");
  JsEnumWrapper<OrgSpecName>::Init(env, exports, "OrgSpecName");
  JsEnumWrapper<OrgNodeKind>::Init(env, exports, "OrgNodeKind");
  JsEnumWrapper<OrgJsonKind>::Init(env, exports, "OrgJsonKind");
  JsEnumWrapper<OrgSemKind>::Init(env, exports, "OrgSemKind");
  JsEnumWrapper<org::AstTrackingGroup::Kind>::Init(env, exports, "KindAstTrackingGroup");
  {
    auto callable = makeCallable(&org::newSemTimeStatic, std::make_tuple(CxxArgSpec<hstd::UserTimeBreakdown>{"breakdown"},
                                                                         CxxArgSpec<bool>{"isActive", 0}));
    exports.Set("newSemTimeStatic", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::parseFile, std::make_tuple(CxxArgSpec<std::string>{"file"},
                                                                  CxxArgSpec<org::OrgParseParameters>{"opts"}));
    exports.Set("parseFile", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::parseString, std::make_tuple(CxxArgSpec<std::string>{"text"}));
    exports.Set("parseString", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::parseStringOpts, std::make_tuple(CxxArgSpec<std::string>{"text"},
                                                                        CxxArgSpec<org::OrgParseParameters>{"opts"}));
    exports.Set("parseStringOpts", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::parseDirectoryOpts, std::make_tuple(CxxArgSpec<std::string>{"path"},
                                                                           CxxArgSpec<org::OrgDirectoryParseParameters>{"opts"}));
    exports.Set("parseDirectoryOpts", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::parseFileWithIncludes, std::make_tuple(CxxArgSpec<std::string>{"file"},
                                                                              CxxArgSpec<org::OrgDirectoryParseParameters>{"opts"}));
    exports.Set("parseFileWithIncludes", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::initImmutableAstContext, std::make_tuple());
    exports.Set("initImmutableAstContext", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::asOneNode, std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"arg"}));
    exports.Set("asOneNode", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::formatToString, std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"arg"}));
    exports.Set("formatToString", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::exportToYamlString, std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"},
                                                                           CxxArgSpec<org::OrgYamlExportOpts>{"opts"}));
    exports.Set("exportToYamlString", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::exportToYamlFile, std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"},
                                                                         CxxArgSpec<std::string>{"path"},
                                                                         CxxArgSpec<org::OrgYamlExportOpts>{"opts"}));
    exports.Set("exportToYamlFile", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::exportToJsonString, std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"}));
    exports.Set("exportToJsonString", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::exportToJsonFile, std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"},
                                                                         CxxArgSpec<std::string>{"path"}));
    exports.Set("exportToJsonFile", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::readProtobufFile, std::make_tuple(CxxArgSpec<std::string>{"file"}));
    exports.Set("readProtobufFile", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::exportToProtobufFile, std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Document>>{"doc"},
                                                                             CxxArgSpec<std::string>{"file"}));
    exports.Set("exportToProtobufFile", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::exportToTreeString, std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"},
                                                                           CxxArgSpec<org::OrgTreeExportOpts>{"opts"}));
    exports.Set("exportToTreeString", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::exportToTreeFile, std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"},
                                                                         CxxArgSpec<std::string>{"path"},
                                                                         CxxArgSpec<org::OrgTreeExportOpts>{"opts"}));
    exports.Set("exportToTreeFile", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::getAstTrackingMap, std::make_tuple(CxxArgSpec<hstd::Vec<org::sem::SemId<org::sem::Org>>>{"nodes"}));
    exports.Set("getAstTrackingMap", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&org::getSubnodeGroups, std::make_tuple(CxxArgSpec<org::sem::SemId<org::sem::Org>>{"node"},
                                                                         CxxArgSpec<org::AstTrackingMap>{"map"}));
    exports.Set("getSubnodeGroups", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  {
    auto callable = makeCallable(&hstd::annotateSequence, std::make_tuple(CxxArgSpec<hstd::Vec<hstd::SequenceSegmentGroup>>{"groups"},
                                                                          CxxArgSpec<int>{"first"},
                                                                          CxxArgSpec<int>{"last"}));
    exports.Set("annotateSequence", Napi::Function::New(env, [callable](Napi::CallbackInfo const& info) -> auto { return WrapFunction(info, callable); }));
  }
  return exports;
}

NODE_API_MODULE(pyhaxorg, InitModule);
/* clang-format on */