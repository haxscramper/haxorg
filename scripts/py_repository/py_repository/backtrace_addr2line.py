#!/usr/bin/env python

## @file   backtrace_addr2line.py
## @brief  Standalone helper to convert asan backtrace function address to the line/column information

# Run addr2line on backtrace generated by asan -- from what I understand
# it is supposed to generate file:line locations automatically, but with
# packaged toolchain that I use it does not work. 

import re
import subprocess
from collections import defaultdict

def get_source_locations(binary_path, addresses):
    try:
        # Call addr2line to get the source location
        print(binary_path)
        result = subprocess.run(["addr2line", "-e", binary_path] + addresses,
                                stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        return result.stdout.decode().strip().split('\n')
    except Exception as e:
        print(f"Error calling addr2line: {e}")
        return None

def process_backtrace(backtrace):
    # Regex pattern to match lines with binary path and address
    pattern = r"(\/\S+)\+0x([a-fA-F0-9]+)"
    binary_addresses = defaultdict(list)

    # First pass: collect addresses for each binary
    for line in backtrace:
        for match in re.finditer(pattern, line):
            binary_path, address = match.groups()
            binary_addresses[binary_path].append(address)

    # Call addr2line for each binary
    source_locations = {}
    for binary, addresses in binary_addresses.items():
        locations = get_source_locations(binary, addresses)
        source_locations.update(dict(zip(addresses, locations)))

    # Second pass: replace addresses with source locations in backtrace
    processed_backtrace = []
    for line in backtrace:
        new_line = line
        for match in re.finditer(pattern, line):
            binary_path, address = match.groups()
            source_location = source_locations.get(address)
            if source_location:
                full_match = match.group(0)
                new_line = new_line.replace(full_match, source_location)

        processed_backtrace.append(new_line)

    return processed_backtrace

def main():
    with open("/tmp/org_stderr.txt", "r") as file:
        backtrace = file.readlines()

    trace = "".join(process_backtrace(backtrace))
    with open("/tmp/asan_backtrace_res.txt", "w") as file:
        file.write(trace)

    print(trace)

if __name__ == "__main__":
    main()
